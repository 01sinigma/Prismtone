// Файл: C:\Py\Prismtone\app\src\main\AndroidManifest.xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <!-- Разрешения для хранения нужны только если вы будете сохранять записи/пресеты во внешнее хранилище -->
    <!-- Для Android 10+ лучше использовать Scoped Storage или MediaStore -->
    <!-- <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"
                     android:maxSdkVersion="28" /> -->
    <!-- <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"
                     android:maxSdkVersion="32" /> -->

    <!-- Добавьте uses-feature, если Web Audio API критично -->
    <uses-feature android:name="android.hardware.touchscreen" android:required="true" />
    <uses-feature android:name="android.software.webview" android:required="true" />


    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.Prismtone"
        tools:targetApi="31">

        <activity
            android:name=".MainActivity"
        android:theme="@style/Theme.MaterialComponents.DayNight.NoActionBar"
        android:exported="true"
        android:screenOrientation="landscape"
        android:configChanges="keyboardHidden|orientation|screenSize|screenLayout|smallestScreenSize">
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
    </activity>
</application>

</manifest>
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\config\defaultAppSettings.json
{
  "theme": "day",
  "language": "en",
  "soundPreset": "default_piano",
  "fxChain": null,
  "visualizer": "waves",
  "touchEffect": "glow",
  "scale": "major",
  "octaveOffset": 0,
  "zoneCount": 12,
  "showNoteNames": true,
  "showLines": true,
  "masterVolumeCeiling": 1.0,
  "enablePolyphonyVolumeScaling": true,
  "yAxisControls": {
    "volume": {
      "minOutput": 0.0,
      "maxOutput": 1.0,
      "yThreshold": 0.0,
      "curveType": "linear",
      "curveFactor": 1.0,
      "outputType": "gain"
    },
    "effects": {
      "minOutput": -60,
      "maxOutput": 0,
      "yThreshold": 0.1,
      "curveType": "exponential",
      "curveFactor": 2.0,
      "outputType": "db"
    }
  },
  "multiTouch": false,
  "midiEnabled": false,
  "midiChannel": 0,
  "midiDevice": null,
  "audioSettings": {
    "sampleRate": 44100,
    "bufferSize": 2048,
    "latency": 0
  },
  "performance": {
    "maxPolyphony": 32,
    "voiceStealing": true,
    "preloadBuffers": true
  },
  "uiSettings": {
    "showFps": false,
    "showDebugInfo": false,
    "animationSpeed": 1.0,
    "touchFeedback": true
  },
  "lastUsedPresets": {
    "soundPresets": [],
    "fxChains": []
  },
  "version": "1.0.0",
  "rocketModeSettings": {
    "intensity": 0.5,
    "visualTheme": "Glow",
    "autoPhases": true,
    "phaseTransitionMode": "activity",
    "phaseDurations": { "ignition": 30, "liftOff": 60, "burst": 90 },
    "harmonicKey": "major",
    "markerLogicMode": "tonalBinding",
    "displayMarkers": { "active": true, "functional": true, "inKeyOnly": true },
    "markerStyle": "GlowFromNote",
    "markerColorScheme": "Classic",
    "highlightActiveNotes": true,
    "markersDisappearOnNewTouch": true,
    "displayFunctionNames": "T",
    "useFadeOutEffects": true,
    "chordHistoryDepth": 2,
    "rocketSubMode": "tonal",
    "tonalTonic": "C"
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\css\styles.css
/* Файл: app/src/main/assets/css/styles.css */

/* Base Styles */
:root {
    --color-background: #ffffff;
    --color-background-rgb: 255, 255, 255;
    --color-surface: #f5f5f5;
    --color-surface-rgb: 245, 245, 245;
    --color-primary: #2196f3;
    --color-primary-rgb: 33, 150, 243;
    --color-primary-light: #64b5f6;
    --color-primary-dark: #1976d2;
    --color-accent: #ff4081;
    --color-accent-rgb: 255, 64, 129;
    --color-text-primary: #333333;
    --color-text-secondary: #757575;
    --color-text-secondary-rgb: 117, 117, 117;
    --color-text-on-dark: #e0e0e0; /* Цвет текста для темного фона загрузки */
    --color-border: #e0e0e0;
    --color-border-rgb: 224, 224, 224;
    --osc-icon-invert: 0%; /* Управляется темами */

    --topbar-height: 50px;
    --panel-width: 320px;
    --knob-size: 60px;
    --knob-size-small: 48px;
    --button-height: 48px;
    --border-radius: 8px;
    --knob-border-radius: 50%;
    --xy-label-height: 30px;

    --preset-cube-size: 80px;
    --preset-grid-gap: 12px;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

html, body {
    height: 100%;
    width: 100%;
    overflow: hidden;
    position: fixed;
    touch-action: manipulation;
    font-family: 'Roboto', Arial, sans-serif;
    background-color: var(--color-background);
    color: var(--color-text-primary);
    overscroll-behavior: none;
}

#app-container {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    position: relative;
    overflow: hidden;
}

/* Typography */
h1, h2, h3, h4, h5, h6 { font-weight: 500; margin-bottom: 10px; color: var(--color-text-primary); }
h2 { font-size: 20px; }
h3 { font-size: 18px; }
h4 { font-size: 16px; }
h5 { font-size: 14px; font-weight: normal; color: var(--color-text-secondary); margin-bottom: 5px; }
label:not(.toggle) { display: block; margin-bottom: 5px; font-weight: 500; font-size: 14px; }

/* Buttons */
button { background-color: var(--color-surface); color: var(--color-text-primary); border: 1px solid var(--color-border); border-radius: var(--border-radius); padding: 8px 16px; font-size: 14px; cursor: pointer; transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s; outline: none; height: var(--button-height); display: inline-flex; align-items: center; justify-content: center; vertical-align: middle; }
button:active { background-color: rgba(var(--color-primary-rgb), 0.15); transform: scale(0.98); box-shadow: none; }
button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; background-color: var(--color-border); }
.round-button { width: 40px; height: 40px; border-radius: 50%; padding: 0; font-size: 18px; flex-shrink: 0; }
.text-button { background: none; border: none; color: var(--color-primary); padding: 0 16px; height: 36px; border-radius: 18px; font-size: 14px; font-weight: 500; text-transform: uppercase; transition: background-color 0.2s, color 0.2s; }
.text-button:hover { background-color: rgba(var(--color-primary-rgb), 0.08); }
.text-button:active { background-color: rgba(var(--color-primary-rgb), 0.15); transform: none; }
#sound-library-button { background-color: var(--color-surface); border: 1px solid var(--color-border); color: var(--color-text-primary); text-transform: none; font-weight: normal; }
#sound-library-button:hover { background-color: rgba(var(--color-border-rgb), 0.5); color: var(--color-text-primary); }
#sound-library-button:active { background-color: rgba(var(--color-border-rgb), 0.8); color: var(--color-text-primary); }
.action-button { background-color: var(--color-primary); color: white; font-size: 14px; height: 36px; margin: 8px 4px; padding: 0 12px; }
.action-button:active { background-color: var(--color-primary-dark); }
.close-button { width: 36px; height: 36px; font-size: 24px; padding: 0; margin: 0; background: none; border: none; color: var(--color-text-secondary); border-radius: 50%; transition: background-color 0.2s; }
.close-button:hover { background-color: rgba(var(--color-border-rgb), 0.5); }
.close-button:active { background-color: rgba(var(--color-border-rgb), 0.8); transform: none; }
.slider-button { width: 36px; height: 36px; font-size: 18px; border-radius: 50%; padding: 0; margin: 0 8px; flex-shrink: 0; }

/* Toggles */
.toggle { position: relative; display: inline-block; width: 50px; height: 26px; flex-shrink: 0; }
.toggle input { opacity: 0; width: 0; height: 0; }
.toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--border-radius); transition: background-color 0.2s ease-out, border-color 0.2s ease-out; box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }
.toggle-slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 2px; bottom: 2px; background-color: var(--color-text-secondary); border-radius: calc(var(--border-radius) - 2px); transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.25s; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
input:checked + .toggle-slider { background-color: var(--color-primary); border-color: var(--color-primary-dark); }
input:checked + .toggle-slider:before { transform: translateX(24px); background-color: var(--color-surface); box-shadow: 0 1px 2px rgba(0,0,0,0.3); }
.toggle input:focus-visible + .toggle-slider { outline: 2px solid var(--color-primary-light); outline-offset: 2px; }

/* Sliders */
.slider-container { display: flex; align-items: center; justify-content: space-between; margin: 10px 0; gap: 10px; }
.slider { flex-grow: 1; -webkit-appearance: none; appearance: none; width: 100%; height: 4px; background: var(--color-border); outline: none; border-radius: 2px; cursor: pointer; }
.slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--color-primary); cursor: pointer; border: 2px solid var(--color-surface); box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
.slider::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: var(--color-primary); cursor: pointer; border: 2px solid var(--color-surface); box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
.slider-value { min-width: 30px; text-align: center; font-weight: bold; font-size: 14px; color: var(--color-text-secondary); }

/* Dropdowns */
.dropdown-container { margin-bottom: 10px; }
.dropdown-container.small { margin-bottom: 5px; }
.dropdown-container label { font-size: 14px; margin-bottom: 4px; }
.dropdown { width: 100%; height: 40px; padding: 0 30px 0 10px; border: 1px solid var(--color-border); border-radius: var(--border-radius); background-color: var(--color-surface); color: var(--color-text-primary); font-size: 14px; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23757575' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e"); background-repeat: no-repeat; background-position: right 10px center; background-size: 16px; cursor: pointer; transition: border-color 0.2s; }
.dropdown:focus { border-color: var(--color-primary); outline: none; box-shadow: 0 0 0 2px rgba(var(--color-primary-rgb), 0.2); }
.dropdown.small { height: 32px; font-size: 12px; padding: 0 25px 0 8px; background-size: 14px; }

/* Top Bar */
#topbar {
    height: var(--topbar-height);
    width: 100%;
    background-color: var(--color-surface);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 12px;
    border-bottom: 1px solid var(--color-border);
    z-index: 100;
    flex-shrink: 0;
    gap: 10px;
}
.topbar-group {
    display: flex;
    align-items: center;
    gap: 8px;
}
#app-title {
    text-align: center;
    font-size: 20px;
    font-weight: bold;
    color: var(--color-primary);
    margin: 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    animation: titleGlow 3s ease-in-out infinite;
    min-width: 100px;
}
.topbar-button {
    margin: 0;
    flex-shrink: 0;
}
.topbar-button.active { background-color: rgba(var(--color-primary-rgb), 0.2); box-shadow: inset 0 0 4px rgba(var(--color-primary-rgb), 0.3); color: var(--color-primary-dark); }
#sound-library-button.active { background-color: rgba(var(--color-primary-rgb), 0.2); border-color: var(--color-primary); color: var(--color-primary-dark); }

#effects-button { font-size: 16px; font-weight: bold; text-transform: uppercase; }
@keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(229, 57, 53, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(229, 57, 53, 0); } 100% { box-shadow: 0 0 0 0 rgba(229, 57, 53, 0); } }
@keyframes titleGlow { 0% { text-shadow: 0 0 5px rgba(var(--color-primary-rgb), 0.4), 0 0 10px rgba(var(--color-primary-rgb), 0.3); } 50% { text-shadow: 0 0 10px rgba(var(--color-primary-rgb), 0.6), 0 0 20px rgba(var(--color-primary-rgb), 0.4); } 100% { text-shadow: 0 0 5px rgba(var(--color-primary-rgb), 0.4), 0 0 10px rgba(var(--color-primary-rgb), 0.3); } }

/* XY Pad */
#xy-pad-container { flex-grow: 1; width: 100%; position: relative; overflow: hidden; background-color: var(--color-background); touch-action: none; }
#xy-labels { position: absolute; top: 0; left: 0; width: 100%; height: var(--xy-label-height); display: flex; z-index: 25; pointer-events: none; background-color: rgba(var(--color-surface-rgb), 0.85); border-bottom: 1px solid var(--color-border); }
.xy-label { position: absolute; top: 50%; transform: translate(-50%, -50%); font-size: 12px; color: var(--color-text-secondary); text-align: center; pointer-events: none; white-space: nowrap; padding: 2px 4px; border-bottom: 2px solid transparent; }

/* Обновленные стили для контейнера зон и новые классы для областей и разделителей */
#xy-visualizer, #xy-zones, #xy-touches { position: absolute; top: var(--xy-label-height); left: 0; width: 100%; height: calc(100% - var(--xy-label-height)); pointer-events: none; }
#xy-zones { z-index: 20; /* Теперь это контейнер для .xy-pad-zone-area и .xy-zone-divider */
           /* Убедитесь, что #xy-zones имеет position: relative; или absolute; */
          }
#xy-visualizer { z-index: 10; }
#xy-touches { z-index: 30; }

/* Новый класс для области зоны (тела клавиши) */
.xy-pad-zone-area {
    position: absolute;
    top: 0;
    height: 100%;
    background-color: transparent; /* Дефолтный фон для "белых" клавиш (прозрачный) */
    /* transition: background-color 0.1s ease-out; */ /* Плавный переход цвета */
    pointer-events: none; /* Должны быть ниже touch events */
    /* border-right: 1px solid transparent; */ /* Если линии делаются через границу */
}

/* Стиль для диезов/бемолей */
.xy-pad-zone-area.sharp-flat-zone {
    /*background-color: rgba(var(--color-text-primary-rgb, 51,51,51), 0.2); !* Пример: полупрозрачный темный фон *!*/
    background-color: rgba(var(--color-border-rgb), 0.3); /* Более светлый серый фон для контраста */
    /* Если нужно изменить ширину, это сложнее и потребует корректировки startX/width в JS */
}

/* Новый класс для линий-разделителей */
.xy-zone-divider {
    position: absolute;
    height: 100%;
    top: 0;
    border-left: 2px solid rgba(var(--color-border-rgb), 0.4); /* Дефолтный стиль линии */
    pointer-events: none; /* Не мешает касаниям */
    /* transition: border-left-color 0.3s ease-out; */ /* Плавный переход цвета линии */
    z-index: 21; /* Выше областей зон, но ниже меток и визуализатора касаний */
}

/* Удаляем или переименовываем старый класс .xy-zone, если он больше не нужен для линий */
/* .xy-zone { display: none; } *//* Или удалите полностью */
/* Если старый .xy-zone использовался только для линий, то просто его переиспользуем */

/* OLD .xy-zone styles - если они были только для линий */
/*
.xy-zone {
    position: absolute;
    height: 100%;
    top: 0;
    border-left: 2px solid rgba(var(--color-border-rgb), 0.4);
    pointer-events: none;
    transition: border-left-color 0.3s ease-out;
}
.xy-zone:hover {
    border-left-color: rgba(var(--color-primary-rgb), 0.6);
}
*/

/* XY-touch (визуализация касаний) - оставляем как есть */
.xy-touch { position: absolute; width: 40px; height: 40px; border-radius: 50%; transform: translate(-50%, -50%) scale(1); pointer-events: none; background: radial-gradient(circle, rgba(var(--color-primary-rgb), 0.8) 0%, rgba(var(--color-primary-rgb), 0) 70%); opacity: 0; transition: opacity 0.3s ease-out, transform 0.1s ease-out, box-shadow 0.1s ease-out, background 0.1s ease-out; will-change: transform, opacity, background, box-shadow; }

/* Panels */
.side-panel, .top-panel { position: absolute; background-color: var(--color-surface); z-index: 200; display: flex; flex-direction: column; box-shadow: 0 0 15px rgba(0, 0, 0, 0.1); overflow: hidden; }
.side-panel { top: var(--topbar-height); height: calc(100% - var(--topbar-height)); width: var(--panel-width); max-width: 85%; transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
.left-panel { left: 0; transform: translateX(-100%); border-right: 1px solid var(--color-border); }
.right-panel { right: 0; transform: translateX(100%); border-left: 1px solid var(--color-border); }
.left-panel.show, .right-panel.show { transform: translateX(0); }
.top-panel { top: var(--topbar-height); left: 0; width: 100%; height: 0; max-height: 70vh; transition: height 0.25s ease-out; border-bottom: 1px solid var(--color-border); }
.top-panel.show { height: 70vh; }
.panel-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; border-bottom: 1px solid var(--color-border); flex-shrink: 0; }
.panel-header h2 { margin: 0; }
.panel-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 12px;
    -webkit-overflow-scrolling: touch;
}
.setting-group {
    margin-bottom: 12px;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(var(--color-border-rgb), 0.5);
}
.setting-group:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
}

/* Убедимся, что у label внутри .setting-group есть консистентный нижний отступ,
   если за ним сразу идет select, как в случае с Visualizer и Touch Effect. */
.setting-group > label { /* Прямой потомок label */
    display: block; /* Если еще не так */
    margin-bottom: 8px; /* Консистентный отступ под заголовком группы */
    font-weight: 500;
    font-size: 14px; /* Уже есть, но для примера */
}

/* Для выпадающих списков, которые идут сразу после label в группе */
.setting-group > .dropdown,
.setting-group > .dropdown-container > .dropdown { /* Если есть обертка .dropdown-container */
    /* Можно добавить margin-top, если нужно, но обычно отступа label достаточно */
}
.toggle-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 4px;
    margin-bottom: 8px;
}
.toggle-container span {
    flex-grow: 1;
    margin-right: 15px;
    font-size: 14px;
    color: var(--color-text-primary);
    font-weight: 500;
}

/* Grid layout for controls */
.control-grid { display: flex; flex-wrap: wrap; gap: 15px; align-items: flex-start; margin-top: 10px; }
.control-grid .knob-container, .control-grid .dropdown-container { margin: 0; flex: 1 1 100px; min-width: 80px; }
.control-grid .dropdown-container { flex-basis: 150px; }

/* Effects Panel - Стили для макро-ручек и Y-Axis */
#effects-panel h4 { margin-top: 15px; }
#macro-controls { justify-content: space-around; margin-bottom: 20px; }
.effect-actions { display: flex; justify-content: center; margin-top: 20px; }
.fx-chain-container { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 10px; }
.fx-chain-container label { flex-basis: 100%; margin-bottom: 5px; }
.fx-chain-container select { flex: 1 1 150px; min-width: 120px; }
.y-axis-controls h4 { margin-bottom: 15px; }
.y-axis-row { display: flex; flex-wrap: wrap; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 15px; }
.y-axis-row .knob-container { flex: 1; min-width: 70px; }
.y-axis-row .dropdown-container { flex: 1; min-width: 100px; }
.y-axis-row .knob-container[data-param^="effectsIntensity"],
.y-axis-row .knob-container[data-param="effectsThreshold"] { }

/* === НОВЫЕ СТИЛИ для Master Output Controls (Часть 1) === */
.master-output-controls h4 { margin-bottom: 15px; }
.master-output-controls .control-grid {
    justify-content: center; /* Центрируем одну ручку */
}
/* ======================================================== */

/* Knobs */
.knob-container { display: flex; flex-direction: column; align-items: center; margin: 5px; min-width: 65px; text-align: center; }
.knob { width: var(--knob-size); height: var(--knob-size); border-radius: var(--knob-border-radius); background-color: var(--color-background); border: 2px solid var(--color-border); position: relative; cursor: ns-resize; touch-action: none; box-shadow: inset 0 1px 2px rgba(0,0,0,0.1), 0 1px 1px rgba(255,255,255,0.5); }
.knob.small { width: var(--knob-size-small); height: var(--knob-size-small); border-width: 1px; }
.knob-dial { position: absolute; top: 5px; left: 50%; width: 3px; height: calc(50% - 7px); background-color: var(--color-primary); transform-origin: bottom center; transform: translateX(-50%) rotate(0deg); border-radius: 2px; pointer-events: none; transition: background-color 0.2s; }
.knob.small .knob-dial { width: 2px; height: calc(50% - 6px); top: 4px; }
.knob-value { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 12px; font-weight: 500; color: var(--color-text-secondary); pointer-events: none; }
.knob.small .knob-value { font-size: 10px; }
.knob-container label { margin-top: 4px; font-size: 11px; color: var(--color-text-secondary); white-space: nowrap; }

/* Sound Library */
.sound-library-container { display: flex; flex-direction: column; gap: 20px; height: 100%; }
.sound-presets { flex: 1; display: flex; flex-direction: column; }
.preset-grid {
    flex-grow: 1;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(var(--preset-cube-size), 1fr));
    gap: var(--preset-grid-gap);
    padding: var(--preset-grid-gap);
    overflow-y: auto;
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius);
    background-color: var(--color-background);
    min-height: 150px;
}
.preset-cube {
    width: var(--preset-cube-size);
    height: var(--preset-cube-size);
    border: 2px solid var(--color-border);
    border-radius: var(--border-radius);
    background-color: var(--color-surface);
    color: var(--color-text-secondary);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 8px;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    overflow: hidden;
    white-space: normal;
    word-break: break-word;
    transition: background-color 0.2s ease-out, border-color 0.2s ease-out,
                box-shadow 0.2s ease-out, transform 0.15s cubic-bezier(0.2, 0.8, 0.4, 1.2);
}
.preset-cube:hover {
    border-color: var(--color-primary-light);
    box-shadow: 0 3px 8px rgba(var(--color-primary-rgb), 0.2);
    transform: translateY(-2px);
}
.preset-cube.active {
    border-color: var(--color-accent);
    color: var(--color-accent);
    font-weight: bold;
    box-shadow: 0 0 12px rgba(var(--color-accent-rgb), 0.5),
                inset 0 0 6px rgba(var(--color-accent-rgb), 0.2);
    transform: scale(1.05);
}
.preset-cube.disabled {
    opacity: 0.6;
    cursor: default;
    font-style: italic;
    background-color: var(--color-border);
    transform: none;
    box-shadow: none;
}

/* Loading Overlay Styles */
#loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(ellipse at center,
        rgba(10, 26, 42, 0.95) 0%,
        rgba(5, 13, 21, 0.98) 50%,
        rgba(0, 0, 0, 1) 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 1;
    visibility: visible;
    cursor: pointer;
    transition: opacity 0.5s ease-out, transform 0.5s ease-out, visibility 0s linear 0.5s;
    overflow: hidden;
}
#loading-overlay::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background:
        radial-gradient(circle at 20% 30%, rgba(33, 150, 243, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(255, 64, 129, 0.15) 0%, transparent 50%);
    pointer-events: none;
}
#loading-overlay.hidden {
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
    cursor: default;
    transition: opacity 0.5s ease-out, transform 0.5s ease-out, visibility 0s linear 0.5s;
}
#loading-overlay.hiding {
    opacity: 0 !important;
    transform: scale(1.2);
    pointer-events: none;
}
#loading-stars-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    pointer-events: none;
}
#loading-prism-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 3;
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
}
.loading-text {
    position: relative;
    z-index: 2;
    font-size: 18px;
    color: var(--color-text-on-dark, #e0e0e0);
    text-align: center;
    padding: 0 20px;
    pointer-events: none;
    transition: opacity 0.3s ease-out;
    text-shadow: 0 0 10px rgba(var(--color-primary-rgb), 0.5);
}
.loading-text.fade-out {
    opacity: 0;
}
#loading-title {
    position: relative;
    z-index: 4;
    font-size: 3.5em;
    font-weight: bold;
    color: var(--color-primary);
    text-shadow: 0 0 8px rgba(var(--color-primary-rgb), 0.6),
                 0 0 15px rgba(var(--color-primary-rgb), 0.4);
    margin-bottom: 10px;
    text-align: center;
    opacity: 0;
    transform: scale(0.8);
    visibility: hidden;
    transition: opacity 0.8s ease-out 0.2s,
                transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) 0.2s,
                visibility 0s linear 1s;
}
#loading-title.show {
    opacity: 1;
    transform: scale(1);
    visibility: visible;
    transition: opacity 0.8s ease-out 0.2s,
                transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) 0.2s,
                visibility 0s linear 0s;
}
.loading-prompt {
    position: relative;
    z-index: 4;
    font-size: 1.2em;
    color: var(--color-text-on-dark, #e0e0e0);
    margin-top: 5px;
    text-align: center;
    font-weight: 500;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.5s ease-out 0.8s,
                visibility 0s linear 1.3s;
    text-shadow: 0 0 8px rgba(var(--color-primary-rgb), 0.4);
}
.loading-prompt.show {
    opacity: 1;
    visibility: visible;
    transition: opacity 0.5s ease-out 0.8s,
                visibility 0s linear 0s;
    animation: promptPulse 2s infinite ease-in-out;
}
@keyframes promptPulse {
    0% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(1.03); }
    100% { opacity: 1; transform: scale(1); }
}

/* Responsive Adjustments & Landscape */
.landscape-mode { }
@media (orientation: landscape) {
    .side-panel { width: 300px; max-width: 40%; }
    .top-panel { max-height: 65vh; }
    .sound-presets { flex: 1; }
    .control-grid .knob-container { flex-basis: 80px; }
    .control-grid .dropdown-container { flex-basis: 120px; }
    #loading-title { font-size: 4em; }
    .loading-prompt { font-size: 1.3em; }
}
@media (max-width: 700px) {
    .side-panel { width: 280px; max-width: 85%; }
    .top-panel { max-height: 75vh; }
    .sound-presets { width: 100%; }
    .fx-chain-container select { flex-basis: 100%; }
    .y-axis-row { justify-content: space-around; }
    .y-axis-row .knob-container, .y-axis-row .dropdown-container { flex-basis: 120px; }
     #loading-title { font-size: 3em; }
     .loading-prompt { font-size: 1.1em; }
}
@media (max-width: 400px) {
     #app-title { font-size: 16px; }
     .topbar-button { padding: 6px; }
     .round-button { width: 36px; height: 36px; font-size: 16px; }
     .text-button { font-size: 12px; }
     .knob { width: 50px; height: 50px; }
     .knob.small { width: 40px; height: 40px; }
     .knob-value { font-size: 10px; }
     .knob.small .knob-value { font-size: 9px; }
     .knob-container label { font-size: 10px; }
     .control-grid .knob-container { min-width: 60px; }
     .control-grid .dropdown-container { min-width: 100px; }
     .preset-cube { --preset-cube-size: 65px; font-size: 10px; }
     .action-button { font-size: 12px; height: 32px; }
     #loading-title { font-size: 2.5em; }
     .loading-prompt { font-size: 1em; }
}

.reload-app-button-style {
    background-color: #e53935;
    color: white;
    border: 1px solid #c62828;
    transition: background-color 0.2s ease-out, transform 0.15s cubic-bezier(0.2, 0.8, 0.4, 1.2), box-shadow 0.2s ease-out;
}
.reload-app-button-style:hover {
    background-color: #d32f2f;
    border-color: #b71c1c;
    transform: translateY(-1px) scale(1.05);
}
.reload-app-button-style:active {
    background-color: #b71c1c;
    transform: scale(0.95);
}
.reload-app-button-style .restart-icon {
    fill: currentColor;
}
.reload-app-button-style.reloading .restart-icon {
    animation: spinReload 2s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
}
@keyframes spinReload {
    0% { transform: rotate(0deg) scale(1); }
    50% { transform: rotate(-360deg) scale(1.1); }
    100% { transform: rotate(-720deg) scale(1); }
}
.reload-app-button-style:disabled {
    background-color: #a0a0a0 !important;
    color: #e0e0e0 !important;
    cursor: wait !important;
    transform: none !important;
    box-shadow: none !important;
}
.reload-app-button-style:disabled .restart-icon {
    opacity: 0.5;
    animation: none !important;
}

@keyframes restartSpin {
    0% { transform: rotate(0deg) scale(1); }
    20% { transform: rotate(-180deg) scale(1.1); }
    40% { transform: rotate(-360deg) scale(1); }
    60% { transform: rotate(-540deg) scale(1.1); }
    80% { transform: rotate(-720deg) scale(1); }
    100% { transform: rotate(-720deg) scale(1); }
}
.restart-audio-button.animating { pointer-events: none; }
.restart-audio-button.animating svg { animation: restartSpin 2s cubic-bezier(0.4, 0, 0.2, 1); }
.restart-audio-button::after {
    content: '';
    position: absolute;
    top: 50%; left: 50%;
    width: 100%; height: 100%;
    background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 70%);
    transform: translate(-50%, -50%) scale(0);
    opacity: 0;
    transition: transform 0.3s ease-out, opacity 0.3s ease-out;
}
.restart-audio-button:hover::after { transform: translate(-50%, -50%) scale(1.5); opacity: 1; }

/* === Custom Selector Popover === */
.custom-selector-popover {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  z-index: 9999;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
}
.custom-selector-popover[style*="display: block"],
.custom-selector-popover.active {
  pointer-events: auto;
}
.custom-selector-backdrop {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(var(--color-background-rgb, 10,10,26), 0.7);
  backdrop-filter: blur(2px);
  z-index: 0;
  transition: background 0.2s;
}
.custom-selector-modal {
  position: relative;
  background: var(--color-surface);
  border-radius: 18px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.25), 0 1.5px 8px rgba(var(--color-primary-rgb,0,191,255),0.08);
  min-width: 260px;
  max-width: 90vw;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  z-index: 1;
  animation: popoverIn 0.18s cubic-bezier(0.4,0,0.2,1);
}
@keyframes popoverIn {
  0% { opacity: 0; transform: scale(0.95) translateY(30px); }
  100% { opacity: 1; transform: scale(1) translateY(0); }
}
.custom-selector-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px 8px 20px;
  border-bottom: 1px solid var(--color-border);
}
#custom-selector-title {
  font-size: 18px;
  font-weight: 600;
  color: var(--color-primary);
}
#custom-selector-close {
  font-size: 22px;
  background: none;
  border: none;
  color: var(--color-text-secondary);
  cursor: pointer;
  border-radius: 50%;
  width: 36px; height: 36px;
  transition: background 0.2s;
}
#custom-selector-close:hover {
  background: rgba(var(--color-border-rgb),0.15);
}
.custom-selector-options {
  padding: 10px 0 10px 0;
  overflow-y: auto;
  max-height: 55vh;
  min-width: 220px;
  scrollbar-width: thin;
  scrollbar-color: var(--color-primary) var(--color-surface);
}
.custom-selector-options::-webkit-scrollbar {
  width: 10px;
  background: var(--color-surface);
}
.custom-selector-options::-webkit-scrollbar-thumb {
  background: var(--color-primary);
  border-radius: 8px;
  border: 2px solid var(--color-surface);
}
.custom-selector-options::-webkit-scrollbar-thumb:hover {
  background: var(--color-primary-dark);
}
.custom-selector-options::-webkit-scrollbar-corner {
  background: var(--color-surface);
}
.custom-selector-option {
  display: flex;
  align-items: center;
  gap: 14px;
  padding: 12px 24px;
  font-size: 16px;
  color: var(--color-text-primary);
  cursor: pointer;
  border: none;
  background: none;
  width: 100%;
  transition: background 0.15s, color 0.15s;
  border-radius: 10px;
  margin: 2px 0;
  outline: none;
}
.custom-selector-option:hover, .custom-selector-option:focus {
  background: rgba(var(--color-primary-rgb),0.10);
  color: var(--color-primary);
}
.custom-selector-option.active {
  background: rgba(var(--color-primary-rgb),0.18);
  color: var(--color-accent, var(--color-primary));
  font-weight: 600;
}
.custom-selector-option .option-preview {
  width: 22px; height: 22px;
  border-radius: 6px;
  flex-shrink: 0;
  background: var(--color-border);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  margin-right: 2px;
}
.custom-selector-option .option-preview.theme {
  border: 2px solid var(--color-primary);
}
.custom-selector-option .option-preview.visualizer {
  border: 2px solid var(--color-accent);
}
.custom-selector-option .option-preview.fxchain {
  border: 2px solid var(--color-primary-dark);
}
.custom-selector-option .option-preview.language {
  font-size: 15px;
  background: none;
  border: none;
}
.custom-selector-option .option-preview.scale {
  font-size: 15px;
  background: none;
  border: none;
}
.custom-selector-option .option-label {
  flex-grow: 1;
  text-align: left;
  font-size: 16px;
  font-weight: 500;
  color: inherit;
}
@media (max-width: 600px) {
  .custom-selector-modal { min-width: 90vw; max-width: 98vw; }
  .custom-selector-options { min-width: 0; }
}

/* styles.css */
.dropdown-display {
    width: 100%;
    height: 40px; /* Такой же, как у .dropdown */
    padding: 0 30px 0 10px;
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius);
    background-color: var(--color-surface);
    color: var(--color-text-primary);
    font-size: 14px;
    line-height: 38px; /* Для вертикального выравнивания текста */
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23757575' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 10px center;
    background-size: 16px;
    cursor: pointer;
    transition: border-color 0.2s;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.dropdown-display:hover {
    border-color: var(--color-primary-light);
}

/* Если нужно кастомизировать отображение выбранного режима */
/* #pad-mode-selector-display { ... } */

/* Для контейнера специфичных настроек, если нужны отступы */
/* #mode-specific-controls-container {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid var(--color-border-rgb, 0.2);
} */

/* Сообщение об отсутствии настроек */
.no-controls-message {
    padding: 10px;
    text-align: center;
    color: var(--color-text-secondary);
    font-style: italic;
}

/* Общий класс для групп контролов в специфичных для режима настройках */
.mode-control-group {
    /* Можно добавить специфичные отступы, если нужно */
}

.knob-sub-label { /* Для метки под ручкой, если используется */
    font-size: 10px;
    color: var(--color-text-secondary);
    margin-top: 2px;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    width: 100%;
}

.xy-pad-zone-area.hint-harmonic-suggestion {
    background-color: yellow !important;
    border-left-color: rgba(var(--color-accent-rgb), 0.7) !important;
    border-right-color: rgba(var(--color-accent-rgb), 0.7) !important;
    transition: background-color 0.2s ease-out, box-shadow 0.2s ease-out;
}
.xy-pad-zone-area.hint-tonic {
    background-color: rgba(var(--color-primary-rgb), 0.25);
}

#rocket-mode-controls-content .setting-group {
    padding-left: 10px;
    border-left: 2px solid var(--color-primary-light);
    margin-top: 15px;
}
#rocket-mode-controls-content h5 {
    color: var(--color-primary);
    margin-bottom: 10px;
    font-size: 1em;
    border-bottom: 1px solid var(--color-border);
    padding-bottom: 5px;
}
.mode-control-item label:not(.toggle) {
    display: block;
    margin-bottom: 5px;
    font-weight: normal;
    font-size: 0.9em;
}
.mode-control-item .dropdown-display,
#rocket-mode-controls-content .dropdown-display {
    font-size: 0.9em;
    height: 36px;
    line-height: 34px;
}
.mode-control-item .knob-container.small-knob-container .knob.small {
    width: var(--knob-size-small, 48px);
    height: var(--knob-size-small, 48px);
}
.mode-control-item .knob-container.small-knob-container .knob-sub-label {
    font-size: 10px;
}
.display-value {
    padding: 8px 0;
    font-weight: bold;
    color: var(--color-text-primary);
}

/* Rocket Mode Phase Buttons */
.rocket-phase-buttons-group {
    display: flex;
    gap: 10px;
    margin: 12px 0 0 0;
    justify-content: flex-start;
}
.rocket-phase-buttons-group .action-button.active {
    background-color: var(--color-accent);
    color: #fff;
    font-weight: bold;
    border-color: var(--color-accent);
    box-shadow: 0 0 8px rgba(var(--color-accent-rgb,255,64,129),0.25);
}
.rocket-phase-buttons-group .action-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

#rocket-status-panel {
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding: 6px 10px;
    background-color: rgba(var(--color-surface-rgb), 0.9);
    border-bottom: 1px solid var(--color-border);
    font-size: 11px;
    color: var(--color-text-secondary);
    height: 30px;
    overflow: hidden;
    white-space: nowrap;
    transition: opacity 0.3s ease-out, height 0.3s ease-out;
    z-index: 90;
}
#rocket-status-panel.rocket-status-panel-hidden {
    opacity: 0;
    height: 0;
    padding-top: 0;
    padding-bottom: 0;
    border-bottom-width: 0;
    pointer-events: none;
}
.status-item {
    display: inline-flex;
    align-items: center;
    margin: 0 5px;
    overflow: hidden;
    text-overflow: ellipsis;
}
.status-icon {
    margin-right: 4px;
    font-size: 13px;
}
.status-item strong {
    color: var(--color-text-primary);
    margin-right: 3px;
}
.status-value {
    font-weight: bold;
    color: var(--color-primary);
    max-width: 120px;
    overflow: hidden;
    text-overflow: ellipsis;
    vertical-align: middle;
}
#status-energy-level {
    letter-spacing: -1px;
}

.rocket-status-hide-btn {
  position: absolute;
  top: 4px;
  right: 8px;
  background: transparent;
  border: none;
  font-size: 1.2em;
  color: var(--color-text-secondary, #888);
  cursor: pointer;
  z-index: 2;
}
.rocket-status-hide-btn:hover {
  color: var(--color-accent, #ff4081);
}
.rocket-status-show-btn {
  position: fixed;
  top: 60px;
  right: 24px;
  z-index: 1000;
  background: var(--color-bg-secondary, #fff);
  border: 1px solid var(--color-border, #ccc);
  border-radius: 50%;
  width: 36px;
  height: 36px;
  font-size: 1.3em;
  color: var(--color-accent, #ff4081);
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(0,0,0,0.08);
  display: flex;
  align-items: center;
  justify-content: center;
}
.rocket-status-show-btn:hover {
  background: var(--color-accent, #ff4081);
  color: #fff;
}
.status-clickable {
  cursor: pointer;
  text-decoration: underline dotted;
  transition: color 0.15s;
}
.status-clickable:hover {
  color: var(--color-accent, #ff4081);
}


================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\css\themes.css
/* Theme variables - colors with RGB values for transparency */

/* Night Theme */
.theme-night {
    --color-background: #121212;
    --color-background-rgb: 18, 18, 18;
    --color-surface: #1e1e1e;
    --color-surface-rgb: 30, 30, 30;
    --color-primary: #bb86fc;
    --color-primary-rgb: 187, 134, 252;
    --color-primary-light: #d9b6fc;
    --color-primary-dark: #9d4edd;
    --color-accent: #03dac6;
    --color-accent-rgb: 3, 218, 198;
    --color-text-primary: #e0e0e0;
    --color-text-secondary: #a0a0a0;
    --color-border: #333333;
    --color-border-rgb: 51, 51, 51;
    --osc-icon-invert: 100%;
}

/* Retro Theme */
.theme-retro {
    --color-background: #fff8e1;
    --color-background-rgb: 255, 248, 225;
    --color-surface: #ffe0b2;
    --color-surface-rgb: 255, 224, 178;
    --color-primary: #ff5722;
    --color-primary-rgb: 255, 87, 34;
    --color-primary-light: #ff8a65;
    --color-primary-dark: #e64a19;
    --color-accent: #795548;
    --color-accent-rgb: 121, 85, 72;
    --color-text-primary: #5d4037;
    --color-text-secondary: #8d6e63;
    --color-border: #bcaaa4;
    --color-border-rgb: 188, 170, 164;
     --osc-icon-invert: 0%;
}

/* Retro theme specific effects */
.theme-retro { background-image: radial-gradient(rgba(188, 170, 164, 0.1) 15%, transparent 16%), radial-gradient(rgba(188, 170, 164, 0.1) 15%, transparent 16%); background-size: 60px 60px; background-position: 0 0, 30px 30px; }
.theme-retro #xy-pad-container { background-image: linear-gradient(rgba(188, 170, 164, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(188, 170, 164, 0.05) 1px, transparent 1px); background-size: 20px 20px; }
.theme-retro .knob { background-image: radial-gradient(circle, var(--color-surface) 0%, var(--color-background) 100%); }

/* Aurora Theme */
.theme-aurora {
    --color-background: #0a0a1a;
    --color-background-rgb: 10, 10, 26;
    --color-surface: #1a1a2e;
    --color-surface-rgb: 26, 26, 46;
    --color-primary: #00ffcc;
    --color-primary-rgb: 0, 255, 204;
    --color-primary-light: #66ffeb;
    --color-primary-dark: #00cc9f;
    --color-accent: #ff00ff;
    --color-accent-rgb: 255, 0, 255;
    --color-text-primary: #e0e0ff;
    --color-text-secondary: #a0a0ff;
    --color-border: #2a2a4a;
    --color-border-rgb: 42, 42, 74;
    --osc-icon-invert: 100%;
}

/* Aurora theme specific effects */
.theme-aurora .knob-dial { box-shadow: 0 0 15px var(--color-primary), 0 0 30px var(--color-accent); }
.theme-aurora .xy-touch { box-shadow: 0 0 25px rgba(var(--color-primary-rgb), 0.8), 0 0 40px rgba(var(--color-accent-rgb), 0.4); }
.theme-aurora button { text-shadow: 0 0 8px var(--color-primary); }
.theme-aurora #app-title { text-shadow: 0 0 15px var(--color-primary), 0 0 30px var(--color-accent); }
.theme-aurora #xy-pad-container { background-image: linear-gradient(45deg, rgba(var(--color-primary-rgb), 0.1), rgba(var(--color-accent-rgb), 0.1)); }

/* Ocean Theme */
.theme-ocean {
    --color-background: #001f3f;
    --color-background-rgb: 0, 31, 63;
    --color-surface: #003366;
    --color-surface-rgb: 0, 51, 102;
    --color-primary: #00bfff;
    --color-primary-rgb: 0, 191, 255;
    --color-primary-light: #66d9ff;
    --color-primary-dark: #0099cc;
    --color-accent: #ff6b6b;
    --color-accent-rgb: 255, 107, 107;
    --color-text-primary: #e0f7ff;
    --color-text-secondary: #a0d8ff;
    --color-border: #004080;
    --color-border-rgb: 0, 64, 128;
    --osc-icon-invert: 100%;
}

/* Ocean theme specific effects */
.theme-ocean .knob-dial { box-shadow: 0 0 10px var(--color-primary), 0 0 20px rgba(var(--color-primary-rgb), 0.5); }
.theme-ocean .xy-touch { box-shadow: 0 0 20px rgba(var(--color-primary-rgb), 0.6); }
.theme-ocean button { text-shadow: 0 0 5px var(--color-primary); }
.theme-ocean #app-title { text-shadow: 0 0 10px var(--color-primary); }
.theme-ocean #xy-pad-container { background-image: linear-gradient(180deg, rgba(var(--color-primary-rgb), 0.1), rgba(var(--color-surface-rgb), 0.2)); }

/* Cyberpunk Theme */
.theme-cyberpunk {
    --color-background: #000000;
    --color-background-rgb: 0, 0, 0;
    --color-surface: #1a1a1a;
    --color-surface-rgb: 26, 26, 26;
    --color-primary: #39ff14;
    --color-primary-rgb: 57, 255, 20;
    --color-primary-light: #7fff00;
    --color-primary-dark: #32cd32;
    --color-accent: #ff00ff;
    --color-accent-rgb: 255, 0, 255;
    --color-text-primary: #39ff14;
    --color-text-secondary: #7fff00;
    --color-border: #333333;
    --color-border-rgb: 51, 51, 51;
    --osc-icon-invert: 100%;
}

/* Cyberpunk theme specific effects */
.theme-cyberpunk .knob-dial { 
    box-shadow: 0 0 20px var(--color-primary), 0 0 40px var(--color-accent);
    background: linear-gradient(45deg, var(--color-primary), var(--color-accent));
}
.theme-cyberpunk .xy-touch { 
    box-shadow: 0 0 30px rgba(var(--color-primary-rgb), 0.9), 0 0 50px rgba(var(--color-accent-rgb), 0.5);
    background: radial-gradient(circle at center, var(--color-primary) 0%, transparent 70%);
}
.theme-cyberpunk button { 
    text-shadow: 0 0 10px var(--color-primary), 0 0 20px var(--color-accent);
    background: linear-gradient(45deg, var(--color-surface), var(--color-background));
}
.theme-cyberpunk #app-title { 
    text-shadow: 0 0 20px var(--color-primary), 0 0 40px var(--color-accent);
    background: linear-gradient(90deg, var(--color-primary), var(--color-accent));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}
.theme-cyberpunk #xy-pad-container { 
    background-image: 
        linear-gradient(45deg, rgba(var(--color-primary-rgb), 0.2), rgba(var(--color-accent-rgb), 0.2)),
        repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(var(--color-primary-rgb), 0.1) 10px, rgba(var(--color-primary-rgb), 0.1) 20px);
}

/* Fire Theme */
.theme-fire {
    --color-background: #1a0000;
    --color-background-rgb: 26, 0, 0;
    --color-surface: #330000;
    --color-surface-rgb: 51, 0, 0;
    --color-primary: #ff3300;
    --color-primary-rgb: 255, 51, 0;
    --color-primary-light: #ff6633;
    --color-primary-dark: #cc2900;
    --color-accent: #ffcc00;
    --color-accent-rgb: 255, 204, 0;
    --color-text-primary: #ff3300;
    --color-text-secondary: #ffcc00;
    --color-border: #4d0000;
    --color-border-rgb: 77, 0, 0;
    --osc-icon-invert: 100%;
}

/* Fire theme specific effects */
.theme-fire #xy-pad-container {
    background: 
        radial-gradient(circle at center,
            rgba(255, 51, 0, 0.3) 0%,
            rgba(255, 204, 0, 0.2) 30%,
            rgba(255, 51, 0, 0.1) 60%,
            transparent 100%);
    animation: fireFlicker 2s ease-in-out infinite;
    position: relative;
    overflow: hidden;
}

.theme-fire #xy-pad-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
        radial-gradient(circle at center,
            rgba(255, 51, 0, 0.4) 0%,
            rgba(255, 204, 0, 0.2) 40%,
            transparent 80%);
    animation: fireWave 4s ease-in-out infinite;
    mix-blend-mode: screen;
}

@keyframes fireFlicker {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.8; transform: scale(1.02); }
}

@keyframes fireWave {
    0% { transform: translateY(0) scale(1); opacity: 0.8; }
    50% { transform: translateY(-10px) scale(1.1); opacity: 1; }
    100% { transform: translateY(0) scale(1); opacity: 0.8; }
}

/* Matrix Theme */
.theme-matrix {
    --color-background: #000000;
    --color-background-rgb: 0, 0, 0;
    --color-surface: #001100;
    --color-surface-rgb: 0, 17, 0;
    --color-primary: #00ff00;
    --color-primary-rgb: 0, 255, 0;
    --color-primary-light: #33ff33;
    --color-primary-dark: #00cc00;
    --color-accent: #00ff66;
    --color-accent-rgb: 0, 255, 102;
    --color-text-primary: #00ff00;
    --color-text-secondary: #33ff33;
    --color-border: #003300;
    --color-border-rgb: 0, 51, 0;
    --osc-icon-invert: 100%;
}

.theme-matrix #xy-pad-container {
    background-image: 
        linear-gradient(180deg, rgba(0, 255, 0, 0.1) 0%, transparent 100%),
        repeating-linear-gradient(0deg, transparent, transparent 20px, rgba(0, 255, 0, 0.1) 20px, rgba(0, 255, 0, 0.1) 40px);
    animation: matrixRain 20s linear infinite;
}

@keyframes matrixRain {
    0% { background-position: 0 0, 0 0; }
    100% { background-position: 0 100%, 0 100%; }
}

/* Hologram Theme */
.theme-hologram {
    --color-background: #000000;
    --color-background-rgb: 0, 0, 0;
    --color-surface: #001a1a;
    --color-surface-rgb: 0, 26, 26;
    --color-primary: #00ffff;
    --color-primary-rgb: 0, 255, 255;
    --color-primary-light: #66ffff;
    --color-primary-dark: #00cccc;
    --color-accent: #ff00ff;
    --color-accent-rgb: 255, 0, 255;
    --color-text-primary: #00ffff;
    --color-text-secondary: #66ffff;
    --color-border: #003333;
    --color-border-rgb: 0, 51, 51;
    --osc-icon-invert: 100%;
}

.theme-hologram #xy-pad-container {
    background: 
        linear-gradient(45deg, 
            rgba(0, 255, 255, 0.1) 25%, 
            transparent 25%, 
            transparent 50%, 
            rgba(0, 255, 255, 0.1) 50%, 
            rgba(0, 255, 255, 0.1) 75%, 
            transparent 75%, 
            transparent);
    background-size: 20px 20px;
    animation: hologramScan 4s linear infinite;
}

@keyframes hologramScan {
    0% { background-position: 0 0; }
    100% { background-position: 40px 40px; }
}

/* Crystal Theme */
.theme-crystal {
    --color-background: #000033;
    --color-background-rgb: 0, 0, 51;
    --color-surface: #000066;
    --color-surface-rgb: 0, 0, 102;
    --color-primary: #00ffff;
    --color-primary-rgb: 0, 255, 255;
    --color-primary-light: #66ffff;
    --color-primary-dark: #00cccc;
    --color-accent: #ff00ff;
    --color-accent-rgb: 255, 0, 255;
    --color-text-primary: #00ffff;
    --color-text-secondary: #66ffff;
    --color-border: #000099;
    --color-border-rgb: 0, 0, 153;
    --osc-icon-invert: 100%;
}

.theme-crystal #xy-pad-container {
    background: 
        linear-gradient(60deg,
            rgba(0, 255, 255, 0.1) 25%,
            rgba(255, 0, 255, 0.1) 50%,
            rgba(0, 255, 255, 0.1) 75%);
    background-size: 200% 200%;
    animation: crystalShine 8s linear infinite;
}

@keyframes crystalShine {
    0% { background-position: 0% 0%; }
    100% { background-position: 200% 200%; }
}

/* Transitions for theme switching */
body, button, .knob, .toggle-slider, .side-panel, .top-panel, #xy-pad-container, #xy-visualizer, .osc-icon {
    transition: background-color 0.5s, background-image 0.5s, color 0.5s, border-color 0.5s, box-shadow 0.5s, filter 0.5s;
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Prismtone</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/themes.css">
    <style>
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: fixed;
            touch-action: manipulation;
            overscroll-behavior: none;
        }
    </style>
</head>
<body class="theme-day landscape-mode">

<div id="app-container">

    <div id="loading-overlay">
        <canvas id="loading-stars-canvas"></canvas>
        <canvas id="loading-prism-canvas"></canvas>
        <div class="loading-text">Loading...</div>
        <div id="loading-title" data-i18n="app_title">Prismtone</div>
        <div class="loading-prompt" data-i18n="hit_play_vibe">Hit Play, Feel the Vibe</div>
    </div>

    <div id="topbar">
        <div class="topbar-group left">
            <button id="menu-button" class="round-button topbar-button" data-i18n-title="menu_button" title="Menu">☰</button>
            <button id="sound-library-button" class="text-button topbar-button" data-i18n="sound_library_button">Sound Library</button>
        </div>
        <div id="app-title" data-i18n="app_title">Prismtone</div>
        <div class="topbar-group right">
            <button id="tonality-button" class="round-button topbar-button" data-i18n-title="tonality_button" title="Tonality">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55c-2.21 0-4 1.79-4 4s1.79 4 4 4s4-1.79 4-4V7h4V3h-6z"/>
                </svg>
            </button>
            <button id="pad-modes-button" class="round-button topbar-button" data-i18n-title="pad_modes_button_title" title="Pad Modes">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M4 4h6v6H4V4zm0 10h6v6H4v-6zm10-10h6v6h-6V4zm0 10h6v6h-6v-6z"/>
                </svg>
            </button>
            <button id="effects-button" class="round-button topbar-button" data-i18n-title="effects_button" title="Effects">fx</button>
            <button id="reload-app-button" class="round-button topbar-button reload-app-button-style" data-i18n-title="reload_app_button_title" title="Reload Application">
                <svg class="restart-icon" xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/>
                </svg>
            </button>
        </div>
    </div>

    <div id="rocket-status-panel" class="rocket-status-panel-hidden">
        <button id="rocket-status-hide-btn" class="rocket-status-hide-btn" title="Hide Rocket Status Panel">×</button>
        <span class="status-item">
            <span class="status-icon"></span>
            <strong data-i18n="status_chord">Chord</strong>:
            <span id="status-current-chord" class="status-value status-clickable">N/A</span>
        </span>
        <span class="status-item">
            <span class="status-icon"></span>
            <strong data-i18n="status_key">Key</strong>:
            <span id="status-current-key" class="status-value status-clickable">C Major</span>
        </span>
        <span class="status-item">
            <span class="status-icon">🎯</span>
            <strong data-i18n="status_next">Next</strong>:
            <span id="status-next-suggestions" class="status-value status-clickable">-</span>
        </span>
        <span class="status-item">
            <span class="status-icon">🌀</span>
            <strong data-i18n="status_energy">Energy</strong>:
            <span id="status-energy-level" class="status-value status-clickable"></span>
        </span>
        <span class="status-item">
            <span class="status-icon">🔥</span>
            <strong data-i18n="status_phase">Phase</strong>:
            <span id="status-current-phase" class="status-value status-clickable">Ignition</span>
        </span>
    </div>
    <button id="rocket-status-show-btn" class="rocket-status-show-btn" style="display:none;" title="Show Rocket Status Panel">🚀</button>

    <div id="xy-pad-container">
        <canvas id="xy-visualizer"></canvas>
        <div id="xy-zones"></div>
        <div id="xy-labels"></div>
    </div>

    <div id="settings-panel" class="side-panel left-panel">
        <div class="panel-header"> <h2 data-i18n="settings_title">Settings</h2> <button class="close-button" data-panel-id="settings-panel">×</button> </div>
        <div class="panel-content">
            <div class="setting-group">
                <label for="language-select" data-i18n="language_label">Language</label>
                <select id="language-select" class="dropdown"></select>
            </div>
            <div class="setting-group">
                <label for="theme-select" data-i18n="theme_label">Theme</label>
                <select id="theme-select" class="dropdown"></select>
            </div>
            <div class="setting-group">
                <label for="visualizer-select" data-i18n="visualizer_label">Visualizer</label>
                <select id="visualizer-select" class="dropdown"></select>
            </div>
            <div class="setting-group">
                <label for="touch-effect-select" data-i18n="touch_effect_label">Touch Effect</label>
                <select id="touch-effect-select" class="dropdown"></select>
            </div>
            <div class="setting-group">
                <h4 data-i18n="display_options_header">Display & Behavior</h4>
                <div class="toggle-container">
                    <span data-i18n="show_note_names">Show Note Names</span>
                    <label class="toggle">
                        <input type="checkbox" id="show-note-names-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-container">
                    <span data-i18n="show_lines">Show Grid Lines</span>
                    <label class="toggle">
                        <input type="checkbox" id="show-lines-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-container">
                    <span data-i18n="highlight_sharps_flats">Highlight Accidentals</span>
                    <label class="toggle">
                        <input type="checkbox" id="highlight-sharps-flats-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-container">
                    <span data-i18n="enable_polyphony_scaling">Polyphony Volume Scaling</span>
                    <label class="toggle">
                        <input type="checkbox" id="enable-polyphony-volume-scaling-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

        </div>
    </div>

    <div id="tonality-panel" class="side-panel right-panel">
        <div class="panel-header"> <h2 data-i18n="tonality_title">Tonality</h2> <button class="close-button" data-panel-id="tonality-panel">×</button> </div>
        <div class="panel-content">
            <div class="setting-group"> <label for="scale-select" data-i18n="scale_label">Scale</label> <div id="scale-select-display" class="dropdown-display" tabindex="0"></div>  </div>
            <div class="setting-group"> <label data-i18n="size_label">Size</label> <div class="slider-container"> <button id="size-down" class="slider-button">-</button> <input type="range" id="size-slider" class="slider" min="8" max="36" value="12" step="2"> <button id="size-up" class="slider-button">+</button> <span id="size-value" class="slider-value">12</span> </div> </div>
            <div class="setting-group"> <label data-i18n="octave_label">Octave</label> <div class="slider-container"> <button id="octave-down" class="slider-button">-</button> <input type="range" id="octave-slider" class="slider" min="-7" max="7" value="0" step="1"> <button id="octave-up" class="slider-button">+</button> <span id="octave-value" class="slider-value">0</span> </div> </div>
        </div>
    </div>

    <div id="effects-panel" class="side-panel right-panel">
        <div class="panel-header"> <h2 data-i18n="effects_title">Effects</h2> <button class="close-button" data-panel-id="effects-panel">×</button> </div>
        <div class="panel-content">
            <div class="setting-group fx-chain-container">
                <label for="fx-chain-select" data-i18n="fx_chain_label">FX Chain</label>
                <select id="fx-chain-select" class="dropdown"></select>
            </div>
            <h4 data-i18n="macro_controls_title">Macro Controls</h4>
            <div id="macro-controls" class="control-grid">
                <div class="knob-container"> <div class="knob" data-param="macro1" data-min="0" data-max="1" data-step="0.01"> <div class="knob-dial"></div><span class="knob-value">0.5</span> </div> <label data-i18n="macro_space">Space</label> </div>
                <div class="knob-container"> <div class="knob" data-param="macro2" data-min="0" data-max="1" data-step="0.01"> <div class="knob-dial"></div><span class="knob-value">0.5</span> </div> <label data-i18n="macro_time">Time</label> </div>
                <div class="knob-container"> <div class="knob" data-param="macro3" data-min="0" data-max="1" data-step="0.01"> <div class="knob-dial"></div><span class="knob-value">0.5</span> </div> <label data-i18n="macro_motion">Motion</label> </div>
                <div class="knob-container"> <div class="knob" data-param="macro4" data-min="0" data-max="1" data-step="0.01"> <div class="knob-dial"></div><span class="knob-value">0.5</span> </div> <label data-i18n="macro_tone">Tone</label> </div>
            </div>
            <div class="setting-group y-axis-controls">
                <h4 data-i18n="y_axis_controls">Y-Axis Controls</h4>
                <h5>Volume</h5>
                <div class="y-axis-row">
                    <div class="knob-container"> <div class="knob small" data-param="volume_minOutput" data-min="0" data-max="1" data-step="0.01"><div class="knob-dial"></div><span class="knob-value">0.0</span></div> <label data-i18n="y_axis_volume_min_output">Min Output</label> </div>
                    <div class="knob-container"> <div class="knob small" data-param="volume_maxOutput" data-min="0" data-max="1" data-step="0.01"><div class="knob-dial"></div><span class="knob-value">1.0</span></div> <label data-i18n="y_axis_volume_max_output">Max Output</label> </div>
                    <div class="knob-container"> <div class="knob small" data-param="volume_yThreshold" data-min="0" data-max="1" data-step="0.01"><div class="knob-dial"></div><span class="knob-value">0.0</span></div> <label data-i18n="y_axis_volume_y_threshold">Y Threshold</label> </div>
                </div>
                <div class="y-axis-row">
                    <div class="dropdown-container small" style="flex-basis: 120px;"> <label for="volume_curveType-select" data-i18n="y_axis_curve_type">Curve Type</label> <select id="volume_curveType-select" class="dropdown small"> <option value="linear" data-i18n="linear">Linear</option> <option value="exponential" data-i18n="exponential">Exponential</option> <option value="logarithmic" data-i18n="logarithmic">Logarithmic</option> <option value="sCurve" data-i18n="s_curve">S-Curve</option> </select> </div>
                    <div class="knob-container"> <div class="knob small" data-param="volume_curveFactor" data-min="0.1" data-max="5" data-step="0.1"><div class="knob-dial"></div><span class="knob-value">1.0</span></div> <label data-i18n="y_axis_curve_factor">Curve Factor</label> </div>
                </div>
                <h5 style="margin-top: 15px;">Effects Send</h5>
                <div class="y-axis-row">
                    <div class="knob-container"> <div class="knob small" data-param="effects_minOutput" data-min="-60" data-max="0" data-step="1"><div class="knob-dial"></div><span class="knob-value">-60</span></div> <label data-i18n="y_axis_effects_min_output">Min Output (dB)</label> </div>
                    <div class="knob-container"> <div class="knob small" data-param="effects_maxOutput" data-min="-60" data-max="0" data-step="1"><div class="knob-dial"></div><span class="knob-value">0</span></div> <label data-i18n="y_axis_effects_max_output">Max Output (dB)</label> </div>
                    <div class="knob-container"> <div class="knob small" data-param="effects_yThreshold" data-min="0" data-max="1" data-step="0.01"><div class="knob-dial"></div><span class="knob-value">0.1</span></div> <label data-i18n="y_axis_effects_y_threshold">Y Threshold</label> </div>
                </div>
                <div class="y-axis-row">
                    <div class="dropdown-container small" style="flex-basis: 120px;"> <label for="effects_curveType-select" data-i18n="y_axis_curve_type">Curve Type</label> <select id="effects_curveType-select" class="dropdown small"> <option value="linear" data-i18n="linear">Linear</option> <option value="exponential" data-i18n="exponential">Exponential</option> <option value="logarithmic" data-i18n="logarithmic">Logarithmic</option> <option value="sCurve" data-i18n="s_curve">S-Curve</option></select> </div>
                    <div class="knob-container"> <div class="knob small" data-param="effects_curveFactor" data-min="0.1" data-max="5" data-step="0.1"><div class="knob-dial"></div><span class="knob-value">2.0</span></div> <label data-i18n="y_axis_curve_factor">Curve Factor</label> </div>
                </div>
            </div>
            <div class="setting-group master-output-controls">
                <h4 data-i18n="master_output_title">Master Output</h4>
                <div class="control-grid">
                    <div class="knob-container">
                        <div class="knob" data-param="masterVolumeCeiling" data-min="0" data-max="1" data-step="0.01" data-default="1.0">
                            <div class="knob-dial"></div><span class="knob-value">1.0</span>
                        </div>
                        <label data-i18n="master_volume_ceiling">Volume Ceiling</label>
                    </div>
                </div>
            </div>
            <div class="effect-actions"> <button id="reset-fx-button" class="action-button" data-i18n="reset_fx">Reset FX</button> </div>
        </div>
    </div>

    <div id="sound-library-panel" class="top-panel">
        <div class="panel-header">
            <h2 data-i18n="presets_panel_title">Presets</h2>
            <button class="close-button" data-panel-id="sound-library-panel">×</button>
        </div>
        <div class="panel-content sound-library-container">
            <div class="sound-presets">
                <div id="preset-grid" class="preset-list preset-grid">

                </div>
            </div>
        </div>
    </div>

    <div id="pad-modes-panel" class="side-panel right-panel">
        <div class="panel-header">
            <h2 data-i18n="pad_modes_panel_title">Pad Modes</h2>
            <button class="close-button" data-panel-id="pad-modes-panel">×</button>
        </div>
        <div class="panel-content">
            <div class="setting-group">
                <label for="pad-mode-selector-display" data-i18n="pad_mode_label">Pad Mode</label>
                <div id="pad-mode-selector-display" class="dropdown-display" tabindex="0" role="combobox" aria-haspopup="listbox" aria-expanded="false">
                    Classic
                </div>
                <select id="pad-mode-selector" class="dropdown" style="display: none;"></select>
            </div>
            <div id="mode-specific-controls-container">
            </div>
        </div>
    </div>

    <div id="custom-selector-popover" class="custom-selector-popover" style="display:none;">
      <div class="custom-selector-backdrop"></div>
      <div class="custom-selector-modal">
        <div class="custom-selector-header">
          <span id="custom-selector-title"></span>
          <button id="custom-selector-close" class="close-button" title="Close">×</button>
        </div>
        <div id="custom-selector-options" class="custom-selector-options"></div>
      </div>
    </div>

</div>

<script src="js/lib/tone.min.js"></script>
<script src="js/lib/tonal.min.js"></script>
<script src="js/MusicTheoryService.js"></script>
<script src="js/PadModeManager.js"></script>
<script src="js/harmonicMarkerEngine.js"></script>
<script src="js/padModes/RocketModeStrategy.js"></script>
<script src="js/padModes/ClassicModeStrategy.js"></script>
<script src="js/bridge-fix.js"></script>
<script src="js/config/audioConfig.js"></script>
<script src="js/moduleManager.js"></script>
<script src="js/i18n.js"></script>
<script src="js/voiceBuilder.js"></script>
<script src="js/synth.js"></script>
<script src="js/visualizer.js"></script>
<script src="js/visualizers/wavesRenderer.js"></script>
<script src="js/visualizers/spectrumRenderer.js"></script>
<script src="js/visualizers/particlesRenderer.js"></script>
<script src="js/visualizers/nebulaRenderer.js"></script>
<script src="js/visualizers/reactiveRipplesRenderer.js"></script>
<script src="js/visualizers/touchTrailsRenderer.js"></script>
<script src="js/touchEffects/glowEffect.js"></script>
<script src="js/touchEffects/markerEffect.js"></script>
<script src="js/touchEffects/rippleEffect.js"></script>
<script src="js/touchEffects/trailEffect.js"></script>
<script src="js/touchEffects/waveEffect.js"></script>
<script src="js/touchEffects/sparkEffect.js"></script>
<script src="js/touchEffects/energyEffect.js"></script>
<script src="js/touchEffects/geometricShardsEffect.js"></script>
<script src="js/touchEffects/novaSparkEffect.js"></script>
<script src="js/touchEffects/ballLightningLinkEffect.js"></script>
<script src="js/managers/blankManager.js"></script>
<script src="js/managers/oscillatorManager.js"></script>
<script src="js/managers/ampEnvManager.js"></script>
<script src="js/managers/filterManager.js"></script>
<script src="js/managers/outputGainManager.js"></script>
<script src="js/managers/pitchEnvManager.js"></script>
<script src="js/managers/lfoManager.js"></script>
<script src="js/managers/filterEnvelopeManager.js"></script>
<script src="js/managers/voiceFxSlotManager.js"></script>
<script src="js/managers/delayFxManager.js"></script>
<script src="js/managers/reverbFxManager.js"></script>
<script src="js/managers/chorusFxManager.js"></script>
<script src="js/managers/distortionFxManager.js"></script>
<script src="js/pad.js"></script>
<script src="js/soundpresets.js"></script>
<script src="js/fxchains.js"></script>
<script src="js/customSelectorPopover.js"></script>
<script src="js/sidepanel.js"></script>
<script src="js/topbar.js"></script>
<script src="js/loading/audio.js"></script>
<script src="js/loading/stars-animation.js"></script>
<script src="js/loading/prism-effect.js"></script>
<script src="js/app.js"></script>

</body>
</html>
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\FxEngine.js
// app/src/main/assets/js/FxEngine.js
const FxEngine = {
    effects: {}, // Экземпляры Tone.js эффектов { effectId: Tone.EffectNode }
    effectDefinitions: {}, // Описания эффектов { effectId: { constructor, params, defaults } }
    fxBusInput: null,    // Входной узел для FX-шины (например, Tone.Channel из synth.js)
    fxBusOutput: null,   // Выходной узел FX-шины (для подключения к мастер-лимитеру в synth.js)
    currentChainId: null,
    currentChainData: null, // Данные текущей активной цепочки
    isReady: false,

    // Константы для имен эффектов, чтобы избежать опечаток
    EFFECT_TYPES: {
        DELAY: 'delay',
        REVERB: 'reverb',
        CHORUS: 'chorus',
        DISTORTION: 'distortion',
        FILTER: 'filter',
        // Добавьте другие типы эффектов, которые у вас есть
    },

    async init(fxBusInput, fxBusOutput) {
        console.log("[FxEngine] Initializing...");
        if (!fxBusInput || !fxBusOutput) {
            console.error("[FxEngine] fxBusInput или fxBusOutput не предоставлены!");
            this.isReady = false;
            return;
        }
        this.fxBusInput = fxBusInput;
        this.fxBusOutput = fxBusOutput;

        // --- Вариант 1: Жестко закодированные определения эффектов (как было в synth.config) ---
        this.effectDefinitions = {
            [this.EFFECT_TYPES.DELAY]: {
                constructor: Tone.FeedbackDelay,
                params: ['delayTime', 'feedback', 'wet'],
                defaults: { delayTime: 0.25, feedback: 0.5, wet: 0, maxDelay: 1 }
            },
            [this.EFFECT_TYPES.REVERB]: {
                constructor: Tone.JCReverb, // Или Tone.Reverb, если он есть и настроен
                params: ['roomSize', 'wet'],
                defaults: { roomSize: 0.5, wet: 0 }
            },
            [this.EFFECT_TYPES.CHORUS]: {
                constructor: Tone.Chorus,
                params: ['frequency', 'depth', 'delayTime', 'wet'],
                defaults: { frequency: 1.5, depth: 0.7, delayTime: 3.5, wet: 0 }
            },
            [this.EFFECT_TYPES.DISTORTION]: {
                constructor: Tone.Distortion,
                params: ['distortion', 'wet', 'oversample'],
                defaults: { distortion: 0.4, wet: 0, oversample: 'none' }
            },
            [this.EFFECT_TYPES.FILTER]: {
                constructor: Tone.Filter,
                params: ['frequency', 'Q', 'type', 'gain', 'rolloff', 'wet'],
                defaults: { frequency: 20000, Q: 1, type: 'lowpass', gain: 0, rolloff: -12, wet: 1 } // wet: 1 для фильтра может быть логично, если он всегда "включен"
            }
            // Добавьте другие эффекты
        };
        console.log("[FxEngine] Effect definitions (hardcoded):", this.effectDefinitions);

        // --- Вариант 2: Динамическая загрузка определений эффектов из modules/effect/*.json ---
        // (Раскомментируйте этот блок и закомментируйте Вариант 1, если хотите это использовать)
        /*
        this.effectDefinitions = {};
        const effectModules = await moduleManager.getModules('effect', true);
        if (effectModules && effectModules.length > 0) {
            effectModules.forEach(effModule => {
                if (effModule && effModule.id && effModule.data?.data?.parameters) {
                    let constructorFunc = null;
                    if (effModule.id === this.EFFECT_TYPES.DELAY && Tone.FeedbackDelay) constructorFunc = Tone.FeedbackDelay;
                    else if (effModule.id === this.EFFECT_TYPES.REVERB && Tone.JCReverb) constructorFunc = Tone.JCReverb;
                    // ... и так далее для других эффектов ...
                    else if (effModule.id === this.EFFECT_TYPES.FILTER && Tone.Filter) constructorFunc = Tone.Filter;


                    if (constructorFunc) {
                        const defaultParams = {};
                        effModule.data.data.parameters.forEach(param => {
                            if (param.name && param.default !== undefined) {
                                defaultParams[param.name] = param.default;
                            }
                        });
                        this.effectDefinitions[effModule.id] = {
                            constructor: constructorFunc,
                            params: effModule.data.data.parameters.map(p => p.name),
                            defaults: defaultParams
                        };
                        console.log(`[FxEngine] Dynamically added effect definition for: ${effModule.id}`);
                    } else {
                         console.warn(`[FxEngine] No Tone.js constructor found for effect module ID: ${effModule.id}`);
                    }
                }
            });
        } else {
            console.warn("[FxEngine] No 'effect' modules found to build dynamic effectDefinitions.");
        }
        */
        // --- Конец Варианта 2 ---

        this._createAllEffectInstances();
        this.isReady = true;
        console.log("[FxEngine] Initialized. Effects created (inactive).");
        await this.applyFxChainById(app.state.fxChain); // Применяем начальную цепочку
    },

    _createAllEffectInstances() {
        console.log("[FxEngine] Creating all effect instances...");
        this.effects = {};
        for (const effectId in this.effectDefinitions) {
            const def = this.effectDefinitions[effectId];
            if (def && def.constructor) {
                try {
                    // Создаем эффект с параметрами по умолчанию и wet = 0 (выключен)
                    const instance = new def.constructor({ ...def.defaults, wet: 0 });
                    this.effects[effectId] = instance;
                    console.log(`[FxEngine] Created instance for effect: ${effectId}`);
                } catch (e) {
                    console.error(`[FxEngine] Failed to create instance for effect ${effectId}:`, e);
                }
            }
        }
    },

    _disconnectAllEffects() {
        if (this.fxBusInput) {
            try {
                this.fxBusInput.disconnect(); // Отсоединяем вход FX-шины от всего
            } catch (e) { console.warn("[FxEngine] Error disconnecting fxBusInput:", e); }
        }
        for (const effectId in this.effects) {
            const effectInstance = this.effects[effectId];
            if (effectInstance && typeof effectInstance.disconnect === 'function') {
                try {
                    effectInstance.disconnect();
                } catch (e) { /* Игнорируем, если уже отсоединен */ }
            }
        }
        console.log("[FxEngine] All effects disconnected from bus and each other.");
    },

    _resetEffectParamsToDefaults() {
        console.log("[FxEngine] Resetting effect parameters to defaults (wet=0)...");
        for (const effectId in this.effects) {
            const effectInstance = this.effects[effectId];
            const def = this.effectDefinitions[effectId];
            if (effectInstance && def && def.defaults) {
                try {
                    // Устанавливаем параметры по умолчанию, включая wet: 0
                    const resetSettings = { ...def.defaults, wet: 0 };
                    if (typeof effectInstance.set === 'function') {
                        effectInstance.set(resetSettings);
                    } else { // Фоллбэк, если set не доступен (маловероятно для Tone.Effect)
                        for (const param in resetSettings) {
                            if (effectInstance[param] && (effectInstance[param] instanceof Tone.Param || effectInstance[param] instanceof Tone.Signal)) {
                                effectInstance[param].value = resetSettings[param];
                            } else if (effectInstance.hasOwnProperty(param)) {
                                effectInstance[param] = resetSettings[param];
                            }
                        }
                    }
                } catch (e) {
                    console.warn(`[FxEngine] Could not reset effect '${effectId}' to defaults:`, e);
                }
            }
        }
    },

    async applyFxChainById(chainId) {
        console.log(`[FxEngine] Attempting to apply FX Chain by ID: ${chainId}`);
        if (!this.isReady) {
            console.warn("[FxEngine] Not ready, cannot apply FX chain.");
            return;
        }
        this.currentChainId = chainId;

        if (!chainId) { // Если chainId null или пустой, применяем "никакую" цепочку
            console.log("[FxEngine] Applying 'None' FX Chain (direct connection).");
            this._disconnectAllEffects();
            this._resetEffectParamsToDefaults(); // Сбрасываем параметры на всякий случай
            if (this.fxBusInput && this.fxBusOutput) {
                try {
                    this.fxBusInput.connect(this.fxBusOutput);
                    console.log("[FxEngine] fxBusInput connected directly to fxBusOutput.");
                } catch (e) { console.error("[FxEngine] Error connecting fxBusInput directly to fxBusOutput:", e); }
            }
            this.currentChainData = null;
            if (typeof fxChains !== 'undefined' && typeof fxChains.updateMacroKnobsFromChain === 'function') {
                fxChains.updateMacroKnobsFromChain(null);
            }
            return;
        }

        const chainModule = await moduleManager.getModule(chainId);
        if (!chainModule || !chainModule.data || !chainModule.data.data) {
            console.error(`[FxEngine] FX Chain module data not found for ID: ${chainId}. Applying 'None' chain.`);
            await this.applyFxChainById(null); // Рекурсивный вызов для сброса
            return;
        }

        this.currentChainData = chainModule.data.data;
        const fxChainSettings = this.currentChainData.effects || []; // Это массив объектов эффектов
        console.log(`[FxEngine] Applying FX chain '${chainId}' with settings:`, JSON.parse(JSON.stringify(fxChainSettings)));

        this._disconnectAllEffects();
        this._resetEffectParamsToDefaults(); // Сначала сбрасываем все эффекты

        const activeEffectInstances = [];
        if (Array.isArray(fxChainSettings)) {
            fxChainSettings.forEach(fxSetting => {
                const effectType = fxSetting.type; // e.g., "delay"
                const effectInstance = this.effects[effectType];
                const definition = this.effectDefinitions[effectType];

                if (effectInstance && definition) {
                    if (fxSetting.enabled !== false) { // Если enabled не false, считаем true
                        const paramsToApply = { ...(fxSetting.params || {}) };
                        // Применяем wet из params, если есть, иначе из definition.defaults (но мы уже сбросили на 0)
                        // Если в fxSetting.params есть wet, он будет использован.
                        // Если его нет, wet останется 0 после _resetEffectParamsToDefaults, что означает "выключен".
                        // Если мы хотим, чтобы enabled=true всегда означало какой-то ненулевой wet,
                        // то нужно добавить логику, например:
                        // if (!paramsToApply.hasOwnProperty('wet')) {
                        //    paramsToApply.wet = definition.defaults.wet !== 0 ? definition.defaults.wet : 0.3; // Пример дефолтного wet
                        // }

                        console.log(`[FxEngine] Configuring effect '${effectType}' with params:`, paramsToApply);
                        try {
                            if (typeof effectInstance.set === 'function') {
                                effectInstance.set(paramsToApply);
                            } else { // Fallback
                                for (const paramName in paramsToApply) {
                                    if (effectInstance[paramName] && (effectInstance[paramName] instanceof Tone.Param || effectInstance[paramName] instanceof Tone.Signal)) {
                                        effectInstance[paramName].value = paramsToApply[paramName];
                                    } else if (effectInstance.hasOwnProperty(paramName)) {
                                        effectInstance[paramName] = paramsToApply[paramName];
                                    }
                                }
                            }
                            activeEffectInstances.push(effectInstance);
                        } catch (e) {
                            console.error(`[FxEngine] Error applying params to effect '${effectType}':`, e, paramsToApply);
                        }
                    } else {
                        console.log(`[FxEngine] Effect '${effectType}' is disabled in chain '${chainId}'.`);
                    }
                } else {
                    console.warn(`[FxEngine] Effect type '${effectType}' in chain '${chainId}' not found or no definition.`);
                }
            });
        }

        // Соединяем активные эффекты и FX шину
        try {
            if (activeEffectInstances.length > 0) {
                this.fxBusInput.chain(...activeEffectInstances, this.fxBusOutput);
                console.log("[FxEngine] Effects chained successfully:", activeEffectInstances.map(inst => inst.constructor.name));
            } else {
                this.fxBusInput.connect(this.fxBusOutput); // Если нет активных эффектов
                console.log("[FxEngine] No active effects, fxBusInput connected directly to fxBusOutput.");
            }
        } catch (chainError) {
            console.error('[FxEngine] Error chaining effects:', chainError);
            try { this.fxBusInput.connect(this.fxBusOutput); } catch (e) {} // Fallback
        }

        // Обновляем UI макро-контроллеров
        if (typeof fxChains !== 'undefined' && typeof fxChains.updateMacroKnobsFromChain === 'function') {
            fxChains.updateMacroKnobsFromChain(this.currentChainData);
        }
    },

    setMacro(macroId, value) {
        if (!this.isReady || !this.currentChainData || !this.currentChainData.macroMappings) {
            // console.warn("[FxEngine] Cannot set macro: Not ready or no current chain/mappings.");
            return;
        }

        const macroLabels = ['Space', 'Time', 'Motion', 'Tone', 'Drive']; // Соответствует data-param на ручках
        const macroIndex = parseInt(macroId.replace('macro', ''), 10) - 1;
        const macroName = macroLabels[macroIndex];

        if (!macroName || !this.currentChainData.macroMappings[macroName]) {
            // console.warn(`[FxEngine] No mapping found for macro: ${macroName} (ID: ${macroId})`);
            return;
        }

        const mappings = this.currentChainData.macroMappings[macroName];
        if (!Array.isArray(mappings)) return;

        mappings.forEach(mapping => {
            const { effect: effectType, param: paramName, range, curve = 'linear' } = mapping;
            if (!effectType || !paramName || !range || range.length !== 2) {
                console.warn(`[FxEngine] Invalid mapping for ${macroName}:`, mapping);
                return;
            }

            const effectInstance = this.effects[effectType];
            const definition = this.effectDefinitions[effectType];
            if (!effectInstance || !definition) {
                console.warn(`[FxEngine] Effect instance or definition for '${effectType}' not found for macro.`);
                return;
            }

            const [min, max] = range;
            let targetValue;
            // TODO: Реализовать разные кривые, если нужно (пока только linear)
            targetValue = min + value * (max - min);

            let actualParamToSet = paramName;
            let actualValueToSet = targetValue;

            if (effectType === this.EFFECT_TYPES.REVERB && paramName === 'decay') {
                actualParamToSet = 'roomSize'; // JCReverb
                actualValueToSet = Math.max(0.001, Math.min(0.999, 0.1 + (targetValue / 10) * 0.85));
            }

            try {
                let targetParam = effectInstance[actualParamToSet];
                if (targetParam instanceof Tone.Param || targetParam instanceof Tone.Signal) {
                    targetParam.rampTo(actualValueToSet, 0.05);
                } else if (effectInstance.hasOwnProperty(actualParamToSet)) {
                    effectInstance[actualParamToSet] = actualValueToSet;
                } else {
                    console.warn(`[FxEngine] Parameter '${actualParamToSet}' not found on effect '${effectType}'.`);
                }
            } catch (e) {
                console.warn(`[FxEngine] Failed to update ${effectType}.${actualParamToSet}:`, e);
            }
        });
    }
};
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\MusicTheoryService.js
// Файл: app/src/main/assets/js/MusicTheoryService.js
// ВЕРСИЯ 2.5: Адаптация к Tonal.js без Tonal.Distance

console.log('[Pre-MTS v2.5] typeof Tonal:', typeof Tonal);
if (typeof Tonal !== 'undefined') {
    console.log('[Pre-MTS v2.5] Tonal object keys:', Object.keys(Tonal));
    console.log('[Pre-MTS v2.5] typeof Tonal.Note:', typeof Tonal.Note);
    console.log('[Pre-MTS v2.5] typeof Tonal.Scale:', typeof Tonal.Scale);
    console.log('[Pre-MTS v2.5] typeof Tonal.Interval:', typeof Tonal.Interval);
    console.log('[Pre-MTS v2.5] typeof Tonal.Distance:', typeof Tonal.Distance); // Ожидаем undefined
    console.log('[Pre-MTS v2.5] typeof Tonal.transpose:', typeof Tonal.transpose); // <--- НОВЫЙ ЛОГ
    if (Tonal.Note) {
        console.log('[Pre-MTS v2.5] typeof Tonal.Note.transpose:', typeof Tonal.Note.transpose); // <--- НОВЫЙ ЛОГ
    }
}

const MusicTheoryService = {
    isTonalJsLoaded: false,
    moduleManagerRef: null,
    scaleDefinitions: {},

    _TonalNote: null,
    _TonalScale: null,
    _TonalInterval: null,
    _TonalTransposeFn: null, // <--- НОВОЕ: для функции транспонирования

    async init(moduleManagerInstance) {
        this.moduleManagerRef = moduleManagerInstance;
        if (!this.moduleManagerRef) {
            console.error("[MusicTheoryService.init] moduleManager instance not provided!");
            this.isTonalJsLoaded = false; return;
        }

        if (typeof Tonal === 'object' && Tonal !== null) {
            this._TonalNote = Tonal.Note;
            this._TonalScale = Tonal.Scale;
            this._TonalInterval = Tonal.Interval;

            // Ищем функцию транспонирования
            if (typeof Tonal.transpose === 'function') {
                this._TonalTransposeFn = Tonal.transpose;
                console.log("[MTS.init] Using Tonal.transpose");
            } else if (this._TonalNote && typeof this._TonalNote.transpose === 'function') {
                this._TonalTransposeFn = this._TonalNote.transpose;
                console.log("[MTS.init] Using Tonal.Note.transpose");
            } else if (Tonal.Distance && typeof Tonal.Distance.transpose === 'function') { // Оставим на всякий случай
                this._TonalTransposeFn = Tonal.Distance.transpose;
                console.log("[MTS.init] Using Tonal.Distance.transpose");
            }

            this.isTonalJsLoaded =
                typeof this._TonalNote === 'object' && this._TonalNote !== null && typeof this._TonalNote.get === 'function' &&
                typeof this._TonalScale === 'object' && this._TonalScale !== null && typeof this._TonalScale.get === 'function' &&
                typeof this._TonalInterval === 'object' && this._TonalInterval !== null && typeof this._TonalInterval.semitones === 'function' &&
                typeof this._TonalTransposeFn === 'function'; // <--- ИЗМЕНЕНО: Проверяем _TonalTransposeFn

        } else {
            this.isTonalJsLoaded = false;
        }

        if (!this.isTonalJsLoaded) {
            console.error("[MusicTheoryService.init v2.5] Tonal.js or its required sub-modules/transpose function are NOT correctly loaded/structured!");
            console.error(`[MTS Debug] Tonal: ${typeof Tonal}, Note: ${typeof Tonal?.Note}, Scale: ${typeof Tonal?.Scale}, Interval: ${typeof Tonal?.Interval}, TransposeFn: ${typeof this._TonalTransposeFn}`);
        } else {
            const tonalVersion = Tonal.VERSION || "unknown (VERSION prop missing)";
            console.log(`[MusicTheoryService v2.5] Initialized. Tonal.js version: ${tonalVersion}. isTonalJsLoaded: ${this.isTonalJsLoaded}`);
        }
        await this.loadScaleDefinitions();
    },

    async loadScaleDefinitions() {
        if (!this.moduleManagerRef) {
            console.error("[MusicTheoryService.loadScaleDefinitions] moduleManagerRef is not set.");
            return;
        }
        console.log("[MusicTheoryService] Loading scale definitions...");
        this.scaleDefinitions = {};
        try {
            const scaleModules = await this.moduleManagerRef.getModules('scale', true);
            console.log("[MTS.loadScaleDefinitions] Received scaleModules:", scaleModules ? JSON.stringify(scaleModules.map(m => m.id)) : 'null');
            if (Array.isArray(scaleModules)) {
                scaleModules.forEach(mod => {
                    if (mod?.id && mod.data?.data?.intervals && Array.isArray(mod.data.data.intervals)) {
                        const intervalsAreNumbers = mod.data.data.intervals.every(i => typeof i === 'number');
                        if (intervalsAreNumbers) {
                            this.scaleDefinitions[mod.id] = mod.data.data.intervals;
                        } else {
                            console.warn(`[MTS] Scale module '${mod.id}' has non-numeric intervals.`);
                        }
                    }
                });
                console.log(`[MusicTheoryService] Loaded ${Object.keys(this.scaleDefinitions).length} scale definitions:`, JSON.parse(JSON.stringify(this.scaleDefinitions)));
            }
        } catch (error) { console.error("[MusicTheoryService] Error loading scale definitions:", error); }
    },

    getNoteDetails(noteNameOrMidi) {
        if (!this.isTonalJsLoaded || !this._TonalNote) return null;
        try {
            const note = this._TonalNote.get(noteNameOrMidi);
            if (note && note.name && typeof note.midi === 'number' && typeof note.freq === 'number') {
                note.isSharpFlat = note.acc !== "";
                return note;
            }
            return null;
        } catch (e) { return null; }
    },

    async getNotesForScale(tonicNameWithOctave, scaleId, octavesToScanBefore = 2, octavesToScanAfter = 2) {
        if (!this.isTonalJsLoaded) { // Теперь проверяет и _TonalTransposeFn
            console.error("[MTS.getNotesForScale v2.5] Tonal.js or its required modules not loaded.");
            return null;
        }
        console.log(`[MTS.getNotesForScale v2.5] Input: tonic=${tonicNameWithOctave}, scaleId=${scaleId}`);

        const intervals = this.scaleDefinitions[scaleId];
        if (!intervals || !Array.isArray(intervals) || intervals.length === 0) {
            // ... (фоллбэк на Tonal.Scale.get(scaleId).intervals как раньше, используя this._TonalInterval.semitones) ...
            console.warn(`[MTS.getNotesForScale v2.5] Intervals for scale ID '${scaleId}' not found in definitions.`);
            if (this._TonalScale && typeof this._TonalScale.get === 'function' && this._TonalInterval && typeof this._TonalInterval.semitones === 'function') {
                const scaleTypeData = this._TonalScale.get(scaleId);
                if (scaleTypeData && !scaleTypeData.empty && Array.isArray(scaleTypeData.intervals)) {
                    console.log(`[MTS.getNotesForScale v2.5] Using intervals from Tonal.Scale.get("${scaleId}"):`, scaleTypeData.intervals);
                    try {
                        const semitoneIntervals = scaleTypeData.intervals.map(ivl => this._TonalInterval.semitones(ivl)).filter(s => typeof s === 'number');
                        if (semitoneIntervals.length > 0) {
                            this.scaleDefinitions[scaleId] = semitoneIntervals; // Кэшируем
                            return this._generateNotesFromIntervals(tonicNameWithOctave, semitoneIntervals, octavesToScanBefore, octavesToScanAfter);
                        }
                    } catch (e) { console.error(`[MTS.getNotesForScale v2.5] Error converting Tonal intervals:`, e); }
                }
            }
            console.error(`[MTS.getNotesForScale v2.5] Cannot proceed without intervals for ${scaleId}.`);
            return null;
        }
        return this._generateNotesFromIntervals(tonicNameWithOctave, intervals, octavesToScanBefore, octavesToScanAfter);
    },

    _generateNotesFromIntervals(tonicNameWithOctave, intervalsInSemitones, octavesToScanBefore, octavesToScanAfter) {
        const tonicDetails = this.getNoteDetails(tonicNameWithOctave);
        if (!tonicDetails || !this._TonalInterval || !this._TonalTransposeFn) { // Проверяем _TonalTransposeFn
            console.error(`[MTS._generateNotesFromIntervals] Invalid tonic or missing Tonal modules: ${tonicNameWithOctave}`);
            return null;
        }

        const allNotes = [];
        const rootMidi = tonicDetails.midi;
        const startOctaveForLoop = tonicDetails.oct - octavesToScanBefore;
        const endOctaveForLoop = tonicDetails.oct + octavesToScanAfter;

        console.log(`[MTS._generateNotesFromIntervals v2.5] Tonic: ${tonicNameWithOctave} (MIDI: ${rootMidi}), Intervals: [${intervalsInSemitones.join(',')}]`);
        console.log(`[MTS._generateNotesFromIntervals v2.5] Generating octaves from ${startOctaveForLoop} to ${endOctaveForLoop}`);

        for (let oct = startOctaveForLoop; oct <= endOctaveForLoop; oct++) {
            intervalsInSemitones.forEach(semitoneOffsetFromRoot => {
                const intervalInSemitones = (oct - tonicDetails.oct) * 12 + semitoneOffsetFromRoot;
                const intervalName = this._TonalInterval.fromSemitones(intervalInSemitones);
                
                let noteName;
                try {
                    // Используем сохраненную функцию транспонирования
                    noteName = this._TonalTransposeFn(tonicNameWithOctave, intervalName);
                } catch (e) {
                    console.warn(`[MTS] Transpose failed for ${tonicNameWithOctave} by ${intervalName}, using MIDI fallback. Error:`, e);
                    const targetMidi = rootMidi + intervalInSemitones;
                    noteName = this._TonalNote.fromMidiSharps(targetMidi);
                }

                const details = this.getNoteDetails(noteName);
                if (details) {
                    allNotes.push(details);
                }
            });
        }

        const uniqueNotes = Array.from(new Map(allNotes.map(note => [note.midi, note])).values());
        uniqueNotes.sort((a, b) => a.midi - b.midi);

        console.log(`[MTS._generateNotesFromIntervals v2.5] Generated ${uniqueNotes.length} unique notes. First: ${uniqueNotes[0]?.name}, Last: ${uniqueNotes[uniqueNotes.length-1]?.name}`);
        return uniqueNotes;
    },

    isSharpOrFlat(noteName) {
        if (!this.isTonalJsLoaded || !this._TonalNote) return false;
        const details = this._TonalNote.get(noteName);
        return details && details.acc !== "";
    },
    midiToFrequency(midiNote) {
        if (!this.isTonalJsLoaded || !this._TonalNote || typeof midiNote !== 'number') return 0;
        return this._TonalNote.freq(midiNote);
    },
    midiToNoteName(midiNote) {
        if (!this.isTonalJsLoaded || !this._TonalNote || typeof midiNote !== 'number') return "?";
        return this._TonalNote.fromMidiSharps(midiNote);
    },
    getAvailableScaleIds() {
        return Object.keys(this.scaleDefinitions);
    },

    /**
     * Возвращает MIDI ноты, которые гармонически сочетаются с данной нотой в указанном строе.
     * @param {number} baseNoteMidi - MIDI значение базовой ноты.
     * @param {string} scaleId - ID строя.
     * @param {number} [count=3] - Максимальное количество предложений.
     * @param {Array<string>} [preferredIntervals=['P5', 'M3', 'P4', 'M6']] - Предпочтительные интервалы (Tonal.js формат).
     * @returns {Promise<Array<number>>} - Массив MIDI нот.
     */
    async getHarmonicSuggestions(baseNoteMidi, scaleId, count = 3, preferredIntervals = ['P5', 'M3', 'P4', 'M6']) {
        console.log(`[MTS.getHarmonicSuggestions] BaseMIDI: ${baseNoteMidi}, ScaleID: ${scaleId}, Count: ${count}, PrefIntervals:`, preferredIntervals);
        if (!this.isTonalJsLoaded || typeof baseNoteMidi !== 'number' || !scaleId) {
            console.log(`[MTS.getHarmonicSuggestions] Early return: TonalLoaded=${this.isTonalJsLoaded}, BaseMIDI type=${typeof baseNoteMidi}, ScaleID=${scaleId}`);
            return [];
        }

        const baseNoteName = Tonal.Note.fromMidi(baseNoteMidi);
        if (!baseNoteName) {
            console.log(`[MTS.getHarmonicSuggestions] Could not get note name from MIDI ${baseNoteMidi}`);
            return [];
        }
        console.log(`[MTS.getHarmonicSuggestions] Base note name: ${baseNoteName}`);

        const scaleNotes = await this.getNotesForScale(baseNoteName, scaleId, 0, 1); // Получаем ноты строя в текущей и следующей октаве
        if (!scaleNotes || scaleNotes.length === 0) {
            console.log(`[MTS.getHarmonicSuggestions] No scale notes found for ${baseNoteName} ${scaleId}`);
            return [];
        }
        console.log(`[MTS.getHarmonicSuggestions] Scale notes (${scaleNotes.length}):`, scaleNotes.map(n => `${n.name}(${n.midi})`));

        const suggestions = new Set(); // Используем Set для уникальности MIDI

        for (const intervalString of preferredIntervals) {
            if (suggestions.size >= count) break;
            try {
                const targetNoteName = Tonal.transpose(baseNoteName, intervalString); // Используем _TonalTransposeFn если есть
                console.log(`[MTS.getHarmonicSuggestions] Transposing ${baseNoteName} by ${intervalString} -> ${targetNoteName}`);
                const targetNoteDetails = this.getNoteDetails(targetNoteName);
                if (targetNoteDetails) {
                    // Проверяем, есть ли эта нота (или ее энгармонический эквивалент) в нашем строе (scaleNotes)
                    const isInScale = scaleNotes.some(scaleNote => scaleNote.midi === targetNoteDetails.midi);
                    console.log(`[MTS.getHarmonicSuggestions] Target ${targetNoteName}(${targetNoteDetails.midi}) in scale: ${isInScale}`);
                    if (isInScale) {
                        suggestions.add(targetNoteDetails.midi);
                        console.log(`[MTS.getHarmonicSuggestions] Added ${targetNoteDetails.midi} to suggestions`);
                    } else {
                        // Если точного совпадения нет, ищем ближайшую ноту строя к предложенной
                        let closestInScaleMidi = null;
                        let minDiff = Infinity;
                        scaleNotes.forEach(scaleNote => {
                            const diff = Math.abs(scaleNote.midi - targetNoteDetails.midi);
                            const isSamePc = (scaleNote.midi % 12) === (targetNoteDetails.midi % 12);
                            const effectiveDiff = isSamePc ? diff / 120 : diff;
                            if (effectiveDiff < minDiff) {
                                minDiff = effectiveDiff;
                                closestInScaleMidi = scaleNote.midi;
                            }
                        });
                        if (closestInScaleMidi !== null && minDiff <= 2) {
                            suggestions.add(closestInScaleMidi);
                            console.log(`[MTS.getHarmonicSuggestions] Added closest ${closestInScaleMidi} (diff: ${minDiff}) to suggestions`);
                        }
                    }
                }
            } catch (e) {
                console.warn(`[MTS.getHarmonicSuggestions] Error transposing by ${intervalString} from ${baseNoteName}:`, e.message);
            }
        }
        // Если не набрали достаточно, можно добавить просто следующие ноты строя
        if (suggestions.size < count) {
            const baseNoteIndexInScale = scaleNotes.findIndex(n => n.midi === baseNoteMidi);
            console.log(`[MTS.getHarmonicSuggestions] Base note index in scale: ${baseNoteIndexInScale}`);
            if (baseNoteIndexInScale !== -1) {
                for (let i = 1; i <= count - suggestions.size; i++) {
                    const nextNoteIndex = (baseNoteIndexInScale + i) % scaleNotes.length;
                    if (scaleNotes[nextNoteIndex]) {
                        suggestions.add(scaleNotes[nextNoteIndex].midi);
                        console.log(`[MTS.getHarmonicSuggestions] Added next scale note ${scaleNotes[nextNoteIndex].midi} to suggestions`);
                    }
                }
            }
        }
        const result = Array.from(suggestions).slice(0, count);
        console.log(`[MTS.getHarmonicSuggestions] Returning suggestions (MIDI):`, result);
        return result;
    },

    /**
     * Возвращает MIDI ноты, классифицированные по гармоническим функциям T/S/D.
     * @param {number} baseNoteMidi - MIDI значение текущей активной ноты.
     * @param {string} scaleId - ID текущего строя (например, "major", "minor").
     * @param {object} [options={}] - Опции.
     * @param {number} [options.countPerFunction=1] - Сколько нот для каждой функции пытаться найти.
     * @param {boolean} [options.includeBaseAsTonic=true] - Включать ли саму baseNoteMidi в тонические предложения.
     * @returns {Promise<Array<{midi: number, name: string, function: 'T' | 'S' | 'D'}>>}
     */
    async getFunctionalHarmonySuggestions(baseNoteMidi, scaleId, options = {}) {
        if (!this.isTonalJsLoaded || typeof baseNoteMidi !== 'number' || !scaleId) {
            console.warn("[MTS.getFunctionalHarmonySuggestions] Invalid input or Tonal.js not loaded.");
            return [];
        }

        const settings = {
            countPerFunction: 1,
            includeBaseAsTonic: true,
            ...options
        };

        const baseNoteName = Tonal.Note.fromMidi(baseNoteMidi);
        if (!baseNoteName) return [];

        const tonicName = Tonal.Note.pitchClass(app.state.currentTonic || "C4");
        const scaleInfo = Tonal.Scale.get(`${tonicName} ${scaleId}`);
        if (scaleInfo.empty) {
            console.warn(`[MTS.getFunctionalHarmonySuggestions] Scale info not found for ${tonicName} ${scaleId}`);
            return [];
        }
        const scalePCs = scaleInfo.notes;

        const suggestions = [];
        const addedMidi = new Set();
        const addSuggestion = (midi, name, func) => {
            if (midi !== null && !addedMidi.has(midi) && suggestions.filter(s => s.function === func).length < settings.countPerFunction) {
                suggestions.push({ midi, name, function: func });
                addedMidi.add(midi);
            }
        };

        // 1. ТОНИЧЕСКИЕ (T)
        if (settings.includeBaseAsTonic) {
            const baseNoteDetails = this.getNoteDetails(baseNoteMidi);
            if (baseNoteDetails && scalePCs.includes(Tonal.Note.pitchClass(baseNoteDetails.name))) {
                addSuggestion(baseNoteMidi, baseNoteName, 'T');
            }
        }
        const globalTonicDetails = this.getNoteDetails(app.state.currentTonic);
        if (globalTonicDetails && globalTonicDetails.midi !== baseNoteMidi) addSuggestion(globalTonicDetails.midi, globalTonicDetails.name, 'T');
        try {
            const tonicFifthName = Tonal.transpose(globalTonicDetails.name, "P5");
            const tonicFifthDetails = this.getNoteDetails(tonicFifthName);
            if (tonicFifthDetails && tonicFifthDetails.midi !== baseNoteMidi && scalePCs.includes(Tonal.Note.pitchClass(tonicFifthDetails.name))) {
                addSuggestion(tonicFifthDetails.midi, tonicFifthDetails.name, 'T');
            }
        } catch(e) { /* ignore transpose error */ }

        // 2. ДОМИНАНТОВЫЕ (D)
        try {
            const dominantRootName = Tonal.transpose(tonicName, "P5");
            const dominantChordNotes = Tonal.Chord.get(`${dominantRootName}maj7`).notes;
            dominantChordNotes.forEach(pc => {
                const octave = Tonal.Note.octave(baseNoteName);
                let targetNoteNameNearBase = pc + octave;
                if (!Tonal.Note.midi(targetNoteNameNearBase)) {
                    targetNoteNameNearBase = pc + (octave + 1);
                }
                const details = this.getNoteDetails(targetNoteNameNearBase);
                if (details && scalePCs.includes(Tonal.Note.pitchClass(details.name))) {
                    addSuggestion(details.midi, details.name, 'D');
                }
            });
        } catch(e) { console.warn("[MTS] Error getting Dominant suggestions", e); }

        // 3. СУБДОМИНАНТОВЫЕ (S)
        try {
            const subdominantRootName = Tonal.transpose(tonicName, "P4");
            const subdominantChordNotes = Tonal.Chord.get(`${subdominantRootName}maj7`).notes;
            subdominantChordNotes.forEach(pc => {
                const octave = Tonal.Note.octave(baseNoteName);
                let targetNoteNameNearBase = pc + octave;
                if (!Tonal.Note.midi(targetNoteNameNearBase)) {
                    targetNoteNameNearBase = pc + (octave + 1);
                }
                const details = this.getNoteDetails(targetNoteNameNearBase);
                if (details && scalePCs.includes(Tonal.Note.pitchClass(details.name))) {
                    addSuggestion(details.midi, details.name, 'S');
                }
            });
        } catch(e) { console.warn("[MTS] Error getting Subdominant suggestions", e); }

        console.log(`[MTS.getFunctionalHarmonySuggestions] For base MIDI ${baseNoteMidi} (${baseNoteName}) in ${tonicName} ${scaleId}, found:`, JSON.parse(JSON.stringify(suggestions)));
        return suggestions;
    }
};

// === Заглушки для Rocket Mode: стандартные аккорды и тоники ===
if (!MusicTheoryService.getAvailableChordNames) {
    MusicTheoryService.getAvailableChordNames = function() {
        return [
            "C", "Cm", "C7", "Cm7", "Cmaj7",
            "D", "Dm", "D7", "Dm7", "Dmaj7",
            "E", "Em", "E7", "Em7", "Emaj7",
            "F", "Fm", "F7", "Fm7", "Fmaj7",
            "G", "Gm", "G7", "Gm7", "Gmaj7",
            "A", "Am", "A7", "Am7", "Amaj7",
            "B", "Bm", "B7", "Bm7", "Bmaj7"
        ];
    };
}
if (!MusicTheoryService.getAvailableTonicNames) {
    MusicTheoryService.getAvailableTonicNames = function() {
        return [
            "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"
        ];
    };
}

// MusicTheoryService.init() теперь будет вызываться из app.js с передачей moduleManager

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\PadModeManager.js
// Файл: app/src/main/assets/js/PadModeManager.js
// Управляет различными режимами работы XY-пэда
// (Код идентичен тому, что был предоставлен в вашем запросе, Шаг 2.2)

// eslint-disable-next-line no-unused-vars
const PadModeManager = {
    strategies: {},
    currentStrategy: null,
    currentModeId: null,
    appRef: null,
    musicTheoryServiceRef: null,
    harmonicMarkerEngineRef: null,
    _initializedStrategies: new Set(), // Храним ID уже инициализированных стратегий

    init(appReference, musicTheoryServiceInstance, harmonicMarkerEngineInstance) {
        console.log("[PadModeManager.init] Received appReference:", appReference);
        if (!appReference || !musicTheoryServiceInstance || !harmonicMarkerEngineInstance) {
            console.error("[PadModeManager.init] App reference, MusicTheoryService or HarmonicMarkerEngine instance not provided!");
            return false;
        }
        this.appRef = appReference;
        this.musicTheoryServiceRef = musicTheoryServiceInstance;
        this.harmonicMarkerEngineRef = harmonicMarkerEngineInstance;
        this._initializedStrategies.clear();
        console.log("[PadModeManager v1.1 - Delayed Strategy Init] Initialized.");
        return true;
    },
    registerStrategy(strategy) {
        if (strategy && typeof strategy.getName === 'function') {
            const modeId = strategy.getName();
            if (this.strategies[modeId]) {
                console.warn(`[PadModeManager] Strategy for mode ID "${modeId}" is being overwritten.`);
            }
            this.strategies[modeId] = strategy;
            console.log(`[PadModeManager] Registered strategy: ${modeId}. Init will be deferred.`);
            // НЕ ВЫЗЫВАЕМ strategy.init() ЗДЕСЬ
        } else {
            console.error("[PadModeManager] Invalid strategy provided for registration:", strategy);
        }
    },
    async setActiveMode(modeId) {
        if (!this.strategies[modeId]) {
            console.error(`[PadModeManager] Strategy for mode ID "${modeId}" not found.`);
            return false;
        }
        const newStrategy = this.strategies[modeId];
        // Инициализируем стратегию, если она еще не была инициализирована
        if (!this._initializedStrategies.has(modeId)) {
            if (typeof newStrategy.init === 'function') {
                console.log(`[PadModeManager.setActiveMode] Lazily initializing strategy '${modeId}' with appRef:`, this.appRef);
                newStrategy.init(this.appRef, this.musicTheoryServiceRef, this.harmonicMarkerEngineRef);
                this._initializedStrategies.add(modeId);
            } else {
                console.warn(`[PadModeManager.setActiveMode] Strategy '${modeId}' has no init method.`);
            }
        }
        // Если мы меняем стратегию, деактивируем старую
        if (this.currentStrategy && this.currentStrategy !== newStrategy && typeof this.currentStrategy.onModeDeactivated === 'function') {
            console.log(`[PadModeManager.setActiveMode] Deactivating old strategy: ${this.currentModeId}`);
            await this.currentStrategy.onModeDeactivated(this.appRef.state, this._getServicesBundle(), this._getUiModulesBundle());
            if (this.currentStrategy) this.currentStrategy._isActive = false;
        }
        this.currentModeId = modeId;
        this.currentStrategy = newStrategy;
        console.log(`[PadModeManager] Active mode set to: ${modeId}`);
        if (typeof this.currentStrategy.onModeActivated === 'function') {
            await this.currentStrategy.onModeActivated(this.appRef.state, this._getServicesBundle(), this._getUiModulesBundle());
            if (this.currentStrategy) this.currentStrategy._isActive = true;
        }
        if (this.appRef && typeof this.appRef.updateZoneLayout === 'function') {
            await this.appRef.updateZoneLayout();
        }
        return true;
    },
    getCurrentStrategy() {
        return this.currentStrategy;
    },
    getCurrentModeId() {
        return this.currentModeId;
    },
    _getServicesBundle() {
        return { musicTheoryService: this.musicTheoryServiceRef };
    },
    _getUiModulesBundle() {
        return { /* sidePanel: sidePanel ... */ };
    },
    async onTonicChanged(newTonic) {
        console.log(`[PadModeManager] Notified of tonic change: ${newTonic}`);
        if (this.currentStrategy && typeof this.currentStrategy.onTonicChanged === 'function') {
            await this.currentStrategy.onTonicChanged(newTonic, this.appRef.state, this._getServicesBundle());
        }
        if (this.appRef && typeof this.appRef.updateZones === 'function') {
            await this.appRef.updateZones();
        }
    },
    async onScaleChanged(newScale) {
        console.log(`[PadModeManager] Notified of scale change: ${newScale}`);
        if (this.currentStrategy && typeof this.currentStrategy.onScaleChanged === 'function') {
            await this.currentStrategy.onScaleChanged(newScale, this.appRef.state, this._getServicesBundle());
        }
        if (this.appRef && typeof this.appRef.updateZones === 'function') {
            await this.appRef.updateZones();
        }
    },
    async onChordChanged(newChord) {
        console.log(`[PadModeManager] Notified of chord change: ${newChord}`);
        if (this.currentStrategy && typeof this.currentStrategy.onChordChanged === 'function') {
            await this.currentStrategy.onChordChanged(newChord, this.appRef.state, this._getServicesBundle());
        }
        if (this.appRef && typeof this.appRef.updateZones === 'function') {
            await this.appRef.updateZones();
        }
    },
    getAvailableModeIds() {
        return Object.keys(this.strategies);
    }
};
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\app.js
// Файл: app/src/main/assets/js/app.js

const app = {
    state: {
        theme: 'day',
        language: 'en',
        soundPreset: '_test_single_preset',
        fxChain: null,
        visualizer: 'waves',
        touchEffect: 'glow',
        scale: 'major',
        octaveOffset: 0,
        zoneCount: 12,
        isAudioReady: false,
        isBridgeReady: false,
        isInitialized: false,
        hasUserInteracted: false,
        showNoteNames: true,
        showLines: true, // Используем showLines, как было изначально в UI HTML
        masterVolumeCeiling: 1.0,
        enablePolyphonyVolumeScaling: true,
        // === ДОБАВЛЕНА currentTonic ===
        currentTonic: "C4", // Дефолтная тоника
        // === ДОБАВЛЕНА highlightSharpsFlats ===
        highlightSharpsFlats: false, // Дефолтное состояние для подсветки диезов/бемолей
        // === ОБНОВЛЕННАЯ СТРУКТУРА yAxisControls для Части 2 ===
        yAxisControls: {
            volume: {
                minOutput: 0.0, // Изменено с 0.1 для полного диапазона, если yThreshold=0
                maxOutput: 1.0,
                yThreshold: 0.0,
                curveType: 'linear',
                curveFactor: 1.0, // Для exponential/log - степень, для sCurve - крутизна
                outputType: 'gain' // 'gain' (0-1)
            },
            effects: {
                minOutput: -60,    // Значение в dB
                maxOutput: 0,      // Значение в dB
                yThreshold: 0.1,
                curveType: 'exponential',
                curveFactor: 2.0,
                outputType: 'db'   // 'db'
            }
        },
        // +++ НОВОЕ СВОЙСТВО +++
        presetYAxisEffectsConfig: null, // Будет хранить yAxisEffectsSendConfig из активного пресета
        // +++ КОНЕЦ НОВОГО СВОЙСТВА +++
        // === НОВОЕ: Состояние для режима пэда ===
        padMode: "classic", // Режим по умолчанию
        currentChordName: null, // Для будущего ChordMode
        rocketModeSettings: {
            highlightActiveNotes: true,
            showDirectionalMarkers: true,
            markerStyle: "GlowFromNote",
            showOnlyForValidChords: false,
            animateMarkerFadeOut: true,
            showChordName: true,
            intensity: 0.5,
            autoPhases: true,
            phaseTransitionMode: 'activity',
            phaseDurations: { ignition: 30, liftOff: 60, burst: 90 },
            // === Новые поля для Rocket Status Panel ===
            chordBehavior: 'analyze', // 'analyze' | 'ignore' | 'fixed'
            nextSuggestionType: 'chords', // 'chords' | 'notes' | 'cadences' | 'improv'
            phaseHintMode: 'phaseAware', // 'phaseAware' | 'ignorePhase' | 'burstOnly'
            energyAffectsHints: true, // true | false
            keyBehavior: 'auto' // 'auto' | 'fixed' | 'ignore'
        },
        // === Rocket Mode Phase State ===
        rocketModePhase: 'ignition',
        rocketModeCurrentPhaseStartTime: 0,
        rocketModeCurrentPhaseActivityCounter: 0,
        rocketModeEnergy: 0,
        // ==============================
        yAxisDefinedByPreset: false, // true, если yAxisControls были установлены из текущего звукового пресета
    },
    elements: {
        loadingOverlay: null,
        loadingText: null,
        loadingTitle: null,
        loadingPrompt: null,
        body: document.body,
        appContainer: null,
        rocketStatusPanel: null,
        statusCurrentChord: null,
        statusCurrentKey: null,
        statusNextSuggestions: null,
        statusEnergyLevel: null,
        statusCurrentPhase: null,
    },
    loadingAudio: null,
    starsAnimation: null,
    prismEffect: null,
    loadingTimeoutId: null,
    isStartingApp: false,
    isRestartingAudio: false,

    async init() {
        console.log('[App.init v2.5.1 PadModeManager] Starting application initialization...');
        this.elements.body = document.body;
        this.elements.appContainer = document.getElementById('app-container');

        this.elements.loadingOverlay = document.getElementById('loading-overlay');
        this.elements.loadingText = this.elements.loadingOverlay?.querySelector('.loading-text');
        this.elements.loadingTitle = document.getElementById('loading-title');
        this.elements.loadingPrompt = document.querySelector('.loading-prompt');

        if (!this.elements.loadingOverlay || !this.elements.loadingText || !this.elements.loadingTitle || !this.elements.loadingPrompt) {
            console.error("[App.init v6] Critical error: Loading overlay elements not found!");
            if (this.elements.loadingText) this.elements.loadingText.textContent = "Initialization Error: UI elements missing.";
            return;
        }

        if (typeof i18n !== 'undefined') {
            i18n.init(this.state.language);
            this.updateLoadingText('initializing', 'Initializing...');
        } else { console.warn("[App.init v6] i18n module not found."); }

        let audioInitPromise = Promise.resolve(false);
        try {
            if (typeof loadingAudio !== 'undefined') {
                this.loadingAudio = loadingAudio;
                const audioBaseUrl = "https://appassets.androidplatform.net/assets/";
                const audioUrls = {
                    stars_warp: audioBaseUrl + 'audio/loading/stars_warp.mp3',
                    logo_reveal: audioBaseUrl + 'audio/loading/logo_reveal.mp3',
                    transition_burst: audioBaseUrl + 'audio/loading/transition_burst.mp3',
                    idle_loop: audioBaseUrl + 'audio/loading/idle_loop.mp3'
                };
                audioInitPromise = this.loadingAudio.init(audioUrls);
            } else { console.warn("[App.init v6] loadingAudio module not found."); }

            if (typeof starsAnimation !== 'undefined') {
                this.starsAnimation = starsAnimation;
                if (!this.starsAnimation.init('loading-stars-canvas')) { console.error("App.init v6: Failed to initialize stars animation."); }
                else { this.starsAnimation.start(); }
            } else { console.warn("[App.init v6] starsAnimation module not found."); }

            if (typeof prismEffect !== 'undefined') {
                this.prismEffect = prismEffect;
                if (!this.prismEffect.init('loading-prism-canvas')) { console.error("App.init v6: Failed to initialize prism effect."); }
            } else { console.warn("[App.init v6] prismEffect module not found."); }

        } catch (loadingModulesError) {
             console.error("App.init v6: Error initializing loading animation/audio modules:", loadingModulesError);
        }

        audioInitPromise.then(audioInitialized => {
            if (audioInitialized) { setTimeout(() => { this.loadingAudio?.playSFX('stars_warp'); }, 150); }
        });

        try {
            console.log('[App.init v6] Waiting for DOM Ready...');
            if (document.readyState === 'loading') { await new Promise(resolve => document.addEventListener('DOMContentLoaded', resolve)); }
            console.log('[App.init v6] DOM Ready.');

            console.log('[App.init v6] Waiting for bridge...');
            this.updateLoadingText('loading_bridge', 'Connecting...');
            await this.waitForBridge();
            console.log('[App.init v6] Bridge Ready.');

            console.log('[App.init v6] Starting main initialization sequence...');
            this.updateLoadingText('loading_settings', 'Loading settings...');
            await this.loadInitialSettings();
            console.log("[App.init v6] Initial currentTonic:", this.state.currentTonic);

            console.log('[App.init v6] Initializing i18n with loaded language...');
            await i18n.loadLanguage(this.state.language);

            this.updateLoadingText('loading_modules', 'Loading modules...');
            if (typeof moduleManager === 'undefined') throw new Error("moduleManager.js is not loaded!");
            await moduleManager.init();

            // MusicTheoryService
            if (typeof MusicTheoryService === 'undefined') throw new Error("MusicTheoryService is not loaded!");
            await MusicTheoryService.init(moduleManager);
            console.log("[App.init v2.5.1] MusicTheoryService initialized. isTonalJsLoaded:", MusicTheoryService.isTonalJsLoaded, "Scale defs count:", Object.keys(MusicTheoryService.scaleDefinitions).length);

            // Pad.js - ИНИЦИАЛИЗИРУЕМ ДО PadModeManager, чтобы pad.isReady было true
            if (typeof pad === 'undefined') throw new Error("pad.js is not loaded!");
            pad.init(document.getElementById('xy-pad-container'));
            console.log("[App.init v2.5.1] Pad initialized. pad.isReady:", pad.isReady);

            // PadModeManager
            console.log('[App.init] Before PadModeManager.init, this (app) is:', this);
            console.log('[App.init PadModes] Initializing PadModeManager...');
            if (typeof PadModeManager === 'undefined') throw new Error("PadModeManager.js is not loaded!");
            if (typeof harmonicMarkerEngine === 'undefined') throw new Error("harmonicMarkerEngine.js is not loaded!");
            harmonicMarkerEngine.init(MusicTheoryService);
            console.log("[App.init] HarmonicMarkerEngine initialized.");
            PadModeManager.init(this, MusicTheoryService, harmonicMarkerEngine);
            console.log("[App.init] PadModeManager initialized.");

            this.state.isInitialized = true; // Перемещаем сюда, если sidePanel зависит от isInitialized
            console.log('[App.init PadModes] Core services initialized (isInitialized = true).');
            
            // Инициализация UI Panels (включая sidePanel)
            if (typeof sidePanel === 'undefined') throw new Error("sidepanel.js is not loaded!");
            sidePanel.init(); // populateStaticSelects и populatePadModeSelectDisplay вызовутся здесь
            
            // Установка активного режима пэда (это вызовет app.updateZones() И sidePanel.displayModeSpecificControls())
            await this.setPadMode(this.state.padMode, true); // true для initialLoad

            // Synth
            if (typeof synth === 'undefined') throw new Error("synth.js is not loaded!");
            synth.init();
            if(synth.isReady) synth.applyMasterVolumeSettings();

            // Visualizer
            let analyserNode = (synth?.isReady) ? synth.getAnalyser() : null;
            if (typeof visualizer === 'undefined') throw new Error("visualizer.js is not loaded!");
            await visualizer.init(document.getElementById('xy-visualizer'), analyserNode);
            if (visualizer.isReady) {
                await visualizer.setVisualizerType(this.state.visualizer);
                await visualizer.setTouchEffectType(this.state.touchEffect);
            }

            // UI Panels
            this.updateLoadingText('loading_ui', 'Initializing UI...');
            if (typeof sidePanel === 'undefined') throw new Error("sidepanel.js is not loaded!");
            sidePanel.init(); // populateStaticSelects вызовется здесь
            // populatePadModeSelect уже вызван выше
            console.log('[App.init v2.5.1] UI modules initialized.');

            if (typeof topbar === 'undefined') throw new Error("topbar.js is not loaded!");
            topbar.init();
            if (typeof soundPresets === 'undefined') throw new Error("soundpresets.js is not loaded!");
            soundPresets.init();
            if (typeof fxChains === 'undefined') throw new Error("fxchains.js is not loaded!");
            fxChains.init();

            // Применение начального UI состояния
            this.updateLoadingText('loading_presets', 'Applying settings...');
            this.applyTheme(this.state.theme);
            await this.applySoundPreset(this.state.soundPreset); // Этот вызов уже содержит _determineEffectiveYAxisControls и обновление UI
            await this.applyFxChain(this.state.fxChain); // Этот вызов также должен содержать _determineEffectiveYAxisControls и обновление UI
            console.log('[App.init v2.5.1] Initial UI state applied.');

            this._updateSidePanelSettingsUI(); // Обновляем все настройки UI
            sidePanel.updateTonalityControls(this.state.octaveOffset, this.state.scale, this.state.zoneCount);
            if (fxChains.updateMasterOutputControlsUI) fxChains.updateMasterOutputControlsUI(this.state.masterVolumeCeiling);
            if (fxChains.updateYAxisControlsUI && this.state.fxChain === null) {
                fxChains.updateYAxisControlsUI(this.state.yAxisControls);
            }
            // app.updateZones() уже был вызван из PadModeManager.setActiveMode()

            this.elements.body.classList.add('landscape-mode');
            console.log('-----------------------------------------');
            console.log('[App.init v2.5.1] Core Initialization Complete.');
            console.log('Waiting for user interaction or timeout...');
            console.log('-----------------------------------------');

            const audioInitializedDone = await audioInitPromise;
            this.elements.loadingText?.classList.add('fade-out');
            if (audioInitializedDone) {
                 this.loadingAudio?.playSFX('logo_reveal');
                 this.loadingAudio?.startMusicLoop();
            }
            this.elements.loadingTitle?.classList.add('show');
            this.elements.loadingPrompt?.classList.add('show');
            if (typeof i18n !== 'undefined') i18n.updateUI();

            this.loadingTimeoutId = setTimeout(() => { this.triggerAppStart(); }, 14500);
            this.elements.loadingOverlay.addEventListener('click', this.handleOverlayClick, { once: true });

            this.elements.rocketStatusPanel = document.getElementById('rocket-status-panel');
            if (this.elements.rocketStatusPanel) {
                this.elements.statusCurrentChord = document.getElementById('status-current-chord');
                this.elements.statusCurrentKey = document.getElementById('status-current-key');
                this.elements.statusNextSuggestions = document.getElementById('status-next-suggestions');
                this.elements.statusEnergyLevel = document.getElementById('status-energy-level');
                this.elements.statusCurrentPhase = document.getElementById('status-current-phase');
            }

        } catch (error) {
            console.error('[App.init v2.5.1] Initialization sequence failed:', error, error.stack);
            this.state.isInitialized = false;
            this.updateLoadingText('error_init_failed_details', `Initialization Error: ${error.message}. Check console.`, true);
            this.starsAnimation?.stop();
            this.loadingAudio?.stopMusicLoop();
            this.loadingAudio?.dispose();
            this.starsAnimation?.cleanup();
            this.prismEffect?.cleanup();
            if (this.loadingTimeoutId) clearTimeout(this.loadingTimeoutId);
        }
    },

    updateLoadingText(key, fallback, isError = false) {
        if (this.elements.loadingText) {
            const message = (typeof i18n !== 'undefined' && i18n.translate) ? i18n.translate(key, fallback) : fallback;
            this.elements.loadingText.textContent = message;
            this.elements.loadingText.style.color = isError ? 'var(--color-accent, #ff4081)' : 'var(--color-text-on-dark, #e0e0e0)';
            this.elements.loadingText.classList.remove('fade-out');
        }
    },

    handleOverlayClick() {
        console.log("[App v6] Loading overlay clicked by user.");
        if (app.loadingTimeoutId) { clearTimeout(app.loadingTimeoutId); app.loadingTimeoutId = null; }
        app.triggerAppStart();
    },

    triggerAppStart() {
        if (app.isStartingApp || !app.state.isInitialized) { return; }
        console.log("[App v6] Triggering app start sequence...");
        app.isStartingApp = true;
        app.loadingAudio?.stopMusicLoop(0.3);
        app.starsAnimation?.stop();
        app.loadingAudio?.playSFX('transition_burst');
        app.elements.loadingTitle?.classList.remove('show');
        app.elements.loadingPrompt?.classList.remove('show');
        if (app.prismEffect) { app.prismEffect.play(() => { app.startAudioAndShowApp(); }); }
        else { app.startAudioAndShowApp(); }
    },

    async startAudioAndShowApp() {
        console.log("[App v6] Starting audio and hiding overlay...");
        try {
            if (Tone.context.state !== 'running') { await Tone.start(); }
            if (Tone.context.state === 'running') {
                app.state.isAudioReady = true;
                // === Экспериментальные настройки Tone.js context ===
                try {
                    Tone.context.lookAhead = 0.15; // По умолчанию ~0.1
                    Tone.context.updateInterval = 0.04; // По умолчанию ~0.03
                    console.log(`[App] Tone.context.lookAhead set to ${Tone.context.lookAhead}, updateInterval set to ${Tone.context.updateInterval}`);
                } catch (e) { console.warn('[App] Could not set Tone.context lookAhead/updateInterval:', e); }
                Tone.context.on('statechange', (e) => {
                    app.state.isAudioReady = Tone.context.state === 'running';
                    if (!app.state.isAudioReady) console.warn("[App v6] Audio context suspended after start!");
                });
                app.hideLoading();
                setTimeout(() => {
                    app.loadingAudio?.dispose(); app.starsAnimation?.cleanup(); app.prismEffect?.cleanup();
                }, 600);
            } else { throw new Error(`Audio context failed to start. State: ${Tone.context.state}`); }
        } catch (error) {
            console.error("[App v6] Failed to start/resume Tone.js:", error);
            app.elements.loadingOverlay?.classList.remove('hiding', 'hidden');
            app.updateLoadingText('error_audio_failed_retry', 'Error starting audio. Please tap again.', true);
            app.elements.loadingTitle?.classList.remove('show');
            app.elements.loadingPrompt?.classList.remove('show');
            app.elements.loadingText?.classList.add('fade-out');
            app.isStartingApp = false; app.state.isAudioReady = false; app.prismEffect?.stop();
            if (this.elements.loadingOverlay) { this.elements.loadingOverlay.removeEventListener('click', this.handleOverlayClick); this.elements.loadingOverlay.addEventListener('click', this.handleOverlayClick, { once: true }); }
        }
    },

    hideLoading() {
        if (this.elements.loadingOverlay && !this.elements.loadingOverlay.classList.contains('hidden')) {
            this.elements.loadingOverlay.classList.add('hiding');
            this.elements.loadingOverlay.addEventListener('transitionend', (event) => {
                 if (event.propertyName === 'opacity' || event.propertyName === 'transform') {
                     if (this.elements.loadingOverlay) { this.elements.loadingOverlay.classList.add('hidden'); this.elements.loadingOverlay.classList.remove('hiding'); }
                 }
            }, { once: true });
        }
    },

    waitForBridge() {
        const timeoutMs = 10000; const checkInterval = 100;
        return new Promise((resolve, reject) => {
            if (window.PrismtoneBridge?.getModules) { this.state.isBridgeReady = true; resolve(); }
            else { let attempts = 0; const maxAttempts = timeoutMs / checkInterval;
                const interval = setInterval(() => { attempts++;
                    if (window.PrismtoneBridge?.getModules) { clearInterval(interval); this.state.isBridgeReady = true; resolve(); }
                    else if (attempts > maxAttempts) { clearInterval(interval); reject(new Error("Bridge connection timed out")); }
                }, checkInterval);
            }
        });
    },

    async loadInitialSettings() {
        console.log("[App.loadInitialSettings] Loading settings...");
        // Пример загрузки из localStorage, замените на реальный вызов Bridge, если нужно
        const savedState = {
            theme: localStorage.getItem('theme') || 'day',
            language: localStorage.getItem('language') || 'en',
            soundPreset: localStorage.getItem('soundPreset') || '_test_single_preset', // Дефолт
            visualizer: localStorage.getItem('visualizer') || 'waves', // Дефолт
            touchEffect: localStorage.getItem('touchEffect') || 'glow', // Дефолт
            scale: localStorage.getItem('scale') || 'major', // Дефолт
            octaveOffset: parseInt(localStorage.getItem('octaveOffset') || '0', 10), // Дефолт 0
            zoneCount: parseInt(localStorage.getItem('zoneCount') || '12', 10), // Дефолт 12
            showNoteNames: localStorage.getItem('showNoteNames') === 'true',
            showLines: localStorage.getItem('showLines') === 'true',
            masterVolumeCeiling: parseFloat(localStorage.getItem('masterVolumeCeiling') || '1.0'),
            enablePolyphonyVolumeScaling: localStorage.getItem('enablePolyphonyVolumeScaling') === 'true',
            // === ЗАГРУЗКА ТОНИКИ ===
            currentTonic: localStorage.getItem('currentTonic') || "C4", // Загружаем или используем дефолт
            // === ЗАГРУЗКА highlightSharpsFlats ===
            highlightSharpsFlats: localStorage.getItem('highlightSharpsFlats') === 'true', // Загружаем или используем дефолт false
            // === ЗАГРУЗКА rocketModeSettings ===
            rocketModeSettings: {
                highlightActiveNotes: localStorage.getItem('rocketModeSettings.highlightActiveNotes') === 'true',
                showDirectionalMarkers: localStorage.getItem('rocketModeSettings.showDirectionalMarkers') === 'true',
                markerStyle: localStorage.getItem('rocketModeSettings.markerStyle') || "GlowFromNote",
                showOnlyForValidChords: localStorage.getItem('rocketModeSettings.showOnlyForValidChords') === 'true',
                animateMarkerFadeOut: localStorage.getItem('rocketModeSettings.animateMarkerFadeOut') === 'true',
                showChordName: localStorage.getItem('rocketModeSettings.showChordName') === 'true',
                // Новые поля:
                chordBehavior: localStorage.getItem('rocketModeSettings.chordBehavior') || 'analyze',
                nextSuggestionType: localStorage.getItem('rocketModeSettings.nextSuggestionType') || 'chords',
                phaseHintMode: localStorage.getItem('rocketModeSettings.phaseHintMode') || 'phaseAware',
                energyAffectsHints: localStorage.getItem('rocketModeSettings.energyAffectsHints') !== 'false',
                keyBehavior: localStorage.getItem('rocketModeSettings.keyBehavior') || 'auto'
            },
            // =======================
        };

        if (!this.state.isBridgeReady) {
             console.warn('[App.loadInitialSettings v6] Bridge not ready. Using defaults.');
             // Применяем дефолтные или загруженные из localStorage, если Bridge недоступен сразу
             this.state = { ...this.state, ...savedState };
             console.log('[App.loadInitialSettings] Initial state updated from localStorage (Bridge not ready):', this.state);
             return; // Выходим, если Bridge не готов
        }
        try {
            const settingsJson = await Promise.race([
                bridgeFix.callBridge('getCurrentSettings'),
                new Promise((_, reject) => setTimeout(() => reject(new Error("getCurrentSettings timeout")), 5000))
            ]);

            if (settingsJson) {
                const settings = JSON.parse(settingsJson);
                console.log('[App.loadInitialSettings v6] Received settings:', settings);
                this.state.theme = settings.theme || this.state.theme;
                this.state.language = settings.language || this.state.language;
                this.state.soundPreset = settings.soundPreset || this.state.soundPreset;
                this.state.fxChain = settings.fxChain ?? this.state.fxChain;
                this.state.visualizer = settings.visualizer || this.state.visualizer;
                this.state.touchEffect = settings.touchEffect || this.state.touchEffect;
                this.state.scale = settings.scale || this.state.scale;
                this.state.octaveOffset = settings.octaveOffset ?? this.state.octaveOffset;
                this.state.zoneCount = settings.zoneCount || this.state.zoneCount;
                this.state.showNoteNames = settings.showNoteNames ?? this.state.showNoteNames;
                this.state.showLines = settings.showLines ?? this.state.showLines; // Было showGrid

                this.state.masterVolumeCeiling = settings.masterVolumeCeiling ?? this.state.masterVolumeCeiling;
                this.state.enablePolyphonyVolumeScaling = settings.enablePolyphonyVolumeScaling ?? this.state.enablePolyphonyVolumeScaling;

                // === ЗАГРУЗКА highlightSharpsFlats из Bridge ===
                this.state.highlightSharpsFlats = settings.highlightSharpsFlats ?? this.state.highlightSharpsFlats; // Загружаем из bridge
                // ===============================================

                // === ОБНОВЛЕНИЕ ЗАГРУЗКИ yAxisControls для Части 2 ===
                const defaultVolY = this.state.yAxisControls.volume;
                const defaultFxY = this.state.yAxisControls.effects;

                if (settings.yAxisControls && typeof settings.yAxisControls === 'object') {
                    const receivedY = settings.yAxisControls;
                    if (receivedY.volume && typeof receivedY.volume === 'object') {
                        this.state.yAxisControls.volume.minOutput = receivedY.volume.minOutput ?? defaultVolY.minOutput;
                        this.state.yAxisControls.volume.maxOutput = receivedY.volume.maxOutput ?? defaultVolY.maxOutput;
                        this.state.yAxisControls.volume.yThreshold = receivedY.volume.yThreshold ?? defaultVolY.yThreshold;
                        this.state.yAxisControls.volume.curveType = receivedY.volume.curveType || defaultVolY.curveType;
                        this.state.yAxisControls.volume.curveFactor = receivedY.volume.curveFactor ?? defaultVolY.curveFactor;
                        this.state.yAxisControls.volume.outputType = receivedY.volume.outputType || defaultVolY.outputType;
                    }
                    if (receivedY.effects && typeof receivedY.effects === 'object') {
                        this.state.yAxisControls.effects.minOutput = receivedY.effects.minOutput ?? defaultFxY.minOutput;
                        this.state.yAxisControls.effects.maxOutput = receivedY.effects.maxOutput ?? defaultFxY.maxOutput;
                        this.state.yAxisControls.effects.yThreshold = receivedY.effects.yThreshold ?? defaultFxY.yThreshold;
                        this.state.yAxisControls.effects.curveType = receivedY.effects.curveType || defaultFxY.curveType;
                        this.state.yAxisControls.effects.curveFactor = receivedY.effects.curveFactor ?? defaultFxY.curveFactor;
                        this.state.yAxisControls.effects.outputType = receivedY.effects.outputType || defaultFxY.outputType;
                    }
                }
                // =====================================================

                // === НОВОЕ: Загрузка currentTonic и highlightSharpsFlats ===
                if (settings.currentTonic !== undefined) this.state.currentTonic = settings.currentTonic;
                if (settings.highlightSharpsFlats !== undefined) this.state.highlightSharpsFlats = settings.highlightSharpsFlats;
                // =======================================================

                // === ЗАГРУЗКА rocketModeSettings ===
                let rocketDefaults = {
                    highlightActiveNotes: true,
                    showDirectionalMarkers: true,
                    markerStyle: "GlowFromNote",
                    showOnlyForValidChords: false,
                    animateMarkerFadeOut: true,
                    showChordName: true,
                    intensity: 0.5,
                    autoPhases: true,
                    phaseTransitionMode: 'activity',
                    phaseDurations: { ignition: 30, liftOff: 60, burst: 90 },
                    // === Новые поля для Rocket Status Panel ===
                    chordBehavior: 'analyze', // 'analyze' | 'ignore' | 'fixed'
                    nextSuggestionType: 'chords', // 'chords' | 'notes' | 'cadences' | 'improv'
                    phaseHintMode: 'phaseAware', // 'phaseAware' | 'ignorePhase' | 'burstOnly'
                    energyAffectsHints: true, // true | false
                    keyBehavior: 'auto' // 'auto' | 'fixed' | 'ignore'
                };
                let loadedRocket = {};
                try {
                    loadedRocket = JSON.parse(localStorage.getItem('rocketModeSettings') || '{}');
                } catch(e) { loadedRocket = {}; }
                this.state.rocketModeSettings = { ...rocketDefaults, ...loadedRocket };
                // ... если есть settings.rocketModeSettings из Bridge, применить его ...
                if (settings && settings.rocketModeSettings) {
                    try {
                        const parsed = typeof settings.rocketModeSettings === 'string' ? JSON.parse(settings.rocketModeSettings) : settings.rocketModeSettings;
                        this.state.rocketModeSettings = { ...rocketDefaults, ...parsed };
                    } catch(e) { console.warn('[App] Failed to parse rocketModeSettings from bridge:', e); }
                }
                // =======================================================

                console.log('[App.loadInitialSettings v6] Final rocketModeSettings:', this.state.rocketModeSettings);
                console.log('[App.loadInitialSettings v6] Initial state updated:', this.state);
            } else {
                 console.warn('[App.loadInitialSettings v6] Received null or empty settings from bridge. Using defaults.');
            }
        } catch (error) {
            console.error('[App.loadInitialSettings v6] Error loading initial settings:', error);
        }
        // После загрузки настроек Rocket Mode из localStorage/Bridge
        const defaultRocketSettings = /* импортировать или получить из defaultAppSettings.json */ window.defaultRocketSettings || {};
        const loadedRocketSettings = this.state.rocketModeSettings || {};
        this.state.rocketModeSettings = {
            ...defaultRocketSettings,
            ...loadedRocketSettings,
            displayMarkers: { ...defaultRocketSettings.displayMarkers, ...(loadedRocketSettings.displayMarkers || {}) },
            phaseDurations: { ...defaultRocketSettings.phaseDurations, ...(loadedRocketSettings.phaseDurations || {}) }
        };
        if (this.state.padMode === 'rocket' && this.state.isInitialized && PadModeManager.getCurrentStrategy()?.getName() === 'rocket') {
            PadModeManager.getCurrentStrategy().updateInternalSetting('all', this.state.rocketModeSettings);
            this.updateZoneLayout();
            this.updateRocketStatusPanel();
        }

        // === Глубокое объединение rocketModeSettings ===
        const baseRocketDefaults = JSON.parse(JSON.stringify(this.state.rocketModeSettings));
        let finalRocketSettings = baseRocketDefaults;
        try {
            const savedJsSettingsJson = localStorage.getItem('prismtoneAppSettings_js');
            if (savedJsSettingsJson) {
                const savedJsSettings = JSON.parse(savedJsSettingsJson);
                if (savedJsSettings.rocketModeSettings) {
                    finalRocketSettings = {
                        ...baseRocketDefaults,
                        ...savedJsSettings.rocketModeSettings,
                        displayMarkers: {
                            ...(baseRocketDefaults.displayMarkers || {}),
                            ...(savedJsSettings.rocketModeSettings.displayMarkers || {})
                        },
                        phaseDurations: {
                            ...(baseRocketDefaults.phaseDurations || {}),
                            ...(savedJsSettings.rocketModeSettings.phaseDurations || {})
                        }
                    };
                    console.log('[App.loadInitialSettings] Loaded and merged rocketModeSettings from localStorage.');
                }
            }
        } catch (e) {
            console.error('[App.loadInitialSettings] Error loading/merging JS-specific settings from localStorage:', e);
        }
        this.state.rocketModeSettings = finalRocketSettings;
        console.log('[App.loadInitialSettings] Final initial rocketModeSettings:', JSON.parse(JSON.stringify(this.state.rocketModeSettings)));
        // ... остальной код ...

        // --- Загрузка presetYAxisEffectsConfig из начального звукового пресета ---
        if (this.state.soundPreset && typeof moduleManager !== 'undefined' && moduleManager) { // Добавлена проверка moduleManager
            const initialPresetModule = await moduleManager.getModule(this.state.soundPreset);
            if (initialPresetModule?.data?.data?.yAxisEffectsSendConfig) {
                this.state.presetYAxisEffectsConfig = JSON.parse(JSON.stringify(initialPresetModule.data.data.yAxisEffectsSendConfig));
                console.log("[App.loadInitialSettings] Initial presetYAxisEffectsConfig set from:", this.state.soundPreset, this.state.presetYAxisEffectsConfig);
            } else {
                this.state.presetYAxisEffectsConfig = null;
                console.log("[App.loadInitialSettings] No yAxisEffectsSendConfig in initial preset:", this.state.soundPreset);
            }
        } else {
            this.state.presetYAxisEffectsConfig = null; // На случай, если soundPreset не определен или moduleManager еще нет
            console.warn("[App.loadInitialSettings] Could not load initial presetYAxisEffectsConfig (soundPreset or moduleManager missing).");
        }
        // --- Конец загрузки presetYAxisEffectsConfig ---

        await this._determineEffectiveYAxisControls(); // Определяем и применяем финальные Y-axis controls

        console.log('[App.loadInitialSettings] Final initial state updated:', JSON.parse(JSON.stringify(this.state))); // Логируем всё состояние
        this.state.yAxisDefinedByPreset = false; // потому что мы еще не знаем, откуда пришли загруженные yAxisControls
    },

    resumeAudio() {
        if (this.state.isInitialized && Tone.context && Tone.context.state !== 'running') {
             console.log(`[App.resumeAudio] Attempting to resume audio. Current state: ${Tone.context.state}, isAudioReady: ${this.state.isAudioReady}`);
            Tone.context.resume().then(() => {
                this.state.isAudioReady = Tone.context.state === 'running';
                console.log(`[App.resumeAudio] Audio resumed. New state: ${Tone.context.state}, isAudioReady: ${this.state.isAudioReady}`);
            }).catch(err => {
                this.state.isAudioReady = false;
                console.error("[App.resumeAudio] Error resuming audio:", err);
            });
        } else if (Tone.context) {
            this.state.isAudioReady = Tone.context.state === 'running';
        } else {
            console.warn("[App.resumeAudio] Tone.context not available.");
            this.state.isAudioReady = false;
        }
    },

    suspendAudio() {
        console.log("[App.suspendAudio] Suspending audio.");
        if (synth?.stopAllNotes) {
            synth.stopAllNotes();
        }
    },

    applyTheme(themeId) {
        if (!themeId) return;
        try {
            const currentClasses = Array.from(this.elements.body.classList);
            const themeClasses = currentClasses.filter(cls => cls.startsWith('theme-'));
            this.elements.body.classList.remove(...themeClasses);
            this.elements.body.classList.add(`theme-${themeId}`);
            this.state.theme = themeId;
            if (visualizer?.updateTheme) visualizer.updateTheme();
            this._updateSidePanelSettingsUI(); // Вынесли в отдельный метод
        } catch (error) { console.error(`[App] Error applying theme ${themeId}:`, error); }
    },

    async applyLanguage(languageId) {
         if (!languageId) return;
        try {
            if (i18n?.loadLanguage) {
                await i18n.loadLanguage(languageId);
                this.state.language = languageId;
                if (this.elements.loadingOverlay && !this.elements.loadingOverlay.classList.contains('hidden')) {
                     const currentTextKey = this.elements.loadingText?.dataset.i18nKey || 'loading';
                     this.updateLoadingText(currentTextKey, currentTextKey);
                }
                 this._updateSidePanelSettingsUI();
            } else { console.error('[App] i18n module not available.'); }
        } catch (error) { console.error(`[App] Error applying language ${languageId}:`, error); }
    },

    async applyVisualizer(visualizerId) {
        if (!visualizerId) return;
        try {
            this.state.visualizer = visualizerId;
            if (visualizer?.setVisualizerType) {
                await visualizer.setVisualizerType(visualizerId);
                 bridgeFix.callBridge('setSetting', 'visualizer', visualizerId).catch(err => console.error("[App] Bridge setVisualizer failed:", err));
            }
            this._updateSidePanelSettingsUI();
        } catch (error) { console.error(`[App] Error applying visualizer ${visualizerId}:`, error); }
    },

    async applyTouchEffect(effectId) {
        if (effectId === undefined) return;
        const targetEffectId = effectId || 'none';
        try {
            this.state.touchEffect = targetEffectId;
            if (visualizer?.setTouchEffectType) {
                await visualizer.setTouchEffectType(targetEffectId);
                 bridgeFix.callBridge('setSetting', 'touchEffect', targetEffectId).catch(err => console.error("[App] Bridge setTouchEffect failed:", err));
            }
            this._updateSidePanelSettingsUI();
        } catch (error) {
            console.error(`[App] Error applying touch effect ${targetEffectId}:`, error);
        }
    },

    _applyAndSyncYAxisState() {
        console.log(`[App._applyAndSyncYAxisState v8] Syncing Y-Axis state from app.state:`, JSON.parse(JSON.stringify(this.state.yAxisControls)));
        if (synth) {
            if (synth.updateAllActiveVoiceMainLevels) synth.updateAllActiveVoiceMainLevels();
            if (synth.updateAllActiveVoiceSendLevels) synth.updateAllActiveVoiceSendLevels();
        }
        if (fxChains?.updateYAxisControlsUI) {
            fxChains.updateYAxisControlsUI(this.state.yAxisControls);
        }
        if (this.state.isInitialized && this.state.isBridgeReady) {
            bridgeFix.callBridge('setYAxisControlGroup', 'volume', JSON.stringify(this.state.yAxisControls.volume))
                .catch(err => console.error("[App._applyAndSyncYAxisState v8] Bridge setYAxis volume failed:", err));
            bridgeFix.callBridge('setYAxisControlGroup', 'effects', JSON.stringify(this.state.yAxisControls.effects))
                .catch(err => console.error("[App._applyAndSyncYAxisState v8] Bridge setYAxis effects failed:", err));
        }
    },

    async applySoundPreset(presetId) {
        const targetPresetId = presetId || (this.config.defaultPreset ? this.config.defaultPreset.id : 'default_piano');
        console.log(`[App.applySoundPreset] Applying preset: ${targetPresetId}`);
        try {
            // ... (существующая логика загрузки presetModuleData) ...
            const presetModule = await moduleManager.getModule(targetPresetId);
            let presetModuleDataForSynth = null;
            if (presetModule?.data?.data) {
                presetModuleDataForSynth = presetModule.data.data;
            } else {
                // Fallback to synth's internal default if module load fails
                presetModuleDataForSynth = synth.config.defaultPreset; // Используем дефолт из synth
                console.warn(`[App.applySoundPreset] Could not load module for '${targetPresetId}', using synth default preset.`);
            }

            if (!presetModuleDataForSynth) {
                throw new Error(`Critical: Preset data for '${targetPresetId}' and synth default are both unavailable.`);
            }

            if (synth?.applyPreset) {
                synth.applyPreset(presetModuleDataForSynth); // Передаем data.data
            } else {
                throw new Error("Synth not ready for preset application");
            }
            if (soundPresets?.updateActivePresetCube) {
                soundPresets.updateActivePresetCube(targetPresetId);
            }
            this.state.soundPreset = targetPresetId; // Обновляем ID активного пресета
            if (targetPresetId && this.state.isBridgeReady) { // Сохраняем только если это не null/undefined
                await bridgeFix.callBridge('setSoundPreset', targetPresetId);
            }

            // === КЛЮЧЕВОЕ ИЗМЕНЕНИЕ ===
            this._resolveAndApplyYAxisControls(true); // true - флаг для принудительного обновления UI/Synth
            // ==========================

        } catch (error) {
            console.error(`[App] Error applying sound preset ${targetPresetId}:`, error, error.stack);
            // Fallback logic if needed
            // ...
        }
    },

    async applyFxChain(chainId) {
        const targetChainId = chainId ?? null;
        console.log(`[App.applyFxChain] Applying FX Chain ID: ${targetChainId}.`);
        try {
            let chainModule = null;
            let fxChainFullDataForSynth = null; // Это объект chainModule.data.data

            if (targetChainId) {
                chainModule = await moduleManager.getModule(targetChainId);
                if (chainModule?.data?.data) {
                    fxChainFullDataForSynth = chainModule.data.data;
                } else if (targetChainId) {
                    console.warn(`[App.applyFxChain] FX Chain module data for ID '${targetChainId}' not found. Will apply empty chain to synth.`);
                }
            }

            // 1. Применяем аудиоэффекты в synth
            if (synth?.applyFxChain) {
                synth.applyFxChain(fxChainFullDataForSynth); // synth.applyFxChain сам разберет fxChainFullDataForSynth.effects
            } else {
                throw new Error("Synth not ready for FX chain application");
            }

            // 2. Обновляем ID активной цепочки в app.state
            this.state.fxChain = targetChainId;
            if (this.state.isBridgeReady) {
                 await bridgeFix.callBridge('setFxChain', targetChainId); // Сохраняем null, если targetChainId - null
            }

            // 3. Обновляем UI (селект цепочки и макро-ручки)
            if (fxChains?.updateActiveChain) {
                fxChains.updateActiveChain(targetChainId);
            }
            if (fxChains?.updateMacroKnobsFromChain) {
                // Передаем полные данные цепочки (fxChainFullDataForSynth), если они есть,
                // т.к. updateMacroKnobsFromChain ожидает объект с полем macroDefaults
                fxChains.updateMacroKnobsFromChain(fxChainFullDataForSynth);
            }

            // 4. === КЛЮЧЕВОЕ ИЗМЕНЕНИЕ ===
            // Разрешаем и применяем Y-Axis настройки, учитывая приоритеты
            this._resolveAndApplyYAxisControls(true); // true - флаг для принудительного обновления UI/Synth
            // ==========================

        } catch (error) {
            console.error(`[App] Error applying FX chain ${targetChainId}:`, error, error.stack);
            // Логика отката...
            try {
                if (synth) synth.applyFxChain(null);
                this.state.fxChain = null;
                if (this.state.isBridgeReady) await bridgeFix.callBridge('setFxChain', null);
                this._resolveAndApplyYAxisControls(true);
                if (fxChains?.updateActiveChain) fxChains.updateActiveChain(null);
                if (fxChains?.updateMacroKnobsFromChain) fxChains.updateMacroKnobsFromChain(null);
            } catch (fallbackError) { console.error('[App] Error during FX chain fallback:', fallbackError); }
        }
    },

    async setScale(scaleId) {
        if (!scaleId || this.state.scale === scaleId) return;
        console.log(`[App] Setting scale to: ${scaleId}`);
        this.state.scale = scaleId;
        if (sidePanel?.updateTonalityControls) {
            sidePanel.updateTonalityControls(this.state.octaveOffset, this.state.scale, this.state.zoneCount);
        }
        bridgeFix.callBridge('setSetting', 'scale', scaleId)
            .catch(err => console.error("[App.setScale] Bridge setSetting scale failed:", err));
        await this.updateZoneLayout();
    },

    async setOctaveOffset(offset) {
        const newOffset = Math.max(-7, Math.min(7, parseInt(offset, 10)));
        if (newOffset === this.state.octaveOffset || isNaN(newOffset)) return;
        this.state.octaveOffset = newOffset;
        await this.updateZoneLayout();
        if (sidePanel?.updateTonalityControls) {
            sidePanel.updateTonalityControls(this.state.octaveOffset, this.state.scale, this.state.zoneCount);
        }
        bridgeFix.callBridge('setOctaveOffset', newOffset).catch(err => console.error("[App] Bridge setOctaveOffset failed:", err));
    },

    async setZoneCount(count) {
        const newCount = parseInt(count, 10);
        if (isNaN(newCount) || newCount < 8 || newCount > 36 || newCount % 2 !== 0) {
            console.warn(`[App.setZoneCount] Invalid zone count: ${count}. Must be an even number between 8 and 36.`);
            if (sidePanel?.updateTonalityControls) {
                sidePanel.updateTonalityControls(this.state.octaveOffset, this.state.scale, this.state.zoneCount);
            }
            return;
        }
        if (newCount === this.state.zoneCount) return;
        this.state.zoneCount = newCount;
        console.log(`[App] Zone count set to: ${this.state.zoneCount}`);
        await this.updateZoneLayout();
        if (sidePanel?.updateTonalityControls) {
            sidePanel.updateTonalityControls(this.state.octaveOffset, this.state.scale, this.state.zoneCount);
        }
        bridgeFix.callBridge('setSetting', 'zoneCount', this.state.zoneCount.toString())
            .catch(err => console.error("[App] Bridge setSetting zoneCount failed:", err));
    },

    async updateZoneLayout() {
        // Полный цикл: layout + визуальные подсказки
        if (!this.state.isInitialized || !PadModeManager || !PadModeManager.getCurrentStrategy() || !pad?.isReady) {
            console.warn(`[App.updateZoneLayout] Aborting: Not ready, no strategy, or pad not ready.`);
            return;
        }
        try {
            const currentStrategy = PadModeManager.getCurrentStrategy();
            const layoutContext = await currentStrategy.getZoneLayoutOptions(this.state);
            if (!layoutContext) {
                pad.drawZones([], this.state.currentTonic);
                await this.updateZoneVisuals([]); // Обновляем визуализацию с пустыми зонами
                return;
            }
            const servicesForStrategy = PadModeManager._getServicesBundle();
            const zonesData = await currentStrategy.generateZoneData(layoutContext, this.state, servicesForStrategy);
            pad.drawZones(zonesData, this.state.currentTonic);
            await this.updateZoneVisuals(zonesData); // ГАРАНТИРОВАННО обновляем hints для актуальных зон
        } catch (error) {
            console.error('[App.updateZoneLayout] Error:', error, error.stack);
            if (pad?.isReady) pad.drawZones([], this.state.currentTonic);
            await this.updateZoneVisuals([]);
        }
    },

    async updateZoneVisuals(currentZonesData = pad._currentDisplayedZones) {
        if (!this.state.isInitialized || !PadModeManager?.getCurrentStrategy() || !pad?.isReady) return;
        try {
            const currentStrategy = PadModeManager.getCurrentStrategy();
            if (typeof currentStrategy.getPadVisualHints === 'function') {
                const services = PadModeManager._getServicesBundle();
                console.log(`[App.updateZoneVisuals] Getting hints for mode: ${PadModeManager.getCurrentModeId()}`);
                const hints = await currentStrategy.getPadVisualHints(currentZonesData, this.state, services);
                console.log(`[App.updateZoneVisuals] ----- HINTS RECEIVED FROM STRATEGY (${hints ? hints.length : 'null/undefined'}) -----`);
                if (Array.isArray(hints)) {
                    hints.forEach((h, i) => {
                        console.log(`  [App] Hint ${i}: zoneIndex=${h.zoneIndex}, type='${h.type}', style='${h.style}', color='${h.color}', note='${h.noteName || (h.notes ? h.notes.join(',') : 'N/A')}'`);
                    });
                    let hintsForVisualizer = [];
                    try {
                        hintsForVisualizer = JSON.parse(JSON.stringify(hints));
                    } catch (e) {
                        console.error("[App.updateZoneVisuals] Error deep copying hints:", e);
                        hintsForVisualizer = hints;
                    }
                    console.log(`[App.updateZoneVisuals] Hints BEING SENT to Visualizer (${hintsForVisualizer ? hintsForVisualizer.length : 'null/undefined'}):`);
                    if (Array.isArray(hintsForVisualizer)) {
                        hintsForVisualizer.forEach((h, i) => {
                            console.log(`  [App] Hint (For Visualizer) ${i}: zoneIndex=${h.zoneIndex}, type='${h.type}', style='${h.style}', color='${h.color}', note='${h.noteName || (h.notes ? h.notes.join(',') : 'N/A')}'`);
                        });
                    }
                    visualizer.updatePadHints(hintsForVisualizer);
                } else {
                    console.warn("[App.updateZoneVisuals] Hints from strategy is not an array:", hints);
                    visualizer.updatePadHints([]);
                }
            } else {
                pad.applyVisualHints([]);
            }
        } catch (error) {
            console.error('[App.updateZoneVisuals] Error:', error);
        }
    },

    toggleNoteNames(show) {
        if (typeof show !== 'boolean') return;
        this.state.showNoteNames = show;
        if (pad?.toggleLabels) pad.toggleLabels(show);
        bridgeFix.callBridge('setSetting', 'showNoteNames', show.toString()).catch(err => console.error("[App] Bridge setSetting showNoteNames failed:", err));
        this._updateSidePanelSettingsUI();
    },

    toggleLines(show) {
        if (typeof show !== 'boolean') return;
        this.state.showLines = show;
        if (pad?.toggleLines) pad.toggleLines(show);
        bridgeFix.callBridge('setSetting', 'showLines', show.toString()).catch(err => console.error("[App] Bridge setSetting showLines failed:", err));
        this._updateSidePanelSettingsUI();
    },

    setMasterVolumeCeiling(value) {
        const processedValue = parseFloat(value);
        if (isNaN(processedValue) || processedValue < 0 || processedValue > 1) {
            console.warn('[App] Invalid value:', value);
            return;
        }
        if (this.state.masterVolumeCeiling === processedValue) return;
        this.state.masterVolumeCeiling = processedValue;
        console.log('[App] Master Volume Ceiling set to:', this.state.masterVolumeCeiling);
        if (synth && synth.isReady) {
            synth.applyMasterVolumeSettings();
        }
        bridgeFix.callBridge('setSetting', 'masterVolumeCeiling', this.state.masterVolumeCeiling.toString())
           .catch(err => console.error("[App] Bridge setSetting masterVolumeCeiling failed:", err));
        if (fxChains && typeof fxChains.updateMasterOutputControlsUI === 'function') {
            fxChains.updateMasterOutputControlsUI(this.state.masterVolumeCeiling);
        }
    },

    setEnablePolyphonyVolumeScaling(isEnabled) {
        const enabled = typeof isEnabled === 'boolean' ? isEnabled : !!isEnabled; // Ensure boolean
        if (this.state.enablePolyphonyVolumeScaling === enabled) return;
        this.state.enablePolyphonyVolumeScaling = enabled;
        console.log('[App] Enable Polyphony Volume Scaling toggled to:', this.state.enablePolyphonyVolumeScaling);
        if (synth && synth.isReady) {
            synth.applyMasterVolumeSettings(); // Re-apply settings as this affects volume calculation
        }
        bridgeFix.callBridge('setSetting', 'enablePolyphonyVolumeScaling', this.state.enablePolyphonyVolumeScaling.toString())
           .catch(err => console.error("[App] Bridge setSetting enablePolyphonyVolumeScaling failed:", err));
        this._updateSidePanelSettingsUI();
    },

    // === ОБНОВЛЕННАЯ ФУНКЦИЯ setYAxisControl для Части 2 ===
    setYAxisControl(group, controlName, value) {
        if (!this.state.yAxisControls[group] || !this.state.yAxisControls[group].hasOwnProperty(controlName)) {
            console.warn(`[App.setYAxisControl] Attempted to set unknown Y-Axis control: ${group}.${controlName}`);
            return;
        }

        let processedValue = value;
        const config = this.state.yAxisControls[group];

        // Валидация и преобразование значения
        if (['minOutput', 'maxOutput', 'yThreshold', 'curveFactor'].includes(controlName)) {
            processedValue = parseFloat(value);
            if (isNaN(processedValue)) {
                console.warn(`[App.setYAxisControl] Invalid number value for ${group}.${controlName}:`, value);
                return;
            }
            // Дополнительные ограничения для конкретных параметров
            if (controlName === 'yThreshold') processedValue = Math.max(0, Math.min(1, processedValue));
            if (group === 'volume' && (controlName === 'minOutput' || controlName === 'maxOutput')) {
                processedValue = Math.max(0, Math.min(1, processedValue));
            }
            if (group === 'effects' && (controlName === 'minOutput' || controlName === 'maxOutput')) {
                processedValue = Math.max(-100, Math.min(0, processedValue)); // Для dB
            }
            if (controlName === 'curveFactor' && config.curveType !== 'sCurve') { // Степень должна быть > 0
                 processedValue = Math.max(0.1, processedValue);
            }
        } else if (controlName === 'curveType') {
            const allowedCurves = ['linear', 'exponential', 'logarithmic', 'sCurve'];
            if (!allowedCurves.includes(value)) {
                console.warn(`[App.setYAxisControl] Invalid curve value '${value}' for ${group}.${controlName}. Ignoring.`);
                if (fxChains?.updateYAxisControlsUI) fxChains.updateYAxisControlsUI(this.state.yAxisControls); // Сбросить UI
                return;
            }
        }
        // outputType не управляется из UI напрямую

        this.state.yAxisControls[group][controlName] = processedValue;

        if (group === 'effects') {
            if (synth?.updateAllActiveVoiceSendLevels) synth.updateAllActiveVoiceSendLevels();
        } else if (group === 'volume') {
            // Если нужно немедленное обновление громкости активных нот,
            // можно добавить synth.updateAllActiveVoiceMainLevels()
            if (synth?.updateAllActiveVoiceMainLevels) synth.updateAllActiveVoiceMainLevels();
        }
        // Сохранение в нативном хранилище (пока не реализовано для новой структуры)
        // TODO: Реализовать сохранение yAxisControls как единого объекта или по группам
        // bridgeFix.callBridge('setSetting', `yAxis_${group}_${controlName}`, processedValue.toString());
        console.log(`[App.setYAxisControl] ${group}.${controlName} set to ${processedValue}`);

        // === КЛЮЧЕВОЕ ИЗМЕНЕНИЕ ===
        this.state.yAxisDefinedByPreset = false; // Ручное изменение отменяет приоритет пресета/цепочки
        this._applyYAxisChangesToUIAndSynth();
        // ==========================
        console.log(`[App.setYAxisControl] ${group}.${controlName} set to ${value}. yAxisDefinedByPreset is now false.`);
    },
    // =======================================================

    async restartAudioEngine() {
        // ... (без изменений от v5) ...
        console.warn("[App] Инициирую перезапуск аудио-движка v7 (без context.close)...");
        if (this.isRestartingAudio) {
            console.warn("[App] Перезапуск аудио уже в процессе.");
            return;
        }
        this.isRestartingAudio = true;
        this.state.isAudioReady = false;

        const restartButton = (typeof topbar !== 'undefined' && topbar.buttons) ? topbar.buttons.restartAudio : null;
        const icon = restartButton ? restartButton.querySelector('.restart-icon') : null;

        if (restartButton) {
            restartButton.disabled = true;
            restartButton.classList.add('restarting');
            if (icon && icon.style.animation !== 'spinRestart 2s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards') {
                 icon.style.animation = 'spinRestart 2s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards';
            }
        }

        if (typeof synth !== 'undefined' && typeof synth.stopAllNotes === 'function') {
            synth.stopAllNotes();
        }
        if (typeof pad !== 'undefined' && typeof pad.emergencyCleanup === 'function') {
            pad.emergencyCleanup();
        }

        console.log("[App.restartAudioEngine] Освобождаю ресурсы synth...");
        if (typeof synth !== 'undefined') {
            if (synth.voices && Array.isArray(synth.voices)) {
                synth.voices.forEach((voiceData, index) => {
                    if (voiceData && voiceData.components) {
                        voiceBuilder.disposeComponents(voiceData.components);
                    }
                    if (voiceData && voiceData.fxSend) {
                        try { voiceData.fxSend.disconnect(); voiceData.fxSend.dispose(); } catch(e) { console.warn(`Ошибка dispose fxSend ${index}:`, e.message); }
                    }
                });
            }
            synth.voices = [];
            synth.voiceState = [];
            if (synth.fxBus) { try { synth.fxBus.disconnect(); synth.fxBus.dispose(); } catch (e) { console.warn("Ошибка dispose fxBus:", e.message); } }
            Object.values(synth.effects || {}).forEach((effect, i) => {
                const effectName = Object.keys(synth.effects)[i] || 'unknown_effect';
                if (effect) {
                    if (typeof effect.disconnect === 'function') { try { effect.disconnect(); } catch (e) {} }
                    if (typeof effect.dispose === 'function') { try { effect.dispose(); } catch (e) { console.warn(`Ошибка dispose эффекта ${effectName}:`, e.message); } }
                }
            });
            synth.effects = {};
            if (synth.masterVolume) { try { synth.masterVolume.disconnect(); synth.masterVolume.dispose(); } catch (e) { console.warn("Ошибка dispose masterVolume:", e.message); } }
            if (synth.limiter) { try { synth.limiter.disconnect(); synth.limiter.dispose(); } catch (e) { console.warn("Ошибка dispose limiter:", e.message); } }
            if (synth.analyser) { try { synth.analyser.disconnect(); synth.analyser.dispose(); } catch (e) { console.warn("Ошибка dispose analyser:", e.message); } }
            synth.isReady = false;
            console.log("[App.restartAudioEngine] Ресурсы synth освобождены.");
        }

        console.log("[App.restartAudioEngine] Пропускаем явное закрытие контекста. Текущее состояние (если есть):", Tone?.context?.state);

        console.log("[App.restartAudioEngine] Попытка запустить/возобновить аудиоконтекст Tone.js...");
        try {
            if (Tone && Tone.context && Tone.context.state === 'closed') {
                console.warn("[App.restartAudioEngine] Контекст Tone.js был 'closed'. Устанавливаю новый.");
                Tone.setContext(new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive', sampleRate: 48000 }));
                console.log("[App.restartAudioEngine] Новый контекст установлен. Его состояние:", Tone.context.state);
            }

            await Tone.start();

            if (Tone.context.state === 'running') {
                this.state.isAudioReady = true;
                console.log("[App.restartAudioEngine] Аудиоконтекст успешно ЗАПУЩЕН/ВОЗОБНОВЛЕН. Состояние:", Tone.context.state);
            } else {
                console.warn(`[App.restartAudioEngine] Контекст после Tone.start() в состоянии: ${Tone.context.state}. Попытка дополнительного resume...`);
                if (Tone.context && typeof Tone.context.resume === 'function') {
                    await Tone.context.resume();
                }
                if (Tone.context.state === 'running') {
                    this.state.isAudioReady = true;
                    console.log("[App.restartAudioEngine] Аудиоконтекст успешно ВОЗОБНОВЛЕН после явного resume. Состояние:", Tone.context.state);
                } else {
                    throw new Error(`Аудиоконтекст не в состоянии 'running' (${Tone.context.state}) после всех попыток.`);
                }
            }
        } catch (e) {
            console.error("[App.restartAudioEngine] КРИТИЧЕСКАЯ ОШИБКА: Не удалось создать или запустить/возобновить аудиоконтекст:", e, e.stack);
            if (i18n) alert(i18n.translate('error_audio_fatal_restart', 'Fatal audio error. Please restart the app.'));
            if (restartButton) {
                restartButton.disabled = false;
                restartButton.classList.remove('restarting');
                if (icon) icon.style.animation = 'none';
            }
            this.isRestartingAudio = false;
            return;
        }

        console.log("[App.restartAudioEngine] Переинициализирую synth и visualizer...");
        try {
            if (typeof synth !== 'undefined' && typeof synth.init === 'function') {
                synth.init();
                if(synth.isReady) synth.applyMasterVolumeSettings();
            }
            if (typeof visualizer !== 'undefined' && typeof visualizer.init === 'function') {
                await visualizer.init(document.getElementById('xy-visualizer'));
            }
        } catch (e) {
            console.error("[App.restartAudioEngine] Ошибка при переинициализации synth/visualizer:", e);
        }

        console.log("[App.restartAudioEngine] Повторно применяю настройки...");
        try {
            await this.applySoundPreset(this.state.soundPreset);
            await this.applyFxChain(this.state.fxChain); // Это обновит YAxis из цепочки
            await this.applyVisualizer(this.state.visualizer);
            await this.applyTouchEffect(this.state.touchEffect);

            if (typeof fxChains !== 'undefined') {
                // YAxisControlsUI уже должен быть обновлен через applyFxChain
                // fxChains.updateYAxisControlsUI(this.state.yAxisControls);
                if (typeof fxChains.updateMasterOutputControlsUI === 'function') {
                    fxChains.updateMasterOutputControlsUI(this.state.masterVolumeCeiling);
                }
                if (fxChains.updateMacroKnobsFromChain) {
                     const chainModule = this.state.fxChain ? await moduleManager.getModule(this.state.fxChain) : null;
                     fxChains.updateMacroKnobsFromChain(chainModule?.data?.data || null);
                }
            }
        } catch (e) {
            console.error("[App.restartAudioEngine] Ошибка при повторном применении настроек:", e);
        }

        const animationDuration = (restartButton && icon) ? 2000 : 50;
        setTimeout(() => {
            if (restartButton) {
                restartButton.disabled = false;
                restartButton.classList.remove('restarting');
                if (icon) icon.style.animation = 'none';
            }
            this.isRestartingAudio = false;
            console.log("[App.restartAudioEngine] Перезапуск аудио-движка полностью завершен. isAudioReady:", this.state.isAudioReady);
        }, animationDuration);

        if (typeof i18n !== 'undefined' && i18n.loadLanguage) {
             await i18n.loadLanguage(this.state.language);
        }
    },
    async triggerFullReload() {
        // ... (без изменений от v5) ...
        console.warn("[App] Запрос на ПОЛНУЮ ПЕРЕЗАГРУЗКУ приложения (WebView reload)...");

        const reloadButton = (typeof topbar !== 'undefined' && topbar.buttons) ? topbar.buttons.reloadApp : null;
        const icon = reloadButton ? reloadButton.querySelector('.restart-icon') : null;

        if (reloadButton) {
            reloadButton.disabled = true;
            reloadButton.classList.add('reloading');
            if (icon && icon.style.animation !== 'spinReload 2s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards') {
                 icon.style.animation = 'spinReload 2s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards';
            }
        }

        try {
            if (window.PrismtoneBridge && typeof window.PrismtoneBridge.reloadWebView === 'function') {
                console.log("[App.triggerFullReload] Вызов PrismtoneBridge.reloadWebView()...");
                bridgeFix.callBridge('reloadWebView');
            } else {
                console.error("[App.triggerFullReload] Функция PrismtoneBridge.reloadWebView не найдена!");
                alert("Error: Cannot perform a full reload. Bridge function missing.");
                if (reloadButton) {
                    reloadButton.disabled = false;
                    reloadButton.classList.remove('reloading');
                    if (icon) icon.style.animation = 'none';
                }
            }
        } catch (error) {
            console.error("[App.triggerFullReload] Ошибка при вызове bridge.reloadWebView:", error);
            alert("Error during full reload attempt. Check console.");
            if (reloadButton) {
                reloadButton.disabled = false;
                reloadButton.classList.remove('reloading');
                if (icon) icon.style.animation = 'none';
            }
        }
    },
    /**
     * Устанавливает текущую тонику приложения.
     * @param {string} noteName - Название ноты (например, "C4", "G#5").
     */
    async setTonic(noteName) {
        if (!this.state.isInitialized || !noteName || this.state.currentTonic === noteName) {
            // Если тоника не изменилась, но updateZones все равно нужен (например, после смены режима пэда)
            if (this.state.currentTonic === noteName && PadModeManager && typeof this.updateZones === 'function') {
                console.log(`[App.setTonic] Tonic ${noteName} already active, but forcing zone update.`);
                await this.updateZones(); // Это может быть избыточным, т.к. PadModeManager сделает это
            }
            return;
        }
        console.log(`[App] Current tonic will be set to: ${noteName}`);
        this.state.currentTonic = noteName;

        if (PadModeManager) {
            await PadModeManager.onTonicChanged(this.state.currentTonic); // PadModeManager вызовет app.updateZones()
        } else {
            console.warn("[App.setTonic] PadModeManager not available, calling updateZones directly.");
            await this.updateZones();
        }
        bridgeFix.callBridge('setSetting', 'currentTonic', this.state.currentTonic)
            .catch(err => console.error("[App.setTonic] Bridge setSetting currentTonic failed:", err));

        if (pad && typeof pad.highlightTonic === "function") {
            pad.highlightTonic(this.state.currentTonic); // Для немедленной подсветки, если pad это делает
        }
        // Обновляем UI панели тональности
        if (sidePanel && typeof sidePanel.updateTonalityControls === 'function') {
            sidePanel.updateTonalityControls(this.state.octaveOffset, this.state.scale, this.state.zoneCount);
        }
    },

    // Добавьте или найдите существующий метод для переключения highlightSharpsFlats
    async toggleHighlightSharpsFlats(enabled) {
        if (typeof enabled !== 'boolean') {
            console.warn('[App] setHighlightSharpsFlats: invalid type for enabled -', typeof enabled);
            return;
        }
        if (this.state.highlightSharpsFlats === enabled) {
            console.log('[App] setHighlightSharpsFlats: no change, already', enabled);
            return;
        }
        this.state.highlightSharpsFlats = enabled;
        console.log('[App] highlightSharpsFlats state updated to:', this.state.highlightSharpsFlats);
        await this.updateZoneLayout();
        // bridgeFix.callBridge('setSetting', 'highlightSharpsFlats', enabled.toString())
        //    .catch(err => console.error("[App] Bridge setSetting highlightSharpsFlats failed:", err));
        this._updateSidePanelSettingsUI();
    },

    // === НОВЫЙ МЕТОД для Установки Аккорда ===
    async setCurrentChord(chordName) {
        const newChord = chordName || null; // null, если сбрасываем аккорд
        if (this.state.currentChordName === newChord) {
            if (PadModeManager && typeof this.updateZones === 'function') {
                 console.log(`[App.setCurrentChord] Chord ${newChord} already active/null, but forcing zone update for current mode.`);
                 await this.updateZones();
            }
            return;
        }
        console.log(`[App] Current chord will be set to: ${newChord}`);
        this.state.currentChordName = newChord;

        if (PadModeManager) {
            await PadModeManager.onChordChanged(this.state.currentChordName);
        } else {
            console.warn("[App.setCurrentChord] PadModeManager not available, calling updateZones directly.");
            await this.updateZones();
        }
        bridgeFix.callBridge('setSetting', 'currentChord', this.state.currentChordName) // Предполагаем, что мост может сохранить null
             .catch(err => console.error("[App.setCurrentChord] Bridge setSetting currentChord failed:", err));

        // TODO: Обновить UI панели аккордов, если она есть и отображает текущий аккорд
        // if (chordPanel && typeof chordPanel.updateCurrentChordDisplay === 'function') {
        //     chordPanel.updateCurrentChordDisplay(this.state.currentChordName);
        // }
    },
    // ======================================

    async setPadMode(modeId, initialLoad = false) {
        if (!modeId || (!initialLoad && this.state.padMode === modeId)) {
            if (this.state.padMode === modeId && !initialLoad) {
                 console.log(`[App.setPadMode] Mode ${modeId} already active. Forcing UI updates for specific controls.`);
                 if (sidePanel?.populatePadModeSelectDisplay) sidePanel.populatePadModeSelectDisplay();
                 if (sidePanel?.displayModeSpecificControls) sidePanel.displayModeSpecificControls(modeId);
            }
            return;
        }
        console.log(`[App.setPadMode] Setting pad mode to: ${modeId}`);
        if (PadModeManager && await PadModeManager.setActiveMode(modeId)) {
            this.state.padMode = modeId;
            bridgeFix.callBridge('setSetting', 'padMode', modeId)
                .catch(err => console.error("[App.setPadMode] Bridge setSetting padMode failed:", err));
            if (sidePanel?.populatePadModeSelectDisplay) sidePanel.populatePadModeSelectDisplay();
            if (sidePanel?.displayModeSpecificControls) sidePanel.displayModeSpecificControls(modeId);
            await this.updateZoneLayout();
        } else {
            console.error(`[App] Failed to set pad mode: ${modeId}. Strategy not found or error.`);
            if (sidePanel?.populatePadModeSelectDisplay) sidePanel.populatePadModeSelectDisplay();
            if (sidePanel?.displayModeSpecificControls) sidePanel.displayModeSpecificControls(this.state.padMode);
        }
        this.updateRocketStatusPanel();
    },
    
    _updateSidePanelSettingsUI() {
        if (sidePanel && typeof sidePanel.updateSettingsControls === 'function') {
            sidePanel.updateSettingsControls(
                this.state.language, this.state.theme, this.state.visualizer,
                this.state.touchEffect, this.state.showNoteNames, this.state.showLines,
                this.state.enablePolyphonyVolumeScaling, this.state.highlightSharpsFlats,
                this.state.padMode, // Передаем текущий режим
                this.state.rocketModeSettings
            );
             // Убедимся, что текстовое поле режима пэда также обновлено
            if (sidePanel.populatePadModeSelectDisplay) {
                sidePanel.populatePadModeSelectDisplay();
            }
        }
    },

    setModeSpecificSetting(modeId, settingName, value) {
        if (modeId === 'rocket' && this.state.rocketModeSettings) {
            let changed = false;
            let actualSettingObject = this.state.rocketModeSettings;
            let actualKey = settingName;
            if (settingName.startsWith("displayMarkers.")) {
                actualKey = settingName.split('.')[1];
                if (!this.state.rocketModeSettings.displayMarkers) {
                    this.state.rocketModeSettings.displayMarkers = {};
                }
                actualSettingObject = this.state.rocketModeSettings.displayMarkers;
            }
            // Аналогично можно добавить для phaseDurations, если потребуется
            if (actualSettingObject.hasOwnProperty(actualKey)) {
                if (actualSettingObject[actualKey] !== value) {
                    actualSettingObject[actualKey] = value;
                    changed = true;
                }
            } else {
                actualSettingObject[actualKey] = value;
                changed = true;
            }
            if (changed) {
                console.log(`[App] Rocket Mode setting '${settingName}' (maps to '${actualKey}') updated to:`, value);
                console.log(`[App] app.state.rocketModeSettings NOW:`, JSON.parse(JSON.stringify(this.state.rocketModeSettings)));
                const currentStrategy = PadModeManager.getCurrentStrategy();
                if (currentStrategy && currentStrategy.getName() === 'rocket' && typeof currentStrategy.updateInternalSetting === 'function') {
                    currentStrategy.updateInternalSetting(settingName, value);
                }
                const visualControls = ['markerStyle', 'highlightActiveNotes', 'showDirectionalMarkers', 'displayMarkers.active', 'displayMarkers.functional', 'displayMarkers.inKeyOnly', 'displayFunctionNames', 'animateMarkerFadeOut', 'visualTheme'];
                const logicControls = ['markerLogicMode', 'rocketSubMode', 'tonalTonic', 'harmonicKey', 'intensity', 'autoPhases', 'phaseTransitionMode', 'chordHistoryDepth', 'phaseDurations.ignition', 'phaseDurations.liftOff', 'phaseDurations.burst'];
                if (this.state.padMode === 'rocket') {
                    if (logicControls.includes(settingName) || settingName.startsWith('phaseDurations.')) {
                        if (currentStrategy && typeof currentStrategy._analyzeAndUpdateMarkers === 'function') {
                            console.log(`[App.setModeSpecificSetting] Logic control '${settingName}' changed, triggering _analyzeAndUpdateMarkers.`);
                            currentStrategy._analyzeAndUpdateMarkers();
                        }
                    } else if (visualControls.includes(settingName) || settingName.startsWith('displayMarkers.')) {
                        console.log(`[App.setModeSpecificSetting] Visual control '${settingName}' changed, triggering updateZoneVisuals.`);
                        this.updateZoneVisuals();
                    }
                }
                this.saveAppSettingsDebounced();
            }
        } else {
            console.warn(`[App] Unknown mode or setting for setModeSpecificSetting: ${modeId}.${settingName}`);
        }
    },

    saveAppSettingsDebounced: (() => {
        let timeout = null;
        return function() {
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                try {
                    localStorage.setItem('rocketModeSettings', JSON.stringify(this.state.rocketModeSettings));
                    // bridgeFix.callBridge('setSetting', 'rocketModeSettings', JSON.stringify(this.state.rocketModeSettings));
                    console.log('[App] Saved rocketModeSettings:', this.state.rocketModeSettings);
                } catch(e) { console.error('[App] Failed to save rocketModeSettings:', e); }
            }, 300);
        };
    })(),

    setRocketPhase(newPhase) {
        const validPhases = ['ignition', 'lift-off', 'burst'];
        if (this.state.rocketModePhase === newPhase || !validPhases.includes(newPhase)) return;
        console.log(`[App.setRocketPhase] Transitioning to phase: ${newPhase}`);
        this.state.rocketModePhase = newPhase;
        this.state.rocketModeCurrentPhaseStartTime = performance.now();
        this.state.rocketModeCurrentPhaseActivityCounter = 0;
        // Можно сбросить/установить энергию по фазе
        // this.state.rocketModeEnergy = newPhase === 'burst' ? 1 : 0;
        if (typeof synth !== 'undefined' && typeof synth.setRocketModePhase === 'function') {
            synth.setRocketModePhase(newPhase);
        }
        const currentStrategy = PadModeManager.getCurrentStrategy && PadModeManager.getCurrentStrategy();
        if (currentStrategy && currentStrategy.getName && currentStrategy.getName() === 'rocket' && typeof currentStrategy.onPhaseChanged === 'function') {
            currentStrategy.onPhaseChanged(newPhase);
        }
        // Можно обновить UI, если есть
        this.updateRocketStatusPanel();
    },
    manualSetRocketPhase(phaseName) {
        if (this.state.padMode !== 'rocket') return;
        if (this.state.rocketModeSettings.autoPhases && this.state.rocketModeSettings.phaseTransitionMode !== 'manual') {
            console.warn("[App.manualSetRocketPhase] Auto-phases enabled, manual transition might be overridden.");
        }
        this.setRocketPhase(phaseName);
    },
    updateRocketStatusPanel() {
        if (!this.elements.rocketStatusPanel || !this.state.isInitialized) return;
        const isRocketActive = this.state.padMode === 'rocket';
        this.elements.rocketStatusPanel.classList.toggle('rocket-status-panel-hidden', !isRocketActive);
        if (!isRocketActive) return;
        try {
            if (this.elements.statusCurrentChord) {
                // Удаляем select для chordBehavior, если был
                const oldSelect = this.elements.rocketStatusPanel.querySelector('#rocket-chord-behavior-select');
                if (oldSelect) oldSelect.remove();
                this.elements.statusCurrentChord.textContent = this.state.currentChordName || (typeof i18n !== 'undefined' ? i18n.translate('status_na', 'N/A') : 'N/A');
            }
            if (this.elements.statusCurrentKey) {
                // Удаляем select для keyBehavior, если был
                const oldSelect = this.elements.rocketStatusPanel.querySelector('#rocket-key-behavior-select');
                if (oldSelect) oldSelect.remove();
                const tonicNoteDetails = MusicTheoryService.getNoteDetails(this.state.currentTonic);
                const tonicDisplay = tonicNoteDetails ? (tonicNoteDetails.pc + tonicNoteDetails.oct) : this.state.currentTonic;
                const scaleDisplay = (typeof i18n !== 'undefined') ? i18n.translate(this.state.scale, this.state.scale) : this.state.scale;
                this.elements.statusCurrentKey.textContent = `${tonicDisplay} ${scaleDisplay}`;
            }
            if (this.elements.statusNextSuggestions) {
                // Удаляем select для nextSuggestionType, если был
                const oldSelect = this.elements.rocketStatusPanel.querySelector('#rocket-next-type-select');
                if (oldSelect) oldSelect.remove();
                const strategy = PadModeManager.getCurrentStrategy && PadModeManager.getCurrentStrategy();
                if (strategy && strategy.getName && strategy.getName() === 'rocket' && strategy._currentSuggestions && strategy._currentSuggestions.length > 0) {
                    const suggestionsText = strategy._currentSuggestions.slice(0, 2).map(sugg => {
                        if (sugg.isChord && sugg.targetChordSymbol) return sugg.targetChordSymbol;
                        if (!sugg.isChord && sugg.noteName) return (typeof Tonal !== 'undefined' ? Tonal.Note.pitchClass(sugg.noteName) : sugg.noteName);
                        return '?';
                    }).join(' / ');
                    this.elements.statusNextSuggestions.textContent = suggestionsText || '-';
                } else {
                    this.elements.statusNextSuggestions.textContent = '-';
                }
            }
            if (this.elements.statusEnergyLevel) {
                // Удаляем toggle для energyAffectsHints, если был
                const oldToggle = this.elements.rocketStatusPanel.querySelector('#rocket-energy-affects-toggle');
                if (oldToggle) {
                    const label = oldToggle.nextSibling;
                    if (label && label.tagName === 'LABEL') label.remove();
                    oldToggle.remove();
                }
                const energyClamped = Math.max(0, Math.min(1, this.state.rocketModeEnergy || 0));
                const barsFilled = Math.floor(energyClamped * 5);
                const barsEmpty = 5 - barsFilled;
                this.elements.statusEnergyLevel.textContent = '▰'.repeat(barsFilled) + '▱'.repeat(barsEmpty);
            }
            if (this.elements.statusCurrentPhase) {
                // Удаляем select для phaseHintMode, если был
                const oldSelect = this.elements.rocketStatusPanel.querySelector('#rocket-phase-hint-select');
                if (oldSelect) oldSelect.remove();
                this.elements.statusCurrentPhase.textContent = (typeof i18n !== 'undefined') ? i18n.translate(`phase_${this.state.rocketModePhase}`, this.state.rocketModePhase) : this.state.rocketModePhase;
            }
        } catch (e) {
            console.error("[App] Error updating status panel:", e);
        }
    },
    async applyRocketPreset(presetId) {
        // ... (загрузка presetModule) ...
        if (presetModule && presetModule.data && presetModule.data.data) {
            const newSettings = presetModule.data.data;
            const baseRocketDefaults = JSON.parse(JSON.stringify(app.state.rocketModeSettings));
            this.state.rocketModeSettings = {
                ...baseRocketDefaults,
                ...newSettings,
                displayMarkers: {
                    ...(baseRocketDefaults.displayMarkers || {}),
                    ...(newSettings.displayMarkers || {})
                },
                phaseDurations: {
                    ...(baseRocketDefaults.phaseDurations || {}),
                    ...(newSettings.phaseDurations || {})
                }
            };
            const currentStrategy = PadModeManager.getCurrentStrategy();
            if (currentStrategy && currentStrategy.getName() === 'rocket' && typeof currentStrategy.updateInternalSetting === 'function') {
                currentStrategy.updateInternalSetting('all', this.state.rocketModeSettings);
            }
            if (sidePanel && typeof sidePanel.displayModeSpecificControls === 'function' && this.state.padMode === 'rocket') {
                sidePanel.displayModeSpecificControls('rocket');
            }
            if (currentStrategy && typeof currentStrategy._analyzeAndUpdateMarkers === 'function' && this.state.padMode === 'rocket') {
                await currentStrategy._analyzeAndUpdateMarkers();
            }
            this.saveAppSettingsDebounced();
            this.updateRocketStatusPanel();
            console.log("[App] Rocket Mode preset applied. New settings:", JSON.parse(JSON.stringify(this.state.rocketModeSettings)));
        }
    },

    _determineEffectiveYAxisControls: async function() {
        console.log("[App._determineYAxis] Determining effective Y-Axis controls...");
        const t0 = performance.now();

        let defaultYVolumeSettings, defaultYEffectsSettings;
        try {
            defaultYVolumeSettings = JSON.parse(JSON.stringify(window.defaultAppSettings.yAxisControls.volume));
            defaultYEffectsSettings = JSON.parse(JSON.stringify(window.defaultAppSettings.yAxisControls.effects));
        } catch (e) {
            console.error("[App._determineYAxis] CRITICAL: Failed to load/parse defaultAppSettings.yAxisControls. Using hardcoded fallbacks.", e);
            defaultYVolumeSettings = { minOutput: 0.0, maxOutput: 1.0, yThreshold: 0.0, curveType: 'linear', curveFactor: 1.0, outputType: 'gain' };
            defaultYEffectsSettings = { minOutput: -60, maxOutput: 0, yThreshold: 0.1, curveType: 'exponential', curveFactor: 2.0, outputType: 'db' };
        }

        let finalYVolume = { ...defaultYVolumeSettings };
        let finalYEffects = { ...defaultYEffectsSettings };
        let sourceOfEffectsSettings = "defaultAppSettings (initial fallback)";
        let sourceOfVolumeSettings = "defaultAppSettings (initial fallback)";

        const currentFxChainId = this.state.fxChain;
        let fxChainData = null;

        if (currentFxChainId && moduleManager) {
            const fxChainModule = await moduleManager.getModule(currentFxChainId);
            if (fxChainModule?.data?.data) {
                fxChainData = fxChainModule.data.data;
                console.log(`[App._determineYAxis] Loaded FX Chain data for '${currentFxChainId}'`);
            } else {
                console.log(`[App._determineYAxis] No data found for FX Chain ID '${currentFxChainId}'`);
            }
        }

        // --- Логика для yAxisControls.volume ---
        if (fxChainData?.yAxisControls?.volume) {
            finalYVolume = { ...defaultYVolumeSettings, ...fxChainData.yAxisControls.volume };
            sourceOfVolumeSettings = `FX Chain (${currentFxChainId})`;
        } else {
            sourceOfVolumeSettings = "defaultAppSettings (for volume)";
        }
        console.log(`[App._determineYAxis] Volume settings source: ${sourceOfVolumeSettings}`);

        // --- Логика для yAxisControls.effects (реализация приоритетов) ---
        console.log(`[App._determineYAxis] === Evaluating Y-Axis Effects ===`);
        console.log(`[App._determineYAxis] 1. FX Chain ID: '${currentFxChainId}'`);
        if (fxChainData?.yAxisControls?.effects) {
            finalYEffects = { ...defaultYEffectsSettings, ...fxChainData.yAxisControls.effects };
            sourceOfEffectsSettings = `FX Chain ('${currentFxChainId}')`;
            console.log(`[App._determineYAxis]   -> USING FX CHAIN. Data:`, JSON.parse(JSON.stringify(fxChainData.yAxisControls.effects)));
        } else {
            console.log(`[App._determineYAxis]   -> No 'effects' config in FX Chain '${currentFxChainId || 'None'}'.`);
            console.log(`[App._determineYAxis] 2. Sound Preset ID: '${this.state.soundPreset}'. Has presetYAxisEffectsConfig:`, this.state.presetYAxisEffectsConfig ? 'YES' : 'NO');
            if (this.state.presetYAxisEffectsConfig && Object.keys(this.state.presetYAxisEffectsConfig).length > 0) {
                const effectsFromPreset = { ...this.state.presetYAxisEffectsConfig };
                if (!effectsFromPreset.outputType && defaultYEffectsSettings.outputType) {
                    effectsFromPreset.outputType = defaultYEffectsSettings.outputType;
                }
                finalYEffects = { ...defaultYEffectsSettings, ...effectsFromPreset };
                sourceOfEffectsSettings = `Sound Preset ('${this.state.soundPreset}')`;
                console.log(`[App._determineYAxis]   -> USING PRESET. Data:`, JSON.parse(JSON.stringify(this.state.presetYAxisEffectsConfig)));
            } else {
                console.log(`[App._determineYAxis]   -> No valid presetYAxisEffectsConfig found.`);
                sourceOfEffectsSettings = "defaultAppSettings (for effects)";
                console.log(`[App._determineYAxis]   -> USING DEFAULT APP SETTINGS (effects).`);
            }
        }
        console.log(`[App._determineYAxis] === Final Y-Axis Effects (Source: ${sourceOfEffectsSettings}) ===:`, JSON.parse(JSON.stringify(finalYEffects)));

        let volumeChanged = false;
        if (JSON.stringify(this.state.yAxisControls.volume) !== JSON.stringify(finalYVolume)) {
            this.state.yAxisControls.volume = { ...finalYVolume };
            volumeChanged = true;
        }

        let effectsChanged = false;
        if (JSON.stringify(this.state.yAxisControls.effects) !== JSON.stringify(finalYEffects)) {
            this.state.yAxisControls.effects = { ...finalYEffects };
            effectsChanged = true;
        }

        if (volumeChanged) {
            console.log('[App._determineYAxis] Volume settings updated in app.state:', JSON.parse(JSON.stringify(this.state.yAxisControls.volume)));
            if (synth?.updateAllActiveVoiceMainLevels) synth.updateAllActiveVoiceMainLevels();
            if (this.state.isInitialized && this.state.isBridgeReady) {
                bridgeFix.callBridge('setYAxisControlGroup', 'volume', JSON.stringify(this.state.yAxisControls.volume))
                    .catch(err => console.error("[App._determineYAxis] Bridge setYAxisControlGroup 'volume' failed:", err));
            }
        }

        if (effectsChanged) {
            console.log('[App._determineYAxis] Effects settings updated in app.state:', JSON.parse(JSON.stringify(this.state.yAxisControls.effects)));
            if (synth?.updateAllActiveVoiceSendLevels) synth.updateAllActiveVoiceSendLevels();
            if (this.state.isInitialized && this.state.isBridgeReady) {
                bridgeFix.callBridge('setYAxisControlGroup', 'effects', JSON.stringify(this.state.yAxisControls.effects))
                    .catch(err => console.error("[App._determineYAxis] Bridge setYAxisControlGroup 'effects' failed:", err));
            }
        }

        if (fxChains?.updateYAxisControlsUI) {
            fxChains.updateYAxisControlsUI(this.state.yAxisControls);
            console.log('[App._determineYAxis] FX Chains UI updated with determined Y-Axis settings.');
        }
        const t1 = performance.now();
        console.log(`[App._determineYAxis] Duration: ${(t1-t0).toFixed(2)}ms`);
    },

    _resolveAndApplyYAxisControls(forceUpdate) {
        console.log("[App._resolveYAxis] Resolving final Y-Axis controls...");
        const defaultYSettings = JSON.parse(JSON.stringify(window.defaultAppSettings?.yAxisControls || {
            volume: { minOutput: 0.0, maxOutput: 1.0, yThreshold: 0.0, curveType: 'linear', curveFactor: 1.0, outputType: 'gain' },
            effects: { minOutput: -60, maxOutput: 0, yThreshold: 0.1, curveType: 'exponential', curveFactor: 2.0, outputType: 'db' }
        }));

        let finalVolumeY = { ...defaultYSettings.volume };
        let finalEffectsY = { ...defaultYSettings.effects };
        let sourceLog = "Defaults";

        // 1. Пресет
        const currentPresetId = this.state.soundPreset;
        const presetModule = currentPresetId ? moduleManager.moduleDataCache[currentPresetId] : null;
        const presetYControls = presetModule?.data?.data?.yAxisControls;

        if (presetYControls && typeof presetYControls === 'object') {
            if (presetYControls.volume && typeof presetYControls.volume === 'object') {
                finalVolumeY = { ...defaultYSettings.volume, ...presetYControls.volume };
                sourceLog = `Preset '${currentPresetId}' (volume)`;
            }
            if (presetYControls.effects && typeof presetYControls.effects === 'object') {
                finalEffectsY = { ...defaultYSettings.effects, ...presetYControls.effects };
                sourceLog = sourceLog === "Defaults" ? `Preset '${currentPresetId}' (effects)` : `${sourceLog} & (effects)`;
            }
            this.state.yAxisDefinedByPreset = !!(presetYControls.volume || presetYControls.effects);
            console.log(`[App._resolveYAxis] Applied from Sound Preset '${currentPresetId}'. yAxisDefinedByPreset: ${this.state.yAxisDefinedByPreset}`);
        } else {
            this.state.yAxisDefinedByPreset = false;
            console.log(`[App._resolveYAxis] No yAxisControls in Sound Preset '${currentPresetId}'. yAxisDefinedByPreset: false.`);
        }

        // 2. FX-цепочка
        if (!this.state.yAxisDefinedByPreset || (presetYControls && (!presetYControls.volume || !presetYControls.effects))) {
            const currentFxChainId = this.state.fxChain;
            const fxChainModule = currentFxChainId ? moduleManager.moduleDataCache[currentFxChainId] : null;
            const fxChainYControls = fxChainModule?.data?.data?.yAxisControls;

            if (fxChainYControls && typeof fxChainYControls === 'object') {
                if (!presetYControls?.volume && fxChainYControls.volume && typeof fxChainYControls.volume === 'object') {
                    finalVolumeY = { ...defaultYSettings.volume, ...fxChainYControls.volume };
                    sourceLog = sourceLog === "Defaults" ? `FX Chain '${currentFxChainId}' (volume)` : `${sourceLog} + FX Chain (volume)`;
                    console.log(`[App._resolveYAxis] Volume Y-Axis from FX Chain '${currentFxChainId}'.`);
                }
                if (!presetYControls?.effects && fxChainYControls.effects && typeof fxChainYControls.effects === 'object') {
                    finalEffectsY = { ...defaultYSettings.effects, ...fxChainYControls.effects };
                    sourceLog = sourceLog === "Defaults" || sourceLog.includes("Preset") && !sourceLog.includes("effects") ? `FX Chain '${currentFxChainId}' (effects)` : `${sourceLog} + FX Chain (effects)`;
                    console.log(`[App._resolveYAxis] Effects Y-Axis from FX Chain '${currentFxChainId}'.`);
                }
            } else if (currentFxChainId) {
                console.log(`[App._resolveYAxis] No yAxisControls in FX Chain '${currentFxChainId}'.`);
            }
        }
        // Применяем финальные значения к app.state
        const volumeChanged = JSON.stringify(this.state.yAxisControls.volume) !== JSON.stringify(finalVolumeY);
        const effectsChanged = JSON.stringify(this.state.yAxisControls.effects) !== JSON.stringify(finalEffectsY);

        if (volumeChanged) this.state.yAxisControls.volume = finalVolumeY;
        if (effectsChanged) this.state.yAxisControls.effects = finalEffectsY;

        console.log(`[App._resolveYAxis] Final Y-Axis source: ${sourceLog}`);
        console.log('[App._resolveYAxis] Final Y-Axis state:', JSON.parse(JSON.stringify(this.state.yAxisControls)));

        // Вызываем обновление UI и Synth, если были изменения или для гарантии
        if (volumeChanged || effectsChanged || forceUpdate === true) {
            this._applyYAxisChangesToUIAndSynth();
        }
    },

    _applyYAxisChangesToUIAndSynth() {
        if (!this.state.isInitialized) return;
        console.log('[App._applyYAxisChangesToUIAndSynth] Updating UI and Synth with final Y-Axis settings.');
        if (fxChains?.updateYAxisControlsUI) {
            fxChains.updateYAxisControlsUI(this.state.yAxisControls);
        }
        if (synth?.isReady) {
            if (synth.updateAllActiveVoiceMainLevels) synth.updateAllActiveVoiceMainLevels();
            if (synth.updateAllActiveVoiceSendLevels) synth.updateAllActiveVoiceSendLevels();
        }
        if (this.state.isBridgeReady) {
            bridgeFix.callBridge('setYAxisControlGroup', 'volume', JSON.stringify(this.state.yAxisControls.volume))
                .catch(err => console.error("[App] Bridge setYAxis (volume) failed:", err));
            bridgeFix.callBridge('setYAxisControlGroup', 'effects', JSON.stringify(this.state.yAxisControls.effects))
                .catch(err => console.error("[App] Bridge setYAxis (effects) failed:", err));
        }
    },
};

document.addEventListener('DOMContentLoaded', () => {
    app.init().catch(error => {
        console.error("[App v6 Global Catch] Unhandled error during app initialization:", error);
        const loadingOverlay = document.getElementById('loading-overlay');
        if (loadingOverlay) {
            const loadingTextElement = loadingOverlay.querySelector('.loading-text');
            if (loadingTextElement) {
                const errorKey = 'error_fatal_init'; const fallbackErrorMsg = 'Fatal Initialization Error.';
                const translatedError = (typeof i18n !== 'undefined' && typeof i18n.translate === 'function') ? i18n.translate(errorKey, fallbackErrorMsg) : fallbackErrorMsg;
                loadingTextElement.textContent = translatedError + ` (${error.message || 'Unknown error'})`;
                loadingTextElement.style.color = '#ff4081'; loadingTextElement.classList.remove('fade-out');
            }
            loadingOverlay.classList.remove('hidden', 'hiding'); loadingOverlay.style.opacity = '1'; loadingOverlay.style.visibility = 'visible';
            const spinner = loadingOverlay.querySelector('.loading-spinner'); if (spinner) spinner.style.display = 'none';
            const title = document.getElementById('loading-title'); const prompt = document.querySelector('.loading-prompt');
            if (title) title.classList.remove('show'); if (prompt) prompt.classList.remove('show');
        }
    });

    // === Rocket Status Panel Show/Hide ===
    const rocketStatusPanel = document.getElementById('rocket-status-panel');
    const rocketStatusHideBtn = document.getElementById('rocket-status-hide-btn');
    const rocketStatusShowBtn = document.getElementById('rocket-status-show-btn');
    if (rocketStatusHideBtn && rocketStatusPanel && rocketStatusShowBtn) {
        rocketStatusHideBtn.addEventListener('click', () => {
            rocketStatusPanel.classList.add('rocket-status-panel-hidden');
            rocketStatusShowBtn.style.display = 'block';
        });
        rocketStatusShowBtn.addEventListener('click', () => {
            rocketStatusPanel.classList.remove('rocket-status-panel-hidden');
            rocketStatusShowBtn.style.display = 'none';
        });
    }
    // === Rocket Status Panel Interactivity ===
    const statusChord = document.getElementById('status-current-chord');
    const statusKey = document.getElementById('status-current-key');
    const statusPhase = document.getElementById('status-current-phase');
    if (statusChord) {
        statusChord.addEventListener('click', () => {
            if (typeof showCustomSelectorPopover === 'function') {
                // Предполагаем, что список аккордов доступен через MusicTheoryService
                const chords = MusicTheoryService.getAvailableChordNames ? MusicTheoryService.getAvailableChordNames() : [];
                showCustomSelectorPopover({
                    type: 'chord',
                    title: i18n.translate('select_chord', 'Select Chord'),
                    itemsArray: chords.map(name => ({ id: name, name })),
                    currentValue: app.state.currentChordName,
                    onSelect: (selectedChord) => {
                        app.setCurrentChord(selectedChord);
                    }
                });
            }
        });
    }
    if (statusKey) {
        statusKey.addEventListener('click', () => {
            if (typeof showCustomSelectorPopover === 'function') {
                const tonics = MusicTheoryService.getAvailableTonicNames ? MusicTheoryService.getAvailableTonicNames() : [];
                const scales = MusicTheoryService.getAvailableScaleIds ? MusicTheoryService.getAvailableScaleIds() : [];
                showCustomSelectorPopover({
                    type: 'key',
                    title: i18n.translate('select_key', 'Select Key'),
                    itemsArray: tonics.flatMap(tonic => scales.map(scale => ({ id: tonic + ' ' + scale, name: tonic + ' ' + i18n.translate(scale, scale) }))),
                    currentValue: app.state.currentTonic + ' ' + app.state.scale,
                    onSelect: (selectedKey) => {
                        const [tonic, ...scaleArr] = selectedKey.split(' ');
                        const scale = scaleArr.join(' ');
                        app.setTonic(tonic);
                        app.setScale(scale);
                    }
                });
            }
        });
    }
    if (statusPhase) {
        statusPhase.addEventListener('click', () => {
            if (typeof showCustomSelectorPopover === 'function') {
                const phases = [
                    { id: 'ignition', name: i18n.translate('rocket_phase_ignition', 'Ignition') },
                    { id: 'lift-off', name: i18n.translate('rocket_phase_lift_off', 'Lift-off') },
                    { id: 'burst', name: i18n.translate('rocket_phase_burst', 'Burst') }
                ];
                showCustomSelectorPopover({
                    type: 'rocket_phase',
                    title: i18n.translate('select_phase', 'Select Phase'),
                    itemsArray: phases,
                    currentValue: app.state.rocketModePhase,
                    onSelect: (selectedPhase) => {
                        app.manualSetRocketPhase(selectedPhase);
                    }
                });
            }
        });
    }
});

window.app = app;

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\bridge-fix.js
// Файл: app/src/main/assets/js/bridge-fix.js
// Provides fixes or wrappers for potential bridge issues (timing, errors)
const bridgeFix = {

    /**
     * Calls a function on the PrismtoneBridge, handling potential errors and timing issues.
     * @param {string} functionName - The name of the bridge function to call.
     * @param {...any} args - Arguments to pass to the bridge function.
     * @returns {Promise<any>} - A promise that resolves with the bridge function's return value or rejects on error.
     */
    async callBridge(functionName, ...args) {
        // console.log(`[BridgeFix] Attempting call: ${functionName}`, args); // Лог вызова (можно раскомментировать для детальной отладки)
        return new Promise((resolve, reject) => {
            if (window.PrismtoneBridge && typeof window.PrismtoneBridge[functionName] === 'function') {
                try {
                    // Преобразуем аргументы в строки, если они объекты (кроме простых типов)
                    const stringArgs = args.map(arg => {
                        if (typeof arg === 'object' && arg !== null) {
                            try {
                                return JSON.stringify(arg);
                            } catch (e) {
                                console.error(`[BridgeFix] Error stringifying argument for ${functionName}:`, arg, e);
                                return null; // Или бросить ошибку? Пока null.
                            }
                        }
                        return arg; // Оставляем примитивы как есть
                    });

                    // Фильтруем null аргументы, возникшие из-за ошибки stringify
                    const finalArgs = stringArgs.filter(arg => arg !== null);
                    if (finalArgs.length !== args.length) {
                         console.error(`[BridgeFix] Some arguments could not be stringified for ${functionName}. Aborting call.`);
                         reject(new Error(`Argument stringification failed for ${functionName}`));
                         return;
                    }

                    // console.log(`[BridgeFix] Executing: PrismtoneBridge.${functionName}`, finalArgs);
                    const result = window.PrismtoneBridge[functionName](...finalArgs);

                    // Android JavascriptInterface calls are synchronous from JS perspective.
                    // The result is returned immediately.
                    // console.log(`[BridgeFix] Result [${functionName}]:`, result);

                    // Проверяем, не вернула ли Java ошибку в виде строки
                    if (typeof result === 'string' && result.toLowerCase().startsWith('error:')) {
                        console.error(`[BridgeFix] Bridge function '${functionName}' returned an error string: ${result}`);
                        reject(new Error(result)); // Отклоняем Promise с ошибкой
                    } else {
                        resolve(result); // Успешно разрешаем Promise
                    }

                } catch (error) {
                    console.error(`[BridgeFix] Error executing bridge function '${functionName}':`, error, error.stack);
                    reject(new Error(`Bridge call execution failed: ${error.message}`));
                }
            } else {
                // Мост недоступен или функция отсутствует
                const errorMsg = `Bridge function '${functionName}' not found or bridge not ready.`;
                console.error(`[BridgeFix] ${errorMsg}`);
                reject(new Error(errorMsg));
            }
        });
    }

    // Можно добавить другие обертки или хелперы при необходимости
};
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\config\audioConfig.js
// Файл: app/src/main/assets/js/config/audioConfig.js
// Централизованная конфигурация аудио движка Prismtone

const audioConfig = {

    /**
     * Определяет порядок следования основных аудио-компонентов в цепочке голоса.
     */
    voiceAudioChainOrder: [
        'oscillator',
        'amplitudeEnv',
        'filter',
        // 'VOICE_INSERT_FX_SLOT', // <--- ДОБАВЛЕННЫЙ МАРКЕР
        'outputGain'
    ],

    /**
     * Список идентификаторов компонентов, которые являются модуляторами
     */
    modulatorComponents: [
        'pitchEnvelope',
        'filterEnvelope',
        'lfo1',
    ],

    // <<<--- ДОБАВЛЕННАЯ СТРОКА ---
    /**
     * Максимальное количество одновременно звучащих голосов.
     */
    polyphony: 6, // Попробуем значение 6 (или 4, если 6 не поможет)
    // --- КОНЕЦ ДОБАВЛЕННОЙ СТРОКИ ---

    /**
     * Реестр менеджеров компонентов.
     */
    componentManagersRegistry: {
        // Заполняется автоматически при загрузке файлов менеджеров
    },

    /**
     * Регистрирует менеджер компонента в реестре.
     */
    registerManager(componentId, managerObject) {
        if (!componentId || !managerObject) {
            console.error("[AudioConfig] Invalid arguments for registerManager:", componentId, managerObject);
            return;
        }
        if (this.componentManagersRegistry.hasOwnProperty(componentId)) {
            console.warn(`[AudioConfig] Manager for component ID '${componentId}' is being overwritten.`);
        }
        this.componentManagersRegistry[componentId] = managerObject;
        console.log(`[AudioConfig] Registered manager for: ${componentId}`);
    },

    /**
     * Получает менеджер по ID компонента.
     */
    getManager(componentId) {
        const manager = this.componentManagersRegistry[componentId];
        if (!manager) {
            // console.warn(`[AudioConfig] Manager not found for component ID: ${componentId}`); // Уменьшаем шум
        }
        return manager || null;
    }
};

// window.audioConfig = audioConfig; // Раскомментировать, если нужен глобальный доступ
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\customSelectorPopover.js
// app/src/main/assets/js/customSelectorPopover.js

// Объявляем функцию в глобальной области видимости
// eslint-disable-next-line no-unused-vars
function showCustomSelectorPopover(options) {
    const {
        type, // 'language', 'theme', 'visualizer', 'touchEffect', 'scale', 'fxChain'
        title, // Заголовок для поповера
        selectElement, // Оригинальный <select> элемент (для получения текущего значения или как fallback)
        currentValue, // Текущее выбранное значение
        onSelect, // callback(newValue)
        parentPanelId // (Опционально) ID родительской панели для позиционирования или стилизации
    } = options;

    console.log(`[CustomSelector] Showing for type: ${type}, title: ${title}, currentValue: ${currentValue}`);

    const popoverElement = document.getElementById('custom-selector-popover');
    const backdropElement = popoverElement?.querySelector('.custom-selector-backdrop');
    const modalElement = popoverElement?.querySelector('.custom-selector-modal');
    const titleElement = popoverElement?.querySelector('#custom-selector-title');
    const optionsContainer = popoverElement?.querySelector('#custom-selector-options');
    const closeButton = popoverElement?.querySelector('#custom-selector-close');

    if (!popoverElement || !backdropElement || !modalElement || !titleElement || !optionsContainer || !closeButton) {
        console.error('[CustomSelector] Critical UI elements for popover are missing!');
        // Возможно, здесь стоит показать стандартный select, если он есть
        if (selectElement && typeof selectElement.click === 'function') {
            // selectElement.click(); // Это не сработает для открытия, только для фокуса
        }
        return;
    }

    titleElement.textContent = title || i18n.translate('select_option', 'Select Option');
    optionsContainer.innerHTML = ''; // Очищаем предыдущие опции

    let itemsPromise;

    // === ПАТЧ: поддержка передачи itemsArray напрямую ===
    if (options.itemsArray) {
        itemsPromise = Promise.resolve(options.itemsArray);
    } else {
        // Загружаем опции в зависимости от типа
        switch (type) {
            case 'language':
            case 'theme':
            case 'visualizer':
            case 'touchEffect':
            case 'scale':
            case 'fxChain':
                console.log(`[CustomSelector] Calling moduleManager.getModules with type: ${type}`);
                itemsPromise = moduleManager.getModules(type, true); // true для forceRefresh, чтобы всегда были свежие данные
                break;
            default:
                console.warn(`[CustomSelector] Unknown type: ${type}. Trying to read from selectElement.`);
                // Попытка прочитать из <select> элемента как fallback
                if (selectElement && selectElement.options) {
                    const selectOptions = Array.from(selectElement.options).map(opt => ({
                        id: opt.value,
                        name: opt.textContent,
                        // Для тем может понадобиться специальная логика для цвета
                    }));
                    itemsPromise = Promise.resolve(selectOptions);
                } else {
                    itemsPromise = Promise.resolve([]);
                }
        }
    }

    itemsPromise.then(items => {
        if (!Array.isArray(items)) {
            console.error(`[CustomSelector] Module items for type '${type}' is not an array. Got:`, items);
            items = [];
        }

        console.log(`[CustomSelector] Loaded ${items.length} items for type: ${type}`);

        if (type === 'fxChain') {
            // Добавляем опцию "-- None --" для FX Chain
            const noneOption = document.createElement('button');
            noneOption.className = 'custom-selector-option';
            noneOption.dataset.value = ""; // Пустое значение для "None"
            const noneLabel = document.createElement('span');
            noneLabel.className = 'option-label';
            noneLabel.textContent = i18n.translate('none_fxchain', '-- None --');
            noneOption.appendChild(noneLabel);
            if (currentValue === null || currentValue === "") {
                noneOption.classList.add('active');
            }
            noneOption.addEventListener('click', () => handleSelect(""));
            optionsContainer.appendChild(noneOption);
        } else if (type === 'touchEffect') {
             const noneOption = document.createElement('button');
             noneOption.className = 'custom-selector-option';
             noneOption.dataset.value = "none";
             const noneLabel = document.createElement('span');
             noneLabel.className = 'option-label';
             noneLabel.textContent = i18n.translate('none_touch_effect', 'None');
             noneOption.appendChild(noneLabel);
             if (currentValue === "none") {
                 noneOption.classList.add('active');
             }
             noneOption.addEventListener('click', () => handleSelect("none"));
             optionsContainer.appendChild(noneOption);
        }


        items.sort((a, b) => (a.name || a.id).localeCompare(b.name || b.id));

        items.forEach(item => {
            const optionButton = document.createElement('button');
            optionButton.className = 'custom-selector-option';
            optionButton.dataset.value = item.id;

            const previewSpan = document.createElement('span');
            previewSpan.className = 'option-preview';
            // Добавляем специфичные для типа превью
            if (type === 'theme' && item.data?.data?.colors?.primary) {
                previewSpan.classList.add('theme');
                previewSpan.style.backgroundColor = item.data.data.colors.primary;
                if (item.data.data.colors.text) { // Цвет текста для лучшей читаемости превью
                    const textColor = item.data.data.colors.text;
                    const contrastBackground =視覺対比の良い色(item.data.data.colors.primary, textColor); // вымышленная функция
                    if (contrastBackground !== item.data.data.colors.primary) {
                         // previewSpan.style.borderColor = textColor; // или другой способ указать контраст
                    }
                }
            } else if (type === 'language') {
                previewSpan.classList.add('language');
                previewSpan.textContent = item.id.toUpperCase(); // Например, "EN", "RU"
            } else if (type === 'visualizer') {
                previewSpan.classList.add('visualizer');
                previewSpan.textContent = 'V'; // Простая иконка
            } else if (type === 'touchEffect') {
                 previewSpan.classList.add('touchEffect');
                 previewSpan.textContent = '✨';
            } else if (type === 'scale') {
                previewSpan.classList.add('scale');
                previewSpan.textContent = '♪';
            } else if (type === 'fxChain') {
                 previewSpan.classList.add('fxchain');
                 previewSpan.textContent = 'FX';
            }
            // ... другие типы по необходимости ...
            optionButton.appendChild(previewSpan);

            const labelSpan = document.createElement('span');
            labelSpan.className = 'option-label';
            labelSpan.textContent = item.name || item.id;
            optionButton.appendChild(labelSpan);

            if (item.id === currentValue) {
                optionButton.classList.add('active');
            }

            optionButton.addEventListener('click', () => handleSelect(item.id));
            optionsContainer.appendChild(optionButton);
        });

        if (items.length === 0 && type !== 'fxChain' && type !== 'touchEffect') {
             const noItemsMsg = document.createElement('div');
             noItemsMsg.className = 'custom-selector-option disabled';
             noItemsMsg.textContent = i18n.translate(`no_${type}_found`, `No ${type}s found`);
             optionsContainer.appendChild(noItemsMsg);
        }

        popoverElement.style.display = 'flex'; // Показываем поповер
        requestAnimationFrame(() => {
            modalElement.classList.add('active'); // для анимации появления
            popoverElement.classList.add('active');
        });

    }).catch(error => {
        console.error(`[CustomSelector] Error loading items for type ${type}:`, error);
        optionsContainer.innerHTML = `<div class="custom-selector-option disabled">${i18n.translate('error_loading_options', 'Error loading options')}</div>`;
        popoverElement.style.display = 'flex';
        requestAnimationFrame(() => {
            modalElement.classList.add('active');
            popoverElement.classList.add('active');
        });
    });

    function closePopover() {
        modalElement.classList.remove('active');
        popoverElement.classList.remove('active');
        // Используем transitionend для скрытия после завершения анимации
        const onTransitionEnd = () => {
            popoverElement.style.display = 'none';
            modalElement.removeEventListener('transitionend', onTransitionEnd);
        };
        modalElement.addEventListener('transitionend', onTransitionEnd);

        // Фоллбэк, если transitionend не сработает (например, нет анимации)
        setTimeout(() => {
             if (popoverElement.style.display !== 'none') {
                popoverElement.style.display = 'none';
             }
        }, 300); // Длительность должна соответствовать CSS transition
    }

    function handleSelect(value) {
        console.log(`[CustomSelector] Selected value: ${value} for type: ${type}`);
        if (selectElement) {
            selectElement.value = value; // Все равно обновляем скрытый select для хранения значения

            // === НОВОЕ: Обновление текстового дисплея ===
            const displayElementId = selectElement.id + '-display'; // e.g., scale-select-display
            const displayElement = document.getElementById(displayElementId);
            if (displayElement) {
                const selectedOption = Array.from(optionsContainer.querySelectorAll('.custom-selector-option'))
                                         .find(opt => opt.dataset.value === value);
                if (selectedOption) {
                    const labelSpan = selectedOption.querySelector('.option-label');
                    displayElement.textContent = labelSpan ? labelSpan.textContent : value;
                } else if (value === "" && type === "fxChain") { // Особый случай для "-- None --" FX Chain
                    displayElement.textContent = i18n.translate('none_fxchain', '-- None --');
                } else if (value === "none" && type === "touchEffect") {
                     displayElement.textContent = i18n.translate('none_touch_effect', 'None');
                }
                 else {
                    displayElement.textContent = value; // Fallback
                }
            }
            // ========================================
        }
        if (typeof onSelect === 'function') {
            onSelect(value);
        }
        closePopover();
    }

    // Обработчики закрытия
    backdropElement.addEventListener('click', closePopover, { once: true });
    closeButton.addEventListener('click', closePopover, { once: true });

    // Закрытие по Esc
    function handleEscKey(event) {
        if (event.key === 'Escape') {
            closePopover();
            document.removeEventListener('keydown', handleEscKey);
        }
    }
    document.addEventListener('keydown', handleEscKey);
}

// Вымышленная функция для примера контрастного цвета, ее нужно реализовать
// function getContrastColor(bgColor, lightColor = '#FFFFFF', darkColor = '#000000') {
//     if (!bgColor) return darkColor;
//     const color = (bgColor.charAt(0) === '#') ? bgColor.substring(1, 7) : bgColor;
//     const r = parseInt(color.substring(0, 2), 16); // hexToR
//     const g = parseInt(color.substring(2, 4), 16); // hexToG
//     const b = parseInt(color.substring(4, 6), 16); // hexToB
//     return (((r * 0.299) + (g * 0.587) + (b * 0.114)) > 186) ? darkColor : lightColor;
// }

// CSS стили для этого поповера должны быть в styles.css или themes.css
// Пример стилей был в одном из предыдущих ответов (секция про `.custom-selector-popover` и т.д.)

// Явное присвоение функции в глобальную область видимости для надежности
if (typeof window !== 'undefined') {
    window.showCustomSelectorPopover = showCustomSelectorPopover;
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\fxchains.js
// Файл: app/src/main/assets/js/fxchains.js
const fxChains = {
    panelElement: null,
    chainSelectElement: null,
    resetButton: null,
    macroControlsContainer: null,
    currentChainId: null,
    userChainPrefix: 'user_',
    macroKnobs: {},

    // === ОБНОВЛЕННАЯ СТРУКТУРА для Части 2 ===
    yAxisControlsElements: {
        volume_minOutputKnob: null,
        volume_maxOutputKnob: null,
        volume_yThresholdKnob: null,
        volume_curveTypeSelect: null,
        volume_curveFactorKnob: null,

        effects_minOutputKnob: null,
        effects_maxOutputKnob: null,
        effects_yThresholdKnob: null,
        effects_curveTypeSelect: null,
        effects_curveFactorKnob: null,
    },
    // =========================================
    masterVolumeCeilingKnob: null,

    init() {
        console.log('[FxChains v5 - YAxisFlex] Initializing...');
        this.panelElement = document.getElementById('effects-panel');
        if (!this.panelElement) { console.error("[FxChains v5] Effects panel element not found!"); return; }

        this.chainSelectElement = document.getElementById('fx-chain-select');
        this.resetButton = document.getElementById('reset-fx-button');
        this.macroControlsContainer = document.getElementById('macro-controls');

        const yAxisContainer = this.panelElement.querySelector('.y-axis-controls');
        if (yAxisContainer) {
            console.log("[FxChains v5] Initializing Y-Axis controls...");
            // === ИНИЦИАЛИЗАЦИЯ НОВЫХ ЭЛЕМЕНТОВ Y-Axis ===
            this.yAxisControlsElements.volume_minOutputKnob = yAxisContainer.querySelector('.knob[data-param="volume_minOutput"]');
            this.yAxisControlsElements.volume_maxOutputKnob = yAxisContainer.querySelector('.knob[data-param="volume_maxOutput"]');
            this.yAxisControlsElements.volume_yThresholdKnob = yAxisContainer.querySelector('.knob[data-param="volume_yThreshold"]');
            this.yAxisControlsElements.volume_curveTypeSelect = document.getElementById('volume_curveType-select');
            this.yAxisControlsElements.volume_curveFactorKnob = yAxisContainer.querySelector('.knob[data-param="volume_curveFactor"]');

            this.yAxisControlsElements.effects_minOutputKnob = yAxisContainer.querySelector('.knob[data-param="effects_minOutput"]');
            this.yAxisControlsElements.effects_maxOutputKnob = yAxisContainer.querySelector('.knob[data-param="effects_maxOutput"]');
            this.yAxisControlsElements.effects_yThresholdKnob = yAxisContainer.querySelector('.knob[data-param="effects_yThreshold"]');
            this.yAxisControlsElements.effects_curveTypeSelect = document.getElementById('effects_curveType-select');
            this.yAxisControlsElements.effects_curveFactorKnob = yAxisContainer.querySelector('.knob[data-param="effects_curveFactor"]');
            // ===========================================

            for (const key in this.yAxisControlsElements) {
                const element = this.yAxisControlsElements[key];
                if (element && element.classList?.contains('knob')) {
                    sidePanel.initKnob(element);
                } else if (!element && key.endsWith('Knob')) {
                     console.error(`[FxChains v5] Y-Axis knob element not found for: ${key}`);
                } else if (!element && key.endsWith('Select')) {
                     console.error(`[FxChains v5] Y-Axis select element not found for: ${key}`);
                }
            }
        } else {
            console.error("[FxChains v5] Could not find .y-axis-controls container!");
        }

        this.macroKnobs = {};
        const macroUIMap = { 'macro1': 'Space', 'macro2': 'Time', 'macro3': 'Motion', 'macro4': 'Tone', 'macro5': 'Drive' };
        if (this.macroControlsContainer) {
            this.macroControlsContainer.querySelectorAll('.knob').forEach(knob => {
                const dataParam = knob.dataset.param;
                const macroKeyName = macroUIMap[dataParam];
                if (macroKeyName) {
                    this.macroKnobs[macroKeyName] = knob;
                    sidePanel.initKnob(knob);
                } else {
                    console.warn(`[FxChains Init] No UI mapping found for knob with data-param: ${dataParam}`);
                }
            });
        }

        const masterOutputContainer = this.panelElement.querySelector('.master-output-controls');
        if (masterOutputContainer) {
            this.masterVolumeCeilingKnob = masterOutputContainer.querySelector('.knob[data-param="masterVolumeCeiling"]');
            if (this.masterVolumeCeilingKnob) {
                sidePanel.initKnob(this.masterVolumeCeilingKnob);
            } else {
                console.error("[FxChains v5] Master Volume Ceiling knob element not found!");
            }
        } else {
            console.error("[FxChains v5] Master Output controls container not found!");
        }

        this.addEventListeners();
        this.populateFxChainList();

        console.log('[FxChains v5] Initialized successfully.');
    },

    addEventListeners() {
        console.log('[FxChains v5] Adding event listeners...');

        if (this.chainSelectElement) {
            this.chainSelectElement.addEventListener('change', async (e) => {
                const chainId = e.target.value;
                await app.applyFxChain(chainId || null); // applyFxChain обновит yAxisControls и вызовет updateYAxisControlsUI
                const chainModule = chainId ? await moduleManager.getModule(chainId) : null;
                this.updateMacroKnobsFromChain(chainModule?.data?.data);
                // this.updateYAxisControlsUI(app.state.yAxisControls); // Уже вызывается в applyFxChain
            });
        }

        if (this.resetButton) {
            this.resetButton.addEventListener('click', async () => {
                await app.applyFxChain(null); // Это сбросит yAxisControls в app.state к дефолтам
                this.updateMacroKnobsFromChain(null);
                // this.updateYAxisControlsUI(app.state.yAxisControls); // Уже вызывается в applyFxChain
            });
        }

        // === ОБНОВЛЕННЫЕ ОБРАБОТЧИКИ Y-Axis ===
        for (const key in this.yAxisControlsElements) {
             const element = this.yAxisControlsElements[key];
             if (element) {
                 const parts = key.split('_'); // e.g., "volume_minOutputKnob" -> ["volume", "minOutputKnob"]
                 const group = parts[0]; // "volume" or "effects"
                 let paramName = parts[1];
                 if (paramName.endsWith('Knob')) paramName = paramName.slice(0, -4);
                 else if (paramName.endsWith('Select')) paramName = paramName.slice(0, -6);

                 if (!paramName) {
                     console.warn("[FxChains v5] Could not determine param name for Y-Axis element:", key);
                     continue;
                 }

                 // === ДЕБАУНС ДЛЯ knob-change ===
                 if (element.classList?.contains('knob')) {
                     let debounceTimer = null;
                     let lastValue = undefined;
                     element.addEventListener('knob-change', (e) => {
                         const value = e.detail.value;
                         if (value === lastValue) return;
                         lastValue = value;
                         if (debounceTimer) clearTimeout(debounceTimer);
                         debounceTimer = setTimeout(() => {
                             app.setYAxisControl(group, paramName, value);
                             debounceTimer = null;
                         }, 40);
                     });
                 } else if (element.tagName === 'SELECT') {
                     element.addEventListener('change', (e) => {
                         app.setYAxisControl(group, paramName, e.target.value);
                     });
                 }
             }
        }
        // =====================================

        for (const uiMacroName in this.macroKnobs) {
            const knob = this.macroKnobs[uiMacroName];
            knob.addEventListener('knob-change', (e) => {
                this.handleMacroKnobChange(uiMacroName, e.detail.value);
            });
        }

        if (this.masterVolumeCeilingKnob) {
            this.masterVolumeCeilingKnob.addEventListener('knob-change', (e) => {
                if (app && typeof app.setMasterVolumeCeiling === 'function') {
                    app.setMasterVolumeCeiling(e.detail.value);
                }
            });
        }
        console.log('[FxChains v5] Event listeners added.');
    },

    handleMacroKnobChange(macroKeyInUI, value) {
        if (typeof synth !== 'undefined' && typeof synth.setMacro === 'function') {
            console.log(`[FxChains UpdateKnobs] Applying macro '${macroKeyInUI}' value ${value} after knob change.`);
            synth.setMacro(macroKeyInUI, value);
        }
    },

    updateMacroKnobsFromChain(fxChainData) {
        const macroDefaults = fxChainData?.macroDefaults || {};
        console.log(`[FxChains updateMacroKnobs] Received fxChainData.macroDefaults:`, JSON.parse(JSON.stringify(macroDefaults)));
        for (const uiMacroName in this.macroKnobs) {
            const knob = this.macroKnobs[uiMacroName];
            const defaultValue = macroDefaults.hasOwnProperty(uiMacroName) ? macroDefaults[uiMacroName] : 0.5;
            console.log(`[FxChains updateMacroKnobs] For UI Macro '${uiMacroName}', default value: ${defaultValue}`);
            sidePanel.setKnobValue(knob, defaultValue, false);
            if (typeof synth !== 'undefined' && typeof synth.setMacro === 'function') {
                console.log(`[FxChains updateMacroKnobs] Applying default for '${uiMacroName}' (${defaultValue}) to synth.`);
                synth.setMacro(uiMacroName, defaultValue);
            }
        }
    },

    async populateFxChainList() {
        // ... (без изменений)
        if (!this.chainSelectElement) return;
        this.chainSelectElement.innerHTML = '';
        this.addOptionToSelect(this.chainSelectElement, '', i18n.translate('none_fxchain', '-- None --'));
        try {
            const chains = await moduleManager.getModules('fxchain', true);
            if (!chains || chains.length === 0) return;
            chains.sort((a, b) => (a.name || a.id).localeCompare(b.name || b.id));
            chains.forEach(chain => {
                this.addOptionToSelect(this.chainSelectElement, chain.id, chain.name || chain.id);
            });
            this.updateActiveChain(app.state.fxChain);
        } catch (error) {
            this.addOptionToSelect(this.chainSelectElement, '', i18n.translate('error_loading_fxchains', 'Error loading chains'), true);
        }
    },

    addOptionToSelect(selectElement, value, text, disabled = false) {
        // ... (без изменений)
        if (!selectElement) return;
        const option = document.createElement('option');
        option.value = value;
        option.textContent = text;
        option.disabled = disabled;
        selectElement.appendChild(option);
    },

    updateActiveChain(chainId) {
        // ... (без изменений)
        this.currentChainId = chainId;
        if (this.chainSelectElement) {
            this.chainSelectElement.value = chainId ?? '';
            if (this.chainSelectElement.value !== (chainId ?? '')) {
                 this.chainSelectElement.value = '';
                 this.currentChainId = null;
            }
        }
    },

    // === ОБНОВЛЕНА ФУНКЦИЯ для новой структуры yAxisControls ===
    updateYAxisControlsUI(yAxisSettings) {
        if (!yAxisSettings || !yAxisSettings.volume || !yAxisSettings.effects) {
            console.warn("[FxChains v5] Cannot update Y-Axis UI, invalid settings provided:", yAxisSettings);
            return;
        }
        console.log('[FxChains.updateYAxisControlsUI] Updating UI with settings:', JSON.parse(JSON.stringify(yAxisSettings)));

        const vol = yAxisSettings.volume;
        const fx = yAxisSettings.effects;

        // Volume Group
        if (this.yAxisControlsElements.volume_minOutputKnob) sidePanel.setKnobValue(this.yAxisControlsElements.volume_minOutputKnob, vol.minOutput ?? 0.0, false);
        if (this.yAxisControlsElements.volume_maxOutputKnob) sidePanel.setKnobValue(this.yAxisControlsElements.volume_maxOutputKnob, vol.maxOutput ?? 1.0, false);
        if (this.yAxisControlsElements.volume_yThresholdKnob) sidePanel.setKnobValue(this.yAxisControlsElements.volume_yThresholdKnob, vol.yThreshold ?? 0.0, false);
        if (this.yAxisControlsElements.volume_curveTypeSelect) this.yAxisControlsElements.volume_curveTypeSelect.value = vol.curveType || 'linear';
        if (this.yAxisControlsElements.volume_curveFactorKnob) sidePanel.setKnobValue(this.yAxisControlsElements.volume_curveFactorKnob, vol.curveFactor ?? 1.0, false);

        // Effects Group
        if (this.yAxisControlsElements.effects_minOutputKnob) {
            console.log(`[FxChains.updateYAxisControlsUI] Setting effects_minOutputKnob to: ${fx.minOutput ?? -60}`);
            sidePanel.setKnobValue(this.yAxisControlsElements.effects_minOutputKnob, fx.minOutput ?? -60, false);
        }
        if (this.yAxisControlsElements.effects_maxOutputKnob) {
            console.log(`[FxChains.updateYAxisControlsUI] Setting effects_maxOutputKnob to: ${fx.maxOutput ?? 0}`);
            sidePanel.setKnobValue(this.yAxisControlsElements.effects_maxOutputKnob, fx.maxOutput ?? 0, false);
        }
        if (this.yAxisControlsElements.effects_yThresholdKnob) {
            console.log(`[FxChains.updateYAxisControlsUI] Setting effects_yThresholdKnob to: ${fx.yThreshold ?? 0.1}`);
            sidePanel.setKnobValue(this.yAxisControlsElements.effects_yThresholdKnob, fx.yThreshold ?? 0.1, false);
        }
        if (this.yAxisControlsElements.effects_curveTypeSelect) {
            console.log(`[FxChains.updateYAxisControlsUI] Setting effects_curveTypeSelect to: ${fx.curveType || 'exponential'}`);
            this.yAxisControlsElements.effects_curveTypeSelect.value = fx.curveType || 'exponential';
        }
        if (this.yAxisControlsElements.effects_curveFactorKnob) {
            console.log(`[FxChains.updateYAxisControlsUI] Setting effects_curveFactorKnob to: ${fx.curveFactor ?? 2.0}`);
            sidePanel.setKnobValue(this.yAxisControlsElements.effects_curveFactorKnob, fx.curveFactor ?? 2.0, false);
        }
        console.log('[FxChains.updateYAxisControlsUI] UI update complete.');
    },
    // =======================================================

    updateMasterOutputControlsUI(masterVolumeCeilingValue) {
        if (this.masterVolumeCeilingKnob) {
            const value = masterVolumeCeilingValue ?? 1.0;
            sidePanel.setKnobValue(this.masterVolumeCeilingKnob, value, false);
        }
    }
};
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\harmonicMarkerEngine.js
// File: assets/js/harmonicMarkerEngine.js
// Harmonic Marker Engine - Core for musical context analysis.
// Версия для Фазы 1

console.log("[HME v1.0] harmonicMarkerEngine.js loaded");

const harmonicMarkerEngine = {
    musicTheoryServiceRef: null,
    isInitialized: false,
    _debug: true, // Флаг для подробного логирования внутри движка

    /**
     * Initializes the Harmonic Marker Engine.
     * @param {object} musicTheoryServiceInstance - Instance of MusicTheoryService.
     */
    init(musicTheoryServiceInstance) {
        if (!musicTheoryServiceInstance || typeof musicTheoryServiceInstance.getNoteDetails !== 'function') {
            console.error("[HME.init] Invalid MusicTheoryService instance provided.");
            this.isInitialized = false;
            return;
        }
        this.musicTheoryServiceRef = musicTheoryServiceInstance;
        this.isInitialized = true;
        console.log(`[HME.init] Initialized. MusicTheoryService Ready: ${this.musicTheoryServiceRef.isTonalJsLoaded}`);
    },

    /**
     * Analyzes the current musical context based on active notes and rocket mode settings.
     * @param {Array<{midiNote: number, name?: string}>} activeNotes - Array of active notes.
     *        Each note object MUST have `midiNote`. `name` is optional but preferred.
     * @param {object} analysisContext - Context from RocketModeStrategy.
     *        - tonicMidi: MIDI number of the current scale's tonic.
     *        - scaleId: ID of the current scale (e.g., "major").
     *        - settings: app.state.rocketModeSettings (для доступа к настройкам, если понадобятся).
     *        - currentPhase: текущая фаза Rocket Mode.
     * @returns {object} - Object with analysis results:
     *      {
     *          isPlayingChord: boolean,
     *          detectedChordSymbol: string | null,
     *          detectedChordDetails: object | null, // Tonal.Chord.get() object
     *          currentHarmonicFunction: string | null, // e.g., "T (I)", "D (V)"
     *          activeNotePitchClasses: Array<string>, // e.g., ["C", "E", "G"]
     *          scaleNotesPitchClasses: Array<string> | null, // e.g., ["C", "D", "E", "F", "G", "A", "B"] for C Major
     *          scaleTonicPc: string | null, // e.g., "C"
     *          isDiatonic: boolean // True if all active notes belong to the current scale
     *      }
     */
    analyzeContext(activeNotes, analysisContext) {
        if (!this.isInitialized) {
            console.warn("[HME.analyzeContext] Not initialized. Call init() first.");
            return this._getDefaultAnalysisResult();
        }
        if (!activeNotes || !Array.isArray(activeNotes) || !analysisContext ||
            analysisContext.tonicMidi === undefined || !analysisContext.scaleId) {
            console.warn("[HME.analyzeContext] Invalid arguments. activeNotes:", activeNotes, "analysisContext:", analysisContext);
            return this._getDefaultAnalysisResult();
        }

        if (this._debug) {
            console.log(`[HME.analyzeContext] INPUT - Active Notes (count: ${activeNotes.length}):`, JSON.parse(JSON.stringify(activeNotes.map(n => n.midiNote))));
            console.log(`[HME.analyzeContext] INPUT - Context: Tonic MIDI=${analysisContext.tonicMidi}, Scale=${analysisContext.scaleId}`);
        }

        const result = this._getDefaultAnalysisResult();

        // 1. Получаем детали активных нот и их pitch classes
        const activeNoteDetails = activeNotes
            .map(note => {
                // Если имя не передано, получаем его из MIDI
                const name = note.name || this.musicTheoryServiceRef.midiToNoteName(note.midiNote);
                return this.musicTheoryServiceRef.getNoteDetails(name); // getNoteDetails может принять и MIDI
            })
            .filter(Boolean); // Убираем null, если getNoteDetails не смог определить ноту

        if (activeNoteDetails.length === 0 && activeNotes.length > 0) {
            console.warn("[HME.analyzeContext] No valid note details could be derived from activeNotes.");
            // Возвращаем дефолтный результат, если не удалось получить детали ни для одной ноты
            return result;
        }

        result.activeNotePitchClasses = activeNoteDetails.map(detail => detail.pc).sort();
        if (this._debug) console.log("[HME.analyzeContext] Active Pitch Classes:", result.activeNotePitchClasses);


        // 2. Определяем аккорд, если нот достаточно
        if (result.activeNotePitchClasses.length >= 2) { // Минимум 2 ноты для попытки определения аккорда
            if (this.musicTheoryServiceRef._TonalChord && typeof this.musicTheoryServiceRef._TonalChord.detect === 'function') {
                const possibleChords = this.musicTheoryServiceRef._TonalChord.detect(result.activeNotePitchClasses);
                if (this._debug) console.log("[HME.analyzeContext] Tonal.Chord.detect found:", possibleChords);

                if (possibleChords && possibleChords.length > 0) {
                    // Выбираем "лучший" аккорд (самый простой или первый из списка)
                    // TODO: Реализовать более умный _selectBestChord, если нужно
                    result.detectedChordSymbol = possibleChords.sort((a, b) => a.length - b.length)[0]; // Пока просто самый короткий символ

                    if (result.detectedChordSymbol) {
                        try {
                            result.detectedChordDetails = this.musicTheoryServiceRef._TonalChord.get(result.detectedChordSymbol);
                            result.isPlayingChord = !result.detectedChordDetails.empty;
                            if (this._debug) console.log(`[HME.analyzeContext] Detected Chord: ${result.detectedChordSymbol}, Is Playing Chord: ${result.isPlayingChord}, Details:`, result.detectedChordDetails);
                        } catch (e) {
                            console.warn(`[HME.analyzeContext] Error getting chord details for ${result.detectedChordSymbol}:`, e);
                            result.detectedChordSymbol = null;
                            result.detectedChordDetails = null;
                            result.isPlayingChord = false;
                        }
                    }
                }
            } else {
                console.warn("[HME.analyzeContext] Tonal.Chord or Tonal.Chord.detect is not available.");
            }
        } else if (result.activeNotePitchClasses.length === 1) {
            result.isPlayingChord = false; // Одна нота - не аккорд
            if (this._debug) console.log("[HME.analyzeContext] Single active note. Not a chord.");
        }


        // 3. Анализ в контексте тональности и лада
        const tonicNoteDetails = this.musicTheoryServiceRef.getNoteDetails(analysisContext.tonicMidi);
        if (tonicNoteDetails) {
            result.scaleTonicPc = tonicNoteDetails.pc;
            if (this.musicTheoryServiceRef._TonalScale && typeof this.musicTheoryServiceRef._TonalScale.get === 'function') {
                const scaleQuery = `${result.scaleTonicPc} ${analysisContext.scaleId}`;
                console.log(`[HME.analyzeContext] Querying Tonal.Scale.get with: "${scaleQuery}"`);
                const scaleData = this.musicTheoryServiceRef._TonalScale.get(scaleQuery);
                if (this._debug) console.log(`[HME.analyzeContext] Tonal.Scale.get response for "${scaleQuery}":`, JSON.parse(JSON.stringify(scaleData)));
                if (scaleData && !scaleData.empty && Array.isArray(scaleData.notes) && scaleData.notes.length > 0) {
                    result.scaleNotesPitchClasses = scaleData.notes.map(n => this.musicTheoryServiceRef._TonalNote.simplify(n));
                    if (this._debug) console.log(`[HME.analyzeContext] Successfully got Scale Notes PCs:`, result.scaleNotesPitchClasses);

                    // Проверка на диатоничность
                    if (result.activeNotePitchClasses.length > 0) {
                        result.isDiatonic = result.activeNotePitchClasses.every(pc => result.scaleNotesPitchClasses.includes(pc));
                        if (this._debug) console.log("[HME.analyzeContext] Active notes are diatonic:", result.isDiatonic);
                    } else {
                        result.isDiatonic = true; // Если нет активных нот, считаем диатоничным
                    }

                    // Определение гармонической функции
                    if (result.isPlayingChord && result.detectedChordDetails?.tonic) {
                        result.currentHarmonicFunction = this._getChordHarmonicFunction(result.detectedChordDetails, result.scaleTonicPc, result.scaleNotesPitchClasses);
                    } else if (result.activeNotePitchClasses.length === 1) {
                        result.currentHarmonicFunction = this._getNoteHarmonicFunction(result.activeNotePitchClasses[0], result.scaleTonicPc, result.scaleNotesPitchClasses);
                    }
                    if (this._debug) console.log("[HME.analyzeContext] Current Harmonic Function:", result.currentHarmonicFunction);

                } else {
                    console.warn(`[HME.analyzeContext] Tonal.Scale.get for "${scaleQuery}" returned empty or invalid data. ScaleData:`, scaleData);
                    // Попытка использовать scaleDefinitions из MTS как фоллбэк
                    const intervalsFromCache = this.musicTheoryServiceRef.scaleDefinitions[analysisContext.scaleId];
                    if (intervalsFromCache && this.musicTheoryServiceRef._TonalTransposeFn && this.musicTheoryServiceRef._TonalInterval && typeof this.musicTheoryServiceRef._TonalInterval.fromSemitones === 'function') {
                        console.log(`[HME.analyzeContext] Falling back to cached intervals for ${analysisContext.scaleId}:`, intervalsFromCache);
                        result.scaleNotesPitchClasses = intervalsFromCache.map(semitoneOffset => {
                            const intervalName = this.musicTheoryServiceRef._TonalInterval.fromSemitones(semitoneOffset);
                            return this.musicTheoryServiceRef._TonalNote.simplify(this.musicTheoryServiceRef._TonalTransposeFn(result.scaleTonicPc, intervalName));
                        });
                        if (this._debug) console.log(`[HME.analyzeContext] Scale Notes PCs from CACHED INTERVALS:`, result.scaleNotesPitchClasses);
                        // Проверка на диатоничность
                        if (result.activeNotePitchClasses.length > 0) {
                            result.isDiatonic = result.activeNotePitchClasses.every(pc => result.scaleNotesPitchClasses.includes(pc));
                            if (this._debug) console.log("[HME.analyzeContext] Active notes are diatonic:", result.isDiatonic);
                        } else {
                            result.isDiatonic = true; // Если нет активных нот, считаем диатоничным
                        }

                        // Определение гармонической функции
                        if (result.isPlayingChord && result.detectedChordDetails?.tonic) {
                            result.currentHarmonicFunction = this._getChordHarmonicFunction(result.detectedChordDetails, result.scaleTonicPc, result.scaleNotesPitchClasses);
                        } else if (result.activeNotePitchClasses.length === 1) {
                            result.currentHarmonicFunction = this._getNoteHarmonicFunction(result.activeNotePitchClasses[0], result.scaleTonicPc, result.scaleNotesPitchClasses);
                        }
                        if (this._debug) console.log("[HME.analyzeContext] Current Harmonic Function:", result.currentHarmonicFunction);

                    } else {
                        console.error(`[HME.analyzeContext] Fallback to cached intervals also failed for ${analysisContext.scaleId}.`);
                    }
                }
            } else {
                console.error("[HME.analyzeContext] Tonal.Scale or Tonal.Scale.get is not available.");
            }
        } else {
            console.warn(`[HME.analyzeContext] Could not get details for tonic MIDI: ${analysisContext.tonicMidi}`);
        }
        if (this._debug) console.log("[HME.analyzeContext] OUTPUT - Analysis Result:", JSON.parse(JSON.stringify(result)));
        return result;
    },

    /**
     * Возвращает объект с дефолтными значениями для результата анализа.
     */
    _getDefaultAnalysisResult() {
        return {
            isPlayingChord: false,
            detectedChordSymbol: null,
            detectedChordDetails: null,
            currentHarmonicFunction: null,
            activeNotePitchClasses: [],
            scaleNotesPitchClasses: null,
            scaleTonicPc: null,
            isDiatonic: false
        };
    },

    /**
     * Определяет гармоническую функцию аккорда в контексте лада.
     * (Копипаста из вашего плана Фазы 1, с небольшими адаптациями и проверками)
     */
    _getChordHarmonicFunction(chordDetails, scaleTonicPc, scaleNotesPc) {
        if (!this.isInitialized || !chordDetails || !chordDetails.tonic || !scaleTonicPc || !scaleNotesPc ||
            !this.musicTheoryServiceRef._TonalNote || !this.musicTheoryServiceRef._TonalInterval || !this.musicTheoryServiceRef._TonalRomanNumeral) {
            if (this._debug) console.warn("[HME._getChordHarmonicFunction] Missing dependencies or invalid args.");
            return null;
        }

        try {
            const chordRootPc = this.musicTheoryServiceRef._TonalNote.simplify(chordDetails.tonic);
            // Интервал от тоники лада до корня аккорда
            const intervalFromScaleTonic = this.musicTheoryServiceRef._TonalInterval.between(scaleTonicPc, chordRootPc);

            if (!intervalFromScaleTonic) {
                // Попытка найти первую диатоническую ноту в аккорде, если корень не в ладу
                const firstDiatonicNoteInChord = chordDetails.notes.find(notePc =>
                    scaleNotesPc.includes(this.musicTheoryServiceRef._TonalNote.simplify(notePc))
                );
                if (firstDiatonicNoteInChord) {
                    const degreeIndex = scaleNotesPc.indexOf(this.musicTheoryServiceRef._TonalNote.simplify(firstDiatonicNoteInChord));
                    return `Variant (contains ${this._degreeToRoman(degreeIndex + 1)})`;
                }
                return "Non-Diatonic";
            }

            // Пытаемся получить римскую цифру
            // Tonal.RomanNumeral.get() ожидает интервал ИЛИ имя ступени (1, 2, #2, b3...)
            // Мы будем использовать имя ступени, полученное из интервала
            const stepName = this.musicTheoryServiceRef._TonalInterval.num(intervalFromScaleTonic) + (this.musicTheoryServiceRef._TonalInterval.alt(intervalFromScaleTonic) || '');

            let chordTypeForRoman = ""; // Tonal.RomanNumeral.get не всегда хорошо работает с полным типом
            const type = chordDetails.type.toLowerCase();
                 if (type.includes("maj7")) chordTypeForRoman = "M7"; // M7 для major seventh
            else if (type.includes("m7")) chordTypeForRoman = "m7";   // m7 для minor seventh
            else if (type.includes("7")) chordTypeForRoman = "7";     // 7 для dominant seventh
            else if (type.includes("m")) chordTypeForRoman = "m";
            else if (type.includes("dim")) chordTypeForRoman = "dim"; // или °
            else if (type.includes("aug")) chordTypeForRoman = "aug"; // или +

            // Tonal.RomanNumeral.get (в Tonal.js > 4.x) может не иметь .get()
            // Вместо этого, Tonal.Degree.romanNumeral(degree, isMajor)
            // Или Tonal.Chord.romanNumeral(chordSymbol, keySignature, isMajor)
            // Пока оставим упрощенный вариант, который может потребовать доработки
            // в зависимости от точной версии Tonal.js и ее API.
            // Попробуем через Tonal.Chord.romanNumeral, если доступно
            let romanNumeralString = null;
            if(this.musicTheoryServiceRef._TonalChord && typeof this.musicTheoryServiceRef._TonalChord.romanNumeral === 'function') {
                try {
                    // Пытаемся определить, мажорный ли лад
                    const isMajorScale = analysisContext.scaleId.toLowerCase().includes("major") || analysisContext.scaleId.toLowerCase().includes("lydian") || analysisContext.scaleId.toLowerCase().includes("mixolydian");
                    romanNumeralString = this.musicTheoryServiceRef._TonalChord.romanNumeral(chordDetails.symbol, scaleTonicPc, isMajorScale).name;
                } catch(e) { /* ignore, try fallback */ }
            }

            if (!romanNumeralString) { // Fallback, если Tonal.Chord.romanNumeral не сработал или недоступен
                romanNumeralString = this._degreeToRoman(this.musicTheoryServiceRef._TonalInterval.num(intervalFromScaleTonic)) + chordTypeForRoman;
            }

            // Преобразование римской цифры в основную функцию (T, S, D)
            const degreeNum = this.musicTheoryServiceRef._TonalInterval.num(intervalFromScaleTonic);
            switch (degreeNum) {
                case 1: return `T (${romanNumeralString})`;
                case 4: return `S (${romanNumeralString})`;
                case 5: return `D (${romanNumeralString})`;
                case 2: return `Sp (${romanNumeralString})`; // Subdominant Parallel / Supertonic
                case 6: return `Tp (${romanNumeralString})`; // Tonic Parallel / Submediant
                case 3: return `Tx (${romanNumeralString})`; // Mediant (может быть T или D в зависимости от контекста)
                case 7: return `L (${romanNumeralString})`;  // Leading Tone (часть D)
                default: return romanNumeralString || "Unknown";
            }

        } catch (e) {
            console.error("[HME._getChordHarmonicFunction] Error:", e);
            // Фоллбэк на простую ступень, если что-то пошло не так
            const degreeIndex = scaleNotesPc.indexOf(this.musicTheoryServiceRef._TonalNote.simplify(chordDetails.tonic));
            if (degreeIndex !== -1) return this._degreeToFunction(degreeIndex + 1, chordDetails.type || "chord");
            return "Unknown Chord Function";
        }
    },

    /**
     * Определяет гармоническую функцию одиночной ноты в контексте лада.
     */
    _getNoteHarmonicFunction(notePc, scaleTonicPc, scaleNotesPc) {
        if (!this.isInitialized || !notePc || !scaleTonicPc || !scaleNotesPc ||
            !this.musicTheoryServiceRef._TonalNote) {
            if (this._debug) console.warn("[HME._getNoteHarmonicFunction] Missing dependencies or invalid args.");
            return null;
        }
        const simplifiedNotePc = this.musicTheoryServiceRef._TonalNote.simplify(notePc);
        const degreeIndex = scaleNotesPc.indexOf(simplifiedNotePc);
        if (degreeIndex !== -1) {
            return this._degreeToFunction(degreeIndex + 1, "note");
        }
        return "Chromatic Note";
    },

    /**
     * Преобразует номер ступени (1-7) в римскую цифру.
     */
    _degreeToRoman(degree) {
        const numerals = ["I", "II", "III", "IV", "V", "VI", "VII"];
        return numerals[degree - 1] || degree.toString();
    },

    /**
     * Преобразует номер ступени и тип аккорда/ноты в метку гармонической функции.
     */
    _degreeToFunction(degree, chordTypeOrNote = "note") {
        const roman = this._degreeToRoman(degree);
        let quality = "";
        // Определение качества аккорда (мажор, минор, и т.д.)
        if (chordTypeOrNote !== "note" && typeof chordTypeOrNote === 'string') {
            const type = chordTypeOrNote.toLowerCase();
                 if (type.includes("major") || type.match(/^M/) || type === "") quality = "";  // Пусто для мажора
            else if (type.includes("minor") || type.match(/^m[^a]/)) quality = "m";
            else if (type.includes("dim")) quality = "°";
            else if (type.includes("aug")) quality = "+";
            // Добавление септаккордов
                 if (type.includes("maj7")) quality = "maj7"; // Major 7th
            else if (type.includes("m7") && !type.includes("maj7")) quality = "m7"; // Minor 7th
            else if (type.includes("7") && !type.includes("maj7") && !type.includes("m7")) quality = "7"; // Dominant 7th
            // Другие типы септаккордов можно добавить по аналогии (m7b5, dim7, etc.)
        }

        // Определение основной функции по ступени
        switch (degree) {
            case 1: return `T (${roman}${quality})`;  // Тоника
            case 4: return `S (${roman}${quality})`;  // Субдоминанта
            case 5: return `D (${roman}${quality})`;  // Доминанта
            case 2: return `Sp (${roman}${quality})`; // Субдоминантовая параллель / Супертоника
            case 6: return `Tp (${roman}${quality})`; // Тоническая параллель / Субмедианта
            case 3: return `Tx (${roman}${quality})`; // Медианта (может быть T или D функцией)
            case 7: return `L (${roman}${quality})`;  // Вводный тон (часть D)
            default: return `Degree ${degree}`; // Если ступень вне 1-7
        }
    }
};

// Для доступа из других модулей, если app.js еще не инициализировал все ссылки
// window.harmonicMarkerEngine = harmonicMarkerEngine;
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\i18n.js
// Файл: app/src/main/assets/js/i18n.js
// Handles internationalization (i18n)
const i18n = {
    currentLanguage: 'en', // Default language
    strings: {}, // Stores translations for the current language { key: value, ... }
    elements: [], // Stores elements with data-i18n attributes found by collectElements
    isInitialized: false,

    /**
     * Initializes the i18n system. Should be called early.
     * @param {string} initialLanguage - The starting language ID.
     */
    init(initialLanguage = 'en') {
        console.log(`[i18n.init] Initializing with language: ${initialLanguage}`);
        this.currentLanguage = initialLanguage;
        // Собираем элементы сразу, чтобы они были готовы к первому обновлению
        this.collectElements();
        this.isInitialized = true;
        // Не загружаем язык здесь, app.js вызовет applyLanguage -> loadLanguage
    },

    /**
     * Finds and stores all elements needing translation. Can be called again if DOM changes.
     */
    collectElements() {
        console.log("[i18n.collectElements] Collecting elements for translation...");
        try {
            this.elements = document.querySelectorAll('[data-i18n], [data-i18n-placeholder], [data-i18n-title]');
            console.log(`[i18n.collectElements] Found ${this.elements.length} elements.`);
        } catch (error) {
             console.error("[i18n.collectElements] Error querying elements:", error);
             this.elements = [];
        }
    },

    /**
     * Loads language data for the given language ID from the module manager.
     * @param {string} languageId - e.g., 'en', 'ru'.
     */
    async loadLanguage(languageId) {
        if (!languageId) {
            console.warn('[i18n.loadLanguage] Called with null/empty languageId. Using current:', this.currentLanguage);
            languageId = this.currentLanguage; // Use current if none provided
        }
        console.log(`[i18n.loadLanguage] Attempting to load language: ${languageId}`);
        this.currentLanguage = languageId;
        this.strings = {}; // Clear previous strings before loading

        try {
            const langModule = await moduleManager.getModule(languageId);

            // Данные строк находятся в langModule.data.data.strings
            if (langModule?.data?.data?.strings) {
                this.strings = langModule.data.data.strings;
                console.log(`[i18n.loadLanguage] Language '${languageId}' loaded successfully with ${Object.keys(this.strings).length} strings.`);
                this.updateUI(); // Update UI after loading new strings
            } else {
                console.warn(`[i18n.loadLanguage] Language module or strings not found for ID: ${languageId}. UI will show keys.`);
                // this.strings остается пустым
                this.updateUI(); // Update UI to show keys as fallback
            }
        } catch (error) {
            console.error(`[i18n.loadLanguage] Error loading language ${languageId}:`, error, error.stack);
            this.strings = {}; // Clear strings on error
            this.updateUI(); // Update UI to show keys as fallback
        }
    },

    /**
     * Translates a given key using the loaded strings.
     * @param {string} key - The key to translate.
     * @param {string} [fallback] - Optional fallback text if key not found. If null, uses the key itself.
     * @returns {string} - The translated string or the key/fallback.
     */
    translate(key, fallback = null) {
        if (!key) return fallback || ''; // Handle null/empty key
        const translation = this.strings[key];
        if (translation !== undefined && translation !== null) {
            return translation;
        } else {
            // console.warn(`[i18n.translate] Translation key not found: '${key}'. Using fallback/key.`);
            return fallback !== null ? fallback : key; // Use provided fallback or the key itself
        }
    },

    /**
     * Updates all registered UI elements with current translations.
     */
    updateUI() {
        if (!this.isInitialized) {
             console.warn("[i18n.updateUI] i18n not initialized yet.");
             return;
        }
        console.log('[i18n.updateUI] Updating UI elements with current translations...');
        if (this.elements.length === 0) {
             console.warn("[i18n.updateUI] No elements collected for translation. Did collectElements run?");
             this.collectElements(); // Попробуем собрать снова
        }
        let updatedCount = 0;
        this.elements.forEach(el => {
            try {
                const key = el.dataset.i18n;
                const placeholderKey = el.dataset.i18nPlaceholder;
                const titleKey = el.dataset.i18nTitle;
                let updated = false;

                if (key) {
                    const translation = this.translate(key);
                    // Обновляем только если текст отличается или это не input/select/textarea
                    if (el.textContent !== translation && !['INPUT', 'SELECT', 'TEXTAREA'].includes(el.tagName)) {
                        el.textContent = translation;
                        updated = true;
                    }
                }
                if (placeholderKey && el.placeholder !== undefined) {
                    const translation = this.translate(placeholderKey);
                    if (el.placeholder !== translation) {
                        el.placeholder = translation;
                        updated = true;
                    }
                }
                 if (titleKey && el.title !== undefined) {
                    const translation = this.translate(titleKey);
                     if (el.title !== translation) {
                        el.title = translation;
                        updated = true;
                    }
                }
                if (updated) updatedCount++;
            } catch (error) {
                 console.error("[i18n.updateUI] Error updating element:", el, error);
            }
        });
        console.log(`[i18n.updateUI] UI update complete. Updated ${updatedCount} elements.`);
    }
};
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\lib\tonal.min.js

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\lib\tone.min.js

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\loading\audio.js
// Файл: app/src/main/assets/js/loading/audio.js
// Управляет звуками и музыкой на экране загрузки (с обработкой ошибок загрузки и логами)

const loadingAudio = {
    sfxPlayers: null,
    musicPlayer: null,
    isLoadedPromise: null,
    isInitialized: false,
    contextStarted: false,
    loadAttempted: false,

    init(audioUrls) {
        if (this.loadAttempted) {
            console.warn("LoadingAudio: Init already attempted.");
            return this.isLoadedPromise || Promise.resolve(false);
        }
        console.log("LoadingAudio: Initializing and attempting to load audio...");
        this.loadAttempted = true;

        if (typeof Tone === 'undefined' || !Tone.Players || !Tone.Player) {
            console.error("LoadingAudio: Tone.js or required components not available!");
            this.isInitialized = false;
            this.isLoadedPromise = Promise.resolve(false);
            return this.isLoadedPromise;
        }

        const sfxUrls = {
            stars_warp: audioUrls.stars_warp,
            logo_reveal: audioUrls.logo_reveal,
            transition_burst: audioUrls.transition_burst
        };
        const musicUrl = audioUrls.idle_loop;

        this.isLoadedPromise = new Promise(async (resolve) => {
            let sfxSuccess = false;
            let musicSuccess = false;

            try {
                this.sfxPlayers = new Tone.Players(sfxUrls).toDestination();
                await Promise.race([
                    Tone.loaded(),
                    new Promise(res => setTimeout(res, 5000))
                ]);
                sfxSuccess = Object.keys(sfxUrls).every(key => this.sfxPlayers.has(key) && this.sfxPlayers.player(key)?.loaded);
                if (sfxSuccess) {
                    console.log("LoadingAudio: SFX loaded successfully.");
                } else {
                    console.warn("LoadingAudio: Failed to load some or all SFX.");
                    Object.keys(sfxUrls).forEach(key => {
                        if (!this.sfxPlayers.has(key) || !this.sfxPlayers.player(key)?.loaded) {
                            console.warn(` - SFX '${key}' failed to load or player missing.`);
                        }
                    });
                }

                if (musicUrl) {
                    this.musicPlayer = new Tone.Player(musicUrl).toDestination();
                    this.musicPlayer.loop = true;
                    this.musicPlayer.fadeIn = 0.5;
                    this.musicPlayer.fadeOut = 0.5;
                    await Promise.race([
                        new Promise(res => { if(this.musicPlayer) this.musicPlayer.buffer.onload = res; else res(); }), // Проверка на null
                        new Promise(res => setTimeout(res, 5000))
                    ]);
                    musicSuccess = this.musicPlayer?.loaded ?? false; // Проверка на null
                    if (musicSuccess) {
                        console.log("LoadingAudio: Background music loaded successfully.");
                    } else {
                        console.warn("LoadingAudio: Failed to load background music.");
                    }
                } else {
                    console.log("LoadingAudio: No background music URL provided.");
                    musicSuccess = true;
                }

            } catch (error) {
                console.error("LoadingAudio: Error during player creation or loading:", error);
                sfxSuccess = false;
                musicSuccess = false;
            }

            this.isInitialized = !!(this.sfxPlayers || this.musicPlayer);
            console.log(`LoadingAudio: Initialization attempt finished. Initialized: ${this.isInitialized}, SFX Loaded: ${sfxSuccess}, Music Loaded: ${musicSuccess}`);
            resolve(this.isInitialized && (sfxSuccess || musicSuccess)); // Разрешаем true только если хоть что-то загрузилось
        });

        return this.isLoadedPromise;
    },

    playSFX(name) {
        this.ensureContextStarted();

        if (!this.isInitialized || !this.sfxPlayers) {
            console.warn(`LoadingAudio: Cannot play SFX '${name}', not initialized or sfxPlayers missing.`);
            return;
        }
        const player = this.sfxPlayers.has(name) ? this.sfxPlayers.player(name) : null;

        if (player && player.loaded) {
            try {
                console.log(`LoadingAudio: Playing SFX '${name}' (State: ${player.state})`);
                player.start(Tone.now());
            } catch (error) {
                console.error(`LoadingAudio: Error starting SFX '${name}':`, error);
            }
        } else if (player && !player.loaded) {
             console.warn(`LoadingAudio: SFX player for '${name}' exists but is not loaded.`);
        } else {
            console.warn(`LoadingAudio: SFX player for '${name}' not found.`);
        }
    },

    startMusicLoop() {
        this.ensureContextStarted();
        if (!this.isInitialized || !this.musicPlayer) {
            console.warn("LoadingAudio: Cannot start music loop, not initialized or musicPlayer missing.");
            return;
        }
        if (this.musicPlayer.loaded && this.musicPlayer.state !== 'started') {
            try {
                // --- ЛОГ ---
                console.log("LoadingAudio: Starting background music loop.");
                this.musicPlayer.start(Tone.now(), 0);
            } catch (error) {
                console.error("LoadingAudio: Error starting music loop:", error);
            }
        } else if (!this.musicPlayer.loaded) {
             console.warn("LoadingAudio: Music player not loaded yet, cannot start loop.");
        } else {
             console.log("LoadingAudio: Music loop already started or player not ready.");
        }
    },

    stopMusicLoop(fadeOutTime = 0.5) {
        if (!this.isInitialized || !this.musicPlayer || this.musicPlayer.state !== 'started') {
            // --- ЛОГ ---
            // console.log(`LoadingAudio: Music loop already stopped or not ready (State: ${this.musicPlayer?.state})`);
            return;
        }
        try {
            // --- ЛОГ ---
            console.log(`LoadingAudio: Stopping background music loop with fade out: ${fadeOutTime}s (Current state: ${this.musicPlayer.state})`);
            this.musicPlayer.volume.rampTo(-Infinity, fadeOutTime);
            this.musicPlayer.stop(Tone.now() + fadeOutTime);
            setTimeout(() => {
                if (this.musicPlayer) {
                    this.musicPlayer.volume.value = 0;
                    // --- ЛОГ ---
                    console.log(`LoadingAudio: Music player stopped (State after stop: ${this.musicPlayer.state})`);
                }
            }, (fadeOutTime + 0.1) * 1000);
        } catch (error) {
            console.error("LoadingAudio: Error stopping music loop:", error);
        }
    },

    async ensureContextStarted() {
        if (this.contextStarted || typeof Tone === 'undefined' || !Tone.context || Tone.context.state === 'running') {
            if (Tone.context && Tone.context.state === 'running') this.contextStarted = true;
            return;
        }
        if (Tone.context.state !== 'suspended') {
             return;
        }
        try {
            console.log("LoadingAudio: Attempting to start Tone.js context...");
            await Tone.start();
            if (Tone.context.state === 'running') {
                console.log("LoadingAudio: Tone.js context started successfully.");
                this.contextStarted = true;
            } else {
                 console.warn("LoadingAudio: Tone.start() completed but context state is:", Tone.context.state);
            }
        } catch (error) {
            // console.error("LoadingAudio: Failed to start Tone.js context:", error);
        }
    },

    dispose() {
        console.log("LoadingAudio: Disposing audio resources...");
        if (this.sfxPlayers) {
            try {
                this.sfxPlayers.dispose();
            } catch (e) { console.error("LoadingAudio: Error disposing sfxPlayers:", e); }
            this.sfxPlayers = null;
        }
        if (this.musicPlayer) {
            try {
                // --- ЛОГ ---
                console.log(`LoadingAudio: Disposing music player (State: ${this.musicPlayer.state})`);
                if (this.musicPlayer.state === 'started') {
                    this.musicPlayer.stop(Tone.now()); // Мгновенная остановка перед dispose
                }
                this.musicPlayer.dispose();
            } catch (e) { console.error("LoadingAudio: Error disposing musicPlayer:", e); }
            this.musicPlayer = null;
        }
        this.isInitialized = false;
        this.isLoadedPromise = null;
        this.contextStarted = false;
        this.loadAttempted = false;
        console.log("LoadingAudio: Disposed.");
    }
};
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\loading\prism-effect.js
// Файл: app/src/main/assets/js/loading/prism-effect.js
// Анимация эффекта радужной ударной волны при финальном переходе

const prismEffect = {
    canvas: null,
    ctx: null,
    animationFrameId: null,
    startTime: 0,
    settings: {
        duration: 700,          // Длительность анимации в мс
        ringCount: 5,           // Количество колец в волне
        maxRadiusMultiplier: 0.8, // Макс. радиус кольца (относительно меньшей стороны canvas)
        initialLineWidth: 6,    // Начальная толщина линии кольца
        lineWidthFadeFactor: 0.8,// Насколько быстро утончается линия (0-1, 1=не утончается)
        expansionCurve: (t) => t * (2 - t), // Кривая расширения (ease-out quad)
        opacityCurve: (t) => 1 - t,      // Кривая затухания прозрачности (линейная)
        hueShiftSpeed: 200,     // Скорость смены оттенка радуги (градусы в секунду)
        glowIntensity: 10,      // Интенсивность свечения (blur)
        glowColorSaturation: 90,// Насыщенность цвета свечения (%)
        glowColorLightness: 65, // Светлота цвета свечения (%)
    },
    rings: [], // Массив активных колец { radius, alpha, lineWidth, hue }
    origin: { x: 0.5, y: 0.5 }, // Центр вспышки по умолчанию
    onCompleteCallback: null,
    isActive: false,
    baseHue: 0, // Базовый оттенок для сдвига

    init(canvasId, userSettings = {}) {
        this.canvas = document.getElementById(canvasId);
        if (!this.canvas) {
            console.error(`PrismEffect: Canvas with ID '${canvasId}' not found.`);
            return false;
        }
        try {
            this.ctx = this.canvas.getContext('2d');
            if (!this.ctx) throw new Error("Failed to get 2D context.");
        } catch (error) {
            console.error("PrismEffect: Failed to get canvas context:", error);
            return false;
        }
        this.settings = { ...this.settings, ...userSettings };
        this.resizeCanvas();
        window.addEventListener('resize', this.resizeCanvas.bind(this));
        console.log("PrismEffect (v2): Initialized.");
        return true;
    },

    resizeCanvas() {
        if (!this.canvas || !this.canvas.parentElement) return;
        requestAnimationFrame(() => {
            const width = this.canvas.parentElement.clientWidth;
            const height = this.canvas.parentElement.clientHeight;
             if (width > 0 && height > 0) {
                if (this.canvas.width !== width || this.canvas.height !== height) {
                    this.canvas.width = width;
                    this.canvas.height = height;
                    console.log(`PrismEffect: Canvas resized to ${width}x${height}`);
                }
            }
        });
    },

    /**
     * Запускает анимацию волны.
     * @param {function} callback - Функция, вызываемая по завершении анимации.
     * @param {{x: number, y: number} | null} [originCoords=null] - Координаты точки касания (0-1).
     */
    play(callback, originCoords = null) {
        if (this.isActive) {
            console.warn("PrismEffect: Animation already playing.");
            return;
        }
        if (!this.ctx || !this.canvas) {
            console.error("PrismEffect: Cannot play, not initialized correctly.");
            if (callback) callback();
            return;
        }
        console.log("PrismEffect: Playing shockwave animation...");
        this.isActive = true;
        this.onCompleteCallback = callback;
        this.startTime = performance.now();
        this.baseHue = Math.random() * 360; // Случайный начальный оттенок

        // Определяем центр волны
        this.origin = originCoords || { x: 0.5, y: 0.5 };

        // Создаем кольца
        this.rings = [];
        for (let i = 0; i < this.settings.ringCount; i++) {
            // Добавляем небольшую задержку для каждого следующего кольца
            const delayFactor = i / this.settings.ringCount * 0.3; // Задержка до 30% от общей длительности
            this.rings.push({
                startTimeOffset: this.settings.duration * delayFactor,
                radius: 0,
                alpha: 0,
                lineWidth: this.settings.initialLineWidth,
                hue: (this.baseHue + (i * (360 / this.settings.ringCount))) % 360 // Распределяем цвета
            });
        }

        // Делаем canvas видимым
        this.canvas.style.opacity = '1';
        this.canvas.style.visibility = 'visible';

        // Запускаем цикл анимации
        if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        this.animate();
    },

    /**
     * Основной цикл анимации волны.
     * @param {number} timestamp - Время с начала анимации.
     */
    animate(timestamp = performance.now()) {
        if (!this.isActive) return;

        const elapsedTotal = timestamp - this.startTime;

        if (!this.ctx || !this.canvas) {
            console.error("PrismEffect: Context or canvas became unavailable during animation.");
            this.stop();
            if (this.onCompleteCallback) this.onCompleteCallback();
            return;
        }

        // Очистка холста с небольшим затуханием
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; // Очень легкое затухание для яркости
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Устанавливаем режим смешивания для яркости
        this.ctx.globalCompositeOperation = 'lighter';

        const canvasMinDim = Math.min(this.canvas.width, this.canvas.height);
        const maxRadiusPx = canvasMinDim * this.settings.maxRadiusMultiplier;
        const originX = this.origin.x * this.canvas.width;
        const originY = this.origin.y * this.canvas.height;
        let activeRings = 0;

        // Обновляем и рисуем кольца
        this.rings.forEach(ring => {
            const elapsedRing = elapsedTotal - ring.startTimeOffset;
            if (elapsedRing <= 0) return; // Кольцо еще не должно появиться

            const progress = Math.min(1.0, elapsedRing / (this.settings.duration * (1 - ring.startTimeOffset / this.settings.duration))); // Прогресс для этого кольца
            if (progress >= 1) return; // Кольцо уже исчезло

            activeRings++;

            // Обновляем параметры кольца
            ring.radius = this.settings.expansionCurve(progress) * maxRadiusPx;
            ring.alpha = this.settings.opacityCurve(progress);
            ring.lineWidth = this.settings.initialLineWidth * Math.pow(this.settings.lineWidthFadeFactor, progress * 5); // Утончается быстрее к концу
            ring.hue = (ring.hue + this.settings.hueShiftSpeed * (elapsedRing / 1000)) % 360; // Сдвигаем цвет

            if (ring.alpha <= 0 || ring.lineWidth < 0.1 || ring.radius < 0) return; // Не рисуем невидимые

            // Рисуем кольцо
            const color = `hsla(${ring.hue}, ${this.settings.glowColorSaturation}%, ${this.settings.glowColorLightness}%, ${ring.alpha.toFixed(2)})`;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = Math.max(0.1, ring.lineWidth);

            // Применяем свечение через фильтр blur
            try {
                const blurAmount = this.settings.glowIntensity * ring.alpha * (1 - progress); // Свечение угасает
                if (blurAmount > 0.5) {
                    this.ctx.filter = `blur(${blurAmount.toFixed(1)}px)`;
                } else {
                    this.ctx.filter = 'none';
                }
            } catch(e) { this.ctx.filter = 'none'; } // Игнорируем ошибку, если blur не поддерживается

            this.ctx.beginPath();
            this.ctx.arc(originX, originY, ring.radius, 0, Math.PI * 2);
            this.ctx.stroke();

            // Сбрасываем фильтр для следующего кольца
            this.ctx.filter = 'none';
        });

        // Сбрасываем режим смешивания
        this.ctx.globalCompositeOperation = 'source-over';

        // Проверяем завершение анимации (когда все кольца исчезли)
        if (activeRings === 0 && elapsedTotal > this.settings.duration * 0.5) { // Добавляем проверку на прошедшее время
            this.stop();
            if (this.onCompleteCallback) {
                this.onCompleteCallback();
            }
        } else {
            // Запрашиваем следующий кадр
            this.animationFrameId = requestAnimationFrame(this.animate.bind(this));
        }
    },

    stop() {
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
        this.isActive = false;
        if (this.canvas) {
            this.canvas.style.opacity = '0';
            this.canvas.style.visibility = 'hidden';
        }
        this.rings = [];
        console.log("PrismEffect: Stopped.");
    },

    cleanup() {
        this.stop();
        if (this.ctx && this.canvas) {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
        console.log("PrismEffect: Cleaned up.");
        window.removeEventListener('resize', this.resizeCanvas.bind(this));
    }
};
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\loading\stars-animation.js
// Файл: app/src/main/assets/js/loading/stars-animation.js
// Анимация звездного поля: плавное появление по экрану + полет "на нас"

const starsAnimation = {
    canvas: null,
    ctx: null,
    starsArray: [],
    animationFrameId: null,
    phase: 'idle', // 'idle', 'running'
    settings: {
        starCount: 350,
        spawnRate: 4,           // Немного уменьшим частоту появления
        starMinRadius: 0.3,
        starMaxRadius: 1.3,     // Сделаем максимальный радиус чуть меньше
        starBaseColor: [200, 220, 255],
        starMinAlpha: 0.2,
        starMaxAlpha: 0.8,
        fadeInSpeed: 2.0,       // Скорость появления можно чуть замедлить

        // === УМЕНЬШЕНИЕ СКОРОСТИ ===
        initialSpeedFactor: 0.005, // Значительно уменьшаем начальную скорость
        acceleration: 1.01,     // Уменьшаем ускорение (ближе к 1 = медленнее)
        maxSpeed: 8,            // Уменьшаем максимальную скорость
        // === КОНЕЦ УМЕНЬШЕНИЯ СКОРОСТИ ===

        radiusFactor: 0.08,
        trailLengthFactor: 0.05,// Можно уменьшить хвост, если скорость низкая
        resetMargin: 50,
    },
    lastTimestamp: 0,

    init(canvasId, userSettings = {}) {
        this.canvas = document.getElementById(canvasId);
        if (!this.canvas) {
            console.error(`StarsAnimation: Canvas with ID '${canvasId}' not found.`);
            return false;
        }
        try {
            this.ctx = this.canvas.getContext('2d');
            if (!this.ctx) throw new Error("Failed to get 2D context.");
        } catch (error) {
            console.error("StarsAnimation: Failed to get canvas context:", error);
            return false;
        }
        this.settings = { ...this.settings, ...userSettings };
        this.resizeCanvas();
        window.addEventListener('resize', this.resizeCanvas.bind(this));
        console.log("StarsAnimation (v5): Initialized.");
        return true;
    },

    resizeCanvas() {
        if (!this.canvas || !this.canvas.parentElement) return;
        requestAnimationFrame(() => {
            const width = this.canvas.parentElement.clientWidth;
            const height = this.canvas.parentElement.clientHeight;
             if (width > 0 && height > 0) {
                if (this.canvas.width !== width || this.canvas.height !== height) {
                    this.canvas.width = width;
                    this.canvas.height = height;
                    console.log(`StarsAnimation: Canvas resized to ${width}x${height}`);
                    this.starsArray = [];
                }
            }
        });
    },

    start() {
        if (this.phase !== 'idle') {
            console.warn("StarsAnimation: Cannot start, already running.");
            return;
        }
        console.log("StarsAnimation: Starting animation loop.");
        this.phase = 'running';
        this.starsArray = [];
        this.lastTimestamp = performance.now();
        if (!this.animationFrameId) {
            this.animate();
        }
    },

    createStar(centerX, centerY) {
        if (!this.canvas || this.canvas.width === 0) return null;

        const x = Math.random() * this.canvas.width;
        const y = Math.random() * this.canvas.height;

        const dx = x - centerX;
        const dy = y - centerY;
        const angle = Math.atan2(dy, dx);
        // Используем initialSpeedFactor от maxSpeed
        const initialSpeed = this.settings.maxSpeed * this.settings.initialSpeedFactor * (0.5 + Math.random() * 0.5);
        const radius = Math.random() * (this.settings.starMaxRadius - this.settings.starMinRadius) + this.settings.starMinRadius;

        return {
            x: x,
            y: y,
            radius: radius,
            initialRadius: radius,
            alpha: 0,
            targetAlpha: Math.random() * (this.settings.starMaxAlpha - this.settings.starMinAlpha) + this.settings.starMinAlpha,
            angle: angle,
            speed: initialSpeed,
        };
    },

    animate(timestamp = performance.now()) {
        this.animationFrameId = requestAnimationFrame(this.animate.bind(this));

        if (this.phase !== 'running' || !this.ctx || !this.canvas || this.canvas.width === 0 || this.canvas.height === 0) {
            return;
        }

        const deltaTime = (timestamp - this.lastTimestamp) / 1000;
        this.lastTimestamp = timestamp;
        const deltaFrames = deltaTime * 60;

        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        this.ctx.fillStyle = 'rgba(0, 0, 10, 0.15)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        const starsToSpawn = Math.max(1, Math.round(this.settings.spawnRate * deltaFrames));
        for (let i = 0; i < starsToSpawn && this.starsArray.length < this.settings.starCount; i++) {
            this.starsArray.push(this.createStar(centerX, centerY));
        }

        for (let i = this.starsArray.length - 1; i >= 0; i--) {
            const star = this.starsArray[i];

            if (star.alpha < star.targetAlpha) {
                star.alpha += this.settings.fadeInSpeed * deltaTime;
                star.alpha = Math.min(star.alpha, star.targetAlpha);
            }

            star.speed = Math.min(this.settings.maxSpeed, star.speed * Math.pow(this.settings.acceleration, deltaFrames));
            star.radius = star.initialRadius + star.speed * this.settings.radiusFactor;
            star.radius = Math.min(star.radius, this.settings.starMaxRadius * 1.5);

            star.x += Math.cos(star.angle) * star.speed * deltaFrames;
            star.y += Math.sin(star.angle) * star.speed * deltaFrames;

            const margin = this.settings.resetMargin;
            if (star.x < -margin || star.x > this.canvas.width + margin ||
                star.y < -margin || star.y > this.canvas.height + margin)
            {
                this.starsArray.splice(i, 1);
            } else {
                this.drawStar(star);
            }
        }
    },

    drawStar(star) {
        if (star.alpha <= 0) return;

        const color = `rgba(${this.settings.starBaseColor.join(',')}, ${star.alpha.toFixed(2)})`;
        const currentRadius = Math.max(0.1, star.radius);

        const trailLength = star.speed * this.settings.trailLengthFactor;
        if (trailLength > 1) {
            const prevX = star.x - Math.cos(star.angle) * trailLength;
            const prevY = star.y - Math.sin(star.angle) * trailLength;
            this.ctx.beginPath();
            this.ctx.moveTo(prevX, prevY);
            this.ctx.lineTo(star.x, star.y);
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = currentRadius * 1.5;
            this.ctx.stroke();
        }

        this.ctx.fillStyle = color;
        this.ctx.beginPath();
        this.ctx.arc(star.x, star.y, currentRadius, 0, Math.PI * 2);
        this.ctx.fill();
    },

    stop() {
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
        this.phase = 'idle';
        console.log("StarsAnimation: Stopped.");
    },

    cleanup() {
        this.stop();
        this.starsArray = [];
        if (this.ctx && this.canvas) {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
        console.log("StarsAnimation: Cleaned up.");
        window.removeEventListener('resize', this.resizeCanvas.bind(this));
    }
};
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\managers\PadModeManager.js
// Assuming PadModeManager is an object
const PadModeManager = {
    appRef: null,
    musicTheoryServiceRef: null,
    strategies: {},
    currentModeId: null,
    currentStrategy: null,

    init(appInstance, musicTheoryServiceInstance) {
        this.appRef = appInstance;
        this.musicTheoryServiceRef = musicTheoryServiceInstance;
        console.log("[PadModeManager.init] Initialized with appRef and musicTheoryServiceRef.");
        // Strategies are expected to register themselves using registerStrategy
    },

    registerStrategy(strategy) {
        if (strategy && strategy.getId && strategy.getName && strategy.getZoneLayoutOptions && strategy.generateZoneData) {
            const id = strategy.getId();
            this.strategies[id] = strategy;
            console.log(`[PadModeManager] Registered strategy: ${strategy.getName()} (ID: ${id})`);
        } else {
            console.error("[PadModeManager] Attempted to register invalid strategy:", strategy);
        }
    },

    async setActiveMode(modeId) {
        console.log("[PadModeManager.setActiveMode] Attempting to set active mode to:", modeId); // Log at entry
        if (!this.strategies[modeId]) {
            console.error(`[PadModeManager.setActiveMode] Strategy for mode '${modeId}' not found.`);
            // Optionally fallback to a default mode or clear pad
            return false; // Indicate failure
        }

        this.currentModeId = modeId;
        this.currentStrategy = this.strategies[modeId];
        console.log("[PadModeManager.setActiveMode] Strategy set to:", this.currentStrategy ? this.currentStrategy.getName() : "null"); // Log strategy set

        // Notify the app that the mode has changed and zones need updating
        // Assuming appRef is set and has an updateZones method
        if (this.appRef && typeof this.appRef.updateZones === 'function') {
            console.log("[PadModeManager.setActiveMode] About to call appRef.updateZones()"); // Log before calling updateZones
            await this.appRef.updateZones();
            return true; // Indicate success
        } else {
            console.error("[PadModeManager.setActiveMode] appRef is not set or appRef.updateZones is not a function.");
            return false; // Indicate failure
        }
    },

    getCurrentModeId() {
        return this.currentModeId;
    },

    getCurrentStrategy() {
        return this.currentStrategy;
    },

    // Handle tonic changes - delegate to current strategy if it supports it
    async onTonicChanged(newTonic) {
        console.log("[PadModeManager.onTonicChanged] Tonic changed to:", newTonic);
        if (this.currentStrategy && typeof this.currentStrategy.onTonicChanged === 'function') {
            console.log("[PadModeManager.onTonicChanged] Delegating to current strategy.");
            await this.currentStrategy.onTonicChanged(newTonic, this.appRef.state, this.appRef.services);
        }
        // Always trigger updateZones as tonic change affects all modes
        if (this.appRef && typeof this.appRef.updateZones === 'function') {
            console.log("[PadModeManager.onTonicChanged] Calling appRef.updateZones() after tonic change.");
            await this.appRef.updateZones();
        }
    },

     // Handle chord changes - delegate to current strategy if it supports it
    async onChordChanged(newChord) {
        console.log("[PadModeManager.onChordChanged] Chord changed to:", newChord);
        if (this.currentStrategy && typeof this.currentStrategy.onChordChanged === 'function') {
            console.log("[PadModeManager.onChordChanged] Delegating to current strategy.");
            await this.currentStrategy.onChordChanged(newChord, this.appRef.state, this.appRef.services);
        }
         // Always trigger updateZones as chord change affects relevant modes
        if (this.appRef && typeof this.appRef.updateZones === 'function') {
            console.log("[PadModeManager.onChordChanged] Calling appRef.updateZones() after chord change.");
            await this.appRef.updateZones();
        }
    }

    // Add other methods as needed, e.g., for handling other global state changes
}; 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\managers\ampEnvManager.js
// Файл: app/src/main/assets/js/managers/ampEnvManager.js
// Менеджер для управления огибающей амплитуды (Tone.AmplitudeEnvelope)

const ampEnvManager = {
    /**
     * Создает узел Tone.AmplitudeEnvelope.
     * @param {object} [initialSettings={}] - Начальные настройки огибающей из пресета.
     * @returns {object} - Объект { nodes: { envelope: Tone.AmplitudeEnvelope }, audioInput: Tone.AmplitudeEnvelope, audioOutput: Tone.AmplitudeEnvelope, error: string | null }
     */
    create(initialSettings = {}) {
        const t0 = performance.now();
        console.log("[AmpEnvManager] create() called with:", initialSettings);
        let nodes = { envelope: null };
        let audioInput = null;
        let audioOutput = null;
        let error = null;
        try {
            const settings = {
                attack: initialSettings.attack ?? 0.01,
                decay: initialSettings.decay ?? 0.1,
                sustain: initialSettings.sustain ?? 0.7,
                release: initialSettings.release ?? 0.5,
                attackCurve: initialSettings.attackCurve || 'linear',
                decayCurve: initialSettings.decayCurve || 'exponential',
                releaseCurve: initialSettings.releaseCurve || 'exponential'
            };
            console.log("[AmpEnvManager] Creating Tone.AmplitudeEnvelope with:", settings);
            const envelope = new Tone.AmplitudeEnvelope(settings);
            nodes.envelope = envelope;
            audioInput = envelope;
            audioOutput = envelope;
            console.log("[AmpEnvManager] create() finished.");
        } catch (err) {
            console.error("[AmpEnvManager] Error in create():", err);
            error = `Failed to create AmplitudeEnvelope: ${err.message}`;
            nodes = null;
            audioInput = null;
            audioOutput = null;
        }
        const t1 = performance.now();
        console.log(`[AmpEnvManager] create() duration: ${(t1-t0).toFixed(2)}ms`);
        return { nodes, audioInput, audioOutput, modInputs: {}, modOutputs: {}, error };
    },

    /**
     * Обновляет параметры огибающей амплитуды.
     * @param {object} nodes - Объект узлов { envelope }.
     * @param {object} newSettings - Новые настройки { attack, decay, sustain, release, attackCurve, decayCurve, releaseCurve }.
     * @returns {boolean} - true при успехе.
     */
    update(nodes, newSettings) {
        const t0 = performance.now();
        console.log("[AmpEnvManager] update() called with:", newSettings);
        if (!nodes || !nodes.envelope || !newSettings) {
            console.warn("[AmpEnvManager] Update called with invalid args", { nodes, newSettings });
            return false;
        }
        const envelope = nodes.envelope;
        try {
            if (newSettings.attack !== undefined) envelope.attack = newSettings.attack;
            if (newSettings.decay !== undefined) envelope.decay = newSettings.decay;
            if (newSettings.sustain !== undefined) envelope.sustain = newSettings.sustain;
            if (newSettings.release !== undefined) envelope.release = newSettings.release;
            if (newSettings.attackCurve !== undefined) envelope.attackCurve = newSettings.attackCurve;
            if (newSettings.decayCurve !== undefined) envelope.decayCurve = newSettings.decayCurve;
            if (newSettings.releaseCurve !== undefined) envelope.releaseCurve = newSettings.releaseCurve;
            console.log("[AmpEnvManager] update() finished.");
            const t1 = performance.now();
            console.log(`[AmpEnvManager] update() duration: ${(t1-t0).toFixed(2)}ms`);
            return true;
        } catch (err) {
            console.error("[AmpEnvManager] Error in update():", err);
            return false;
        }
    },

    /**
     * Соединяет огибающую с соседями по цепочке.
     */
    connectPeers(nodes, prevOutputNode, nextInputNode) {
        // Используем стандартную реализацию blankManager
        return blankManager.connectPeers(nodes, prevOutputNode, nextInputNode);
    },

    /**
     * Огибающая амплитуды не имеет состояния enable/bypass.
     */
    enable(nodes, isEnabled) {
        console.log(`[AmpEnvManager] enable() called with ${isEnabled} (no action needed).`);
        return true;
    },

    /**
     * Огибающая амплитуды обычно не является целью модуляции.
     */
    connectModulator(nodes, targetParamPath, sourceNode) {
        console.warn(`[AmpEnvManager] connectModulator called for '${targetParamPath}', but AmpEnv is not typically modulated.`);
        // Можно добавить поддержку модуляции attack/decay/sustain/release, если нужно,
        // но они не являются Tone.Param или Tone.Signal по умолчанию.
        return false; // Возвращаем false, т.к. не поддерживается
    },

    /**
     * Отключение модулятора (неприменимо).
     */
    disconnectModulator(nodes, targetParamPath, sourceNode) {
        console.warn(`[AmpEnvManager] disconnectModulator called for '${targetParamPath}'.`);
        return true; // Возвращаем true, т.к. подключения и не было
    },

    /**
     * Уничтожает узел огибающей.
     */
    dispose(nodes) {
        const t0 = performance.now();
        console.log("[AmpEnvManager] dispose() called");
        if (nodes && nodes.envelope) {
            try {
                nodes.envelope.disconnect();
                nodes.envelope.dispose();
                console.log("[AmpEnvManager] Envelope node disposed.");
            } catch (e) {
                console.warn("[AmpEnvManager] Error disposing envelope node:", e);
            }
        }
        const t1 = performance.now();
        console.log(`[AmpEnvManager] dispose() duration: ${(t1-t0).toFixed(2)}ms`);
    },

    // --- Специфичные методы для AmpEnv ---

    /**
     * Запускает фазу атаки огибающей.
     * @param {object} nodes - Узлы компонента { envelope }.
     * @param {Tone.Time} [time=Tone.now()] - Время запуска.
     * @param {number} [velocity=1] - Громкость атаки (0-1).
     */
    triggerAttack(nodes, time = Tone.now(), velocity = 1) {
        const t0 = performance.now();
        console.log(`[AmpEnvManager] triggerAttack() called. Time: ${time}, Velocity: ${velocity}`);
        if (!nodes || !nodes.envelope) {
            console.warn("[AmpEnvManager] triggerAttack called, but envelope node is missing.");
            return;
        }
        try {
            nodes.envelope.triggerAttack(time, velocity);
        } catch (e) {
            console.error("[AmpEnvManager] Error in triggerAttack():", e);
            try { nodes.envelope.triggerRelease(time); } catch (re) {}
        }
        const t1 = performance.now();
        console.log(`[AmpEnvManager] triggerAttack() duration: ${(t1-t0).toFixed(2)}ms`);
    },

    /**
     * Запускает фазу затухания огибающей.
     * @param {object} nodes - Узлы компонента { envelope }.
     * @param {Tone.Time} [time=Tone.now()] - Время запуска затухания.
     */
    triggerRelease(nodes, time = Tone.now()) {
        const t0 = performance.now();
        console.log(`[AmpEnvManager] triggerRelease() called. Time: ${time}`);
        if (!nodes || !nodes.envelope) {
            console.warn("[AmpEnvManager] triggerRelease called, but envelope node is missing.");
            return;
        }
        try {
            nodes.envelope.triggerRelease(time);
        } catch (e) {
            if (e.message.includes("cannot schedule triggerRelease") || e.message.includes("already triggered release")) {
                console.warn(`[AmpEnvManager] Warning during triggerRelease (likely safe to ignore): ${e.message}`);
            } else {
                console.error("[AmpEnvManager] Error in triggerRelease():", e);
            }
        }
        const t1 = performance.now();
        console.log(`[AmpEnvManager] triggerRelease() duration: ${(t1-t0).toFixed(2)}ms`);
    }
};

// Регистрация менеджера в audioConfig
if (typeof audioConfig !== 'undefined' && typeof audioConfig.registerManager === 'function') {
    audioConfig.registerManager('amplitudeEnv', ampEnvManager); // Используем ID 'amplitudeEnv'
} else {
    console.error("[AmpEnvManager] audioConfig or audioConfig.registerManager is not available.");
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\managers\blankManager.js
// Файл: app/src/main/assets/js/managers/blankManager.js
// Шаблон для создания нового менеджера аудио-компонента

const blankManager = {
    /**
     * Создает узлы Tone.js для этого компонента.
     * Вызывается ОДИН РАЗ при создании голоса в voiceBuilder.
     * @param {object | null} initialSettings - Начальные настройки из пресета (или default) для этого компонента.
     * @returns {object} - Объект вида:
     * {
     *   nodes: object | null,        // Объект со ссылками на созданные узлы Tone.js (или null при ошибке)
     *   audioInput: Tone.InputNode | null, // Узел для приема аудиосигнала (если компонент в аудиоцепочке)
     *   audioOutput: Tone.OutputNode | null,// Узел для вывода аудиосигнала (если компонент в аудиоцепочке)
     *   modInputs?: object,           // (Опционально) { paramName: Tone.Param | Tone.Signal, ... } для модулируемых параметров
     *   modOutputs?: object,          // (Опционально) { sourceName: Tone.Signal | Tone.LFO | ..., ... } для выходов модуляции
     *   error: string | null         // Сообщение об ошибке или null
     * }
     */
    create(initialSettings = {}) {
        console.log("[BlankManager] Creating nodes with settings:", initialSettings);
        let nodes = {};
        let audioInput = null;
        let audioOutput = null;
        let modInputs = {}; // Пример для модулируемых параметров
        let modOutputs = {}; // Пример для выходов модуляции
        let error = null;

        try {
            // --- Здесь логика создания узлов Tone.js ---
            // Пример: Создаем простой Gain как заглушку/проходной узел
            const gainNode = new Tone.Gain(1);
            nodes.gain = gainNode;
            audioInput = gainNode;  // Вход компонента - это вход Gain
            audioOutput = gainNode; // Выход компонента - это выход Gain

            // Пример добавления модулируемого параметра
            // modInputs.gain = gainNode.gain;

            // Важно: Сразу соединить вход и выход для passthrough по умолчанию
            // (Если это простой узел типа Gain/Channel, это неявно)
            // Если компонент сложнее, может потребоваться nodes.input.connect(nodes.output);

            // (Опционально) Инициализация параметров из initialSettings
            // if (initialSettings.someParam !== undefined) {
            //     nodes.someNode.value = initialSettings.someParam;
            // }

            console.log("[BlankManager] Nodes created successfully.");

        } catch (err) {
            console.error("[BlankManager] Error creating nodes:", err);
            error = `Failed to create: ${err.message}`;
            nodes = null; // Обнуляем узлы при ошибке
            audioInput = null;
            audioOutput = null;
            modInputs = {};
            modOutputs = {};
        }

        return { nodes, audioInput, audioOutput, modInputs, modOutputs, error };
    },

    /**
     * Обновляет параметры существующих узлов компонента.
     * Вызывается из synth.js при применении пресета или изменении настроек в UI.
     * @param {object} nodes - Объект узлов, возвращенный методом create.
     * @param {object} newSettings - Новые настройки для компонента.
     * @returns {boolean} - true при успехе, false при ошибке.
     */
    update(nodes, newSettings) {
        if (!nodes || !newSettings) {
            console.warn("[BlankManager] Update called with invalid args", nodes, newSettings);
            return false;
        }
        // console.log("[BlankManager] Updating nodes with settings:", newSettings); // Менее подробный лог
        try {
            // --- Здесь логика обновления параметров узлов Tone.js ---
            // Пример: Обновление гейна
            if (newSettings.gain !== undefined && nodes.gain?.gain instanceof Tone.Param) {
                 nodes.gain.gain.rampTo(newSettings.gain, 0.02); // Плавное изменение
            }

            // Пример: Обновление другого параметра
            // if (newSettings.someParam !== undefined && nodes.someNode?.value !== undefined) {
            //     if (nodes.someNode instanceof Tone.Param || nodes.someNode instanceof Tone.Signal) {
            //         nodes.someNode.rampTo(newSettings.someParam, 0.02);
            //     } else {
            //         nodes.someNode.value = newSettings.someParam;
            //     }
            // }
            return true; // Успех
        } catch (err) {
            console.error("[BlankManager] Error updating nodes:", err);
            return false; // Ошибка
        }
    },

    /**
     * Соединяет аудио входы/выходы компонента с соседями по цепочке.
     * Вызывается из voiceBuilder при построении цепочки.
     * @param {object} nodes - Объект узлов, возвращенный методом create.
     * @param {Tone.OutputNode | null} prevOutputNode - Выходной узел предыдущего компонента.
     * @param {Tone.InputNode | null} nextInputNode - Входной узел следующего компонента.
     * @returns {boolean} - true при успехе, false при ошибке.
     */
    connectPeers(nodes, prevOutputNode, nextInputNode) {
        // Проверяем наличие audioInput/audioOutput, если компонент должен быть в аудиоцепочке
        if (!nodes || !nodes.audioInput || !nodes.audioOutput || !prevOutputNode || !nextInputNode) {
            console.warn("[BlankManager] connectPeers called with invalid args or missing audioInput/Output", { nodes, prevOutputNode, nextInputNode });
            // Если это модулятор (нет audioInput/Output), то это не ошибка, просто ничего не делаем
            return (!nodes || (!nodes.audioInput && !nodes.audioOutput));
        }
        console.log("[BlankManager] Connecting peers...");
        try {
            // Соединяем выход предыдущего -> вход этого -> выход этого -> вход следующего
            prevOutputNode.connect(nodes.audioInput);
            nodes.audioOutput.connect(nextInputNode);
            console.log("[BlankManager] Peers connected.");
            return true;
        } catch (err) {
            console.error("[BlankManager] Error connecting peers:", err);
            // Попытка отката соединений при ошибке (может быть сложно и не всегда нужно)
            try { prevOutputNode.disconnect(nodes.audioInput); } catch(e){}
            try { nodes.audioOutput.disconnect(nextInputNode); } catch(e){}
            return false;
        }
    },

    /**
     * Включает/выключает или обходит (bypass) компонент.
     * Вызывается из synth.js при изменении флага 'enabled'.
     * Требуется в основном для опциональных модулей (LFO, PitchEnv, VoiceFX).
     * @param {object} nodes - Объект узлов.
     * @param {boolean} isEnabled - Новое состояние.
     * @returns {boolean} - true при успехе, false при ошибке.
     */
    enable(nodes, isEnabled) {
        if (!nodes) return false;
        console.log(`[BlankManager] Setting enabled state to: ${isEnabled}`);
        try {
            // --- Логика включения/выключения/обхода ---
            // Реализация зависит от компонента.
            // Для компонентов без enable/bypass просто возвращаем true.

            // Пример для LFO:
            // if (nodes.lfo) { isEnabled ? nodes.lfo.start() : nodes.lfo.stop(); }

            // Пример для FX с bypass через Gain:
            // if (nodes.bypassGain && nodes.effectGain) {
            //     nodes.bypassGain.gain.rampTo(isEnabled ? 0 : 1, 0.01);
            //     nodes.effectGain.gain.rampTo(isEnabled ? 1 : 0, 0.01);
            // }

            // Пример для FX с bypass через Channel (более сложный):
            // if (nodes.inputChannel && nodes.outputChannel && nodes.effectNode) {
            //     if (isEnabled) {
            //         nodes.inputChannel.disconnect(nodes.outputChannel); // Разрываем прямой путь
            //         nodes.inputChannel.connect(nodes.effectNode);
            //         nodes.effectNode.connect(nodes.outputChannel);
            //     } else {
            //         nodes.inputChannel.disconnect(nodes.effectNode); // Разрываем путь через эффект
            //         try { nodes.effectNode.disconnect(nodes.outputChannel); } catch(e){} // Может быть уже отключен
            //         nodes.inputChannel.connect(nodes.outputChannel); // Восстанавливаем прямой путь
            //     }
            // }
            console.log("[BlankManager] Enabled state set (no action defined in template).");
            return true;
        } catch (err) {
            console.error(`[BlankManager] Error setting enabled state to ${isEnabled}:`, err);
            return false;
        }
    },

    /**
     * Подключает выходной узел модулятора к параметру этого компонента.
     * Вызывается из synth.js (или ModMatrixManager).
     * @param {object} nodes - Узлы этого компонента.
     * @param {string} targetParamPath - Путь к параметру внутри nodes (напр., "filter.frequency.value").
     * @param {Tone.OutputNode} sourceNode - Выходной узел модулятора (LFO, Env, etc.).
     * @returns {boolean} - true при успехе.
     */
    connectModulator(nodes, targetParamPath, sourceNode) {
        if (!nodes || !targetParamPath || !sourceNode) {
             console.warn("[BlankManager] connectModulator called with invalid args.");
             return false;
        }
        console.log(`[BlankManager] Connecting modulator to: ${targetParamPath}`);
        try {
            // Используем общую функцию поиска из voiceBuilder
            const targetParam = voiceBuilder.findParamByPath(nodes, targetParamPath);
            if (targetParam instanceof Tone.Param || targetParam instanceof Tone.Signal) {
                sourceNode.connect(targetParam);
                console.log(`[BlankManager] Modulator connected successfully to ${targetParamPath}`);
                return true;
            } else {
                console.warn(`[BlankManager] Target parameter '${targetParamPath}' not found or not connectable. Target:`, targetParam);
                return false;
            }
        } catch (err) {
            console.error(`[BlankManager] Error connecting modulator to ${targetParamPath}:`, err);
            return false;
        }
    },

    /**
     * Отключает модулятор от параметра этого компонента.
     * @param {object} nodes - Узлы этого компонента.
     * @param {string} targetParamPath - Путь к параметру внутри nodes.
     * @param {Tone.OutputNode} sourceNode - Выходной узел модулятора.
     * @returns {boolean} - true при успехе.
     */
    disconnectModulator(nodes, targetParamPath, sourceNode) {
        if (!nodes || !targetParamPath || !sourceNode) {
             console.warn("[BlankManager] disconnectModulator called with invalid args.");
             return false;
        }
        console.log(`[BlankManager] Disconnecting modulator from: ${targetParamPath}`);
        try {
            const targetParam = voiceBuilder.findParamByPath(nodes, targetParamPath);
            if (targetParam instanceof Tone.Param || targetParam instanceof Tone.Signal) {
                sourceNode.disconnect(targetParam);
                console.log(`[BlankManager] Modulator disconnected from ${targetParamPath}`);
                return true;
            }
            // Если цель не найдена, считаем успешным отключением
            return true;
        } catch (err) {
            // Игнорируем ошибки, если уже отключен (Tone.js может бросать исключение)
            console.warn(`[BlankManager] Error/Warning disconnecting modulator from ${targetParamPath} (may already be disconnected):`, err.message);
            return true; // Считаем успешным, т.к. цель - разорвать связь
        }
    },

    /**
     * Корректно отключает и уничтожает все узлы компонента.
     * Вызывается из voiceBuilder при ошибке или из synth при полном удалении голоса.
     * @param {object} nodes - Объект узлов.
     */
    dispose(nodes) {
        if (!nodes) return;
        console.log("[BlankManager] Disposing nodes...");
        const safeDispose = (node) => {
            if (node && typeof node.dispose === 'function') {
                try {
                    // Пытаемся отключить перед удалением, если возможно
                    if (typeof node.disconnect === 'function') {
                        node.disconnect();
                    }
                    node.dispose();
                } catch (e) {
                    console.warn("[BlankManager] Error disposing node:", node, e);
                }
            } else if (Array.isArray(node)) {
                 // Если узел - массив (например, в FatOscillator), рекурсивно удаляем его элементы
                 node.forEach(subNode => safeDispose(subNode));
            }
        };
        // Перебираем все узлы в объекте nodes и вызываем safeDispose
        for (const key in nodes) {
            safeDispose(nodes[key]);
        }
        console.log("[BlankManager] Nodes disposed.");
    },

    // --- Дополнительные методы (специфичные для компонента) ---

    /**
     * Пример: Метод для запуска огибающей (если это менеджер огибающей).
     * @param {object} nodes - Узлы компонента.
     * @param {Tone.Time} [time=Tone.now()] - Время запуска.
     * @param {number} [velocity=1] - Громкость атаки (0-1).
     */
    triggerAttack(nodes, time = Tone.now(), velocity = 1) {
        if (!nodes) return;
        console.log(`[BlankManager] Trigger Attack called (no action defined in template). Time: ${time}, Velocity: ${velocity}`);
        // Пример:
        // if (nodes.envelope && typeof nodes.envelope.triggerAttack === 'function') {
        //     try {
        //         nodes.envelope.triggerAttack(time, velocity);
        //     } catch (e) { console.error("[BlankManager] Error in triggerAttack:", e); }
        // }
    },

    /**
     * Пример: Метод для запуска фазы затухания огибающей.
     * @param {object} nodes - Узлы компонента.
     * @param {Tone.Time} [time=Tone.now()] - Время запуска затухания.
     */
    triggerRelease(nodes, time = Tone.now()) {
        if (!nodes) return;
        console.log(`[BlankManager] Trigger Release called (no action defined in template). Time: ${time}`);
        // Пример:
        // if (nodes.envelope && typeof nodes.envelope.triggerRelease === 'function') {
        //     try {
        //         nodes.envelope.triggerRelease(time);
        //     } catch (e) { console.error("[BlankManager] Error in triggerRelease:", e); }
        // }
    }

};

// Важно: Если менеджер управляет несколькими однотипными узлами (как LFO),
// то 'nodes' может быть массивом или объектом с индексированными ключами,
// и методы create/update/enable/dispose/etc. должны принимать индекс или ID
// или итерировать по всем управляемым узлам.
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\managers\chorusFxManager.js
// Файл: app/src/main/assets/js/managers/chorusFxManager.js
const chorusFxManager = {
    create(initialSettings = {}) {
        console.log("[ChorusFxManager] Creating Chorus node with settings:", initialSettings);
        let nodes = { chorusNode: null };
        let audioInput = null;
        let audioOutput = null;
        let error = null;

        try {
            const settings = {
                frequency: initialSettings.frequency ?? 1.5,
                depth: initialSettings.depth ?? 0.7,
                delayTime: initialSettings.delayTime ?? 3.5,
                wet: initialSettings.wet ?? 0.0,
                type: initialSettings.type || 'sine', // Tone.Chorus поддерживает тип LFO
                spread: initialSettings.spread || 180 // Для стереоэффекта
            };
            nodes.chorusNode = new Tone.Chorus(settings).start(); // Запускаем LFO хоруса
            audioInput = nodes.chorusNode;
            audioOutput = nodes.chorusNode;
            console.log("[ChorusFxManager] Chorus node created successfully.");
        } catch (err) {
            console.error("[ChorusFxManager] Error creating Chorus node:", err);
            error = `Failed to create Chorus: ${err.message}`;
            nodes = null;
        }
        return { nodes, audioInput, audioOutput, modInputs: {}, modOutputs: {}, error };
    },

    update(nodes, newSettings) {
        if (!nodes?.chorusNode || !newSettings) return false;
        const chorusNode = nodes.chorusNode;
        console.log("[ChorusFxManager] Updating Chorus with:", newSettings);
        try {
            if (newSettings.frequency !== undefined && chorusNode.frequency instanceof Tone.Param) chorusNode.frequency.rampTo(newSettings.frequency, 0.02);
            if (newSettings.depth !== undefined && chorusNode.depth instanceof Tone.Param) chorusNode.depth.rampTo(newSettings.depth, 0.02);
            if (newSettings.delayTime !== undefined && typeof chorusNode.delayTime === 'number') chorusNode.delayTime = newSettings.delayTime; // delayTime - не Param
            if (newSettings.wet !== undefined && chorusNode.wet instanceof Tone.Param) chorusNode.wet.rampTo(newSettings.wet, 0.02);
            if (newSettings.type !== undefined) chorusNode.type = newSettings.type;
            if (newSettings.spread !== undefined) chorusNode.spread = newSettings.spread;
            return true;
        } catch (err) {
            console.error("[ChorusFxManager] Error updating Chorus:", err);
            return false;
        }
    },

    enable(nodes, isEnabled) {
        if (!nodes?.chorusNode) return false;
        const chorusNode = nodes.chorusNode;
        console.log(`[ChorusFxManager] Setting enabled to ${isEnabled}`);
        try {
            if (!isEnabled && chorusNode.wet.value > 0) chorusNode._previousWet = chorusNode.wet.value;
            const targetWet = isEnabled ? (chorusNode._previousWet ?? 0.5) : 0; // Дефолтный wet 0.5 при включении, если не было сохранено
            chorusNode.wet.rampTo(targetWet, 0.02);
            // LFO хоруса стартует в create, останавливать его не нужно, wet=0 достаточно
            return true;
        } catch (err) { return false; }
    },

    connectPeers(nodes, prev, next) { return blankManager.connectPeers(nodes, prev, next); },
    dispose(nodes) {
        if (nodes?.chorusNode) {
            nodes.chorusNode.stop(); // Останавливаем LFO перед удалением
            blankManager.dispose({ chorusNode: nodes.chorusNode });
        }
    }
    // connectModulator и disconnectModulator можно наследовать от blankManager или реализовать если нужно
};

if (typeof audioConfig !== 'undefined' && audioConfig.registerManager) {
    audioConfig.registerManager('chorus', chorusFxManager);
} else {
    console.error("[ChorusFxManager] audioConfig or registerManager missing.");
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\managers\delayFxManager.js
// Файл: app/src/main/assets/js/managers/delayFxManager.js
const delayFxManager = {
    /**
     * Создает узел Tone.FeedbackDelay.
     * @param {object} [initialSettings={}] - Начальные настройки (delayTime, feedback, wet).
     * @returns {object} - { nodes: { delayNode: Tone.FeedbackDelay }, audioInput, audioOutput, error }
     */
    create(initialSettings = {}) {
        console.log("[DelayFxManager] Creating FeedbackDelay with settings:", initialSettings);
        let nodes = {
            delayNode: null
        };
        let audioInput = null;
        let audioOutput = null;
        let error = null;

        try {
            const settings = {
                delayTime: initialSettings.delayTime ?? 0.25,
                feedback: initialSettings.feedback ?? 0.3,
                wet: initialSettings.wet ?? 0.0, // По умолчанию инсертный эффект может быть выключен (wet=0) или полностью включен (wet=1)
                maxDelay: initialSettings.maxDelay || 1 // Максимальное время задержки
            };

            const delayNode = new Tone.FeedbackDelay(settings);
            nodes.delayNode = delayNode;
            audioInput = delayNode;
            audioOutput = delayNode;

            console.log("[DelayFxManager] FeedbackDelay node created successfully.");

        } catch (err) {
            console.error("[DelayFxManager] Error creating FeedbackDelay node:", err);
            error = `Failed to create FeedbackDelay: ${err.message}`;
            nodes = null; // Обнуляем узлы при ошибке
        }

        return { nodes, audioInput, audioOutput, modInputs: {}, modOutputs: {}, error };
    },

    /**
     * Обновляет параметры FeedbackDelay.
     * @param {object} nodes - Объект узлов { delayNode }.
     * @param {object} newSettings - Новые настройки { delayTime, feedback, wet }.
     * @returns {boolean} - true при успехе.
     */
    update(nodes, newSettings) {
        if (!nodes || !nodes.delayNode || !newSettings) {
            console.warn("[DelayFxManager] Update called with invalid args", { nodes, newSettings });
            return false;
        }
        const delayNode = nodes.delayNode;
        // console.log("[DelayFxManager] Updating FeedbackDelay with:", newSettings); // Менее подробный лог

        try {
            if (newSettings.delayTime !== undefined && delayNode.delayTime instanceof Tone.Param) {
                delayNode.delayTime.rampTo(newSettings.delayTime, 0.02);
            }
            if (newSettings.feedback !== undefined && delayNode.feedback instanceof Tone.Param) {
                delayNode.feedback.rampTo(newSettings.feedback, 0.02);
            }
            if (newSettings.wet !== undefined && delayNode.wet instanceof Tone.Param) {
                delayNode.wet.rampTo(newSettings.wet, 0.02);
            }
            return true;
        } catch (err) {
            console.error("[DelayFxManager] Error updating FeedbackDelay:", err);
            return false;
        }
    },

    /**
     * Соединяет эффект с соседями по цепочке.
     */
    connectPeers(nodes, prevOutputNode, nextInputNode) {
        // Используем стандартную реализацию blankManager
        return blankManager.connectPeers(nodes, prevOutputNode, nextInputNode);
    },

    /**
     * Включает/выключает эффект (через параметр wet).
     * @param {object} nodes - Узлы компонента { delayNode }.
     * @param {boolean} isEnabled - Новое состояние.
     * @returns {boolean} - true при успехе.
     */
    enable(nodes, isEnabled) {
        if (!nodes || !nodes.delayNode) {
            console.warn("[DelayFxManager] Enable called with invalid nodes", nodes);
            return false;
        }
        console.log(`[DelayFxManager] Setting enabled state to: ${isEnabled}`);
        try {
            // Управляем через wet. Сохраняем предыдущее значение wet, если оно было.
            const delayNode = nodes.delayNode;
            if (isEnabled) {
                // Восстанавливаем сохраненное значение wet или используем дефолтное (например, 0.5)
                // Это значение должно приходить из настроек пресета.
                // Пока что, если enable(true), то мы ожидаем, что update() установит правильный wet.
                // Здесь можно просто убедиться, что wet не 0, если isEnabled.
                // Более сложная логика:
                // if (delayNode.wet.value === 0 && delayNode._savedWetValue === undefined) {
                //    delayNode._savedWetValue = 0.5; // Default wet if enabling from 0
                // }
                // delayNode.wet.rampTo(delayNode._savedWetValue || 0.5, 0.02);
                // delete delayNode._savedWetValue;
                // Простой вариант: enable просто готовит его к работе, а update установит wet.
                // Если эффект был выключен (wet=0), то при включении он должен взять wet из пресета.
                // voiceBuilder должен вызвать update после enable, или enable должен принимать settings.
                // Для простоты, предположим, что 'wet' из пресета будет применен через update.
                // Этот метод в основном для ситуаций, когда мы переключаем enable без изменения пресета.

                // Если мы хотим, чтобы enable(true) устанавливал некий дефолтный wet, если он был 0:
                const currentWet = delayNode.wet.value;
                const targetWet = nodes._lastWetValueForEnable !== undefined ? nodes._lastWetValueForEnable : 0.3; // или из defaultSettings
                if (currentWet < 0.01 && targetWet > 0) { // Если был выключен
                     delayNode.wet.rampTo(targetWet, 0.02);
                } else if (currentWet >= 0.01 && targetWet > 0){ // Если уже был включен, просто используем его значение
                    // Ничего не делаем, update должен был установить правильный wet
                }
                // Если пресет говорит wet:0 и enabled:true - это валидно, он включен, но не активен.
                // Поэтому, enable не должен сам по себе менять wet на не-ноль, если только он не был выключен через enable(false)
            } else {
                // Сохраняем текущее значение wet перед тем, как установить его в 0
                if (delayNode.wet.value > 0) {
                    nodes._lastWetValueForEnable = delayNode.wet.value;
                }
                delayNode.wet.rampTo(0, 0.02);
            }
            return true;
        } catch (err) {
            console.error(`[DelayFxManager] Error setting enabled state to ${isEnabled}:`, err);
            return false;
        }
    },

    /**
     * Подключение модулятора (если нужно для дилея, например, модуляция delayTime).
     */
    connectModulator(nodes, targetParamPath, sourceNode) {
        return blankManager.connectModulator(nodes, targetParamPath, sourceNode);
    },

    disconnectModulator(nodes, targetParamPath, sourceNode) {
        return blankManager.disconnectModulator(nodes, targetParamPath, sourceNode);
    },

    /**
     * Уничтожает узел дилея.
     */
    dispose(nodes) {
        console.log("[DelayFxManager] Disposing FeedbackDelay node...");
        if (nodes && nodes.delayNode) {
            blankManager.dispose({ delayNode: nodes.delayNode });
        } else {
            console.log("[DelayFxManager] No FeedbackDelay node found to dispose.");
        }
    }
};

// Регистрация менеджера в audioConfig
if (typeof audioConfig !== 'undefined' && typeof audioConfig.registerManager === 'function') {
    audioConfig.registerManager('delay', delayFxManager); // Используем ID 'delay'
} else {
    console.error("[DelayFxManager] audioConfig or audioConfig.registerManager is not available.");
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\managers\distortionFxManager.js
// Файл: app/src/main/assets/js/managers/distortionFxManager.js
const distortionFxManager = {
    isOptional: true, // Инсертные эффекты опциональны

    /**
     * Создает узел Tone.Distortion.
     * @param {object} [initialSettings={}] - Начальные настройки из пресета (секция params эффекта).
     * @returns {object} - Объект { nodes: { distortionNode: Tone.Distortion }, audioInput: Tone.Distortion, audioOutput: Tone.Distortion, error: string | null }
     */
    create(initialSettings = {}) {
        console.log("[DistortionFxManager] Creating Distortion node with settings:", initialSettings);
        let nodes = {
            distortionNode: null
        };
        let audioInput = null;
        let audioOutput = null;
        let error = null;

        try {
            const settings = {
                distortion: initialSettings.distortion ?? 0.4, // Значение искажения
                wet: initialSettings.wet ?? 1.0,             // Wet по умолчанию 1.0 для инсертов
                oversample: initialSettings.oversample || 'none' // 'none', '2x', '4x'
            };

            const distortionNode = new Tone.Distortion(settings);
            nodes.distortionNode = distortionNode;
            audioInput = distortionNode;
            audioOutput = distortionNode;

            // modInputs не обязательны для простых эффектов, но можно добавить для wet/distortion
            // modInputs: {
            //    distortion: distortionNode.distortion, // Это Signal, а не Param
            //    wet: distortionNode.wet
            // }

            console.log("[DistortionFxManager] Distortion node created successfully.");

        } catch (err) {
            console.error("[DistortionFxManager] Error creating Distortion node:", err);
            error = `Failed to create Distortion: ${err.message}`;
            nodes = null;
            audioInput = null;
            audioOutput = null;
        }

        return { nodes, audioInput, audioOutput, modInputs: {}, modOutputs: {}, error };
    },

    /**
     * Обновляет параметры Tone.Distortion.
     * @param {object} nodes - Объект узлов { distortionNode }.
     * @param {object} newSettings - Новые настройки { distortion, wet, oversample }.
     * @returns {boolean} - true при успехе.
     */
    update(nodes, newSettings) {
        if (!nodes || !nodes.distortionNode || !newSettings) {
            console.warn("[DistortionFxManager] Update called with invalid args", { nodes, newSettings });
            return false;
        }
        const distortionNode = nodes.distortionNode;
        console.log("[DistortionFxManager] Updating Distortion with:", newSettings);

        try {
            if (newSettings.distortion !== undefined && typeof distortionNode.distortion === 'number') { // distortion - это просто число
                distortionNode.distortion = Math.max(0, Math.min(1, newSettings.distortion)); // Ограничиваем 0-1
            }
            if (newSettings.wet !== undefined && distortionNode.wet instanceof Tone.Param) {
                distortionNode.wet.rampTo(newSettings.wet, 0.02);
            }
            if (newSettings.oversample !== undefined && ['none', '2x', '4x'].includes(newSettings.oversample)) {
                distortionNode.oversample = newSettings.oversample;
            }
            return true;
        } catch (err) {
            console.error("[DistortionFxManager] Error updating Distortion:", err);
            return false;
        }
    },

    /**
     * Включает/выключает эффект (управляет wet).
     * @param {object} nodes - Узлы компонента { distortionNode }.
     * @param {boolean} isEnabled - Новое состояние.
     * @returns {boolean} - true.
     */
    enable(nodes, isEnabled) {
        if (!nodes || !nodes.distortionNode) {
            console.warn("[DistortionFxManager] Enable called with invalid nodes.");
            return false;
        }
        const distortionNode = nodes.distortionNode;
        console.log(`[DistortionFxManager] Setting enabled to ${isEnabled}`);
        try {
            // Сохраняем предыдущее значение wet, если выключаем
            if (!isEnabled && distortionNode.wet.value > 0) {
                distortionNode._previousWet = distortionNode.wet.value;
            }
            const targetWet = isEnabled ? (distortionNode._previousWet ?? 1.0) : 0;
            distortionNode.wet.rampTo(targetWet, 0.02);
            return true;
        } catch (err) {
            console.error("[DistortionFxManager] Error in enable/disable:", err);
            return false;
        }
    },

    /**
     * Соединяет эффект с соседями по цепочке.
     */
    connectPeers(nodes, prevOutputNode, nextInputNode) {
        // Используем стандартную реализацию blankManager
        return blankManager.connectPeers(nodes, prevOutputNode, nextInputNode);
    },

    /**
     * Освобождает ресурсы.
     */
    dispose(nodes) {
        console.log("[DistortionFxManager] Disposing Distortion node...");
        if (nodes && nodes.distortionNode) {
            blankManager.dispose({ distortionNode: nodes.distortionNode });
        } else {
            console.log("[DistortionFxManager] No distortion node found to dispose.");
        }
    },

    // connectModulator и disconnectModulator можно опустить, если не планируется модуляция параметров дисторшна
    // или использовать реализации из blankManager, если параметры объявлены в modInputs
};

// Регистрация менеджера в audioConfig
if (typeof audioConfig !== 'undefined' && typeof audioConfig.registerManager === 'function') {
    audioConfig.registerManager('distortion', distortionFxManager);
} else {
    console.error("[DistortionFxManager] audioConfig or audioConfig.registerManager is not available.");
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\managers\filterEnvelopeManager.js
// Файл: app/src/main/assets/js/managers/filterEnvelopeManager.js
// Менеджер для огибающей фильтра (Filter Envelope)

const filterEnvelopeManager = {
    isOptional: true, // Это опциональный компонент

    /**
     * Создает узлы Tone.Envelope и Tone.Multiply для управления параметрами фильтра.
     * @param {object} [initialSettings={}] - Начальные настройки из пресета (секция filterEnvelope.params).
     * @returns {object} - Объект вида:
     * {
     *   nodes: { env: Tone.Envelope, amountControl: Tone.Multiply } | null,
     *   audioInput: null, // Модуляторы обычно не имеют аудио входа/выхода
     *   audioOutput: null,
     *   modOutputs: { output: Tone.Multiply } | {}, // Выход, уже масштабированный по amount
     *   error: string | null
     * }
     */
    create(initialSettings = {}) {
        const t0 = performance.now();
        console.log("[FilterEnvManager CREATE ENTRY] Called with initialSettings:", JSON.stringify(initialSettings, null, 2));
        let nodes = { env: null, amountControl: null };
        let modOutputs = { output: null };
        let error = null;
        try {
            console.log("[FilterEnvManager] Creating Tone.Envelope and Tone.Multiply...");
            nodes.env = new Tone.Envelope({
                attack: initialSettings.attack ?? 0.1,
                decay: initialSettings.decay ?? 0.2,
                sustain: initialSettings.sustain ?? 0.5,
                release: initialSettings.release ?? 0.5,
                attackCurve: initialSettings.attackCurve || 'linear',
                decayCurve: initialSettings.decayCurve || 'exponential',
                releaseCurve: initialSettings.releaseCurve || 'exponential'
            });
            nodes.amountControl = new Tone.Multiply(initialSettings.amount ?? 0);
            nodes.env.connect(nodes.amountControl);
            modOutputs.output = nodes.amountControl;
            if (!modOutputs.output) {
                console.error("[FilterEnvManager CREATE CRITICAL] modOutputs.output is STILL NULL after assignment!");
                error = "modOutputs.output was not correctly assigned.";
            } else {
                console.log("[FilterEnvManager CREATE SUCCESS] Nodes created. env:", !!nodes.env, "amountControl:", !!nodes.amountControl, "modOutputs.output:", !!modOutputs.output);
            }
        } catch (err) {
            console.error("[FilterEnvManager CREATE ERROR]", err);
            error = `Failed to create FilterEnvelope: ${err.message}`;
            nodes = null;
            modOutputs = {};
        }
        const t1 = performance.now();
        console.log(`[FilterEnvManager] create() duration: ${(t1-t0).toFixed(2)}ms`);
        console.log(`[FilterEnvManager CREATE EXIT] Returning: error='${error}', hasNodes=${!!nodes}, hasEnv=${!!nodes?.env}, hasAmountCtrl=${!!nodes?.amountControl}, hasModOutput=${!!modOutputs?.output}`);
        return { nodes, audioInput: null, audioOutput: null, modOutputs, error };
    },

    /**
     * Обновляет параметры огибающей и amount.
     * @param {object} nodes - Объект узлов (nodes.env, nodes.amountControl).
     * @param {object} newSettings - Новые настройки.
     * @returns {boolean} - true при успехе.
     */
    update(nodes, newSettings) {
        const t0 = performance.now();
        console.log("[FilterEnvManager] update() called with:", newSettings);
        if (!nodes?.env || !nodes?.amountControl) {
            console.warn("[FilterEnvManager] Update called with invalid nodes.", nodes);
            return false;
        }
        try {
            const envParamsToSet = {};
            if (newSettings.attack !== undefined) envParamsToSet.attack = newSettings.attack;
            if (newSettings.decay !== undefined) envParamsToSet.decay = newSettings.decay;
            if (newSettings.sustain !== undefined) envParamsToSet.sustain = newSettings.sustain;
            if (newSettings.release !== undefined) envParamsToSet.release = newSettings.release;
            if (newSettings.attackCurve !== undefined) envParamsToSet.attackCurve = newSettings.attackCurve;
            if (newSettings.decayCurve !== undefined) envParamsToSet.decayCurve = newSettings.decayCurve;
            if (newSettings.releaseCurve !== undefined) envParamsToSet.releaseCurve = newSettings.releaseCurve;
            if (Object.keys(envParamsToSet).length > 0) {
                nodes.env.set(envParamsToSet);
            }
            if (newSettings.amount !== undefined && nodes.amountControl.factor instanceof Tone.Signal) {
                nodes.amountControl.factor.value = newSettings.amount;
            } else if (newSettings.amount !== undefined) {
                nodes.amountControl.value = newSettings.amount;
            }
            console.log("[FilterEnvManager] update() finished.");
            const t1 = performance.now();
            console.log(`[FilterEnvManager] update() duration: ${(t1-t0).toFixed(2)}ms`);
            return true;
        } catch (err) {
            console.error("[FilterEnvManager] Error in update():", err);
            return false;
        }
    },

    /** Filter Envelope не участвует в основной аудио цепочке */
    connectPeers(nodes, prevOutputNode, nextInputNode) {
        return true;
    },

    /**
     * Включение/выключение (обычно управляется подключением/amount).
     * @param {object} nodes - Узлы компонента.
     * @param {boolean} isEnabled - Новое состояние.
     * @returns {boolean} - true.
     */
    enable(nodes, isEnabled) {
        console.log(`[FilterEnvManager] enable() called with state: ${isEnabled}. Effect primarily controlled by connection and amount parameter.`);
        return true;
    },

     /** Запуск атаки огибающей */
    triggerAttack(nodes, time = Tone.now()) {
        const t0 = performance.now();
        console.log(`[FilterEnvManager] triggerAttack() called. Time: ${time}`);
        if (nodes?.env && typeof nodes.env.triggerAttack === 'function') {
            try {
                nodes.env.triggerAttack(time);
                const t1 = performance.now();
                console.log(`[FilterEnvManager] triggerAttack() duration: ${(t1-t0).toFixed(2)}ms`);
                return true;
            } catch (e) {
                console.error("[FilterEnvManager] Error triggering attack:", e);
                try { if(nodes.env.state !== "stopped") nodes.env.triggerRelease(time); } catch (re) {}
                return false;
            }
        }
        console.warn("[FilterEnvManager] triggerAttack called, but envelope node is missing or invalid.");
        return false;
    },

    /** Запуск затухания огибающей */
    triggerRelease(nodes, time = Tone.now()) {
        const t0 = performance.now();
        console.log(`[FilterEnvManager] triggerRelease() called. Time: ${time}`);
        if (nodes?.env && typeof nodes.env.triggerRelease === 'function') {
            // Логируем состояние огибающей перед вызовом
            console.log('[FilterEnvManager] env state before triggerRelease:', {
                state: nodes.env.state,
                value: nodes.env.value,
                attack: nodes.env.attack,
                decay: nodes.env.decay,
                sustain: nodes.env.sustain,
                release: nodes.env.release,
                attackCurve: nodes.env.attackCurve,
                decayCurve: nodes.env.decayCurve,
                releaseCurve: nodes.env.releaseCurve
            });
            // Анти-флуд: если triggerRelease вызывается повторно за 10мс
            if (!nodes.env._lastReleaseCall) nodes.env._lastReleaseCall = 0;
            const now = performance.now();
            if (now - nodes.env._lastReleaseCall < 10) {
                console.warn('[FilterEnvManager] triggerRelease called twice within 10ms for the same envelope!');
            }
            nodes.env._lastReleaseCall = now;
            try {
                nodes.env.triggerRelease(time);
                const t1 = performance.now();
                console.log(`[FilterEnvManager] triggerRelease() duration: ${(t1-t0).toFixed(2)}ms`);
                return true;
            } catch (e) {
                if (!e.message.toLowerCase().includes("cannot schedule") && !e.message.toLowerCase().includes("already triggered")) {
                    console.error("[FilterEnvManager] Error triggering release:", e);
                }
                return false;
            }
        }
        console.warn("[FilterEnvManager] triggerRelease called, but envelope node is missing or invalid.");
        return false;
    },

    /** FilterEnv является источником модуляции, а не целью */
    connectModulator(nodes, targetParamPath, sourceNode) {
        console.warn(`[FilterEnvManager] connectModulator called for '${targetParamPath}', but FilterEnv is a modulator source, not a target.`);
        return false;
    },

    disconnectModulator(nodes, targetParamPath, sourceNode) {
        console.warn(`[FilterEnvManager] disconnectModulator called for '${targetParamPath}'. (No action as it's a source)`);
        return true;
    },

    /** Освобождает ресурсы */
    dispose(nodes) {
        const t0 = performance.now();
        console.log("[FilterEnvManager] dispose() called");
        if (nodes?.env) {
            try {
                nodes.env.disconnect();
                nodes.env.dispose();
                console.log("[FilterEnvManager] Envelope node disposed.");
            } catch (e) {
                console.warn("[FilterEnvManager] Error disposing env node:", e);
            }
        }
        if (nodes?.amountControl) {
            try {
                nodes.amountControl.disconnect();
                nodes.amountControl.dispose();
                console.log("[FilterEnvManager] Multiply node disposed.");
            } catch (e) {
                console.warn("[FilterEnvManager] Error disposing amountControl node:", e);
            }
        }
        const t1 = performance.now();
        console.log(`[FilterEnvManager] dispose() duration: ${(t1-t0).toFixed(2)}ms`);
    }
};

// Регистрация менеджера в audioConfig
if (typeof audioConfig !== 'undefined' && audioConfig.registerManager) {
    audioConfig.registerManager('filterEnvelope', filterEnvelopeManager);
} else {
    console.error("[FilterEnvManager] Unable to register manager: audioConfig or registerManager function not found.");
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\managers\filterManager.js
// Файл: app/src/main/assets/js/managers/filterManager.js
// Менеджер для управления основным фильтром голоса (Tone.Filter)

const filterManager = {
    /**
     * Создает узел Tone.Filter.
     * @param {object} [initialSettings={}] - Начальные настройки фильтра из пресета.
     * @returns {object} - Объект { nodes: { filter: Tone.Filter }, audioInput: Tone.Filter, audioOutput: Tone.Filter, modInputs: { frequency, detune, Q, gain }, error: string | null }
     */
    create(initialSettings = {}) {
        const t0 = performance.now();
        console.log("[FilterManager] create() called with:", initialSettings);
        let nodes = { filter: null };
        let audioInput = null;
        let audioOutput = null;
        let modInputs = {};
        let error = null;
        try {
            const settings = {
                frequency: initialSettings.frequency ?? 5000,
                Q: initialSettings.Q ?? initialSettings.resonance ?? 1,
                type: initialSettings.type || 'lowpass',
                rolloff: initialSettings.rolloff ?? -12,
                gain: initialSettings.gain ?? 0
            };
            // Валидация типа фильтра
            const validTypes = ['lowpass', 'highpass', 'bandpass', 'lowshelf', 'highshelf', 'notch', 'allpass', 'peaking'];
            if (!validTypes.includes(settings.type)) {
                console.warn(`[FilterManager] Invalid filter type '${settings.type}'. Using 'lowpass'.`);
                settings.type = 'lowpass';
            }
            // Валидация rolloff
            const validRolloffs = [-12, -24, -48, -96];
            if (!validRolloffs.includes(settings.rolloff)) {
                console.warn(`[FilterManager] Invalid filter rolloff '${settings.rolloff}'. Using '-12'.`);
                settings.rolloff = -12;
            }
            console.log("[FilterManager] Creating Tone.Filter with:", settings);
            const filterNode = new Tone.Filter(settings);
            nodes.filter = filterNode;
            audioInput = filterNode;
            audioOutput = filterNode;
            const isConnectableAudioParam = (param) => param && typeof param.value !== 'undefined' && typeof param.rampTo === 'function';
            if (isConnectableAudioParam(filterNode.frequency)) modInputs.frequency = filterNode.frequency;
            if (isConnectableAudioParam(filterNode.detune)) modInputs.detune = filterNode.detune;
            if (isConnectableAudioParam(filterNode.Q)) modInputs.Q = filterNode.Q;
            if (isConnectableAudioParam(filterNode.gain)) modInputs.gain = filterNode.gain;
            console.log("[FilterManager] create() finished.");
        } catch (err) {
            console.error("[FilterManager] Error in create():", err);
            error = `Failed to create Filter: ${err.message}`;
            nodes = null;
            audioInput = null;
            audioOutput = null;
            modInputs = {};
        }
        const t1 = performance.now();
        console.log(`[FilterManager] create() duration: ${(t1-t0).toFixed(2)}ms`);
        return { nodes, audioInput, audioOutput, modInputs, modOutputs: {}, error };
    },

    /**
     * Обновляет параметры фильтра.
     * @param {object} nodes - Объект узлов { filter }.
     * @param {object} newSettings - Новые настройки { frequency, Q, type, rolloff, gain }.
     * @returns {boolean} - true при успехе.
     */
    update(nodes, newSettings) {
        const t0 = performance.now();
        console.log("[FilterManager] update() called with:", newSettings);
        if (!nodes || !nodes.filter || !newSettings) {
            console.warn("[FilterManager] Update called with invalid args", { nodes, newSettings });
            return false;
        }
        const filterNode = nodes.filter;
        try {
            if (newSettings.frequency !== undefined && filterNode.frequency instanceof Tone.Param) {
                filterNode.frequency.rampTo(newSettings.frequency, 0.02);
            }
            if (newSettings.Q !== undefined && filterNode.Q instanceof Tone.Param) {
                filterNode.Q.rampTo(newSettings.Q, 0.02);
            }
            if (newSettings.gain !== undefined && filterNode.gain instanceof Tone.Param) {
                filterNode.gain.rampTo(newSettings.gain, 0.02);
            }
            if (newSettings.type !== undefined) {
                const validTypes = ['lowpass', 'highpass', 'bandpass', 'lowshelf', 'highshelf', 'notch', 'allpass', 'peaking'];
                if (validTypes.includes(newSettings.type)) {
                    filterNode.type = newSettings.type;
                } else {
                    console.warn(`[FilterManager] Invalid filter type '${newSettings.type}' ignored.`);
                }
            }
            if (newSettings.rolloff !== undefined) {
                const validRolloffs = [-12, -24, -48, -96];
                if (validRolloffs.includes(newSettings.rolloff)) {
                    filterNode.rolloff = newSettings.rolloff;
                } else {
                    console.warn(`[FilterManager] Invalid filter rolloff '${newSettings.rolloff}' ignored.`);
                }
            }
            console.log("[FilterManager] update() finished.");
            const t1 = performance.now();
            console.log(`[FilterManager] update() duration: ${(t1-t0).toFixed(2)}ms`);
            return true;
        } catch (err) {
            console.error("[FilterManager] Error in update():", err);
            return false;
        }
    },

    /**
     * Соединяет фильтр с соседями по цепочке.
     */
    connectPeers(nodes, prevOutputNode, nextInputNode) {
        // Используем стандартную реализацию blankManager
        return blankManager.connectPeers(nodes, prevOutputNode, nextInputNode);
    },

    /**
     * Основной фильтр обычно не имеет состояния enable/bypass.
     */
    enable(nodes, isEnabled) {
        console.log(`[FilterManager] enable() called with ${isEnabled} (no action needed).`);
        return true;
    },

    /**
     * Подключает модулятор к параметру фильтра.
     * @param {object} nodes - Узлы этого компонента (должен содержать nodes.filter).
     * @param {string} targetParamPath - Имя целевого параметра ('frequency', 'Q', 'gain', 'detune').
     * @param {Tone.OutputNode} sourceNode - Выходной узел модулятора.
     * @returns {boolean} - true при успехе.
     */
    connectModulator(nodes, targetParamPath, sourceNode) {
        if (!nodes?.filter || !targetParamPath || !sourceNode) return false;
        let targetParamInstance = null;
        switch (targetParamPath) {
            case 'frequency': targetParamInstance = nodes.filter.frequency; break;
            case 'Q': targetParamInstance = nodes.filter.Q; break;
            case 'gain': targetParamInstance = nodes.filter.gain; break;
            case 'detune': targetParamInstance = nodes.filter.detune; break;
            default:
                console.warn(`[FilterManager] Unsupported targetParamPath: '${targetParamPath}'`);
                return false;
        }
        if (targetParamInstance && (targetParamInstance instanceof Tone.Param || targetParamInstance instanceof Tone.Signal)) {
            try {
                sourceNode.connect(targetParamInstance);
                console.log(`[FilterManager] Modulator connected to filter.${targetParamPath}`);
                return true;
            } catch (e) {
                console.error(`[FilterManager] Error connecting modulator to filter.${targetParamPath}:`, e);
                return false;
            }
        } else {
            console.warn(`[FilterManager] Target parameter 'filter.${targetParamPath}' not found or not a connectable Param/Signal. Instance:`, targetParamInstance);
            return false;
        }
    },

    /**
     * Отключает модулятор от параметра фильтра.
     */
    disconnectModulator(nodes, targetParamPath, sourceNode) {
        if (!nodes?.filter || !targetParamPath || !sourceNode) return false;
        let targetParamInstance = null;
        switch (targetParamPath) {
            case 'frequency': targetParamInstance = nodes.filter.frequency; break;
            case 'Q': targetParamInstance = nodes.filter.Q; break;
            case 'gain': targetParamInstance = nodes.filter.gain; break;
            case 'detune': targetParamInstance = nodes.filter.detune; break;
        }
        if (targetParamInstance && (targetParamInstance instanceof Tone.Param || targetParamInstance instanceof Tone.Signal)) {
            try {
                sourceNode.disconnect(targetParamInstance);
                console.log(`[FilterManager] Modulator disconnected from filter.${targetParamPath}`);
                return true;
            } catch (e) {
                console.warn(`[FilterManager] Error/Warning disconnecting modulator from filter.${targetParamPath}:`, e.message);
                return true;
            }
        }
        return true;
    },

    /**
     * Уничтожает узел фильтра.
     */
    dispose(nodes) {
        const t0 = performance.now();
        console.log("[FilterManager] dispose() called");
        if (nodes && nodes.filter) {
            try {
                nodes.filter.disconnect();
                nodes.filter.dispose();
                console.log("[FilterManager] Filter node disposed.");
            } catch (e) {
                console.warn("[FilterManager] Error disposing filter node:", e);
            }
        }
        const t1 = performance.now();
        console.log(`[FilterManager] dispose() duration: ${(t1-t0).toFixed(2)}ms`);
    }
};

// Регистрация менеджера в audioConfig
if (typeof audioConfig !== 'undefined' && typeof audioConfig.registerManager === 'function') {
    audioConfig.registerManager('filter', filterManager);
} else {
    console.error("[FilterManager] audioConfig or audioConfig.registerManager is not available.");
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\managers\lfoManager.js
// Файл: app/src/main/assets/js/managers/lfoManager.js
// Менеджер для LFO (Low Frequency Oscillator)

const lfoManager = {
    isOptional: true,

    /**
     * Создает LFO и узел для управления глубиной модуляции.
     * @param {object} initialSettings - { type, rate, depth (0-1), phase, (target - не используется здесь) }
     * @returns {object} - { nodes: { lfo, depthControl }, modOutputs: { output: depthControlOutput } ... }
     */
    create(initialSettings = {}) {
        const t0 = performance.now();
        console.log("[LFOManager] create() called with:", initialSettings);
        let nodes = { lfo: null, depth: null };
        let modOutputs = { output: null };
        let error = null;
        try {
            console.log("[LFOManager] Creating Tone.LFO and Tone.Multiply...");
            nodes.lfo = new Tone.LFO({
                frequency: initialSettings.frequency ?? 5,
                min: -1,
                max: 1,
                type: initialSettings.type || 'sine',
                phase: initialSettings.phase || 0,
            });
            nodes.depth = new Tone.Multiply(initialSettings.depth ?? 0.01); // Малый диапазон по умолчанию
            nodes.lfo.connect(nodes.depth);
            modOutputs.output = nodes.depth;
            console.log("[LFOManager] create() finished.");
        } catch (err) {
            console.error("[LFOManager] Error in create():", err);
            error = `Failed to create LFO: ${err.message}`;
            nodes = null;
            modOutputs = {};
        }
        const t1 = performance.now();
        console.log(`[LFOManager] create() duration: ${(t1-t0).toFixed(2)}ms`);
        return { nodes, audioInput: null, audioOutput: null, modOutputs, error };
    },

    update(nodes, newSettings) {
        const t0 = performance.now();
        console.log("[LFOManager] update() called with:", newSettings);
        if (!nodes?.lfo || !nodes?.depth) {
            console.warn("[LFOManager] Update called with invalid nodes.", nodes);
            return false;
        }
        try {
            if (newSettings.frequency !== undefined) nodes.lfo.frequency.value = newSettings.frequency;
            if (newSettings.type !== undefined) nodes.lfo.type = newSettings.type;
            if (newSettings.phase !== undefined) nodes.lfo.phase = newSettings.phase;
            if (newSettings.depth !== undefined && nodes.depth.factor instanceof Tone.Signal) {
                nodes.depth.factor.value = newSettings.depth;
            } else if (newSettings.depth !== undefined) {
                nodes.depth.value = newSettings.depth;
            }
            console.log("[LFOManager] update() finished.");
            const t1 = performance.now();
            console.log(`[LFOManager] update() duration: ${(t1-t0).toFixed(2)}ms`);
            return true;
        } catch (err) {
            console.error("[LFOManager] Error in update():", err);
            return false;
        }
    },

    connectPeers(nodes, prevOutputNode, nextInputNode) {
        return true;
    },

    /**
     * Включает/выключает LFO.
     * @param {object} nodes - Узлы компонента.
     * @param {boolean} isEnabled - Новое состояние.
     * @param {object} [options={}] - Доп. опции, например { retrigger: true }
     * @returns {boolean} - true при успехе.
     */
    enable(nodes, isEnabled) {
        console.log(`[LFOManager] enable() called with state: ${isEnabled}.`);
        if (nodes?.lfo) {
            if (isEnabled) nodes.lfo.start();
            else nodes.lfo.stop();
        }
        return true;
    },

    triggerAttack(nodes, time) {
        const t0 = performance.now();
        console.log(`[LFOManager] triggerAttack() called. Time: ${time}`);
        if (nodes?.lfo) {
            try {
                nodes.lfo.start(time);
                const t1 = performance.now();
                console.log(`[LFOManager] triggerAttack() duration: ${(t1-t0).toFixed(2)}ms`);
                return true;
            } catch (e) {
                console.error("[LFOManager] Error triggering LFO start:", e);
                return false;
            }
        }
        return false;
    },

    triggerRelease(nodes, time) {
        const t0 = performance.now();
        console.log(`[LFOManager] triggerRelease() called. Time: ${time}`);
        if (nodes?.lfo) {
            try {
                nodes.lfo.stop(time);
                const t1 = performance.now();
                console.log(`[LFOManager] triggerRelease() duration: ${(t1-t0).toFixed(2)}ms`);
                return true;
            } catch (e) {
                console.error("[LFOManager] Error triggering LFO stop:", e);
                return false;
            }
        }
        return false;
    },

    dispose(nodes) {
        const t0 = performance.now();
        console.log("[LFOManager] dispose() called");
        if (nodes?.lfo) {
            try {
                nodes.lfo.disconnect();
                nodes.lfo.dispose();
                console.log("[LFOManager] LFO node disposed.");
            } catch (e) {
                console.warn("[LFOManager] Error disposing LFO node:", e);
            }
        }
        if (nodes?.depth) {
            try {
                nodes.depth.disconnect();
                nodes.depth.dispose();
                console.log("[LFOManager] Multiply node disposed.");
            } catch (e) {
                console.warn("[LFOManager] Error disposing Multiply node:", e);
            }
        }
        const t1 = performance.now();
        console.log(`[LFOManager] dispose() duration: ${(t1-t0).toFixed(2)}ms`);
    }
};

if (typeof audioConfig !== 'undefined' && typeof audioConfig.registerManager === 'function') {
    audioConfig.registerManager('lfo1', lfoManager);
} else {
    console.error("[LFOManager] audioConfig or audioConfig.registerManager is not available.");
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\managers\oscillatorManager.js
// Файл: app/src/main/assets/js/managers/oscillatorManager.js
// ВЕРСИЯ V3: Тестирование Tone.Oscillator для sine, ограничение FatOsc, исправление rampTo

const oscillatorManager = {
    create(initialSettings = { type: 'triangle' }) {
        const t0 = performance.now();
        console.log("[OscillatorManager] create() called with:", initialSettings);
        let nodes = {
            oscillatorNode: null,
            oscillatorType: initialSettings.type || 'triangle'
        };
        let audioOutput = null;
        let modInputs = {};
        let error = null;
        try {
            const oscType = nodes.oscillatorType;
            const phase = initialSettings.phase ?? 0;
            const detune = 0;
            const portamentoTime = initialSettings.portamento ?? 0;
            let oscNode;
            let t_type_start, t_type_end;
            if (oscType === 'sine') {
                t_type_start = performance.now();
                console.log("[OscillatorManager] Creating Tone.Oscillator (sine)", {phase, detune, portamentoTime});
                oscNode = new Tone.Oscillator({
                    type: 'sine',
                    frequency: 440,
                    detune: detune,
                    phase: phase,
                    portamento: portamentoTime
                }).start();
                t_type_end = performance.now();
                console.log(`[OscillatorManager] Tone.Oscillator (sine) created in ${(t_type_end-t_type_start).toFixed(2)}ms`);
            } else if (["square", "sawtooth", "triangle"].includes(oscType)) {
                t_type_start = performance.now();
                console.log(`[OscillatorManager] Creating Tone.OmniOscillator (${oscType})`, {phase, detune, portamentoTime});
                oscNode = new Tone.OmniOscillator({
                    type: oscType,
                    phase: phase,
                    detune: detune,
                    portamento: portamentoTime
                }).start();
                t_type_end = performance.now();
                console.log(`[OscillatorManager] Tone.OmniOscillator (${oscType}) created in ${(t_type_end-t_type_start).toFixed(2)}ms`);
            } else if (oscType === 'pwm') {
                t_type_start = performance.now();
                console.log("[OscillatorManager] Creating Tone.PWMOscillator", {modulationFrequency: initialSettings.modulationFrequency, phase, detune, portamentoTime});
                oscNode = new Tone.PWMOscillator({
                    modulationFrequency: initialSettings.modulationFrequency ?? 0.5,
                    phase: phase,
                    detune: detune,
                    portamento: portamentoTime
                }).start();
                t_type_end = performance.now();
                console.log(`[OscillatorManager] Tone.PWMOscillator created in ${(t_type_end-t_type_start).toFixed(2)}ms`);
                if (oscNode.modulationFrequency) modInputs.modulationFrequency = oscNode.modulationFrequency;
            } else if (oscType === 'pulse') {
                t_type_start = performance.now();
                console.log("[OscillatorManager] Creating Tone.PulseOscillator", {width: initialSettings.width, phase, detune, portamentoTime});
                oscNode = new Tone.PulseOscillator({
                    width: initialSettings.width ?? 0.5,
                    phase: phase,
                    detune: detune,
                    portamento: portamentoTime
                }).start();
                t_type_end = performance.now();
                console.log(`[OscillatorManager] Tone.PulseOscillator created in ${(t_type_end-t_type_start).toFixed(2)}ms`);
                if (oscNode.width) modInputs.width = oscNode.width;
            } else if (oscType.startsWith('fat')) {
                t_type_start = performance.now();
                console.log("[OscillatorManager] Creating Tone.FatOscillator", {oscType, initialSettings});
                const baseType = oscType.substring(3).toLowerCase();
                const maxFatCount = 5;
                const currentCount = initialSettings.count ?? 3;
                const safeCount = Math.max(1, Math.min(currentCount, maxFatCount));
                oscNode = new Tone.FatOscillator({
                    type: baseType,
                    count: safeCount,
                    spread: initialSettings.spread ?? 20,
                    phase: phase,
                    detune: detune,
                    portamento: portamentoTime
                }).start();
                t_type_end = performance.now();
                console.log(`[OscillatorManager] Tone.FatOscillator created in ${(t_type_end-t_type_start).toFixed(2)}ms`);
            } else if (oscType.startsWith('am')) {
                t_type_start = performance.now();
                console.log("[OscillatorManager] Creating Tone.AMOscillator", {oscType, initialSettings});
                const baseType = oscType.substring(2).toLowerCase();
                oscNode = new Tone.AMOscillator({
                    type: baseType,
                    harmonicity: initialSettings.harmonicity ?? 1,
                    modulationType: initialSettings.modulationType ?? 'square',
                    phase: phase,
                    detune: detune,
                    portamento: portamentoTime
                }).start();
                t_type_end = performance.now();
                console.log(`[OscillatorManager] Tone.AMOscillator created in ${(t_type_end-t_type_start).toFixed(2)}ms`);
                if (oscNode.harmonicity) modInputs.harmonicity = oscNode.harmonicity;
            } else if (oscType.startsWith('fm')) {
                t_type_start = performance.now();
                console.log("[OscillatorManager] Creating Tone.FMOscillator", {oscType, initialSettings});
                const baseType = oscType.substring(2).toLowerCase();
                oscNode = new Tone.FMOscillator({
                    type: baseType,
                    harmonicity: initialSettings.harmonicity ?? 1,
                    modulationIndex: initialSettings.modulationIndex ?? 10,
                    modulationType: initialSettings.modulationType ?? 'square',
                    phase: phase,
                    detune: detune,
                    portamento: portamentoTime
                }).start();
                t_type_end = performance.now();
                console.log(`[OscillatorManager] Tone.FMOscillator created in ${(t_type_end-t_type_start).toFixed(2)}ms`);
                if (oscNode.harmonicity) modInputs.harmonicity = oscNode.harmonicity;
                if (oscNode.modulationIndex) modInputs.modulationIndex = oscNode.modulationIndex;
            } else if (["white", "pink", "brown"].includes(oscType)) {
                t_type_start = performance.now();
                console.log("[OscillatorManager] Creating Tone.Noise", {oscType});
                oscNode = new Tone.Noise(oscType).start();
                t_type_end = performance.now();
                console.log(`[OscillatorManager] Tone.Noise (${oscType}) created in ${(t_type_end-t_type_start).toFixed(2)}ms`);
            } else {
                t_type_start = performance.now();
                console.warn(`[OscillatorManager] Unsupported type: ${oscType}. Using triangle (OmniOscillator).`);
                nodes.oscillatorType = 'triangle';
                oscNode = new Tone.OmniOscillator({
                    type: 'triangle',
                    phase: phase,
                    detune: detune,
                    portamento: portamentoTime
                }).start();
                t_type_end = performance.now();
                console.log(`[OscillatorManager] Tone.OmniOscillator (triangle fallback) created in ${(t_type_end-t_type_start).toFixed(2)}ms`);
            }
            nodes.oscillatorNode = oscNode;
            audioOutput = oscNode;
            if (oscNode.frequency && (oscNode.frequency instanceof Tone.Param || oscNode.frequency instanceof Tone.Signal)) {
                modInputs.frequency = oscNode.frequency;
            }
            if (oscNode.detune && (oscNode.detune instanceof Tone.Param || oscNode.detune instanceof Tone.Signal)) {
                modInputs.detune = oscNode.detune;
            }
            console.log("[OscillatorManager] create() finished. Node type:", oscNode.constructor.name);
        } catch (err) {
            console.error("[OscillatorManager] Error in create():", err, err.stack);
            error = `Failed to create oscillator: ${err.message}`;
            nodes = null;
            audioOutput = null;
            modInputs = {};
        }
        const t1 = performance.now();
        console.log(`[OscillatorManager] create() duration: ${(t1-t0).toFixed(2)}ms`);
        return { nodes, audioInput: null, audioOutput, modInputs, modOutputs: {}, error };
    },
    update(nodes, newSettings) {
        const t0 = performance.now();
        console.log("[OscillatorManager] update() called with:", JSON.stringify(newSettings, null, 2));
        if (!nodes?.oscillatorNode || !newSettings) {
            console.warn("[OscillatorManager] Update called with invalid args", JSON.parse(JSON.stringify({ nodes, newSettings })));
            return false;
        }
        const oscNode = nodes.oscillatorNode;
        const oscType = nodes.oscillatorType;
        try {
            // Логируем состояние перед изменением
            console.log("[OscillatorManager] update() oscNode state before:", {
                frequency: oscNode.frequency?.value,
                detune: oscNode.detune?.value,
                phase: oscNode.phase,
                portamento: oscNode.portamento,
                type: oscNode.type,
                count: oscNode.count,
                spread: oscNode.spread,
                width: oscNode.width?.value,
                modulationFrequency: oscNode.modulationFrequency?.value,
                harmonicity: oscNode.harmonicity?.value,
                modulationIndex: oscNode.modulationIndex?.value,
                modulationType: oscNode.modulationType
            });
            let t_param_start, t_param_end;
            if (newSettings.frequency !== undefined && oscNode.frequency && (oscNode.frequency instanceof Tone.Param || oscNode.frequency instanceof Tone.Signal)) {
                if (oscNode.frequency.cancelScheduledValues) oscNode.frequency.cancelScheduledValues(Tone.now());
                t_param_start = performance.now();
                oscNode.frequency.value = newSettings.frequency;
                t_param_end = performance.now();
                console.log(`[OscillatorManager] frequency.value set in ${(t_param_end-t_param_start).toFixed(2)}ms`);
            }
            if (newSettings.detune !== undefined && oscNode.detune && (oscNode.detune instanceof Tone.Param || oscNode.detune instanceof Tone.Signal)) {
                if (oscNode.detune.cancelScheduledValues) oscNode.detune.cancelScheduledValues(Tone.now());
                t_param_start = performance.now();
                oscNode.detune.value = newSettings.detune;
                t_param_end = performance.now();
                console.log(`[OscillatorManager] detune.value set in ${(t_param_end-t_param_start).toFixed(2)}ms`);
            }
            if (newSettings.phase !== undefined && oscNode.hasOwnProperty('phase') && typeof oscNode.phase === 'number') {
                t_param_start = performance.now();
                oscNode.phase = newSettings.phase;
                t_param_end = performance.now();
                console.log(`[OscillatorManager] phase set in ${(t_param_end-t_param_start).toFixed(2)}ms`);
            }
            if (newSettings.portamento !== undefined && oscNode.hasOwnProperty('portamento') && typeof oscNode.portamento === 'number') {
                t_param_start = performance.now();
                oscNode.portamento = newSettings.portamento;
                t_param_end = performance.now();
                console.log(`[OscillatorManager] portamento set in ${(t_param_end-t_param_start).toFixed(2)}ms`);
            }
            switch (oscType) {
                case 'pwm':
                    if (newSettings.modulationFrequency !== undefined && oscNode.modulationFrequency && (oscNode.modulationFrequency instanceof Tone.Param || oscNode.modulationFrequency instanceof Tone.Signal)) {
                        if (oscNode.modulationFrequency.cancelScheduledValues) oscNode.modulationFrequency.cancelScheduledValues(Tone.now());
                        t_param_start = performance.now();
                        oscNode.modulationFrequency.value = newSettings.modulationFrequency;
                        t_param_end = performance.now();
                        console.log(`[OscillatorManager] modulationFrequency.value set in ${(t_param_end-t_param_start).toFixed(2)}ms`);
                    }
                    break;
                case 'pulse':
                    if (newSettings.width !== undefined && oscNode.width && (oscNode.width instanceof Tone.Param || oscNode.width instanceof Tone.Signal)) {
                        if (oscNode.width.cancelScheduledValues) oscNode.width.cancelScheduledValues(Tone.now());
                        t_param_start = performance.now();
                        oscNode.width.value = newSettings.width;
                        t_param_end = performance.now();
                        console.log(`[OscillatorManager] width.value set in ${(t_param_end-t_param_start).toFixed(2)}ms`);
                    }
                    break;
                case 'fatsine': case 'fatsquare': case 'fatsawtooth': case 'fattriangle':
                    if (newSettings.count !== undefined && oscNode.hasOwnProperty('count') && typeof oscNode.count === 'number') {
                        t_param_start = performance.now();
                        const maxFatCount = 5;
                        const newCount = Math.max(1, Math.min(parseInt(newSettings.count, 10), maxFatCount));
                        if (parseInt(newSettings.count, 10) > maxFatCount) {
                            console.warn(`[OscillatorManager] FatOscillator count (${newSettings.count}) exceeded max (${maxFatCount}). Clamped to ${newCount}.`);
                        }
                        oscNode.count = newCount;
                        t_param_end = performance.now();
                        console.log(`[OscillatorManager] count set in ${(t_param_end-t_param_start).toFixed(2)}ms`);
                    }
                    if (newSettings.spread !== undefined && oscNode.hasOwnProperty('spread') && typeof oscNode.spread === 'number') {
                        t_param_start = performance.now();
                        oscNode.spread = newSettings.spread;
                        t_param_end = performance.now();
                        console.log(`[OscillatorManager] spread set in ${(t_param_end-t_param_start).toFixed(2)}ms`);
                    }
                    break;
                case 'amtriangle': case 'amsine': case 'amsquare': case 'amsawtooth':
                    if (newSettings.harmonicity !== undefined && oscNode.harmonicity && (oscNode.harmonicity instanceof Tone.Param || oscNode.harmonicity instanceof Tone.Signal)) {
                        if (oscNode.harmonicity.cancelScheduledValues) oscNode.harmonicity.cancelScheduledValues(Tone.now());
                        t_param_start = performance.now();
                        oscNode.harmonicity.value = newSettings.harmonicity;
                        t_param_end = performance.now();
                        console.log(`[OscillatorManager] harmonicity.value set in ${(t_param_end-t_param_start).toFixed(2)}ms`);
                    }
                    if (newSettings.modulationType !== undefined && oscNode.hasOwnProperty('modulationType')) {
                        t_param_start = performance.now();
                        oscNode.modulationType = newSettings.modulationType;
                        t_param_end = performance.now();
                        console.log(`[OscillatorManager] modulationType set in ${(t_param_end-t_param_start).toFixed(2)}ms`);
                    }
                    break;
                case 'fmtriangle': case 'fmsine': case 'fmsquare': case 'fmsawtooth':
                    if (newSettings.harmonicity !== undefined && oscNode.harmonicity && (oscNode.harmonicity instanceof Tone.Param || oscNode.harmonicity instanceof Tone.Signal)) {
                        if (oscNode.harmonicity.cancelScheduledValues) oscNode.harmonicity.cancelScheduledValues(Tone.now());
                        t_param_start = performance.now();
                        oscNode.harmonicity.value = newSettings.harmonicity;
                        t_param_end = performance.now();
                        console.log(`[OscillatorManager] harmonicity.value set in ${(t_param_end-t_param_start).toFixed(2)}ms`);
                    }
                    if (newSettings.modulationIndex !== undefined && oscNode.modulationIndex && (oscNode.modulationIndex instanceof Tone.Param || oscNode.modulationIndex instanceof Tone.Signal)) {
                        if (oscNode.modulationIndex.cancelScheduledValues) oscNode.modulationIndex.cancelScheduledValues(Tone.now());
                        t_param_start = performance.now();
                        oscNode.modulationIndex.value = newSettings.modulationIndex;
                        t_param_end = performance.now();
                        console.log(`[OscillatorManager] modulationIndex.value set in ${(t_param_end-t_param_start).toFixed(2)}ms`);
                    }
                    if (newSettings.modulationType !== undefined && oscNode.hasOwnProperty('modulationType')) {
                        t_param_start = performance.now();
                        oscNode.modulationType = newSettings.modulationType;
                        t_param_end = performance.now();
                        console.log(`[OscillatorManager] modulationType set in ${(t_param_end-t_param_start).toFixed(2)}ms`);
                    }
                    break;
            }
            if (newSettings.type !== undefined && oscNode.hasOwnProperty('type')) {
                t_param_start = performance.now();
                oscNode.type = newSettings.type;
                t_param_end = performance.now();
                console.log(`[OscillatorManager] type set in ${(t_param_end-t_param_start).toFixed(2)}ms`);
            }
            console.log("[OscillatorManager] update() finished.");
            const t1 = performance.now();
            console.log(`[OscillatorManager] update() duration: ${(t1-t0).toFixed(2)}ms`);
            return true;
        } catch (err) {
            console.error("[OscillatorManager] Error in update():", err);
            return false;
        }
    },
    dispose(nodes) {
        const t0 = performance.now();
        console.log("[OscillatorManager] dispose() called");
        if (nodes?.oscillatorNode) {
            try {
                nodes.oscillatorNode.disconnect();
                nodes.oscillatorNode.dispose();
                console.log("[OscillatorManager] Oscillator node disposed.");
            } catch (e) {
                console.warn("[OscillatorManager] Error disposing oscillator node:", e);
            }
        }
        const t1 = performance.now();
        console.log(`[OscillatorManager] dispose() duration: ${(t1-t0).toFixed(2)}ms`);
    },
    connectPeers(nodes, prevOutputNode, nextInputNode) {
        return true;
    },
    enable(nodes, isEnabled) {
        return true;
    },
    connectModulator(nodes, targetParamPath, sourceNode) {
        return true;
    },
    disconnectModulator(nodes, targetParamPath, sourceNode) {
        return true;
    }
};

if (typeof audioConfig !== 'undefined' && typeof audioConfig.registerManager === 'function') {
    audioConfig.registerManager('oscillator', oscillatorManager);
} else {
    console.error("[OscillatorManager] audioConfig or audioConfig.registerManager is not available.");
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\managers\outputGainManager.js
// Файл: app/src/main/assets/js/managers/outputGainManager.js
// Менеджер для управления выходным гейном голоса (Tone.Gain)

const outputGainManager = {
    /**
     * Создает узел Tone.Gain для выходной громкости голоса.
     * @param {object} [initialSettings={ gain: 0 }] - Начальные настройки (обычно гейн = 0).
     * @returns {object} - Объект { nodes: { gainNode: Tone.Gain }, audioInput: Tone.Gain, audioOutput: Tone.Gain, modInputs: { gain }, error: string | null }
     */
    create(initialSettings = { gain: 0 }) {
        const t0 = performance.now();
        console.log("[OutputGainManager] create() called with:", initialSettings);
        let nodes = { gainNode: null };
        let audioInput = null;
        let audioOutput = null;
        let modInputs = {};
        let error = null;
        try {
            const gainNode = new Tone.Gain(0);
            nodes.gainNode = gainNode;
            audioInput = gainNode;
            audioOutput = gainNode;
            if (gainNode.gain instanceof Tone.Param) {
                modInputs.gain = gainNode.gain;
            }
            console.log("[OutputGainManager] create() finished.");
        } catch (err) {
            console.error("[OutputGainManager] Error in create():", err);
            error = `Failed to create Gain: ${err.message}`;
            nodes = null;
            audioInput = null;
            audioOutput = null;
            modInputs = {};
        }
        const t1 = performance.now();
        console.log(`[OutputGainManager] create() duration: ${(t1-t0).toFixed(2)}ms`);
        return { nodes, audioInput, audioOutput, modInputs, modOutputs: {}, error };
    },

    /**
     * Обновляет параметр gain выходного узла.
     * @param {object} nodes - Объект узлов { gainNode }.
     * @param {object} newSettings - Новые настройки { gain }.
     * @returns {boolean} - true при успехе.
     */
    update(nodes, newSettings) {
        const t0 = performance.now();
        console.log("[OutputGainManager] update() called with:", JSON.stringify(newSettings, null, 2));
        if (!nodes || !nodes.gainNode || !newSettings) {
            console.warn("[OutputGainManager] Update called with invalid args", JSON.parse(JSON.stringify({ nodes, newSettings })));
            return false;
        }
        const gainNode = nodes.gainNode;
        try {
            if (newSettings.gain !== undefined && gainNode.gain instanceof Tone.Param) {
                gainNode.gain.rampTo(newSettings.gain, 0.02);
            } else if (newSettings.gain !== undefined) {
                gainNode.gain = newSettings.gain;
                console.warn("[OutputGainManager] Updated gain directly (not ramped).");
            }
            console.log("[OutputGainManager] update() finished.");
            const t1 = performance.now();
            console.log(`[OutputGainManager] update() duration: ${(t1-t0).toFixed(2)}ms`);
            return true;
        } catch (err) {
            console.error("[OutputGainManager] Error in update():", err);
            return false;
        }
    },

    /**
     * Соединяет выходной гейн с соседями по цепочке.
     */
    connectPeers(nodes, prevOutputNode, nextInputNode) {
        if (!nodes || !nodes.gainNode || !prevOutputNode) {
            console.warn("[OutputGainManager] connectPeers called with invalid args", { nodes, prevOutputNode, nextInputNode });
            return false;
        }
        console.log("[OutputGainManager] Connecting previous node to gain input...");
        try {
            prevOutputNode.connect(nodes.gainNode);
            console.log("[OutputGainManager] Previous node connected to input.");
            return true;
        } catch (err) {
            console.error("[OutputGainManager] Error connecting input peer:", err);
            try { prevOutputNode.disconnect(nodes.gainNode); } catch(e){}
            return false;
        }
    },

    /**
     * Выходной гейн не имеет состояния enable/bypass.
     */
    enable(nodes, isEnabled) {
        console.log(`[OutputGainManager] enable() called with ${isEnabled} (no action needed).`);
        return true;
    },

    /**
     * Подключает модулятор к параметру gain (если нужно).
     */
    connectModulator(nodes, targetParamPath, sourceNode) {
        return blankManager.connectModulator(nodes, targetParamPath, sourceNode);
    },

    /**
     * Отключает модулятор от параметра gain.
     */
    disconnectModulator(nodes, targetParamPath, sourceNode) {
        return blankManager.disconnectModulator(nodes, targetParamPath, sourceNode);
    },

    /**
     * Уничтожает узел гейна.
     */
    dispose(nodes) {
        const t0 = performance.now();
        console.log("[OutputGainManager] dispose() called");
        if (nodes && nodes.gainNode) {
            try {
                nodes.gainNode.disconnect();
                nodes.gainNode.dispose();
                console.log("[OutputGainManager] Gain node disposed.");
            } catch (e) {
                console.warn("[OutputGainManager] Error disposing gain node:", e);
            }
        }
        const t1 = performance.now();
        console.log(`[OutputGainManager] dispose() duration: ${(t1-t0).toFixed(2)}ms`);
    }
};

// Регистрация менеджера в audioConfig
if (typeof audioConfig !== 'undefined' && typeof audioConfig.registerManager === 'function') {
    audioConfig.registerManager('outputGain', outputGainManager);
} else {
    console.error("[OutputGainManager] audioConfig or audioConfig.registerManager is not available.");
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\managers\pitchEnvManager.js
// Файл: app/src/main/assets/js/managers/pitchEnvManager.js
// Менеджер для огибающей высоты тона (Pitch Envelope)

const pitchEnvManager = {
    isOptional: true, // Это опциональный компонент

    /**
     * Создает узлы Tone.Envelope и Tone.Multiply для управления питчем.
     * @param {object} initialSettings - Настройки из пресета (секция pitchEnvelope).
     * @returns {object} - { nodes: object|null, audioInput: null, audioOutput: null, modOutputs?: object, error: string|null }
     */
    create(initialSettings = {}) {
        const t0 = performance.now();
        console.log("[PitchEnvManager] create() called with:", initialSettings);
        let nodes = {};
        let modOutputs = {}; // Выход для подключения к detune
        let error = null;

        // Компонент создается, только если enabled: true (проверяется в voiceBuilder)
        // Здесь мы просто создаем узлы на основе переданных настроек

        try {
            console.log("[PitchEnvManager] Creating Tone.Envelope and Tone.Multiply...");
            nodes.env = new Tone.Envelope({
                attack: initialSettings.attack ?? 0.1,
                decay: initialSettings.decay ?? 0.1,
                sustain: initialSettings.sustain ?? 0.5,
                release: initialSettings.release ?? 0.2,
                attackCurve: initialSettings.attackCurve || 'linear',
                // decay/release curve не поддерживаются в Tone.Envelope напрямую
            });

            // Узел для масштабирования выхода огибающей (0-1) в центы
            nodes.amount = new Tone.Multiply(initialSettings.amount ?? 100);

            // Соединяем выход огибающей с входом умножителя
            nodes.env.connect(nodes.amount);

            // Выход модулятора - это выход умножителя
            modOutputs.pitch = nodes.amount; // Стандартизированное имя выхода

            console.log("[PitchEnvManager] create() finished.");

        } catch (err) {
            console.error("[PitchEnvManager] Error in create():", err);
            error = `Failed to create PitchEnvelope nodes: ${err.message}`;
            nodes = null;
            modOutputs = {};
        }

        const t1 = performance.now();
        console.log(`[PitchEnvManager] create() duration: ${(t1-t0).toFixed(2)}ms`);
        // Pitch Env не имеет прямого аудио входа/выхода
        return { nodes, audioInput: null, audioOutput: null, modOutputs, error };
    },

    /**
     * Обновляет параметры огибающей и amount.
     * @param {object} nodes - Объект узлов (nodes.env, nodes.amount).
     * @param {object} newSettings - Новые настройки.
     * @returns {boolean} - true при успехе.
     */
    update(nodes, newSettings) {
        const t0 = performance.now();
        console.log("[PitchEnvManager] update() called with:", newSettings);
        if (!nodes?.env || !nodes?.amount) {
            console.warn("[PitchEnvManager] Update called with invalid nodes.", nodes);
            return false;
        }
        try {
            const envSettings = {};
            if (newSettings.attack !== undefined) envSettings.attack = newSettings.attack;
            if (newSettings.decay !== undefined) envSettings.decay = newSettings.decay;
            if (newSettings.sustain !== undefined) envSettings.sustain = newSettings.sustain;
            if (newSettings.release !== undefined) envSettings.release = newSettings.release;
            if (newSettings.attackCurve !== undefined) envSettings.attackCurve = newSettings.attackCurve;
            if (Object.keys(envSettings).length > 0) {
                nodes.env.set(envSettings);
            }
            if (newSettings.amount !== undefined && nodes.amount.factor instanceof Tone.Signal) {
                nodes.amount.factor.value = newSettings.amount;
            } else if (newSettings.amount !== undefined) {
                nodes.amount.value = newSettings.amount;
            }
            console.log("[PitchEnvManager] update() finished.");
            const t1 = performance.now();
            console.log(`[PitchEnvManager] update() duration: ${(t1-t0).toFixed(2)}ms`);
            return true;
        } catch (err) {
            console.error("[PitchEnvManager] Error in update():", err);
            return false;
        }
    },

    /** Pitch Env не участвует в основной аудио цепочке */
    connectPeers(nodes, prevOutputNode, nextInputNode) {
        return true;
    },

    /**
     * Включает/выключает эффект огибающей.
     * В данной реализации это управляется подключением/отключением к цели (detune) в voiceBuilder/synth.
     * Этот метод может быть пустым или управлять внутренним состоянием, если нужно.
     * @param {object} nodes - Узлы компонента.
     * @param {boolean} isEnabled - Новое состояние.
     * @returns {boolean} - true.
     */
    enable(nodes, isEnabled) {
        console.log(`[PitchEnvManager] enable() called with state: ${isEnabled}. Connection handled elsewhere.`);
        // Логика включения/выключения (если не через connect/disconnect)
        // Например, можно установить amount в 0 при выключении:
        // if (nodes?.amount?.factor instanceof Tone.Signal) {
        //     nodes.amount.factor.value = isEnabled ? (nodes.amount._savedValue || 100) : 0;
        //     if (isEnabled) delete nodes.amount._savedValue; else nodes.amount._savedValue = nodes.amount.factor.value;
        // }
        return true;
    },

     /** Запуск атаки огибающей */
    triggerAttack(nodes, time) {
        const t0 = performance.now();
        console.log(`[PitchEnvManager] triggerAttack() called. Time: ${time}`);
        if (nodes?.env) {
            try {
                nodes.env.triggerAttack(time);
                const t1 = performance.now();
                console.log(`[PitchEnvManager] triggerAttack() duration: ${(t1-t0).toFixed(2)}ms`);
                return true;
            } catch (e) {
                console.error("[PitchEnvManager] Error triggering attack:", e);
                return false;
            }
        }
        return false;
    },

    /** Запуск затухания огибающей */
    triggerRelease(nodes, time) {
        const t0 = performance.now();
        console.log(`[PitchEnvManager] triggerRelease() called. Time: ${time}`);
        if (nodes?.env) {
            try {
                nodes.env.triggerRelease(time);
                const t1 = performance.now();
                console.log(`[PitchEnvManager] triggerRelease() duration: ${(t1-t0).toFixed(2)}ms`);
                return true;
            } catch (e) {
                console.error("[PitchEnvManager] Error triggering release:", e);
                return false;
            }
        }
        return false;
    },

    /** Освобождает ресурсы */
    dispose(nodes) {
        const t0 = performance.now();
        console.log("[PitchEnvManager] dispose() called");
        if (nodes?.env) {
            try {
                nodes.env.disconnect();
                nodes.env.dispose();
                console.log("[PitchEnvManager] Envelope node disposed.");
            } catch (e) {
                console.warn("[PitchEnvManager] Error disposing Envelope node:", e);
            }
        }
        if (nodes?.amount) {
            try {
                nodes.amount.disconnect();
                nodes.amount.dispose();
                console.log("[PitchEnvManager] Multiply node disposed.");
            } catch (e) {
                console.warn("[PitchEnvManager] Error disposing Multiply node:", e);
            }
        }
        const t1 = performance.now();
        console.log(`[PitchEnvManager] dispose() duration: ${(t1-t0).toFixed(2)}ms`);
    }
};

// Регистрация менеджера
if (typeof audioConfig !== 'undefined' && audioConfig.registerManager) {
    audioConfig.registerManager('pitchEnvelope', pitchEnvManager);
} else {
    console.error("[PitchEnvManager] Unable to register manager: audioConfig or registerManager function not found.");
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\managers\reverbFxManager.js

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\managers\settingsManager.js
// Файл: app/src/main/assets/js/managers/settingsManager.js
const settingsManager = {
    appRef: null, // Ссылка на главный объект app
    isInitialized: false,
    isLoading: false,
    isSaving: false,
    debounceTimeoutId: null,
    debounceDelay: 1500, // 1.5 секунды задержки для сохранения часто изменяемых настроек

    defaultSettingsPath: 'https://appassets.androidplatform.net/assets/config/defaultAppSettings.json', // Полный путь

    /**
     * Инициализирует менеджер настроек.
     * @param {object} appInstance - Ссылка на главный объект приложения (app).
     */
    init(appInstance) {
        if (this.isInitialized) {
            console.warn("[SettingsManager] Already initialized.");
            return;
        }
        this.appRef = appInstance;
        if (!this.appRef) {
            console.error("[SettingsManager.init] App reference not provided!");
            return;
        }
        this.isInitialized = true;
        console.log("[SettingsManager] Initialized. Debounce delay:", this.debounceDelay);
    },

    /**
     * Загружает настройки с нативной стороны или из defaultAppSettings.json.
     * Не применяет их к app.state, а просто возвращает.
     * @returns {Promise<object|null>} Объект с настройками или null при ошибке.
     */
    async _loadSettings() {
        if (!this.isInitialized || !this.appRef) {
            console.error("[SettingsManager._loadSettings] Not initialized or appRef missing.");
            return null;
        }
        if (this.isLoading) {
            console.warn("[SettingsManager._loadSettings] Settings are already being loaded.");
            return null; // Или вернуть Promise, который уже в процессе
        }
        this.isLoading = true;
        console.log("[SettingsManager._loadSettings] Attempting to load settings...");

        let nativeSettings = null;
        if (this.appRef.state.isBridgeReady) {
            try {
                console.log("[SettingsManager._loadSettings] Fetching all settings from native bridge...");
                const settingsJson = await bridgeFix.callBridge('getAllSettings');
                if (settingsJson) {
                    nativeSettings = JSON.parse(settingsJson);
                    console.log("[SettingsManager._loadSettings] Successfully loaded settings from native:", nativeSettings);
                } else {
                    console.warn("[SettingsManager._loadSettings] Native bridge returned null or empty settings.");
                }
            } catch (error) {
                console.error("[SettingsManager._loadSettings] Error loading settings from native bridge:", error);
                nativeSettings = null; // Ошибка при загрузке с моста
            }
        } else {
            console.warn("[SettingsManager._loadSettings] Bridge not ready, skipping native settings load.");
        }

        this.isLoading = false;

        if (nativeSettings && Object.keys(nativeSettings).length > 0) {
            return nativeSettings;
        } else {
            // Если с нативной стороны ничего не пришло, грузим дефолты из JSON
            console.log("[SettingsManager._loadSettings] No native settings found or error, attempting to load from default JSON.");
            return this._loadDefaultSettingsFromJSON();
        }
    },

    /**
     * Загружает настройки из файла defaultAppSettings.json.
     * @returns {Promise<object|null>}
     */
    async _loadDefaultSettingsFromJSON() {
        try {
            console.log(`[SettingsManager._loadDefaultSettingsFromJSON] Fetching default settings from: ${this.defaultSettingsPath}`);
            const response = await fetch(this.defaultSettingsPath);
            if (!response.ok) {
                throw new Error(`Failed to fetch default settings: ${response.status} ${response.statusText}`);
            }
            const defaultSettings = await response.json();
            console.log("[SettingsManager._loadDefaultSettingsFromJSON] Successfully loaded default settings from JSON:", defaultSettings);
            return defaultSettings;
        } catch (error) {
            console.error("[SettingsManager._loadDefaultSettingsFromJSON] Error loading default settings from JSON:", error);
            return null; // Возвращаем null при ошибке загрузки/парсинга JSON
        }
    },

    /**
     * Основной метод, вызываемый из app.js.
     * Загружает настройки и, если успешно, возвращает их.
     * Если загрузка не удалась, возвращает null, чтобы app.js использовал свои встроенные дефолты.
     * @returns {Promise<object|null>} Загруженные настройки или null.
     */
    async loadAndApplySettings() {
        if (!this.isInitialized) {
            console.error("[SettingsManager.loadAndApplySettings] Not initialized.");
            return null;
        }
        console.log("[SettingsManager.loadAndApplySettings] Starting load and apply process...");

        let loadedSettings = await this._loadSettings();

        if (loadedSettings && Object.keys(loadedSettings).length > 0) {
            console.log("[SettingsManager.loadAndApplySettings] Settings loaded/defaulted successfully:", loadedSettings);
            return loadedSettings;
        } else {
            console.warn("[SettingsManager.loadAndApplySettings] No settings could be loaded (native or JSON). App will use its internal defaults.");
            return null; // Сигнализируем app.js, что нужно использовать его собственные дефолты
        }
        // Применение к app.state будет происходить в app.js на основе возвращенного объекта
    },

    /**
     * Собирает текущее состояние из app.state для сохранения.
     * @returns {object} Объект с настройками для сохранения.
     */
    _collectStateForSaving() {
        if (!this.appRef || !this.appRef.state) {
            console.error("[SettingsManager._collectStateForSaving] App reference or state is missing.");
            return {};
        }
        // Собираем только те поля, которые хотим сохранять
        const {
            theme, language, soundPreset, fxChain, visualizer, touchEffect,
            scale, octaveOffset, zoneCount, showNoteNames, showLines, yAxisControls
        } = this.appRef.state;

        return {
            theme, language, soundPreset, fxChain, visualizer, touchEffect,
            scale, octaveOffset, zoneCount, showNoteNames, showLines,
            yAxisControls: { ...yAxisControls } // Глубокое копирование для yAxisControls
        };
    },

    /**
     * Сохраняет текущее состояние настроек на нативную сторону.
     * @param {object} [options={}]
     * @param {boolean} [options.forceImmediate=false] - Если true, сохраняет немедленно.
     */
    async saveStateToNative(options = {}) {
        if (!this.isInitialized || !this.appRef?.state?.isBridgeReady) {
            console.warn("[SettingsManager.saveStateToNative] Not initialized or bridge not ready. Save skipped.");
            return;
        }
        if (this.isSaving && !options.forceImmediate) {
            console.log("[SettingsManager.saveStateToNative] Already saving, call queued or will be handled by debounce.");
            return;
        }

        this.isSaving = true;
        const settingsToSave = this._collectStateForSaving();
        console.log(`[SettingsManager.saveStateToNative] Saving settings to native (Immediate: ${!!options.forceImmediate}):`, JSON.parse(JSON.stringify(settingsToSave)));

        try {
            await bridgeFix.callBridge('saveAllSettings', JSON.stringify(settingsToSave));
            console.log("[SettingsManager.saveStateToNative] Settings successfully saved to native.");
        } catch (error) {
            console.error("[SettingsManager.saveStateToNative] Error saving settings to native:", error);
        } finally {
            this.isSaving = false;
        }
    },

    /**
     * Отложенное сохранение состояния.
     */
    debouncedSaveState() {
        if (!this.isInitialized) return;

        if (this.debounceTimeoutId) {
            clearTimeout(this.debounceTimeoutId);
        }
        this.debounceTimeoutId = setTimeout(() => {
            this.saveStateToNative({ forceImmediate: true }); // Дебаунс истек, сохраняем немедленно
            this.debounceTimeoutId = null;
        }, this.debounceDelay);
        // console.log("[SettingsManager.debouncedSaveState] Save call debounced."); // Можно раскомментировать для отладки
    }
};
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\managers\voiceFxSlotManager.js
const voiceFxSlotManager = {
    isOptional: true,
    create() {
        const bypassNode = new Tone.Gain(1).toDestination(); // Временно в toDestination, чтобы не было ошибок
        return {
            nodes: { bypass: bypassNode },
            audioInput: bypassNode,
            audioOutput: bypassNode,
            error: null
        };
    },
    update() { return true; },
    connectPeers(nodes, prev, next) {
        if (nodes?.bypass && prev && next) {
            prev.connect(nodes.bypass);
            nodes.bypass.connect(next);
            return true;
        }
        return false; // Или true если некритично
     },
    enable() { return true; },
    dispose(nodes) { if (nodes?.bypass) nodes.bypass.dispose(); },
    connectModulator() { return false; },
    disconnectModulator() { return true; }
};
// Регистрация менеджера, если она не в audioConfig.js
// if (typeof audioConfig !== 'undefined') audioConfig.registerManager('VOICE_INSERT_FX_SLOT', voiceFxSlotManager);
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\moduleManager.js
// Файл: app/src/main/assets/js/moduleManager.js
// Manages interaction with Java ModuleManager via the bridge
const moduleManager = {
    modules: {}, // Cache for loaded module lists { type: [ModuleInfo, ...], ... }
    moduleDataCache: {}, // Cache for individual module data { id: ModuleInfo, ... } - Storing full ModuleInfo

    async init() {
        console.log('[ModuleManager.init] Initializing...');
        // Pre-fetch common module types on init? Could improve perceived performance.
        // await this.getModules('soundpreset');
        // await this.getModules('fxchain');
        // await this.getModules('theme');
        // await this.getModules('language');
        // Or fetch on demand as currently implemented.
    },

    /**
     * Fetches the list of modules for a given type from the bridge.
     * Uses cache unless forceRefresh is true.
     * @param {string} moduleTypeInput - e.g., 'soundpreset', 'theme'
     * @param {boolean} forceRefresh - If true, bypasses cache.
     * @returns {Promise<Array<object>>} - Array of ModuleInfo objects (as received from Java).
     */
    async getModules(moduleTypeInput, forceRefresh = false) {
        // Apply lowercase normalization only for specific types if needed, otherwise keep original case
        let moduleType = moduleTypeInput;
        if (moduleTypeInput === 'fxChain') { // Assuming 'fxChain' is the only type expected in lowercase by Java
             moduleType = moduleTypeInput.toLowerCase(); // Normalisasi только для fxChain
        }
        // Для других типов (например, 'touchEffect', 'theme') оставляем исходный регистр

        console.log(`[ModuleManager.getModules] Input moduleType: ${moduleTypeInput}, forceRefresh: ${forceRefresh}. Processed type: ${moduleType}`);
        if (!moduleType) {
            console.error("[ModuleManager.getModules] Called with null or empty moduleType after processing.");
            return [];
        }

        if (!forceRefresh && this.modules[moduleType]) {
            console.log(`[ModuleManager.getModules] Returning cached modules for type: ${moduleType} (${this.modules[moduleType].length} items)`);
            return this.modules[moduleType];
        }

        console.log(`[ModuleManager.getModules] Fetching modules via bridge for type: ${moduleType} (Force refresh: ${forceRefresh})`);
        try {
            const modulesJson = await bridgeFix.callBridge('getModules', moduleType);
            if (modulesJson) {
                const parsedModules = JSON.parse(modulesJson);
                // Basic validation
                if (Array.isArray(parsedModules)) {
                     console.log(`[ModuleManager.getModules] Fetched ${parsedModules.length} modules for ${moduleType}. Caching...`);
                     this.modules[moduleType] = parsedModules;
                     // Cache individual module data (the full ModuleInfo object)
                     parsedModules.forEach(mod => {
                         if (mod && mod.id) { // Basic check for valid module structure
                             this.moduleDataCache[mod.id] = mod; // Store the whole ModuleInfo object
                         } else {
                              console.warn(`[ModuleManager.getModules] Invalid module structure found in list for type ${moduleType}:`, mod);
                         }
                     });
                     return parsedModules;
                } else {
                    console.error(`[ModuleManager.getModules] Invalid module list format received for ${moduleType}. Expected array, got:`, typeof parsedModules);
                    this.modules[moduleType] = []; // Cache empty array
                    return [];
                }
            } else {
                 console.warn(`[ModuleManager.getModules] Received null or empty module list for ${moduleType} from bridge.`);
                 this.modules[moduleType] = [];
                 return [];
            }
        } catch (error) {
            console.error(`[ModuleManager.getModules] Error fetching or parsing modules for type ${moduleType}:`, error, error.stack);
            this.modules[moduleType] = []; // Return empty on error
            return [];
        }
    },

    /**
     * Gets the full ModuleInfo object for a specific module by its ID.
     * Uses cache first, then falls back to fetching the list if needed.
     * @param {string} moduleId - The unique ID of the module.
     * @returns {Promise<object|null>} - The ModuleInfo object including data, or null if not found.
     */
    async getModule(moduleId) {
        if (!moduleId) {
             console.warn("[ModuleManager.getModule] Called with null or empty moduleId.");
             return null;
        }

        if (this.moduleDataCache[moduleId]) {
            // console.log(`[ModuleManager.getModule] Returning cached data for module: ${moduleId}`);
            return this.moduleDataCache[moduleId];
        }

        console.log(`[ModuleManager.getModule] Module ${moduleId} not in cache, searching lists...`);
        const knownTypes = ['soundpreset', 'fxchain', 'theme', 'language', 'visualizer', 'effect', 'scale', 'touchEffect'];

        for (const type of knownTypes) {
             // Ensure list for this type is fetched if not already cached
             if (!this.modules[type]) {
                 console.log(`[ModuleManager.getModule] Cache miss for type ${type}, fetching list...`);
                 await this.getModules(type); // Fetch and cache the list
             }
             // Check the (potentially newly fetched) list
             const moduleList = this.modules[type];
             if (Array.isArray(moduleList)) {
                 const foundModule = moduleList.find(mod => mod && mod.id === moduleId);
                 if (foundModule) {
                     console.log(`[ModuleManager.getModule] Found module ${moduleId} in type ${type}`);
                     // Cache it again just in case (should already be cached by getModules)
                     this.moduleDataCache[moduleId] = foundModule;
                     return foundModule;
                 }
             } else {
                  console.warn(`[ModuleManager.getModule] Module list for type ${type} is not an array after fetching.`);
             }
        }

        console.warn(`[ModuleManager.getModule] Module with ID ${moduleId} not found after searching all known types.`);
        return null;
    },

    /**
     * Clears the module cache. Useful if modules are updated externally.
     */
    clearCache() {
        console.log('[ModuleManager.clearCache] Clearing module cache.');
        this.modules = {};
        this.moduleDataCache = {};
    },

    /**
     * Refreshes the cache for a specific module type or all types.
     * @param {string} [moduleType] - Optional. The type to refresh. If null, refreshes all known types.
     */
     async refreshCache(moduleType = null) {
         if (moduleType) {
             console.log(`[ModuleManager.refreshCache] Refreshing cache for type: ${moduleType}`);
             await this.getModules(moduleType, true); // Force refresh for specific type
         } else {
             console.log("[ModuleManager.refreshCache] Refreshing cache for all known types...");
             const knownTypes = Object.keys(this.modules); // Refresh types already in cache
             // Or use a predefined list:
             // const knownTypes = ['soundpreset', 'fxchain', 'theme', 'language', 'visualizer', 'effect', 'scale'];
             for (const type of knownTypes) {
                 await this.getModules(type, true);
             }
             console.log("[ModuleManager.refreshCache] All known types refreshed.");
         }
     }
};
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\pad.js
const pad = {
    container: null,
    visualizerCanvas: null,
    zonesContainer: null,
    labelsContainer: null,
    isReady: false,
    zonesData: [],
    activeTouchesInternal: new Map(),
    config: {
        labelVisibility: true,
        linesVisibility: true, // Это значение будет управляться через toggleLines
        debug: true,
        touchEndTolerance: 300
    },
    lastY: 0.5,
    lastInteractionTime: 0,
    cachedRect: null,
    _currentDisplayedZones: [],
    _currentVisualHints: [], // Храним текущие подсказки

    init(containerElement) {
        console.log('[Pad v8 - PadMode Integration] Initializing...');
        if (!containerElement) {
            console.error('[Pad v8] Container element not provided!');
            this.isReady = false; return;
        }
        this.container = containerElement;
        this.visualizerCanvas = this.container.querySelector('#xy-visualizer');
        this.zonesContainer = this.container.querySelector('#xy-zones');
        this.labelsContainer = this.container.querySelector('#xy-labels');

        if (!this.visualizerCanvas || !this.zonesContainer || !this.labelsContainer) {
            console.error('[Pad v8] Missing required child elements (visualizer, zones, or labels).');
            this.isReady = false; return;
        }
        // Устанавливаем начальное состояние видимости линий из app.state, если app уже доступно
        if (typeof app !== 'undefined' && app.state && app.state.highlightSharpsFlats && zone.isSharpFlat) {
             console.log(`[Pad.drawZones] Applying .sharp-flat-zone to ${zone.noteName}`);
             zoneElement.classList.add('sharp-flat-zone');
        }

        this.addEventListeners();
        this.addGlobalSafetyHandlers();
        this.updateCachedRect();
        window.addEventListener('resize', this.updateCachedRect.bind(this));
        this.isReady = true;
        console.log('[Pad v8] Initialized successfully.');
    },

    updateCachedRect() {
        if (this.container) {
            this.cachedRect = this.container.getBoundingClientRect();
        } else {
            this.cachedRect = null;
        }
    },

    addGlobalSafetyHandlers() {
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) { this.emergencyCleanup(); }
        });
        window.addEventListener('blur', () => { this.emergencyCleanup(); });
    },

    emergencyCleanup() {
        console.warn("[Pad v8] Emergency Cleanup triggered.");
        if (typeof synth !== 'undefined' && synth.forceStopAllNotes) {
            synth.forceStopAllNotes();
        }
        this.activeTouchesInternal.forEach((touchData) => {
            if (typeof visualizer !== 'undefined' && typeof visualizer.notifyTouchUp === 'function') {
                visualizer.notifyTouchUp(touchData.pointerId);
            }
        });
        this.activeTouchesInternal.clear();
    },

    addEventListeners() {
        if (!this.container) return;
        const eventOptions = { passive: false, capture: true };
        this.container.addEventListener('pointerdown', this.handlePointerDown.bind(this), eventOptions);
        this.container.addEventListener('pointermove', this.handlePointerMove.bind(this), eventOptions);
        this.container.addEventListener('pointerup', this.handlePointerUpOrCancel.bind(this), eventOptions);
        this.container.addEventListener('pointercancel', this.handlePointerUpOrCancel.bind(this), eventOptions);
        this.container.addEventListener('pointerleave', this.handlePointerLeave.bind(this), eventOptions);
        this.container.addEventListener('contextmenu', (e) => e.preventDefault());
    },

    async updateZones() {
        if (!this.isReady || !PadModeManager || !PadModeManager.getCurrentStrategy()) {
            console.warn(`[Pad.updateZones] Aborting: Not ready or no strategy. PadReady: ${this.isReady}`);
            if (this.isReady) this.drawZones([], app.state.currentTonic);
            return;
        }
        console.log(`[Pad.updateZones] Updating zones for mode: ${PadModeManager.getCurrentModeId()}.`);
        try {
            const currentStrategy = PadModeManager.getCurrentStrategy();
            const layoutContext = await currentStrategy.getZoneLayoutOptions(app.state);
            if (!layoutContext) {
                console.warn("[Pad.updateZones] No layout context from strategy. Pad cleared.");
                this.drawZones([], app.state.currentTonic);
                return;
            }
            const servicesForStrategy = { musicTheoryService: MusicTheoryService };
            const zonesData = await currentStrategy.generateZoneData(layoutContext, app.state, servicesForStrategy);
            this.drawZones(zonesData, app.state.currentTonic);
            if (typeof currentStrategy.getPadVisualHints === 'function') {
                console.log(`[Pad.updateZones] Calling getPadVisualHints for mode: ${PadModeManager.getCurrentModeId()}`);
                const hints = await currentStrategy.getPadVisualHints(this._currentDisplayedZones, app.state, servicesForStrategy);
                console.log(`[Pad.updateZones] Hints received:`, hints ? JSON.parse(JSON.stringify(hints)) : hints);
                this.applyVisualHints(hints);
            } else {
                this.applyVisualHints([]);
            }
        } catch (error) {
            console.error('[Pad.updateZones] Error:', error, error.stack);
            if (this.isReady) this.drawZones([], app.state.currentTonic);
        }
    },

    applyVisualHints(hintsArray) {
        if (!this.isReady) return;
        this._currentVisualHints = hintsArray || [];
        const visualizerHintsPayload = [];
        this.zonesContainer.querySelectorAll('.xy-pad-zone-area').forEach(zoneEl => {
            const hintClasses = Array.from(zoneEl.classList).filter(cls => cls.startsWith('hint-'));
            if (hintClasses.length > 0) zoneEl.classList.remove(...hintClasses);
        });
        if (this._currentVisualHints.length === 0) {
            if (typeof visualizer !== 'undefined' && typeof visualizer.updatePadHints === 'function') {
                visualizer.updatePadHints([]);
            }
            return;
        }
        this._currentVisualHints.forEach(hint => {
            const zone = this._currentDisplayedZones[hint.zoneIndex];
            if (zone) {
                if (hint.styleClass && hint.type === 'active_note') {
                    const zoneDivs = this.zonesContainer.querySelectorAll('.xy-pad-zone-area');
                    const targetZoneDiv = zoneDivs[hint.zoneIndex];
                    if (targetZoneDiv) {
                        targetZoneDiv.classList.add(hint.styleClass);
                    }
                }
                const hintXcenterNormalized = zone.startX + (zone.endX - zone.startX) / 2;
                let color = hint.colorHint || '#FFFFFF';
                let sizeFactor = 1.0;
                let intensity = 1.0;
                if (hint.function === 'ACTIVE') {
                    sizeFactor = 1.2; intensity = 1.0;
                }
                visualizerHintsPayload.push({
                    id: `padhint_${zone.index}_${hint.function || hint.type}`,
                    x: hintXcenterNormalized,
                    yPosOnCanvas: 0.03,
                    color: color,
                    type: hint.function || hint.type,
                    intensity: intensity,
                    sizeFactor: sizeFactor
                });
            }
        });
        if (typeof visualizer !== 'undefined' && typeof visualizer.updatePadHints === 'function') {
            visualizer.updatePadHints(visualizerHintsPayload);
        }
    },

    drawZones(zonesData, currentTonicNoteName) {
        console.log(`[Pad.drawZones ENTRY v8.1] Received zonesData (length: ${zonesData ? zonesData.length : 'null/undefined'}), currentTonic: ${currentTonicNoteName}`);
        if (!this.isReady || !this.zonesContainer || !this.labelsContainer) return;
        if (zonesData && zonesData.length > 0) console.log("[Pad.drawZones] First zone example:", JSON.stringify(zonesData[0]));

        console.log(`[Pad.drawZones v8] Drawing ${zonesData.length} zones. Current tonic: ${currentTonicNoteName}`);
        this._currentDisplayedZones = Array.isArray(zonesData) ? zonesData : [];

        this.zonesContainer.innerHTML = '';
        this.labelsContainer.innerHTML = '';

        if (this._currentDisplayedZones.length === 0) {
            console.warn("[Pad.drawZones v8] No zonesData to draw.");
            return;
        }

        let borderColorRgb = '224, 224, 224';
        let textColor = '#757575';
        let noteColorsForLabels = {};

        try {
            const computedStyle = getComputedStyle(document.body);
            borderColorRgb = computedStyle.getPropertyValue('--color-border-rgb').trim() || borderColorRgb;
            textColor = computedStyle.getPropertyValue('--color-text-secondary').trim() || textColor;
            if (typeof visualizer !== 'undefined' && visualizer.themeColors) {
                 noteColorsForLabels = visualizer.noteColors ||
                                       { 0: '#FF0000', 1: '#FF4500', 2: '#FFA500', 3: '#FFD700', 4: '#FFFF00', 5: '#9ACD32', 6: '#32CD32', 7: '#00BFFF', 8: '#0000FF', 9: '#8A2BE2', 10: '#FF00FF', 11: '#FF1493' };
            } else {
                noteColorsForLabels = { 0: '#FF0000', 1: '#FF4500', 2: '#FFA500', 3: '#FFD700', 4: '#FFFF00', 5: '#9ACD32', 6: '#32CD32', 7: '#00BFFF', 8: '#0000FF', 9: '#8A2BE2', 10: '#FF00FF', 11: '#FF1493' };
            }
        } catch (e) { console.warn("[Pad v8 drawZones] Error getting styles/colors:", e); }

        const zoneLineColor = `rgba(${borderColorRgb}, ${this.config.linesVisibility ? 0.4 : 0})`;

        this._currentDisplayedZones.forEach((zone, index) => {
            console.log(`[Pad.drawZones] Drawing zone ${index}:`, zone.noteName,`startX: ${zone.startX}, width: ${(zone.endX - zone.startX) * 100}%`);
            zone.index = index;

            const zoneElement = document.createElement('div');
            zoneElement.className = 'xy-pad-zone-area';
            zoneElement.style.left = `${zone.startX * 100}%`;
            zoneElement.style.width = `${(zone.endX - zone.startX) * 100}%`;

            if (app.state.highlightSharpsFlats && zone.isSharpFlat) {
                zoneElement.classList.add('sharp-flat-zone');
            }
            if (zone.noteName === currentTonicNoteName) {
                zoneElement.classList.add('tonic-zone');
            }

            this.zonesContainer.appendChild(zoneElement);

            if (this.config.linesVisibility && index > 0) {
                const lineElement = document.createElement('div');
                lineElement.className = 'xy-zone-divider';
                lineElement.style.left = `${zone.startX * 100}%`;
                lineElement.style.borderLeftColor = zoneLineColor;
                this.zonesContainer.appendChild(lineElement);
            }

            if (this.config.labelVisibility && zone.startX !== undefined && zone.endX !== undefined) {
                const label = document.createElement('div');
                label.className = 'xy-label';
                label.textContent = zone.labelOverride || zone.noteName || '?';
                label.style.color = textColor;
                const labelX = ((zone.startX + zone.endX) / 2) * 100;
                label.style.left = `${labelX}%`;
                if (zone.midiNote !== undefined && noteColorsForLabels) {
                    const noteIndex = zone.midiNote % 12;
                    label.style.borderBottomColor = noteColorsForLabels[noteIndex] || 'transparent';
                }
                this.labelsContainer.appendChild(label);
            }
        });
        if (this.config.linesVisibility && this._currentDisplayedZones.length > 0) {
            const lastLine = document.createElement('div');
            lastLine.className = 'xy-zone-divider'; lastLine.style.left = `100%`;
            lastLine.style.borderLeftColor = zoneLineColor;
            this.zonesContainer.appendChild(lastLine);
        }
        // this.applyVisualHints(this._currentVisualHints); // Раскомментируйте, если нужно
    },

    _getPadContext() {
        return {
            appState: app.state,
            synthRef: synth,
            padDimensions: this.cachedRect ? { width: this.cachedRect.width, height: this.cachedRect.height } : null
        };
    },

    async handlePointerDown(event) {
        if (app && !app.state.isAudioReady && !app.state.hasUserInteracted) {
            app.state.hasUserInteracted = true;
            try {
                await Tone.start();
                if (Tone.context.state === 'running') { app.state.isAudioReady = true; }
                else { throw new Error(`Audio context state: ${Tone.context.state}`); }
            } catch (error) {
                console.error('[Pad v8] Failed to start audio context:', error);
                app.state.hasUserInteracted = false; app.state.isAudioReady = false; return;
            }
        }
        if (!this.isReady || !app?.state.isAudioReady || !synth?.isReady) return;
        if (event.pointerType === 'mouse' && event.button !== 0) return;

        event.preventDefault();
        this.lastInteractionTime = Date.now();
        try { this.container.setPointerCapture(event.pointerId); }
        catch (e) { console.warn(`[Pad v8] Failed to capture pointer ${event.pointerId}:`, e); }

        const touchInfo = this.getTouchInfo(event);
        if (!touchInfo) return;
        this.lastY = touchInfo.y;

        const strategy = PadModeManager.getCurrentStrategy();
        if (!strategy || typeof strategy.onPointerDown !== 'function') {
            console.warn("[Pad v8] No current strategy or onPointerDown method missing.");
            return;
        }

        const noteAction = await strategy.onPointerDown(event.pointerId, touchInfo.x, touchInfo.y, this._currentDisplayedZones, this._getPadContext());

        if (noteAction) {
            if (noteAction.type === 'note_on' && noteAction.note) {
                const velocity = noteAction.velocityFactor !== undefined ? noteAction.velocityFactor : 0.7;
                synth.startNote(noteAction.note.frequency, velocity, touchInfo.y, event.pointerId);

                const zone = this._currentDisplayedZones.find(z => z.midiNote === noteAction.note.midiNote);
                this.activeTouchesInternal.set(event.pointerId, {
                    pointerId: event.pointerId, x: touchInfo.x, y: touchInfo.y,
                    currentZoneIndex: zone ? zone.index : -1,
                    baseFrequency: noteAction.note.frequency,
                    state: 'down'
                });

                if (typeof visualizer !== 'undefined' && typeof visualizer.notifyTouchDown === 'function') {
                    visualizer.notifyTouchDown({
                        id: event.pointerId, x: touchInfo.x, y: touchInfo.y, rawX: event.clientX, rawY: event.clientY,
                        noteInfo: noteAction.note,
                        state: 'down'
                    });
                }

            } else if (noteAction.type === 'chord_on' && noteAction.chordNotes) {
                console.log("[Pad v8] Chord ON action received:", noteAction.chordNotes);
                 synth.startChord(noteAction.chordNotes, 0.7, touchInfo.y, event.pointerId);

                 this.activeTouchesInternal.set(event.pointerId, {
                    pointerId: event.pointerId, x: touchInfo.x, y: touchInfo.y,
                    currentZoneIndex: -1,
                    state: 'down', isChord: true, chordNotes: noteAction.chordNotes
                 });
                 if (typeof visualizer !== 'function') {
                    visualizer.notifyTouchDown({
                        id: event.pointerId, x: touchInfo.x, y: touchInfo.y, rawX: event.clientX, rawY: event.clientY,
                        isChord: true, chordNotes: noteAction.chordNotes,
                        state: 'down'
                    });
                 }

            }
        }
    },

    async handlePointerMove(event) {
        const pointerId = event.pointerId; // Получаем ID из события
        if (!this.activeTouchesInternal.has(pointerId) || !this.isReady || !app?.state.isAudioReady || !synth?.isReady) return;
        event.preventDefault();
        this.lastInteractionTime = Date.now();

        const touchInfo = this.getTouchInfo(event);
        if (!touchInfo) return;
        this.lastY = touchInfo.y;

        const strategy = PadModeManager.getCurrentStrategy();
        if (!strategy || typeof strategy.onPointerMove !== 'function') return;

        const internalTouchData = this.activeTouchesInternal.get(pointerId);
        if (!internalTouchData) return; // Этого не должно быть, если has(pointerId) true

        // Вызываем onPointerMove стратегии
        const noteAction = await strategy.onPointerMove(pointerId, touchInfo.x, touchInfo.y, this._currentDisplayedZones, this._getPadContext());

        if (noteAction) {
            if (noteAction.type === 'note_change') {
                console.log(`[Pad.handlePointerMove] Note Change for pointerId ${pointerId}: Old ${noteAction.oldNote?.name}, New ${noteAction.newNote.name}`);
                if (synth.isReady) {
                    if (internalTouchData.isChord) synth.triggerReleaseChord(pointerId);
                    else synth.triggerRelease(pointerId); // Release старой ноты/аккорда
                    
                    const velocity = noteAction.newNote.velocityFactor !== undefined ? noteAction.newNote.velocityFactor : 0.7;
                    synth.startNote(noteAction.newNote.frequency, velocity, touchInfo.y, pointerId); // Start новой ноты
                }
                internalTouchData.baseFrequency = noteAction.newNote.frequency;
                internalTouchData.isChord = false; delete internalTouchData.chordNotes;
                // Обновляем visualizer
                 if (typeof visualizer !== 'undefined' && typeof visualizer.notifyTouchMove === 'function') {
                    visualizer.notifyTouchMove({
                        id: pointerId, x: touchInfo.x, y: touchInfo.y, rawX: event.clientX, rawY: event.clientY,
                        noteInfo: noteAction.newNote, state: 'move'
                    });
                }

            } else if (noteAction.type === 'note_update') {
                // console.log(`[Pad.handlePointerMove] Note Update for pointerId ${pointerId}: ${noteAction.note.name}`);
                if (synth.isReady) {
                    if (internalTouchData.isChord) synth.updateChord(pointerId, 0.7, touchInfo.y);
                    else synth.updateNote(noteAction.note.frequency, 0.7, touchInfo.y, pointerId);
                }
                // Обновляем visualizer
                 if (typeof visualizer !== 'undefined' && typeof visualizer.notifyTouchMove === 'function') {
                    visualizer.notifyTouchMove({
                        id: pointerId, x: touchInfo.x, y: touchInfo.y, rawX: event.clientX, rawY: event.clientY,
                        noteInfo: noteAction.note, state: 'move'
                    });
                }
            } else if (noteAction.type === 'note_off') { // Если стратегия решила, что нужно отпустить ноту
                console.log(`[Pad.handlePointerMove] Note Off requested by strategy for pointerId ${pointerId}`);
                if (synth.isReady) {
                    if (internalTouchData.isChord) synth.triggerReleaseChord(pointerId);
                    else synth.triggerRelease(pointerId);
                }
                this.activeTouchesInternal.delete(pointerId);
                if (typeof visualizer !== 'undefined' && typeof visualizer.notifyTouchUp === 'function') {
                     visualizer.notifyTouchUp(pointerId);
                }
            } else if (noteAction.type === 'note_on' && noteAction.note) {
                if (internalTouchData.isChord) {
                    synth.triggerReleaseChord(pointerId);
                } else {
                    synth.triggerRelease(pointerId);
                }
                const velocity = noteAction.velocityFactor !== undefined ? noteAction.velocityFactor : 0.7;
                synth.startNote(noteAction.note.frequency, velocity, touchInfo.y, pointerId);

                const zone = this._currentDisplayedZones.find(z => z.midiNote === noteAction.note.midiNote);
                internalTouchData.currentZoneIndex = zone ? zone.index : -1;
                internalTouchData.baseFrequency = noteAction.note.frequency;
                internalTouchData.isChord = false; delete internalTouchData.chordNotes;

                if (typeof visualizer !== 'undefined' && typeof visualizer.notifyTouchMove === 'function') {
                    visualizer.notifyTouchMove({
                        id: pointerId, x: touchInfo.x, y: touchInfo.y, rawX: event.clientX, rawY: event.clientY,
                        noteInfo: noteAction.note, state: 'move'
                    });
                }

            } else if (noteAction.type === 'chord_on' && noteAction.chordNotes) {
                 if (internalTouchData.isChord) synth.triggerReleaseChord(pointerId);
                 else synth.triggerRelease(pointerId);

                 synth.startChord(noteAction.chordNotes, 0.7, touchInfo.y, pointerId);
                 internalTouchData.isChord = true; internalTouchData.chordNotes = noteAction.chordNotes;
                 internalTouchData.currentZoneIndex = -1;

                 if (typeof visualizer !== 'undefined' && typeof visualizer.notifyTouchMove === 'function') {
                    visualizer.notifyTouchMove({
                        id: pointerId, x: touchInfo.x, y: touchInfo.y, rawX: event.clientX, rawY: event.clientY,
                        isChord: true, chordNotes: noteAction.chordNotes, state: 'move'
                    });
                 }
            } else if (noteAction.type === 'noop' || noteAction === null) {
                if (internalTouchData.isChord) {
                     synth.updateChord(pointerId, 0.7, touchInfo.y);
                } else if (internalTouchData.baseFrequency) {
                     synth.updateNote(internalTouchData.baseFrequency, 0.7, touchInfo.y, pointerId);
                }

                 if (typeof visualizer !== 'undefined' && typeof visualizer.notifyTouchMove === 'function') {
                     const noteInfoForViz = internalTouchData.isChord ? null : (internalTouchData.baseFrequency ? { frequency: internalTouchData.baseFrequency } : null);
                    visualizer.notifyTouchMove({
                        id: pointerId, x: touchInfo.x, y: touchInfo.y, rawX: event.clientX, rawY: event.clientY,
                        noteInfo: noteInfoForViz,
                        state: 'move'
                    });
                 }
            }
            // Добавить обработку 'chord_change', 'chord_update', если они будут
        } else {
            if (internalTouchData.isChord) synth.triggerReleaseChord(pointerId);
            else synth.triggerRelease(pointerId);
            this.activeTouchesInternal.delete(pointerId);

            if (typeof visualizer !== 'undefined' && typeof visualizer.notifyTouchUp === 'function') {
                 visualizer.notifyTouchUp(pointerId);
            }
        }
        // Обновляем данные касания в любом случае, если оно еще активно
        if(this.activeTouchesInternal.has(pointerId)){
            internalTouchData.x = touchInfo.x;
            internalTouchData.y = touchInfo.y;
            internalTouchData.state = 'move';
        }
    },

    async handlePointerUpOrCancel(event) {
        if (!this.activeTouchesInternal.has(event.pointerId) || !this.isReady) return;
        event.preventDefault();
        this.lastInteractionTime = Date.now();
        const pointerId = event.pointerId;

        try { if (this.container.hasPointerCapture(pointerId)) { this.container.releasePointerCapture(pointerId); } } catch (e) { console.warn(`[Pad v8] Failed to release pointer ${pointerId}:`, e); }

        const strategy = PadModeManager.getCurrentStrategy();
        let noteAction = null;
        if (strategy && typeof strategy.onPointerUp === 'function') {
            noteAction = await strategy.onPointerUp(pointerId, this._getPadContext());
        }

        const internalTouchData = this.activeTouchesInternal.get(pointerId);

        if (synth?.isReady) {
            if (internalTouchData?.isChord) {
                synth.triggerReleaseChord(pointerId);
            } else {
                synth.triggerRelease(pointerId);
            }
        }

        if (noteAction) {
            console.log("[Pad v8] NoteAction from strategy onPointerUp:", noteAction);
        }

        if (typeof visualizer !== 'undefined' && typeof visualizer.notifyTouchUp === 'function') {
            visualizer.notifyTouchUp(pointerId);
        }
        this.activeTouchesInternal.delete(pointerId);
    },

    handlePointerLeave(event) {
         if (this.activeTouchesInternal.has(event.pointerId)) {
             console.log(`[Pad.handlePointerLeave] Pointer ${event.pointerId} left container. Releasing note.`);
             this.handlePointerUpOrCancel(event);
         }
    },

    getTouchInfo(event) {
        if (!this.cachedRect) this.updateCachedRect();
        if (!this.cachedRect) return null;

        const x = Math.max(0, Math.min(1, (event.clientX - this.cachedRect.left) / this.cachedRect.width));
        const y = Math.max(0, Math.min(1, 1.0 - (event.clientY - this.cachedRect.top) / this.cachedRect.height));

        return { x, y };
    },

    toggleLabels(show) {
        const enabled = typeof show === 'boolean' ? show : !this.config.labelVisibility;
        if (this.config.labelVisibility === enabled) return;
        this.config.labelVisibility = enabled;
        this.drawZones(this._currentDisplayedZones, app.state.currentTonic);
    },

    toggleLines(show) {
        const enabled = typeof show === 'boolean' ? show : !this.config.linesVisibility;
        if (this.config.linesVisibility === enabled) return;
        this.config.linesVisibility = enabled;
        this.drawZones(this._currentDisplayedZones, app.state.currentTonic);
    },

    hasRecentActivity() {
        return Date.now() - this.lastInteractionTime < 1000;
    },

    getLastYPosition() {
        return this.lastY;
    },

    getActiveTouchStates() {
        const states = [];
        this.activeTouchesInternal.forEach((touchData, pointerId) => {
            let noteInfoForViz = null;
            if (!touchData.isChord && touchData.baseFrequency) {
                const zone = this._currentDisplayedZones.find(z => Math.abs(z.frequency - touchData.baseFrequency) < 0.01);
                noteInfoForViz = zone ? { noteName: zone.noteName, frequency: zone.frequency, midiNote: zone.midiNote } : { frequency: touchData.baseFrequency };
            } else if (touchData.isChord && touchData.chordNotes) {
                 noteInfoForViz = { isChord: true, chordNotes: touchData.chordNotes };
            }

            states.push({
                id: pointerId,
                x: touchData.x, y: touchData.y, state: touchData.state,
                noteInfo: noteInfoForViz,
                isChord: touchData.isChord,
                chordNotes: touchData.chordNotes
            });
        });
        return states;
    }
};

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\padModes\ClassicModeStrategy.js
// Файл: app/src/main/assets/js/padModes/ClassicModeStrategy.js
// Стратегия для классического режима работы XY-пэда
// ВЕРСИЯ 1.2: Исправление ReferenceError

const ClassicModeStrategy = {
    appRef: null,
    musicTheoryServiceRef: null,
    _isActive: false,
    _activeNoteInfo: new Map(),

    init(appReference, musicTheoryServiceInstance) {
        console.log(`[${this.getName()}Strategy.init] Received appReference:`, appReference ? 'Exists' : 'NULL');
        this.appRef = appReference;
        this.musicTheoryServiceRef = musicTheoryServiceInstance;
        console.log(`[${this.getName()}Strategy.init] this.appRef set to:`, this.appRef ? 'Exists' : 'NULL');
        console.log("[ClassicModeStrategy v1.2 PadModes] Initialized.");
    },

    getName: () => "classic",
    getDisplayName: () => i18n.translate('pad_mode_classic', 'Classic'), // Локализуемое имя

    requiresTonic: () => true,
    requiresScale: () => true,
    requiresChord: () => false,

    getModeSpecificControlsConfig: () => {
        // Для классического режима пока нет специфичных настроек
        return [];
    },

    onSpecificControlChanged(controlName, value) {
        // Обработка изменений специфичных контролов режима
        console.log(`[ClassicModeStrategy] Control '${controlName}' changed to:`, value);
        // Здесь будет логика, если для Classic Mode появятся настройки
        // Может потребоваться app.updateZones() или другие действия
    },

    async getZoneLayoutOptions(appState) {
        console.log("[ClassicModeStrategy.getZoneLayoutOptions] Received appState:", JSON.parse(JSON.stringify(appState))); // Log at beginning
        if (!appState) {
            console.error("[ClassicModeStrategy.getZoneLayoutOptions] appState is missing.");
            return null;
        }
        const layoutOptions = {
            tonicNameWithOctave: appState.currentTonic, // Переименовано для ясности
            scaleId: appState.scale,                  // Переименовано для ясности
            octaveOffsetFromTonic: appState.octaveOffset, // Это смещение применяется к тонике для пэда
        };
        console.log("[ClassicModeStrategy.getZoneLayoutOptions] Returning context:", layoutOptions); // Log before return
        return layoutOptions;
    },

    /**
     * @param {object} layoutContext - { tonicNameWithOctave, scaleId, octaveOffsetFromTonic }
     * @param {object} appState - Полное состояние app.state (для zoneCount)
     * @param {object} services - { musicTheoryService }
     * @returns {Promise<Array<ZoneData>>}
     * ZoneData: { index, startX, endX, noteName, frequency, midiNote, isSharpFlat, type: 'note' }
     */
    async generateZoneData(layoutContext, appState, services) {
        console.log("[ClassicModeStrategy.generateZoneData] Context:", layoutContext, "AppState:", appState);
        if (!layoutContext || !appState || !services?.musicTheoryService) {
            console.error("[ClassicModeStrategy.generateZoneData] Invalid arguments.");
            return [];
        }

        const { scaleId } = layoutContext; // Лад, выбранный пользователем
        const userSelectedTonic = layoutContext.tonicNameWithOctave; // Тоника, выбранная пользователем
        const zoneCount = appState.zoneCount;

        // --- НАША ЦЕЛЕВАЯ ЦЕНТРАЛЬНАЯ НОТА ИЗМЕНЕНА НА F4 ---
        const TARGET_CENTER_MIDI_NOTE = 65; // F4 (было 67 для G4)
        // ---------------------------------------------------

        if (!services.musicTheoryService.isTonalJsLoaded) {
            console.error("[ClassicModeStrategy.generateZoneData] MusicTheoryService not available.");
            return [];
        }

        // 1. Получаем полный пул нот для ВЫБРАННОГО ЛАДА от ВЫБРАННОЙ ТОНИКИ
        const octavesToScan = Math.ceil(zoneCount / 7) + 3;
        const scaleNotesPool = await services.musicTheoryService.getNotesForScale(
            userSelectedTonic,
            scaleId,
            octavesToScan,
            octavesToScan
        );

        if (!scaleNotesPool || scaleNotesPool.length === 0) {
            console.warn(`[ClassicModeStrategy.generateZoneData] No notes from MTS for ${userSelectedTonic} ${scaleId}.`);
            return [];
        }
        const targetCenterNoteName = services.musicTheoryService.midiToNoteName(TARGET_CENTER_MIDI_NOTE);
        console.log(`[ClassicModeStrategy.generateZoneData] Scale notes pool (length ${scaleNotesPool.length}) for ${userSelectedTonic} ${scaleId}. Target MIDI for center: ${TARGET_CENTER_MIDI_NOTE} (${targetCenterNoteName})`);

        // 2. Находим в этом пуле ноту, которая наиболее близка к нашей TARGET_CENTER_MIDI_NOTE (F4)
        let closestNoteToTargetCenter = null;
        let minMidiDiffToTarget = Infinity;

        for (const note of scaleNotesPool) {
            const diff = Math.abs(note.midi - TARGET_CENTER_MIDI_NOTE);
            if (diff < minMidiDiffToTarget) {
                minMidiDiffToTarget = diff;
                closestNoteToTargetCenter = note;
            } else if (diff === minMidiDiffToTarget) {
                if (closestNoteToTargetCenter && note.midi < closestNoteToTargetCenter.midi) {
                     closestNoteToTargetCenter = note;
                }
            }
        }

        if (!closestNoteToTargetCenter) {
            console.error(`[ClassicModeStrategy.generateZoneData] Could not find any note in the pool for ${userSelectedTonic} ${scaleId}.`);
            return [];
        }
        console.log(`[ClassicModeStrategy.generateZoneData] Note closest to target F4 (MIDI ${TARGET_CENTER_MIDI_NOTE}) in current scale ${userSelectedTonic} ${scaleId} is: ${closestNoteToTargetCenter.name} (MIDI ${closestNoteToTargetCenter.midi})`);

        // 3. Находим индекс этой "центральной" ноты в нашем отсортированном пуле scaleNotesPool
        const centralNoteInPoolIndex = scaleNotesPool.findIndex(note => note.midi === closestNoteToTargetCenter.midi);

        if (centralNoteInPoolIndex === -1) {
            console.error("[ClassicModeStrategy.generateZoneData] CRITICAL: closestNoteToTargetCenter not found in scaleNotesPool by index.");
            return [];
        }

        const zones = [];
        const zoneWidth = 1.0 / zoneCount;
        const halfZoneCount = Math.floor(zoneCount / 2);

        // 4. Определяем начальный индекс в scaleNotesPool
        let targetZoneIndexForCenterNote = Math.floor(zoneCount / 2);
        if (zoneCount % 2 === 0) {
            targetZoneIndexForCenterNote = (zoneCount / 2) - 1;
        }
        
        let startIndexInPool = centralNoteInPoolIndex - targetZoneIndexForCenterNote;

        console.log(`[ClassicModeStrategy.generateZoneData] Target Zone Index for Center Note (F4 or closest): ${targetZoneIndexForCenterNote}. Calculated startIndexInPool: ${startIndexInPool}`);

        for (let i = 0; i < zoneCount; i++) {
            const currentPoolIndex = startIndexInPool + i;
            let noteDetailsToUse;

            if (currentPoolIndex >= 0 && currentPoolIndex < scaleNotesPool.length) {
                noteDetailsToUse = scaleNotesPool[currentPoolIndex];
            } else {
                console.warn(`[ClassicModeStrategy.generateZoneData] Index ${currentPoolIndex} out of bounds for scaleNotesPool (len ${scaleNotesPool.length}) for zone ${i}.`);
                if (scaleNotesPool.length > 0) {
                     const clampedIndex = Math.max(0, Math.min(scaleNotesPool.length - 1, currentPoolIndex));
                     noteDetailsToUse = scaleNotesPool[clampedIndex];
                     console.warn(`[ClassicModeStrategy.generateZoneData] Using fallback note ${noteDetailsToUse.name} for out-of-bounds zone ${i}`);
                } else {
                    continue; 
                }
            }
            
            if (noteDetailsToUse) {
                zones.push({
                    index: i,
                    startX: i * zoneWidth,
                    endX: (i + 1) * zoneWidth,
                    noteName: noteDetailsToUse.name,
                    frequency: noteDetailsToUse.freq,
                    midiNote: noteDetailsToUse.midi,
                    isSharpFlat: noteDetailsToUse.isSharpFlat,
                    type: 'note'
                });
            }
        }
        console.log(`[ClassicModeStrategy.generateZoneData] Generated zones (length ${zones.length}). Centered around MIDI ${closestNoteToTargetCenter.midi}.`);
        if (zones.length > targetZoneIndexForCenterNote && zones[targetZoneIndexForCenterNote]) {
            console.log(`[ClassicModeStrategy.generateZoneData] Note at target center zone index ${targetZoneIndexForCenterNote} is: ${zones[targetZoneIndexForCenterNote].noteName} (MIDI ${zones[targetZoneIndexForCenterNote].midiNote})`);
        }
        return zones;
    },

    onPointerDown(pointerId, x, y, currentZones, padContext) {
        if (!currentZones || currentZones.length === 0) return null;
        let foundZone = null;
        for (let i = 0; i < currentZones.length; i++) {
            const zone = currentZones[i];
            if (zone.startX !== undefined && zone.endX !== undefined && x >= zone.startX && x < zone.endX) {
                foundZone = zone; break;
            }
        }
        if (!foundZone && x >= 1.0 && currentZones.length > 0) {
            foundZone = currentZones[currentZones.length - 1];
        }
        if (foundZone) {
            const noteDetails = {
                frequency: foundZone.frequency,
                midiNote: foundZone.midiNote,
                name: foundZone.noteName
            };
            this._activeNoteInfo.set(pointerId, noteDetails);
            return { type: 'note_on', note: noteDetails };
        }
        return null;
    },

    onPointerMove(pointerId, x, y, currentZones, padContext) {
        if (!currentZones || currentZones.length === 0) return null;
        const previousNoteInfo = this._activeNoteInfo.get(pointerId);
        if (!previousNoteInfo) return null;
        let newFoundZone = null;
        for (let i = 0; i < currentZones.length; i++) {
            const zone = currentZones[i];
            if (zone.startX !== undefined && zone.endX !== undefined && x >= zone.startX && x < zone.endX) {
                newFoundZone = zone; break;
            }
        }
        if (!newFoundZone && x >= 1.0 && currentZones.length > 0) {
            newFoundZone = currentZones[currentZones.length - 1];
        }
        if (newFoundZone) {
            const newNoteDetails = {
                frequency: newFoundZone.frequency,
                midiNote: newFoundZone.midiNote,
                name: newFoundZone.noteName
            };
            if (newNoteDetails.midiNote !== previousNoteInfo.midiNote) {
                this._activeNoteInfo.set(pointerId, newNoteDetails);
                return { type: 'note_change', oldNote: previousNoteInfo, newNote: newNoteDetails };
            } else {
                return { type: 'note_update', note: newNoteDetails };
            }
        } else {
            this._activeNoteInfo.delete(pointerId);
            return { type: 'note_off', note: previousNoteInfo };
        }
    },

    onPointerUp(pointerId, padContext) {
        this._activeNoteInfo.delete(pointerId);
        return null;
    },

    getPadVisualHints: (currentZones, appState, services) => [], // Как раньше

    onModeActivated(appState, services, uiModules) {
        this._isActive = true;
        console.log("[ClassicModeStrategy v1.2 PadModes] Activated.");
    },
    onModeDeactivated(appState, services, uiModules) {
        this._isActive = false;
        console.log("[ClassicModeStrategy v1.2 PadModes] Deactivated.");
    },
    async onTonicChanged(newTonic, appState, services) {
        console.log(`[ClassicModeStrategy v1.2 PadModes] Notified of tonic change: ${newTonic}.`);
        // Zone update будет вызван PadModeManager -> app.updateZones()
    },
    async onScaleChanged(newScale, appState, services) {
        console.log(`[ClassicModeStrategy v1.2 PadModes] Notified of scale change: ${newScale}.`);
        // Zone update будет вызван PadModeManager -> app.updateZones()
    },
    async onChordChanged(newChord, appState, services) { /* Не используется */ }
};

if (typeof PadModeManager !== 'undefined' && PadModeManager.registerStrategy) {
    PadModeManager.registerStrategy(ClassicModeStrategy);
} else {
    console.warn("[ClassicModeStrategy v1.2 PadModes] PadModeManager not found for self-registration.");
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\padModes\RocketModeStrategy.js
// File: assets/js/padModes/RocketModeStrategy.js
// Main strategy for Rocket Mode.
// Версия для Фазы 2.1: Интеграция с HME, делегирование подстратегиям, присвоение zoneIndex.

console.log("[RMS v2.1] RocketModeStrategy.js loaded");

const RocketModeStrategy = {
    appRef: null,
    musicTheoryServiceRef: null,
    harmonicMarkerEngineRef: null,
    _isActive: false,
    _currentSubModeStrategy: null,
    _currentSuggestions: [],
    _activeNotesMap: new Map(),
    _previousActiveSuggestionsMap: new Map(), // Карта { suggestionId: suggestionObject }
    _debug: true, // Флаг для логов внутри этой стратегии

    init(appReference, musicTheoryServiceInstance, harmonicMarkerEngineInstance) {
        if (!appReference || !musicTheoryServiceInstance || !harmonicMarkerEngineInstance) {
            console.error("[RMS.init] CRITICAL: Missing core dependencies (app, MTS, or HME). Rocket Mode will likely fail.");
            this._isActive = false;
            return false;
        }
        this.appRef = appReference;
        this.musicTheoryServiceRef = musicTheoryServiceInstance;
        this.harmonicMarkerEngineRef = harmonicMarkerEngineInstance;
        if (this._debug) console.log(`[RMS.init] Initialized. App: ${!!this.appRef}, MTS: ${!!this.musicTheoryServiceRef}, HME: ${!!this.harmonicMarkerEngineRef}`);
        return true;
    },

    getName: () => "rocket",
    getDisplayName: () => i18n.translate('pad_mode_rocket', 'Rocket'),
    requiresTonic: () => true,
    requiresScale: () => true,
    requiresChord: () => false,

    async onModeActivated(appState, services, uiModules) {
        if (this._debug) console.log("[RMS.onModeActivated] Activating Rocket Mode.");
        this._isActive = true;
        this._currentSuggestions = [];
        this._activeNotesMap.clear();
        this._previousActiveSuggestionsMap.clear();
        await this._updateSubModeStrategy();
        console.log(`[RMS.onModeActivated] Sub-strategy after update: ${this._currentSubModeStrategy ? this._currentSubModeStrategy.getName() : 'NULL'}`);
        await this._analyzeAndUpdateMarkers();
        if (this.appRef?.updateRocketStatusPanel) this.appRef.updateRocketStatusPanel();
    },

    async onModeDeactivated(appState, services, uiModules) {
        if (this._debug) console.log("[RMS.onModeDeactivated] Deactivating Rocket Mode.");
        this._isActive = false;
        this._currentSuggestions = [];
        this._activeNotesMap.clear();
        this._previousActiveSuggestionsMap.clear();
        if (this.appRef?.updateZoneVisuals) await this.appRef.updateZoneVisuals([]);
        if (this.appRef?.updateRocketStatusPanel) this.appRef.updateRocketStatusPanel();
    },

    async getZoneLayoutOptions(appState) {
        if (typeof ClassicModeStrategy === 'undefined' || typeof ClassicModeStrategy.getZoneLayoutOptions !== 'function') {
            console.error("[RMS.getZoneLayoutOptions] ClassicModeStrategy or its method not found!");
            return { tonicNameWithOctave: appState.currentTonic, scaleId: appState.scale, octaveOffsetFromTonic: appState.octaveOffset };
        }
        return ClassicModeStrategy.getZoneLayoutOptions(appState);
    },

    async generateZoneData(layoutContext, appState, services) {
        if (typeof ClassicModeStrategy === 'undefined' || typeof ClassicModeStrategy.generateZoneData !== 'function') {
            console.error("[RMS.generateZoneData] ClassicModeStrategy or its method not found!");
            return [];
        }
        const classicServices = { musicTheoryService: this.musicTheoryServiceRef };
        return ClassicModeStrategy.generateZoneData(layoutContext, appState, classicServices);
    },

    async _updateSubModeStrategy() {
        if (!this.appRef?.state?.rocketModeSettings) {
            console.error("[RMS._updateSubModeStrategy] CRITICAL: app.state.rocketModeSettings not available. Cannot select sub-strategy.");
            this._currentSubModeStrategy = null;
            return;
        }
        const currentMarkerLogicMode = this.appRef.state.rocketModeSettings.markerLogicMode;
        if (this._debug) console.log(`[RMS._updateSubModeStrategy] Attempting to set logic mode: '${currentMarkerLogicMode}'. Current sub-strategy: ${this._currentSubModeStrategy ? this._currentSubModeStrategy.getName() : 'None'}`);

        if (this._currentSubModeStrategy && this._currentSubModeStrategy.getName() === currentMarkerLogicMode) {
            if (this._debug) console.log(`[RMS._updateSubModeStrategy] Sub-strategy '${currentMarkerLogicMode}' already active.`);
            return; // Ничего не меняем, если уже активна нужная
        }

        let StrategyClassConstructor;
        switch (currentMarkerLogicMode) {
            case 'tonalBinding': StrategyClassConstructor = window.TonalBindingSubModeStrategy; break;
            case 'adaptiveAnalysis': StrategyClassConstructor = window.AdaptiveAnalysisSubModeStrategy; break;
            case 'semiFree': StrategyClassConstructor = window.SemiFreeSubModeStrategy; break;
            case 'randomDirected': StrategyClassConstructor = window.RandomDirectedSubModeStrategy; break;
            default:
                console.warn(`[RMS._updateSubModeStrategy] Unknown markerLogicMode: '${currentMarkerLogicMode}'. Falling back to TonalBinding.`);
                StrategyClassConstructor = window.TonalBindingSubModeStrategy;
        }

        if (this._debug) console.log(`[RMS._updateSubModeStrategy] Resolved Class for '${currentMarkerLogicMode}':`, StrategyClassConstructor);

        if (typeof StrategyClassConstructor === 'function') {
            try {
                this._currentSubModeStrategy = new StrategyClassConstructor(this.musicTheoryServiceRef, this.harmonicMarkerEngineRef, this.appRef);
                if (this._currentSubModeStrategy && typeof this._currentSubModeStrategy.getName === 'function') {
                    if (this._debug) console.log(`[RMS._updateSubModeStrategy] Successfully CREATED/SWITCHED to sub-strategy: '${this._currentSubModeStrategy.getName()}'`);
                } else {
                    console.error(`[RMS._updateSubModeStrategy] Sub-strategy instance for '${currentMarkerLogicMode}' is invalid (missing getName or null).`);
                    this._currentSubModeStrategy = null;
                }
            } catch (e) {
                console.error(`[RMS._updateSubModeStrategy] CRITICAL error INSTANTIATING sub-strategy for '${currentMarkerLogicMode}':`, e.stack);
                this._currentSubModeStrategy = null;
            }
        } else {
            console.error(`[RMS._updateSubModeStrategy] ERROR: No valid constructor found for sub-strategy '${currentMarkerLogicMode}'. Check if JS file is loaded and class is assigned to window.ClassName.`);
            this._currentSubModeStrategy = null;
        }
    },

    async _analyzeAndUpdateMarkers() {
        if (!this._isActive || !this.harmonicMarkerEngineRef?.isInitialized || !this.musicTheoryServiceRef?.isTonalJsLoaded || !this.appRef) {
            console.warn("[RMS._analyzeAndUpdateMarkers] Aborting: Not active or core HME/MTS/AppRef dependencies not ready.");
            this._currentSuggestions = [];
            if (this.appRef?.updateZoneVisuals) await this.appRef.updateZoneVisuals([]);
            return;
        }
        if (!this._currentSubModeStrategy || typeof this._currentSubModeStrategy.analyzeAndSuggest !== 'function' || !this._currentSubModeStrategy.isUsable()) {
            console.warn(`[RMS._analyzeAndUpdateMarkers] Aborting: Sub-strategy '${this._currentSubModeStrategy?.getName() || "unknown"}' not available, not usable, or analyzeAndSuggest is not a function.`);
            this._currentSuggestions = [];
            return;
        }
        if (this._debug) console.log("[RMS._analyzeAndUpdateMarkers] Starting analysis cycle...");
        const activeNotesForAnalysis = Array.from(this._activeNotesMap.values()).map(note => ({ midiNote: note.midiNote, name: note.name }));
        const padCurrentZones = (typeof pad !== 'undefined' && pad._currentDisplayedZones) ? pad._currentDisplayedZones : [];
        if (this._debug) {
            console.log(`[RMS._analyzeAndUpdateMarkers] pad._currentDisplayedZones (length: ${padCurrentZones.length}):`);
            padCurrentZones.slice(0, 5).forEach((z, i) => console.log(`  Zone ${i}: MIDI=${z.midiNote}, Name=${z.noteName}, startX=${z.startX !== undefined ? z.startX.toFixed(3) : 'n/a'}`));
        }
        if (padCurrentZones.length === 0 && this._debug) {
            console.warn("[RMS._analyzeAndUpdateMarkers] No zones available from pad._currentDisplayedZones. Marker positioning will likely fail.");
        }
        const tonicMidiForHME = this.musicTheoryServiceRef.getNoteDetails(this.appRef.state.currentTonic)?.midi;
        if (tonicMidiForHME === undefined) {
            console.error(`[RMS._analyzeAndUpdateMarkers] CRITICAL: Could not get MIDI for currentTonic: ${this.appRef.state.currentTonic}`);
        }
        const rocketContext = {
            tonicMidi: tonicMidiForHME,
            scaleId: this.appRef.state.scale,
            settings: this.appRef.state.rocketModeSettings,
            currentPhase: this.appRef.state.rocketModePhase,
            padZones: padCurrentZones,
            previousSuggestions: Array.from(this._previousActiveSuggestionsMap.values()).map(s => ({ ...s }))
        };
        const hmeAnalysisResult = this.harmonicMarkerEngineRef.analyzeContext(activeNotesForAnalysis, rocketContext);
        if (this._debug) console.log("[RMS._analyzeAndUpdateMarkers] HME Analysis Result:", JSON.parse(JSON.stringify(hmeAnalysisResult)));
        const rawSuggestions = await this._currentSubModeStrategy.analyzeAndSuggest(activeNotesForAnalysis, hmeAnalysisResult, rocketContext);
        if (this._debug) console.log(`[RMS._analyzeAndUpdateMarkers] Raw suggestions from SubMode '${this._currentSubModeStrategy.getName()}':`, rawSuggestions ? JSON.parse(JSON.stringify(rawSuggestions)) : "None");
        const processedSuggestions = [];
        const newActiveSuggestionsMap = new Map();
        const now = performance.now();
        if (Array.isArray(rawSuggestions)) {
            for (const sugg of rawSuggestions) {
                if (!sugg || (sugg.midiNote === undefined && (!sugg.midiNotes || sugg.midiNotes.length === 0))) {
                    console.warn("[RMS._analyzeAndUpdateMarkers] Invalid suggestion object from sub-strategy (missing MIDI):", sugg);
                    continue;
                }
                let zoneIndex = -1;
                const primaryMidiForZoneLookup = sugg.isChord ? (sugg.midiNotes ? sugg.midiNotes[0] : undefined) : sugg.midiNote;
                if (primaryMidiForZoneLookup !== undefined && Array.isArray(rocketContext.padZones) && rocketContext.padZones.length > 0) {
                    zoneIndex = rocketContext.padZones.findIndex(zone => zone && zone.midiNote === primaryMidiForZoneLookup);
                    if (this._debug && zoneIndex === -1) {
                        console.warn(`[RMS._analyzeAndUpdateMarkers] Zone lookup FAILED. Target MIDI: ${primaryMidiForZoneLookup} for sugg ID ${sugg.suggestionId}. Available zone MIDIs:`, rocketContext.padZones.map(z => z?.midiNote));
                    }
                } else if (this._debug) {
                    console.warn(`[RMS._analyzeAndUpdateMarkers] Zone lookup SKIPPED for sugg ID ${sugg.suggestionId}. Target MIDI: ${primaryMidiForZoneLookup}, Pad Zones Count: ${rocketContext.padZones?.length}`);
                }
                if (zoneIndex === -1) continue;
                console.log(`[RMS._analyzeAndUpdateMarkers] Processing raw sugg: MIDI=${primaryMidiForZoneLookup}, Name=${sugg.noteName || sugg.chordSymbol}. Found zoneIndex: ${zoneIndex}`);
                const existingPrevSuggestion = this._previousActiveSuggestionsMap.get(sugg.suggestionId);
                const processedSugg = {
                    ...sugg,
                    zoneIndex: zoneIndex,
                    isNew: !existingPrevSuggestion,
                    isStillValid: true,
                    creationTime: existingPrevSuggestion ? existingPrevSuggestion.creationTime : now,
                    lastActiveTime: now
                };
                processedSuggestions.push(processedSugg);
                newActiveSuggestionsMap.set(processedSugg.suggestionId, processedSugg);
            }
        }
        
        // Обрабатываем старые "затухающие" маркеры из _previousActiveSuggestionsMap
        const fadeOutDelay = this.appRef.state.rocketModeSettings.fadeOutDelayMs || 200;
        this._previousActiveSuggestionsMap.forEach((prevSugg, prevSuggId) => {
            if (!newActiveSuggestionsMap.has(prevSuggId)) { // Если старый маркер не был обновлен/подтвержден новыми предложениями
                if (now - (prevSugg.lastActiveTime || 0) > fadeOutDelay) {
                    // Помечаем на удаление/затухание в visualizer
                    const fadingSugg = { ...prevSugg, isStillValid: false, isNew: false };
                    processedSuggestions.push(fadingSugg); // Добавляем, чтобы visualizer мог его отрисовать с затуханием
                    if (this._debug) console.log(`[RMS._analyzeAndUpdateMarkers] Marking suggestion ${prevSuggId} as NOT valid (for fade-out).`);
                } else {
                    // Еще не пора затухать, держим активным (переносим в новый набор, если он еще не там)
                    const stillValidPrevSugg = { ...prevSugg, isNew: false, isStillValid: true, lastActiveTime: now };
                    processedSuggestions.push(stillValidPrevSugg);
                    newActiveSuggestionsMap.set(prevSuggId, stillValidPrevSugg); // Переносим в новую карту, чтобы он не исчез сразу
                    if (this._debug) console.log(`[RMS._analyzeAndUpdateMarkers] Suggestion ${prevSuggId} is kept (within fadeOutDelay).`);
                }
            }
        });

        this._currentSuggestions = processedSuggestions;
        this._previousActiveSuggestionsMap = newActiveSuggestionsMap;
        if (this._debug) {
            console.log(`[RMS._analyzeAndUpdateMarkers] Final processed suggestions for visualizer (${this._currentSuggestions.length}):`, JSON.parse(JSON.stringify(this._currentSuggestions)));
        }
        if (this.appRef?.updateZoneVisuals) await this.appRef.updateZoneVisuals();
        // updateRocketStatusPanel уже вызывается при изменении currentChordName
    },


    // --- Обработчики событий касания (в основном делегируют ClassicModeStrategy, но добавляют анализ) ---
    async onPointerDown(pointerId, x, y, currentDisplayZones, padContext) {
        if (this._debug) console.log(`[RMS.onPointerDown] Pointer: ${pointerId}, Coords: (${x.toFixed(2)}, ${y.toFixed(2)})`);
        if (!this._isActive) return null;

        const classicAction = ClassicModeStrategy.onPointerDown(pointerId, x, y, currentDisplayZones, padContext);

        if (classicAction && classicAction.type === 'note_on' && classicAction.note) {
            const noteDetails = {
                midiNote: classicAction.note.midiNote, name: classicAction.note.name, frequency: classicAction.note.frequency,
                pointerId, x, y, startTime: performance.now()
            };
            this._activeNotesMap.set(pointerId, noteDetails);
            if (this.appRef?.incrementRocketActivity) this.appRef.incrementRocketActivity();
             if (this.appRef?.updateRocketEnergy) {
                const energyGain = (this.appRef.state.rocketModeSettings.energyGainPerNote || 0.02) * (0.5 + y * 0.5);
                this.appRef.updateRocketEnergy(energyGain);
            }
            await this._analyzeAndUpdateMarkers();
            return classicAction;
        }
        if (this._debug) console.warn("[RMS.onPointerDown] No valid note_on action from ClassicModeStrategy.");
        return null;
    },

    async onPointerMove(pointerId, x, y, currentDisplayZones, padContext) {
        if (!this._isActive) return null;
        const activeTouch = this._activeNotesMap.get(pointerId);
        if (!activeTouch) return null;

        const classicAction = ClassicModeStrategy.onPointerMove(pointerId, x, y, currentDisplayZones, padContext);

        if (classicAction) {
            activeTouch.x = x; activeTouch.y = y; // Обновляем координаты в любом случае
            if (classicAction.type === 'note_change' && classicAction.newNote) {
                activeTouch.midiNote = classicAction.newNote.midiNote;
                activeTouch.name = classicAction.newNote.name;
                activeTouch.frequency = classicAction.newNote.frequency;
                activeTouch.startTime = performance.now();
                if (this.appRef?.incrementRocketActivity) this.appRef.incrementRocketActivity();
                 if (this.appRef?.updateRocketEnergy) {
                    const energyGain = (this.appRef.state.rocketModeSettings.energyGainPerNote || 0.02) * (0.5 + y * 0.5);
                    this.appRef.updateRocketEnergy(energyGain);
                }
                await this._analyzeAndUpdateMarkers();
            } else if (classicAction.type === 'note_update' && classicAction.note) {
                // Если нота та же, но Y изменился, энергия может обновиться
                 if (this.appRef?.updateRocketEnergy && Math.random() < 0.05) {
                    const energyGain = (this.appRef.state.rocketModeSettings.energyGainPerNote || 0.02) * 0.05 * (0.5 + y * 0.5);
                    this.appRef.updateRocketEnergy(energyGain);
                    if (this.appRef.updateRocketStatusPanel) this.appRef.updateRocketStatusPanel();
                }
            } else if (classicAction.type === 'note_off') {
                this._activeNotesMap.delete(pointerId);
                await this._analyzeAndUpdateMarkers();
            }
            return classicAction;
        }
        return null;
    },

    async onPointerUp(pointerId, padContext) {
        if (this._debug) console.log(`[RMS.onPointerUp] Pointer: ${pointerId}`);
        if (!this._isActive) return null;
        const classicAction = ClassicModeStrategy.onPointerUp(pointerId, padContext); // ClassicModeStrategy сама удалит из своего _activeNoteInfo
        const releasedNote = this._activeNotesMap.get(pointerId);
        if (releasedNote) {
            this._activeNotesMap.delete(pointerId);
            await this._analyzeAndUpdateMarkers();
            // Возвращаем данные отпущенной ноты для synth.triggerRelease
            return { type: 'note_off', note: { name: releasedNote.name, midiNote: releasedNote.midiNote, frequency: releasedNote.frequency } };
        }
        return null; // Если classicAction был null
    },

    // --- Формирование подсказок для Visualizer ---
    async getPadVisualHints(currentDisplayZonesFromPad, appState, services) {
        if (!this._isActive || !this.appRef || !appState?.rocketModeSettings) {
            return [];
        }
        const hints = [];
        const settings = appState.rocketModeSettings;
        const now = performance.now();

        if (settings.highlightActiveNotes && this._activeNotesMap.size > 0) {
            this._activeNotesMap.forEach(activePlayedNote => {
                const zoneIdx = currentDisplayZonesFromPad.findIndex(z => z.midiNote === activePlayedNote.midiNote);
                if (zoneIdx !== -1) {
                    hints.push({
                        suggestionId: `active_${activePlayedNote.midiNote}_${activePlayedNote.pointerId}`,
                        zoneIndex: zoneIdx, type: 'active_note_highlight',
                        style: 'ActiveGlow', // Можно сделать настраиваемым
                        color: settings.markerColors?.ActiveNote || '#FFFFFF',
                        noteName: activePlayedNote.name, midiNote: activePlayedNote.midiNote,
                        holdTimeMs: Math.max(0, now - (activePlayedNote.startTime || now)),
                        isNew: true, isStillValid: true, creationTime: activePlayedNote.startTime || now
                    });
                }
            });
        }

        if (settings.showDirectionalMarkers && this._currentSuggestions && this._currentSuggestions.length > 0) {
            this._currentSuggestions.forEach((suggestion) => {
                if (suggestion.zoneIndex === undefined || suggestion.zoneIndex < 0 || suggestion.zoneIndex >= currentDisplayZonesFromPad.length) {
                    if (this._debug) console.warn(`[RMS.getPadVisualHints] Suggestion ID ${suggestion.suggestionId} for MIDI ${suggestion.midiNote || 'N/A'} has invalid zoneIndex ${suggestion.zoneIndex}. Dropping.`);
                    return;
                }

                const currentPhase = appState.rocketModePhase || 'ignition';
                const phaseSpecificSettings = settings.phaseSettings ? (settings.phaseSettings[currentPhase] || {}) : {};
                const hintStyle = settings.phaseBasedStyleOverride && phaseSpecificSettings.markerStyle
                                  ? phaseSpecificSettings.markerStyle
                                  : (suggestion.style || settings.markerStyle || "GlowFromNote");
                const hintColor = suggestion.color || settings.markerColors?.Default || '#4CAF50';
                let label = '';
                if (settings.markerLabels === 'function' && suggestion.functionLabel) label = suggestion.functionLabel;
                else if (settings.markerLabels === 'chordName' && suggestion.chordSymbol) label = suggestion.chordSymbol;
                else if (settings.markerLabels === 'chordName' && !suggestion.isChord && suggestion.noteName && this.musicTheoryServiceRef?._TonalNote) {
                     label = this.musicTheoryServiceRef._TonalNote.pc(suggestion.noteName);
                }

                hints.push({
                    ...suggestion, type: 'harmonic_suggestion', style: hintStyle, color: hintColor, label: label,
                    fadeOutDurationMs: settings.fadeOutDurationMs || 600,
                    fadeOutDelayMs: settings.fadeOutDelayMs || 200
                });
            });
        }
        if (this._debug) console.log(`[RMS.getPadVisualHints] FINAL HINTS for visualizer (${hints.length}):`, JSON.parse(JSON.stringify(hints)));
        return hints;
    },

    // --- Конфигурация UI для настроек ---
    getModeSpecificControlsConfig() {
        if (this._debug) console.log("[RMS.getModeSpecificControlsConfig] appRef:", !!this.appRef, "mtsRef:", !!this.musicTheoryServiceRef);
        if (!this.appRef || !this.appRef.state || !this.musicTheoryServiceRef) {
            console.warn("[RMS.getModeSpecificControlsConfig] appRef or MTS not available.");
            return [];
        }
        const currentSettings = this.appRef.state.rocketModeSettings;
        const mts = this.musicTheoryServiceRef;
        const createOptions = (keyPrefix, ids, defaultNameFn = id => id) => {
            return ids.map(id => ({ id: id.toString(), name: i18n.translate(`${keyPrefix}_${id.toString().toLowerCase().replace(/\s+/g, '_')}`, defaultNameFn(id)) }));
        };
        const phaseDurations = currentSettings.phaseDurations || { ignition: 30, liftOff: 60, burst: 90 };

        return [
            { name: 'intensity', labelKey: 'rocket_intensity', type: 'knob', min: 0.1, max: 1.0, step: 0.05, default: currentSettings.intensity, group: 'general' },
            { name: 'visualTheme', labelKey: 'rocket_visual_theme', type: 'select', options: createOptions('rocket_theme', ['Glow', 'NeonLines', 'SubtleDots']), default: currentSettings.visualTheme, group: 'general' },
            { name: 'autoPhases', labelKey: 'rocket_auto_phases', type: 'toggle', default: currentSettings.autoPhases, group: 'phases' },
            { name: 'phaseTransitionMode', labelKey: 'rocket_phase_transition', type: 'select', options: createOptions('phase_mode', ['activity', 'time', 'manual']), default: currentSettings.phaseTransitionMode, group: 'phases', condition: () => currentSettings.autoPhases },
            { name: 'phaseVisualStyle', labelKey: 'rocket_phase_visual_style', type: 'select', options: createOptions('transition_style', ['fade', 'ripple', 'instant']), default: currentSettings.phaseVisualStyle || 'fade', group: 'phases' },
            { name: 'phaseDurations.ignition', labelKey: 'rocket_phase_ignition', type: 'knob', min: 5, max: 180, step: 5, default: phaseDurations.ignition, unit: 's', group: 'phases', condition: () => currentSettings.autoPhases && currentSettings.phaseTransitionMode === 'time' },
            { name: 'phaseDurations.liftOff', labelKey: 'rocket_phase_lift_off', type: 'knob', min: 5, max: 180, step: 5, default: phaseDurations.liftOff, unit: 's', group: 'phases', condition: () => currentSettings.autoPhases && currentSettings.phaseTransitionMode === 'time' },
            { name: 'phaseDurations.burst', labelKey: 'rocket_phase_burst', type: 'knob', min: 5, max: 180, step: 5, default: phaseDurations.burst, unit: 's', group: 'phases', condition: () => currentSettings.autoPhases && currentSettings.phaseTransitionMode === 'time' },
            { name: 'markerLogicMode', labelKey: 'rocket_marker_logic', type: 'select',
                options: createOptions('marker_logic', ['tonalBinding', 'adaptiveAnalysis', 'semiFree', 'randomDirected'], id => id.charAt(0).toUpperCase() + id.slice(1).replace(/([A-Z])/g, ' $1').trim()),
                default: currentSettings.markerLogicMode, group: 'harmonicLogic' },
            { name: 'harmonicKeyDisplay', labelKey: 'rocket_harmonic_key', type: 'display', getValue: () => `${this.appRef.state.currentTonic || 'N/A'} ${i18n.translate(this.appRef.state.scale, this.appRef.state.scale)}`, group: 'harmonicLogic' },
            { name: 'tonalTonic', labelKey: 'rocket_sf_basekey', type: 'select',
                 options: (mts.getAvailableTonicNames ? mts.getAvailableTonicNames() : ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']).map(t => ({id: t, name: t})),
                 default: currentSettings.tonalTonic, group: 'harmonicLogic', condition: () => currentSettings.markerLogicMode === 'semiFree' || currentSettings.keyBehavior === 'fixed' },
             { name: 'harmonicKey', labelKey: 'key_signature_type', type: 'select',
                options: (mts.getAvailableScaleIds ? mts.getAvailableScaleIds() : ['major', 'minor']).map(s => ({id: s, name: i18n.translate(s,s)})),
                default: currentSettings.harmonicKey, group: 'harmonicLogic', condition: () => currentSettings.markerLogicMode === 'semiFree' || currentSettings.keyBehavior === 'fixed' },
            { name: 'markerStyle', labelKey: 'rocket_marker_style', type: 'select',
                options: createOptions('style', ['GlowFromNote', 'WaveToNote', 'PulseRing', 'SparkTrail', 'ShadowDrop']),
                default: currentSettings.markerStyle, group: 'interactiveBehavior' },
            { name: 'markerColorScheme', labelKey: 'rocket_marker_colors', type: 'select', options: createOptions('color_scheme', ['Classic', 'Monochrome', 'NoteColor']), default: currentSettings.markerColorScheme, group: 'interactiveBehavior' },
            { name: 'highlightActiveNotes', labelKey: 'rocket_highlight_active', type: 'toggle', default: currentSettings.highlightActiveNotes, group: 'interactiveBehavior' },
            { name: 'showDirectionalMarkers', labelKey: 'rocket_show_markers', type: 'toggle', default: currentSettings.showDirectionalMarkers, group: 'interactiveBehavior' },
            { name: 'displayMarkers.active', labelKey: 'rocket_dm_active', type: 'toggle', default: currentSettings.displayMarkers?.active ?? true, group: 'interactiveBehavior', condition: () => currentSettings.showDirectionalMarkers },
            { name: 'displayMarkers.functional', labelKey: 'rocket_dm_functional', type: 'toggle', default: currentSettings.displayMarkers?.functional ?? true, group: 'interactiveBehavior', condition: () => currentSettings.showDirectionalMarkers },
            { name: 'displayMarkers.inKeyOnly', labelKey: 'rocket_dm_inkey', type: 'toggle', default: currentSettings.displayMarkers?.inKeyOnly ?? true, group: 'interactiveBehavior', condition: () => currentSettings.showDirectionalMarkers && currentSettings.markerLogicMode === 'tonalBinding' },
            { name: 'markerLabels', labelKey: 'rocket_marker_labels', type: 'select', options: createOptions('labels', ['none', 'function', 'chordName']), default: currentSettings.markerLabels, group: 'interactiveBehavior', condition: () => currentSettings.showDirectionalMarkers },
            { name: 'markersDisappearOnNewTouch', labelKey: 'rocket_markers_disappear', type: 'toggle', default: currentSettings.markersDisappearOnNewTouch, group: 'interactiveBehavior' },
            { name: 'useFadeOutEffects', labelKey: 'rocket_use_fade_out', type: 'toggle', default: currentSettings.useFadeOutEffects, group: 'interactiveBehavior' },
            { name: 'fadeOutDelayMs', labelKey: 'rocket_fade_delay', type: 'knob', min:0, max:2000, step:50, default: currentSettings.fadeOutDelayMs, unit: 'ms', group: 'interactiveBehavior', condition: () => currentSettings.useFadeOutEffects },
            { name: 'fadeOutDurationMs', labelKey: 'rocket_fade_duration', type: 'knob', min:100, max:3000, step:50, default: currentSettings.fadeOutDurationMs, unit: 'ms', group: 'interactiveBehavior', condition: () => currentSettings.useFadeOutEffects },
            { name: 'maxMarkersPerZone', labelKey: 'rocket_max_markers_zone', type: 'knob', min:1, max:5, step:1, default: currentSettings.maxMarkersPerZone, group: 'interactiveBehavior' },
            { name: 'phaseBasedStyleOverride', labelKey: 'rocket_phase_styles', type: 'toggle', default: currentSettings.phaseBasedStyleOverride, group: 'interactiveBehavior' },
            { name: 'chordHistoryDepth', labelKey: 'rocket_chord_history', type: 'knob', min:0, max:5, step:1, default: currentSettings.chordHistoryDepth, group: 'interactiveBehavior' }
        ];
    },

    async onSpecificControlChanged(settingName, value) {
        if (this._debug) console.log(`[RMS.onSpecificControlChanged] Setting '${settingName}' changed to: ${value}. Current logic mode: ${this.appRef.state.rocketModeSettings.markerLogicMode}`);
        // this.appRef.setModeSpecificSetting('rocket', settingName, value); // Это уже должно быть вызвано из sidepanel -> app

        if (settingName === 'markerLogicMode') {
            await this._updateSubModeStrategy(); // Обновляем подстратегию ПЕРЕД анализом
        }
        // Для других настроек, специфичных для подрежима
        if (this._currentSubModeStrategy && typeof this._currentSubModeStrategy.onSubModeSettingChanged === 'function') {
             this._currentSubModeStrategy.onSubModeSettingChanged(settingName, value, this.appRef.state.rocketModeSettings);
        }
        await this._analyzeAndUpdateMarkers();
    },

    updateInternalSetting(settingName, value) {
        // Эта функция больше не нужна, так как app.setModeSpecificSetting напрямую обновляет app.state.rocketModeSettings
        // и onSpecificControlChanged в RocketModeStrategy реагирует на это.
        // Оставляем ее пустой или удаляем, чтобы избежать путаницы.
        // console.warn("[RMS.updateInternalSetting] This method is deprecated. Settings are updated via app.setModeSpecificSetting and onSpecificControlChanged.");
    }
};

// Саморегистрация
if (typeof PadModeManager !== 'undefined' && PadModeManager.registerStrategy) {
    PadModeManager.registerStrategy(RocketModeStrategy);
} else {
    console.warn("[RocketModeStrategy v2.1] PadModeManager not found for self-registration.");
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\services\MusicTheoryService.js
// Файл: app/src/main/assets/js/services/MusicTheoryService.js
// ВЕРСИЯ 2.2: Исправление getNotesForScale с Tonal.Scale.get().notes и транспонированием

console.log('[Pre-MTS v2.2] typeof Tonal:', typeof Tonal);
if (typeof Tonal !== 'undefined') {
    console.log('[Pre-MTS v2.2] Tonal object:', Tonal);
}

const MusicTheoryService = {
    isTonalJsLoaded: false,
    moduleManagerRef: null,
    scaleDefinitions: {}, // { scaleId: [intervals], ... } - Кэш интервалов строя

    async init(moduleManagerInstance) {
        this.moduleManagerRef = moduleManagerInstance;
        if (!this.moduleManagerRef) {
            console.error("[MusicTheoryService.init] moduleManager instance not provided!");
            this.isTonalJsLoaded = false;
            return;
        }

        this.isTonalJsLoaded = typeof Tonal !== 'undefined' && Tonal &&
                               typeof Tonal.Note !== 'undefined' &&
                               typeof Tonal.Scale !== 'undefined' && // Проверяем наличие Tonal.Scale
                               typeof Tonal.Interval !== 'undefined'; // Нужен для транспонирования

        if (!this.isTonalJsLoaded) {
            console.error("[MusicTheoryService.init] Tonal.js library is NOT LOADED or Tonal.Note/Scale/Interval is missing!");
        } else {
            const coreModule = Tonal.Core || Tonal;
            const tonalVersion = coreModule.VERSION || (typeof coreModule.version === 'string' ? coreModule.version : undefined) || "Tonal object exists but version not found";
            console.log("[MusicTheoryService v2.2] Initialized. Tonal.js version:", tonalVersion);
        }
        await this.loadScaleDefinitions(); // Загружаем определения строев (интервалы)
    },

    async loadScaleDefinitions() {
        if (!this.moduleManagerRef) {
            console.error("[MusicTheoryService.loadScaleDefinitions] moduleManagerRef is not set.");
            return;
        }
        console.log("[MusicTheoryService] Loading scale definitions...");
        this.scaleDefinitions = {};
        try {
            const scaleModules = await this.moduleManagerRef.getModules('scale', true);
            console.log("[MTS.loadScaleDefinitions] Received scaleModules:", scaleModules ? JSON.stringify(scaleModules.map(m => m.id)) : 'null');
            if (Array.isArray(scaleModules)) {
                scaleModules.forEach(mod => {
                    if (mod?.id && mod.data?.data?.intervals && Array.isArray(mod.data.data.intervals)) {
                        this.scaleDefinitions[mod.id] = mod.data.data.intervals;
                    } else {
                        console.warn(`[MusicTheoryService] Invalid scale module data for ID: ${mod?.id}`, mod);
                    }
                });
                console.log(`[MusicTheoryService] Loaded ${Object.keys(this.scaleDefinitions).length} scale definitions:`, JSON.parse(JSON.stringify(this.scaleDefinitions)));
            }
        } catch (error) { console.error("[MusicTheoryService] Error loading scale definitions:", error); }
    },

    getNoteDetails(noteNameOrMidi) {
        if (!this.isTonalJsLoaded) return null;
        try {
            const note = Tonal.Note.get(noteNameOrMidi);
            if (note && note.name && typeof note.midi === 'number' && typeof note.freq === 'number') {
                note.isSharpFlat = note.acc !== "";
                return note;
            }
            return null;
        } catch (e) { return null; }
    },

    /**
     * Возвращает массив объектов нот для указанной тоники и строя.
     * @param {string} tonicNameWithOctave - Тоника с октавой, например "C4".
     * @param {string} scaleId - ID строя (например, "major", "blues").
     * @param {number} [octavesToScanBefore=2]
     * @param {number} [octavesToScanAfter=2]
     * @returns {Promise<Array<object> | null>}
     */
    async getNotesForScale(tonicNameWithOctave, scaleId, octavesToScanBefore = 2, octavesToScanAfter = 2) {
        if (!this.isTonalJsLoaded) {
            console.error("[MTS.getNotesForScale v2.2] Tonal.js not loaded.");
            return null;
        }
        console.log(`[MTS.getNotesForScale v2.2] Input: tonic=${tonicNameWithOctave}, scaleId=${scaleId}`);

        try {
            const tonicDetails = this.getNoteDetails(tonicNameWithOctave);
            if (!tonicDetails) {
                console.error(`[MTS.getNotesForScale v2.2] Invalid tonic: ${tonicNameWithOctave}`);
                return null;
            }
            const tonicPc = Tonal.Note.pitchClass(tonicNameWithOctave); // "C", "F#"

            // Пытаемся получить ноты строя (pitch classes) от Tonal.Scale.get()
            // Tonal.Scale.get("major").notes -> ["1P", "2M", "3M", "4P", "5P", "6M", "7M"] (интервалы) ИЛИ
            // Tonal.Scale.get("C major").notes -> ["C", "D", "E", "F", "G", "A", "B"] (ноты)
            // Tonal.js > 4.x.x использует ScaleType.get (Tonal.Scale.get)
            let scaleInfo = Tonal.Scale.get(scaleId); // Попробуем по ID/типу
            if (scaleInfo.empty) { // Если по ID не нашли, пробуем с тоникой
                scaleInfo = Tonal.Scale.get(`${tonicPc} ${scaleId}`);
            }

            console.log(`[MTS.getNotesForScale v2.2] Tonal.Scale.get("${scaleId}" or "${tonicPc} ${scaleId}") result:`,
                scaleInfo ? JSON.parse(JSON.stringify(scaleInfo)) : null);

            let baseScaleNotesPc; // Массив pitch classes ["C", "D", "E"...] или ["Db", "Eb", "F"...]
            if (!scaleInfo.empty && scaleInfo.notes && scaleInfo.notes.every(n => typeof n === 'string' && !n.match(/\d/))) {
                // Если .notes уже содержит pitch classes (например, для "C major")
                baseScaleNotesPc = scaleInfo.notes;
            } else if (!scaleInfo.empty && scaleInfo.intervals && Array.isArray(scaleInfo.intervals)) {
                // Если .notes содержит интервалы или их нет, но есть .intervals, генерируем pitch classes от тоники
                baseScaleNotesPc = scaleInfo.intervals.map(interval => Tonal.Note.simplify(Tonal.Distance.transpose(tonicPc, interval)));
            } else {
                 // Последний фоллбэк: используем наши кэшированные интервалы, если Tonal.Scale.get не дал нужного
                const intervalsFromCache = this.scaleDefinitions[scaleId];
                if (intervalsFromCache) {
                    console.warn(`[MTS.getNotesForScale v2.2] Falling back to cached intervals for scale ${scaleId}`);
                    baseScaleNotesPc = intervalsFromCache.map(semitone => Tonal.Note.simplify(Tonal.Distance.transpose(tonicPc, Tonal.Interval.fromSemitones(semitone))));
                } else {
                    console.error(`[MTS.getNotesForScale v2.2] Could not get notes or intervals for scale: ${scaleId}`);
                    return null;
                }
            }

            console.log(`[MTS.getNotesForScale v2.2] Base pitch classes for ${tonicPc} ${scaleId}:`, baseScaleNotesPc);

            if (!baseScaleNotesPc || baseScaleNotesPc.length === 0) {
                console.error(`[MTS.getNotesForScale v2.2] No base pitch classes found for scale: ${scaleId}`);
                return null;
            }

            const allNotes = [];
            const rootMidi = tonicDetails.midi; // MIDI нота корневой тоники, относительно которой строим диапазон

            // Определяем начальную октаву для сканирования
            // Мы хотим, чтобы ноты генерировались вокруг tonicNameWithOctave
            const minMidi = rootMidi - (octavesToScanBefore * 12);
            const maxMidi = rootMidi + (octavesToScanAfter * 12) + 11; // +11 чтобы захватить верхнюю октаву

            // Находим первую ноту строя, которая >= minMidi
            let currentMidi = Tonal.Note.midi(baseScaleNotesPc[0] + "0"); // Начинаем с очень низкой октавы
            while (currentMidi < minMidi - 12) { // -12 чтобы не пропустить первую нужную ноту
                currentMidi += 12;
            }
            
            let safetyCounter = 0;
            const maxSafety = (octavesToScanBefore + octavesToScanAfter + 2) * baseScaleNotesPc.length * 2; // Ограничение на количество итераций (умножено на 2 на всякий случай)

            while (currentMidi <= maxMidi && safetyCounter < maxSafety) {
                 // Проверяем, является ли текущая MIDI нота частью строя относительно tonicPc
                 const noteNameFromMidi = Tonal.Note.fromMidi(currentMidi);
                 if (noteNameFromMidi !== "") { // Пропускаем невалидные MIDI
                     const pitchClassFromMidi = Tonal.Note.pitchClass(noteNameFromMidi);
                     // Проверяем, есть ли этот pitch class в нашем baseScaleNotesPc (генерированном от tonicPc)
                     // Или, что надежнее, проверяем через chroma строя относительно tonicPc

                     // Получаем интервал в полутонах от tonicPc до текущей ноты (в пределах октавы)
                     const intervalInSemitones = Tonal.Distance.semitones(tonicPc + "4", pitchClassFromMidi + "4") % 12; // Используем C4 как референс для полутонов
                     const normalizedInterval = intervalInSemitones < 0 ? intervalInSemitones + 12 : intervalInSemitones;

                     if (!scaleInfo.empty && scaleInfo.chroma.includes(normalizedInterval)) {
                         const details = this.getNoteDetails(currentMidi); // Используем MIDI для получения деталей
                         if (details) {
                              allNotes.push(details);
                         }
                     } else if (scaleInfo.empty) { // Если Tonal.Scale.get не дал chroma, используем наш кэш (более точно)
                          const intervalsFromCache = this.scaleDefinitions[scaleId];
                          if (intervalsFromCache && intervalsFromCache.includes(normalizedInterval)) {
                               const details = this.getNoteDetails(currentMidi);
                                if (details) {
                                    allNotes.push(details);
                                }
                          }
                     }
                 }

                currentMidi++; // Переходим к следующему полутону
                safetyCounter++;
            }
            if (safetyCounter >= maxSafety) {
                console.warn("[MTS.getNotesForScale v2.2] Safety counter hit, loop terminated early.");
            }


            const uniqueNotes = Array.from(new Map(allNotes.map(note => [note.midi, note])).values());
            uniqueNotes.sort((a, b) => a.midi - b.midi);

            console.log(`[MTS.getNotesForScale v2.2] Generated ${uniqueNotes.length} unique notes.`);
            return uniqueNotes;

        } catch (e) {
            console.error(`[MTS.getNotesForScale v2.2] Error for ${tonicNameWithOctave} ${scaleId}:`, e, e.stack);
            return null;
        }
    },

    isSharpOrFlat(noteName) { /* ... без изменений ... */ },
    midiToFrequency(midiNote) { /* ... без изменений ... */ },
    midiToNoteName(midiNote) { /* ... без изменений ... */ },
    getAvailableScaleIds() { /* ... без изменений ... */ }
};

// MusicTheoryService.init() вызывается из app.js
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\sidepanel.js
const sidePanel = {
    panels: {},
    closeButtons: [],
    knobsInitialized: new WeakSet(),

    octaveSlider: null,
    octaveValueDisplay: null,
    octaveDownButton: null,
    octaveUpButton: null,
    scaleSelect: null,
    scaleSelectDisplay: null,
    sizeSlider: null,
    sizeValueDisplay: null,
    sizeDownButton: null,
    sizeUpButton: null,
    sizeMap: [7, 12, 24, 36],

    languageSelect: null,
    themeSelect: null,
    visualizerSelect: null,
    touchEffectSelect: null,
    noteNamesToggle: null,
    linesToggle: null,
    multiTouchToggle: null,
    // === НОВОЕ: Ссылка на переключатель Polyphony Volume Scaling ===
    enablePolyphonyScalingToggle: null,
    // ============================================================
    // === НОВОЕ: Ссылка на переключатель Highlight Sharps/Flats ===
    highlightSharpsFlatsToggle: null,
    // ============================================================
    padModeSelect: null,
    padModeSelectorDisplay: null,       // Для отображения выбранного режима
    modeSpecificControlsContainer: null, // Контейнер для настроек режима

    // === Rocket Mode UI ===
    rocketModeEnableToggle: null,
    // ...

    init() {
        console.log('[SidePanel.init PadModes] Initializing...');
        this.panels = {
            settings: document.getElementById('settings-panel'),
            tonality: document.getElementById('tonality-panel'),
            effects: document.getElementById('effects-panel'),
            soundLibrary: document.getElementById('sound-library-panel'),
            padModes: document.getElementById('pad-modes-panel') // Новая панель
        };

        let allPanelsFound = true;
        for (const id in this.panels) {
            if (!this.panels[id]) {
                console.error(`[SidePanel.init v3] Panel element with ID '${id}' not found!`);
                allPanelsFound = false;
            }
        }
        if (!allPanelsFound) {
             console.error("[SidePanel.init v3] Not all panel elements were found. Functionality might be limited.");
        }

        this.closeButtons = document.querySelectorAll('.close-button');
        if (this.closeButtons.length === 0) {
             console.warn('[SidePanel.init v3] No elements with class "close-button" found.');
        }

        this.octaveSlider = document.getElementById('octave-slider');
        this.octaveValueDisplay = document.getElementById('octave-value');
        this.octaveDownButton = document.getElementById('octave-down');
        this.octaveUpButton = document.getElementById('octave-up');
        this.scaleSelect = document.getElementById('scale-select');
        this.scaleSelectDisplay = document.getElementById('scale-select-display');
        this.sizeSlider = document.getElementById('size-slider');
        this.sizeValueDisplay = document.getElementById('size-value');
        this.sizeDownButton = document.getElementById('size-down');
        this.sizeUpButton = document.getElementById('size-up');

        this.languageSelect = document.getElementById('language-select');
        this.themeSelect = document.getElementById('theme-select');
        this.visualizerSelect = document.getElementById('visualizer-select');
        this.touchEffectSelect = document.getElementById('touch-effect-select');
        this.noteNamesToggle = document.getElementById('show-note-names-toggle');
        this.linesToggle = document.getElementById('show-lines-toggle');
        this.multiTouchToggle = document.getElementById('toggle-multi-touch');
        // === ИНИЦИАЛИЗАЦИЯ ПЕРЕКЛЮЧАТЕЛЯ ===
        console.log('[SidePanel.init] Attempting to get element by ID: enable-polyphony-volume-scaling-toggle', document.getElementById('enable-polyphony-volume-scaling-toggle'));
        this.enablePolyphonyScalingToggle = document.getElementById('enable-polyphony-volume-scaling-toggle');
        if (!this.enablePolyphonyScalingToggle) console.warn("[SidePanel.init] Enable Polyphony Scaling toggle ('enable-polyphony-volume-scaling-toggle') NOT FOUND.");
        else console.log("[SidePanel.init] Found Enable Polyphony Scaling toggle.");
        // ===================================

        // === ИНИЦИАЛИЗАЦИЯ НОВОГО ПЕРЕКЛЮЧАТЕЛЯ Highlight Sharps/Flats ===
        console.log('[SidePanel.init] Attempting to get element by ID: highlight-sharps-flats-toggle', document.getElementById('highlight-sharps-flats-toggle'));
        this.highlightSharpsFlatsToggle = document.getElementById('highlight-sharps-flats-toggle');
        if (!this.highlightSharpsFlatsToggle) console.warn("[SidePanel.init] Highlight Sharps/Flats toggle ('highlight-sharps-flats-toggle') NOT FOUND.");
        else console.log("[SidePanel.init] Found Highlight Sharps/Flats toggle.");
        // ==============================================================

        this.padModeSelect = document.getElementById('pad-mode-select');

        this.masterVolumeCeilingSlider = document.getElementById('master-volume-ceiling-slider');
        this.masterVolumeCeilingValue = document.getElementById('master-volume-ceiling-value');
        this.enablePolyphonyVolumeScalingToggle = document.getElementById('enable-polyphony-volume-scaling-toggle');
        this.resetSettingsButton = document.getElementById('reset-settings-button');
        this.restartAudioButton = document.getElementById('restart-audio-button');
        this.reloadAppButton = document.getElementById('reload-app-button');

        this.fxChainSelect = document.getElementById('fx-chain-select');
        this.macroControlsContainer = document.getElementById('macro-controls');
        this.yAxisControlsContainer = document.getElementById('yaxis-controls-container');
        this.yaxisControlTargetDisplay = document.getElementById('yaxis-control-target-display');
        this.resetFxButton = document.getElementById('reset-fx-button');

        this.padModeSelectorDisplay = document.getElementById('pad-mode-selector-display');
        this.modeSpecificControlsContainer = document.getElementById('mode-specific-controls-container');
        if (!this.padModeSelectorDisplay) console.error("[SidePanel.init PadModes] Pad Mode Selector Display not found!");
        if (!this.modeSpecificControlsContainer) console.error("[SidePanel.init PadModes] Mode Specific Controls Container not found!");

        // === Rocket Mode UI ===
        this.rocketModeEnableToggle = document.getElementById('rocket-mode-enable-toggle');
        // ...

        if (this.sizeSlider) {
            this.sizeSlider.min = "8";
            this.sizeSlider.max = "36";
            this.sizeSlider.step = "2";
            this.sizeSlider.value = app && app.state ? app.state.zoneCount.toString() : "12";
        }

        this.addEventListeners();
        this.populateStaticSelects();
        this.populatePadModeSelectDisplay();
        console.log('[SidePanel.init PadModes] Initialized successfully.');
    },

    addEventListeners() {
        console.log('[SidePanel.addEventListeners PadModes] Adding event listeners...');
        this.closeButtons.forEach(btn => {
            if (btn) {
                btn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    const panelId = event.currentTarget.dataset.panelId;
                    if (panelId && this.panels[panelId]) {
                        this.hidePanel(panelId);
                    } else {
                        this.hideAllPanels();
                    }
                });
            }
        });

        if (this.octaveSlider) { this.octaveSlider.addEventListener('input', (e) => this.handleOctaveChange(e.target.value)); this.octaveSlider.addEventListener('change', (e) => this.handleOctaveChange(e.target.value, true)); }
        if (this.octaveDownButton) { this.octaveDownButton.addEventListener('click', () => { if(this.octaveSlider) this.handleOctaveChange(parseInt(this.octaveSlider.value) - 1, true); }); }
        if (this.octaveUpButton) { this.octaveUpButton.addEventListener('click', () => { if(this.octaveSlider) this.handleOctaveChange(parseInt(this.octaveSlider.value) + 1, true); }); }
        if (this.scaleSelect) { this.scaleSelect.addEventListener('change', (e) => { app.setScale(e.target.value); }); }
        if (this.scaleSelectDisplay) {
            this.scaleSelectDisplay.addEventListener('mousedown', (e) => {
                e.preventDefault();
                showCustomSelectorPopover({
                    type: 'scale',
                    title: i18n.translate('scale_label', 'Scale'),
                    itemsArray: MusicTheoryService.getAvailableScaleIds().map(id => ({
                        id: id,
                        name: i18n.translate(id, id.charAt(0).toUpperCase() + id.slice(1))
                    })),
                    currentValue: app.state.scale,
                    onSelect: async (selectedScaleId) => {
                        await app.setScale(selectedScaleId);
                        this.updateScaleDisplay(selectedScaleId);
                    }
                });
            });
        }
        if (this.sizeSlider) {
            this.sizeSlider.addEventListener('input', (e) => this.handleSizeChange(e.target.value));
            this.sizeSlider.addEventListener('change', (e) => this.handleSizeChange(e.target.value, true));
        }
        if (this.sizeDownButton) {
            this.sizeDownButton.addEventListener('click', () => {
                if(this.sizeSlider) {
                    const currentValue = parseInt(this.sizeSlider.value, 10);
                    this.handleSizeChange(currentValue - 2, true);
                }
            });
        }
        if (this.sizeUpButton) {
            this.sizeUpButton.addEventListener('click', () => {
                if(this.sizeSlider) {
                    const currentValue = parseInt(this.sizeSlider.value, 10);
                    this.handleSizeChange(currentValue + 2, true);
                }
            });
        }

        if (this.languageSelect) {
            this.languageSelect.addEventListener('mousedown', (e) => {
                e.preventDefault();
                showCustomSelectorPopover({
                    type: 'language',
                    title: i18n.translate('language_label', 'Language'),
                    selectElement: this.languageSelect,
                    currentValue: app.state.language,
                    onSelect: (val) => { app.applyLanguage(val); bridgeFix.callBridge('setLanguage', val); }
                });
            });
        }
        if (this.themeSelect) {
            this.themeSelect.addEventListener('mousedown', (e) => {
                e.preventDefault();
                showCustomSelectorPopover({
                    type: 'theme',
                    title: i18n.translate('theme_label', 'Theme'),
                    selectElement: this.themeSelect,
                    currentValue: app.state.theme,
                    onSelect: (val) => { app.applyTheme(val); bridgeFix.callBridge('setTheme', val); }
                });
            });
        }
        if (this.visualizerSelect) {
            this.visualizerSelect.addEventListener('mousedown', (e) => {
                e.preventDefault();
                showCustomSelectorPopover({
                    type: 'visualizer',
                    title: i18n.translate('visualizer_label', 'Visualizer'),
                    selectElement: this.visualizerSelect,
                    currentValue: app.state.visualizer,
                    onSelect: (val) => { app.applyVisualizer(val); bridgeFix.callBridge('setVisualizer', val); }
                });
            });
        }
        if (this.touchEffectSelect) {
            this.touchEffectSelect.addEventListener('mousedown', (e) => {
                e.preventDefault();
                showCustomSelectorPopover({
                    type: 'touchEffect',
                    title: i18n.translate('touch_effect_label', 'Touch Effect'),
                    selectElement: this.touchEffectSelect,
                    currentValue: app.state.touchEffect,
                    onSelect: (val) => { app.applyTouchEffect(val); }
                });
            });
        }

        if (this.noteNamesToggle) {
            this.noteNamesToggle.addEventListener('change', () => {
                if (app && typeof app.toggleNoteNames === 'function') {
                    app.toggleNoteNames(this.noteNamesToggle.checked);
                }
            });
        }
        if (this.linesToggle) {
            this.linesToggle.addEventListener('change', () => {
                if (app && typeof app.toggleLines === 'function') {
                    app.toggleLines(this.linesToggle.checked);
                }
            });
        }
        if (this.multiTouchToggle) { /* this.multiTouchToggle.addEventListener('change', () => { app.toggleMultiTouch(this.multiTouchToggle.checked); }); */ } // Мультитач пока disabled

        // === ОБРАБОТЧИК ДЛЯ Polyphony Volume Scaling Toggle ===
        if (this.enablePolyphonyScalingToggle) {
            this.enablePolyphonyScalingToggle.addEventListener('change', () => {
                if (app && typeof app.setEnablePolyphonyVolumeScaling === 'function') {
                    app.setEnablePolyphonyVolumeScaling(this.enablePolyphonyScalingToggle.checked);
                }
            });
        } else { console.warn("[SidePanel.addEventListeners v3] Enable Polyphony Scaling toggle not found."); }
        // ====================================================

        // === ОБРАБОТЧИК ДЛЯ Highlight Sharps/Flats Toggle ===
        if (this.highlightSharpsFlatsToggle) {
            this.highlightSharpsFlatsToggle.addEventListener('change', () => {
                if (app && typeof app.toggleHighlightSharpsFlats === 'function') {
                    app.toggleHighlightSharpsFlats(!!this.highlightSharpsFlatsToggle.checked);
                }
            });
        } else { console.warn("[SidePanel.addEventListeners v3] Highlight Sharps/Flats toggle not found."); }
        // ====================================================

        const fxChainSelect = document.getElementById('fx-chain-select');
        if (fxChainSelect) {
            fxChainSelect.addEventListener('mousedown', (e) => {
                e.preventDefault();
                showCustomSelectorPopover({
                    type: 'fxChain',
                    title: i18n.translate('fx_chain_label', 'FX Chain'),
                    selectElement: fxChainSelect,
                    currentValue: app.state.fxChain,
                    onSelect: (val) => { app.applyFxChain(val); }
                });
            });
        }

        if (this.padModeSelect) {
            this.padModeSelect.addEventListener('mousedown', (e) => {
                e.preventDefault();
                if (typeof PadModeManager !== 'undefined' && typeof showCustomSelectorPopover === 'function') {
                    const modeOptions = PadModeManager.getAvailableModeIds().map(modeId => {
                        const strategy = PadModeManager.strategies[modeId];
                        return {
                            id: modeId,
                            name: strategy && typeof strategy.getDisplayName === 'function' ?
                                  strategy.getDisplayName() :
                                  (strategy && typeof strategy.getName === 'function' ?
                                   i18n.translate(`pad_mode_${strategy.getName()}`, strategy.getName()) :
                                   modeId)
                        };
                    });

                    showCustomSelectorPopover({
                        type: 'padMode',
                        title: i18n.translate('pad_mode_label', 'Pad Mode'),
                        itemsArray: modeOptions,
                        currentValue: app.state.padMode,
                        onSelect: (val) => { app.setPadMode(val); }
                    });
                } else {
                    console.warn("[SidePanel] PadModeManager or showCustomSelectorPopover not available for pad mode select.");
                }
            });
        }

        if (this.masterVolumeCeilingSlider) {
            this.masterVolumeCeilingSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                if (this.masterVolumeCeilingValue) {
                    this.masterVolumeCeilingValue.textContent = `${Math.round(value * 100)}%`;
                }
                app.setMasterVolumeCeiling(value);
            });
        }

        if (this.resetSettingsButton) {
            this.resetSettingsButton.addEventListener('click', () => {
                console.warn("[SidePanel] Reset Settings button clicked. Logic not implemented yet.");
                alert("Reset Settings functionality is not yet implemented.");
            });
        }

        if (this.restartAudioButton) {
            this.restartAudioButton.addEventListener('click', () => {
                app.restartAudioEngine();
            });
        }

        if (this.reloadAppButton) {
            this.reloadAppButton.addEventListener('click', () => {
                app.triggerFullReload();
            });
        }

        if (this.padModeSelectorDisplay) {
            this.padModeSelectorDisplay.addEventListener('mousedown', (e) => {
                e.preventDefault();
                if (typeof PadModeManager === 'undefined' || typeof showCustomSelectorPopover !== 'function') {
                    console.error("[SidePanel] PadModeManager or showCustomSelectorPopover not available.");
                    return;
                }
                const availableModeIds = PadModeManager.getAvailableModeIds();
                const modeOptions = availableModeIds.map(modeId => {
                    const strategy = PadModeManager.strategies[modeId];
                    let displayName = modeId;
                    if (strategy && typeof strategy.getDisplayName === 'function') {
                        displayName = strategy.getDisplayName();
                    } else if (strategy && typeof strategy.getName === 'function') {
                        displayName = i18n.translate(`pad_mode_${strategy.getName()}`, strategy.getName());
                    }
                    return { id: modeId, name: displayName };
                });
                showCustomSelectorPopover({
                    type: 'padMode',
                    title: i18n.translate('pad_mode_select_title', 'Select Pad Mode'),
                    itemsArray: modeOptions,
                    currentValue: app.state.padMode,
                    onSelect: (selectedModeId) => {
                        app.setPadMode(selectedModeId);
                    },
                });
            });
            this.padModeSelectorDisplay.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    this.padModeSelectorDisplay.dispatchEvent(new MouseEvent('mousedown'));
                }
            });
        }

        // === Rocket Mode UI ===
        if (this.rocketModeEnableToggle && this.modeSpecificControlsContainer) {
            this.rocketModeEnableToggle.addEventListener('change', async (e) => {
                const isEnabled = e.target.checked;
                const newMode = isEnabled ? 'rocket' : 'classic';
                if (app && typeof app.setPadMode === 'function') {
                    await app.setPadMode(newMode);
                }
                if (isEnabled && (!this.modeSpecificControlsContainer.hasChildNodes() || 
                    this.modeSpecificControlsContainer.querySelector('p[data-i18n="rocket_mode_settings_placeholder"]'))) {
                    this.displayModeSpecificControls('rocket');
                }
            });
        }
        // ...

        console.log('[SidePanel.addEventListeners PadModes] Listeners added.');
    },

    async populateStaticSelects() {
        console.log('[SidePanel.populateStaticSelects] Populating static select dropdowns...');
        await this.populateSelectWithOptions(this.languageSelect, 'language', 'name', 'id', app.state.language);
        await this.populateSelectWithOptions(this.themeSelect, 'theme', 'name', 'id', app.state.theme);
        await this.populateSelectWithOptions(this.visualizerSelect, 'visualizer', 'name', 'id', app.state.visualizer);
        await this.populateSelectWithOptions(this.touchEffectSelect, 'touchEffect', 'name', 'id', app.state.touchEffect);
        await this.populateSelectWithOptions(document.getElementById('fx-chain-select'), 'fxChain', 'name', 'id', app.state.fxChain);
        await this.populateSelectWithOptions(this.padModeSelect, 'padMode', 'name', 'id', app.state.padMode);
        this.updateScaleDisplay(app.state.scale);
        console.log('[SidePanel.populateStaticSelects] Select dropdowns populated.');
    },

    async populateSelectWithOptions(selectElement, moduleType, textField, valueField, currentAppStateValue) {
        if (!selectElement) { console.warn(`[SidePanel.populateSelectWithOptions v3] Select element for ${moduleType} not found.`); return; }
        selectElement.innerHTML = '';
        try {
            const modules = await moduleManager.getModules(moduleType);
            if (!Array.isArray(modules)) {
                fxChains.addOptionToSelect(selectElement, '', `Error loading ${moduleType}s`, true); return;
            }
            if (modules.length === 0 && moduleType !== 'touchEffect') {
                 fxChains.addOptionToSelect(selectElement, '', `No ${moduleType}s found`, true); return;
            }

            if (moduleType === 'touchEffect') {
                fxChains.addOptionToSelect(selectElement, 'none', i18n.translate('none_touch_effect', 'None'));
            }

            modules.sort((a, b) => (a[textField] || a[valueField]).localeCompare(b[textField] || b[valueField]));
            modules.forEach(mod => {
                if (mod[valueField] === 'none' && moduleType === 'touchEffect') return;
                fxChains.addOptionToSelect(selectElement, mod[valueField], mod[textField] || mod[valueField]);
            });

             if (currentAppStateValue && selectElement.querySelector(`option[value="${currentAppStateValue}"]`)) {
                 selectElement.value = currentAppStateValue;
             } else if (currentAppStateValue) {
                 console.warn(`[SidePanel.populateSelectWithOptions v3] Initial state value '${currentAppStateValue}' for ${moduleType} not found. Setting to first/default.`);
                 if (moduleType === 'touchEffect' && selectElement.querySelector(`option[value="none"]`)) {
                     selectElement.value = 'none';
                 } else if (selectElement.options.length > 0) {
                    selectElement.selectedIndex = 0;
                 }
             } else if (selectElement.options.length > 0) {
                selectElement.selectedIndex = 0;
             }
        } catch (error) {
            console.error(`[SidePanel.populateSelectWithOptions v3] Error populating ${moduleType} select:`, error);
            fxChains.addOptionToSelect(selectElement, '', `Error loading ${moduleType}s`, true);
        }
    },

    updateTonalityControls(octave, scaleId, zoneCount) {
        if (this.octaveSlider) this.octaveSlider.value = octave;
        if (this.octaveValueDisplay) this.octaveValueDisplay.textContent = octave;
        if (this.scaleSelect && this.scaleSelect.options.length > 0) {
            if (this.scaleSelect.querySelector(`option[value="${scaleId}"]`)) { this.scaleSelect.value = scaleId; }
            else { this.scaleSelect.selectedIndex = 0; }
        }
        this.updateScaleDisplay(scaleId);
        if (this.sizeSlider) this.sizeSlider.value = zoneCount;
        if (this.sizeValueDisplay) this.sizeValueDisplay.textContent = zoneCount;
    },

    populatePadModeSelectDisplay() {
        if (!this.padModeSelectorDisplay || typeof PadModeManager === 'undefined') return;
        const currentModeId = app.state.padMode;
        const strategy = PadModeManager.strategies[currentModeId];
        let displayName = currentModeId;
        if (strategy && typeof strategy.getDisplayName === 'function') {
            displayName = strategy.getDisplayName();
        } else if (strategy && typeof strategy.getName === 'function') {
            displayName = i18n.translate(`pad_mode_${strategy.getName()}`, strategy.getName());
        } else if (typeof i18n !== 'undefined') {
            displayName = i18n.translate(`pad_mode_${currentModeId}`, currentModeId);
        }
        this.padModeSelectorDisplay.textContent = displayName;
    },

    displayModeSpecificControls(modeId) {
        if (!this.modeSpecificControlsContainer || typeof PadModeManager === 'undefined') {
            this.modeSpecificControlsContainer.innerHTML = `<p class="no-controls-message">${i18n.translate('error_loading_mode_settings', 'Error loading mode settings.')}</p>`;
            return;
        }
        this.modeSpecificControlsContainer.innerHTML = '';
        const strategy = PadModeManager.strategies[modeId];
        if (!strategy || typeof strategy.getModeSpecificControlsConfig !== 'function') {
            this.modeSpecificControlsContainer.innerHTML = `<p class="no-controls-message">${i18n.translate('error_loading_mode_settings', 'Error loading mode settings config.')}</p>`;
            return;
        }
        const controlsConfig = strategy.getModeSpecificControlsConfig();
        if (!Array.isArray(controlsConfig) || controlsConfig.length === 0) {
            this.modeSpecificControlsContainer.innerHTML = `<p class="no-controls-message">${i18n.translate('no_specific_settings_' + modeId, 'No specific settings for this mode.')}</p>`;
            return;
        }
        // Группировка по секциям
        const controlSections = { general: [], phases: [], harmonicLogic: [], interactiveBehavior: [] };
        controlsConfig.forEach(config => {
            if (["intensity", "visualTheme"].includes(config.name)) controlSections.general.push(config);
            else if (config.name.includes('Phase') || config.name.includes('Duration')) controlSections.phases.push(config);
            else if (["harmonicKeyDisplay","markerLogicMode", "displayMarkers", "markerStyle", "markerColorScheme", "tonalTonic"].some(n => config.name.startsWith(n))) controlSections.harmonicLogic.push(config);
            else controlSections.interactiveBehavior.push(config);
        });
        const createSection = (titleKey, titleDefault, configs) => {
            if (configs.length === 0) return;
            const sectionDiv = document.createElement('div');
            sectionDiv.className = 'setting-group mode-section';
            const titleH5 = document.createElement('h5');
            titleH5.textContent = i18n.translate(titleKey, titleDefault);
            sectionDiv.appendChild(titleH5);
            configs.forEach(config => {
                const controlDiv = document.createElement('div');
                controlDiv.className = config.type === 'toggle' ? 'toggle-container' : 'setting-item mode-control-item';
                let labelElement;
                const controlId = `rocket-control-${config.name.replace('.', '-')}`;
                if (config.type !== 'toggle') {
                    labelElement = document.createElement('label');
                    labelElement.htmlFor = controlId;
                    labelElement.textContent = i18n.translate(config.labelKey, config.labelDefault || config.name);
                    // Tooltip для label
                    if (config.description) {
                        labelElement.title = config.description;
                        labelElement.classList.add('has-tooltip');
                    }
                    controlDiv.appendChild(labelElement);
                }
                let controlInputElement;
                const currentValue = (app.state.rocketModeSettings && app.state.rocketModeSettings.hasOwnProperty(config.name))
                    ? app.state.rocketModeSettings[config.name]
                    : config.default;
                let currentDisplayMarkerValue = null;
                if (config.name.startsWith("displayMarkers.")) {
                    const subKey = config.name.split('.')[1];
                    if (app.state.rocketModeSettings && app.state.rocketModeSettings.displayMarkers) {
                        currentDisplayMarkerValue = app.state.rocketModeSettings.displayMarkers[subKey] !== undefined
                            ? app.state.rocketModeSettings.displayMarkers[subKey]
                            : config.default;
                    } else {
                        currentDisplayMarkerValue = config.default;
                    }
                }
                switch (config.type) {
                    case 'toggle':
                        const spanLabel = document.createElement('span');
                        spanLabel.textContent = i18n.translate(config.labelKey, config.labelDefault || config.name);
                        // Tooltip для toggle
                        if (config.description) {
                            spanLabel.title = config.description;
                            spanLabel.classList.add('has-tooltip');
                        }
                        controlDiv.appendChild(spanLabel);
                        const toggleLabel = document.createElement('label');
                        toggleLabel.className = 'toggle';
                        controlInputElement = document.createElement('input');
                        controlInputElement.type = 'checkbox';
                        controlInputElement.id = controlId;
                        controlInputElement.checked = config.name.startsWith("displayMarkers.") ? currentDisplayMarkerValue : currentValue;
                        const sliderSpan = document.createElement('span');
                        sliderSpan.className = 'toggle-slider';
                        toggleLabel.appendChild(controlInputElement);
                        toggleLabel.appendChild(sliderSpan);
                        controlDiv.appendChild(toggleLabel);
                        break;
                    case 'select':
                        controlInputElement = document.createElement('div');
                        controlInputElement.id = controlId;
                        controlInputElement.className = 'dropdown-display';
                        controlInputElement.tabIndex = 0;
                        controlInputElement.setAttribute('role', 'combobox');
                        const selectedOption = config.options.find(opt => opt.id === currentValue);
                        controlInputElement.textContent = selectedOption
                            ? (selectedOption.labelKey ? i18n.translate(selectedOption.labelKey, selectedOption.name) : selectedOption.name)
                            : currentValue;
                        controlDiv.appendChild(controlInputElement);
                        break;
                    case 'knob':
                        const knobContainer = document.createElement('div');
                        knobContainer.className = 'knob-container small-knob-container';
                        controlInputElement = document.createElement('div');
                        controlInputElement.className = 'knob small';
                        controlInputElement.id = controlId;
                        Object.assign(controlInputElement.dataset, {
                            param: config.name, min: config.min, max: config.max, step: config.step, default: currentValue
                        });
                        if (config.logScale) controlInputElement.dataset.log = 'true';
                        controlInputElement.innerHTML = `<div class="knob-dial"></div><span class="knob-value">${currentValue}</span>`;
                        knobContainer.appendChild(controlInputElement);
                        const knobLabel = document.createElement('label');
                        knobLabel.className = 'knob-sub-label';
                        knobLabel.textContent = i18n.translate(config.labelKey, config.labelDefault || config.name);
                        knobContainer.appendChild(knobLabel);
                        controlDiv.appendChild(knobContainer);
                        this.initKnob(controlInputElement);
                        break;
                    case 'display':
                        controlInputElement = document.createElement('span');
                        controlInputElement.id = controlId;
                        controlInputElement.className = 'display-value';
                        if (typeof config.getValue === 'function') {
                            controlInputElement.textContent = config.getValue();
                        } else {
                            controlInputElement.textContent = currentValue;
                        }
                        controlDiv.appendChild(controlInputElement);
                        break;
                }
                if (controlInputElement) {
                    const eventType = (config.type === 'toggle' || config.type === 'text') ? 'change' :
                                      (config.type === 'knob') ? 'knob-change' : null;
                    if (eventType) {
                        controlInputElement.addEventListener(eventType, (e) => {
                            const val = (config.type === 'toggle') ? e.target.checked :
                                        (config.type === 'knob') ? e.detail.value : e.target.value;
                            app.setModeSpecificSetting('rocket', config.name, val);
                        });
                    } else if (config.type === 'select') {
                        controlInputElement.addEventListener('mousedown', (e) => {
                            e.preventDefault();
                            const currentValFromState = config.name.startsWith("displayMarkers.")
                                ? app.state.rocketModeSettings.displayMarkers[config.name.split('.')[1]]
                                : app.state.rocketModeSettings[config.name];
                            showCustomSelectorPopover({
                                type: `rocket_${config.name.replace('.', '_')}`,
                                title: i18n.translate(config.labelKey, config.labelDefault || config.name),
                                itemsArray: config.options.map(opt => ({
                                    id: opt.id,
                                    name: opt.labelKey ? i18n.translate(opt.labelKey, opt.name) : opt.name
                                })),
                                currentValue: currentValFromState,
                                onSelect: (selectedValue) => {
                                    app.setModeSpecificSetting('rocket', config.name, selectedValue);
                                    const selOpt = config.options.find(o => o.id === selectedValue);
                                    controlInputElement.textContent = selOpt
                                        ? (selOpt.labelKey ? i18n.translate(selOpt.labelKey, selOpt.name) : selOpt.name)
                                        : selectedValue;
                                }
                            });
                        });
                        controlInputElement.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                controlInputElement.dispatchEvent(new MouseEvent('mousedown'));
                            }
                        });
                    }
                }
                sectionDiv.appendChild(controlDiv);
            });
            this.modeSpecificControlsContainer.appendChild(sectionDiv);
        };
        createSection('rocket_section_general', 'General', controlSections.general);
        createSection('rocket_section_phases', 'Phases', controlSections.phases);
        createSection('rocket_section_harmonic_logic', 'Harmonic Logic', controlSections.harmonicLogic);
        createSection('rocket_section_interactive_behavior', 'Interactive Behavior', controlSections.interactiveBehavior);

        if (modeId === 'rocket') {
            // === Кнопки ручного перехода фаз ===
            const appState = app.state;
            const rocketSettings = appState.rocketModeSettings;
            const manualAllowed = !rocketSettings.autoPhases || rocketSettings.phaseTransitionMode === 'manual';
            const phases = [
                { id: 'ignition', label: i18n.translate('rocket_phase_ignition', 'Ignition') },
                { id: 'lift-off', label: i18n.translate('rocket_phase_lift_off', 'Lift-off') },
                { id: 'burst', label: i18n.translate('rocket_phase_burst', 'Burst') }
            ];
            const btnGroup = document.createElement('div');
            btnGroup.className = 'rocket-phase-buttons-group';
            phases.forEach(phase => {
                const btn = document.createElement('button');
                btn.textContent = phase.label;
                btn.className = 'action-button';
                btn.disabled = !manualAllowed;
                if (appState.rocketModePhase === phase.id) btn.classList.add('active');
                btn.addEventListener('click', () => app.manualSetRocketPhase(phase.id));
                btnGroup.appendChild(btn);
            });
            this.modeSpecificControlsContainer.appendChild(btnGroup);
        }
    },

    updateSettingsControls(langId, themeId, vizId, touchEffectId, showNames, showGrid, enablePolyScaling, highlightSharps, currentPadMode) {
        if (this.languageSelect && this.languageSelect.options.length > 0) { if (this.languageSelect.querySelector(`option[value="${langId}"]`)) this.languageSelect.value = langId; else { this.languageSelect.selectedIndex = 0; } }
        if (this.themeSelect && this.themeSelect.options.length > 0) { if (this.themeSelect.querySelector(`option[value="${themeId}"]`)) this.themeSelect.value = themeId; else { this.themeSelect.selectedIndex = 0; } }
        if (this.visualizerSelect && this.visualizerSelect.options.length > 0) { if (this.visualizerSelect.querySelector(`option[value="${vizId}"]`)) this.visualizerSelect.value = vizId; else { this.visualizerSelect.selectedIndex = 0; } }
        if (this.touchEffectSelect && this.touchEffectSelect.options.length > 0) {
            const targetVal = touchEffectId || 'none';
            if (this.touchEffectSelect.querySelector(`option[value="${targetVal}"]`)) {
                this.touchEffectSelect.value = targetVal;
            } else {
                console.warn(`[SidePanel.updateSettingsControls v3] Touch Effect ID '${targetVal}' not found.`);
                if (this.touchEffectSelect.querySelector(`option[value="none"]`)) {
                    this.touchEffectSelect.value = 'none';
                } else {
                     this.touchEffectSelect.selectedIndex = 0;
                }
            }
        }

        if (this.noteNamesToggle) this.noteNamesToggle.checked = showNames;
        if (this.linesToggle) this.linesToggle.checked = showGrid;
        if (this.highlightSharpsFlatsToggle) this.highlightSharpsFlatsToggle.checked = highlightSharps;

        if (this.enablePolyphonyScalingToggle) this.enablePolyphonyScalingToggle.checked = enablePolyScaling;

        if (this.padModeSelect && this.padModeSelect.options.length > 0) {
            if (currentPadMode && this.padModeSelect.querySelector(`option[value="${currentPadMode}"]`)) {
                this.padModeSelect.value = currentPadMode;
            } else if (this.padModeSelect.options.length > 0) {
                this.padModeSelect.selectedIndex = 0;
            }
        }
        this.populatePadModeSelectDisplay();
        this.displayModeSpecificControls(currentPadMode);
        console.log(`[SidePanel.updateSettingsControls] Updated UI for Language: ${langId}, Theme: ${themeId}, Viz: ${vizId}, Effect: ${touchEffectId}, Names: ${showNames}, Lines: ${showGrid}, PolyScaling: ${enablePolyScaling}, SharpsFlats: ${highlightSharps}, PadMode: ${currentPadMode}`);
    },

    handleOctaveChange(value, finalChange = false) {
        const newOffset = parseInt(value, 10);
        if (isNaN(newOffset)) return;
        const clampedOffset = Math.max(-7, Math.min(7, newOffset));
        if (this.octaveSlider) this.octaveSlider.value = clampedOffset;
        if (this.octaveValueDisplay) this.octaveValueDisplay.textContent = clampedOffset;
        if (finalChange && clampedOffset !== app.state.octaveOffset) { app.setOctaveOffset(clampedOffset); }
    },

    handleSizeChange(value, finalChange = false) {
        const newSize = parseInt(value, 10);
        if (isNaN(newSize)) return;
        let clampedSize = Math.max(8, Math.min(36, newSize));
        if (clampedSize % 2 !== 0) {
            if (clampedSize === 35) clampedSize = 34;
            else if (clampedSize < 8) clampedSize = 8;
            else clampedSize = Math.round(clampedSize / 2) * 2;
            clampedSize = Math.max(8, Math.min(36, clampedSize));
        }
        if (this.sizeSlider) this.sizeSlider.value = clampedSize;
        if (this.sizeValueDisplay) this.sizeValueDisplay.textContent = clampedSize;
        if (finalChange && clampedSize !== app.state.zoneCount) {
            app.setZoneCount(clampedSize);
        }
    },

    showPanel(panelId) {
        this.hideAllPanels(panelId);
        const panel = this.panels[panelId];
        if (panel) {
            panel.classList.add('show');
            if (topbar && typeof topbar.getButtonForPanel === 'function') {
                const button = topbar.getButtonForPanel(panelId);
                if (button) button.classList.add('active');
            }
        }
    },

    hidePanel(panelId) {
        const panel = this.panels[panelId];
        if (panel) {
            panel.classList.remove('show');
            if (topbar && typeof topbar.getButtonForPanel === 'function') {
                const button = topbar.getButtonForPanel(panelId);
                if (button) button.classList.remove('active');
            }
        }
    },

    hideAllPanels(exceptId = null) {
        if (topbar && typeof topbar.deactivateAllButtons === 'function') {
            topbar.deactivateAllButtons();
        }
        for (const id in this.panels) {
            if (id !== exceptId && this.panels[id]) {
                this.hidePanel(id);
            }
        }
    },

    isPanelOpen(panelId) {
        const panel = this.panels[panelId];
        return panel ? panel.classList.contains('show') : false;
    },

    initKnob(knobElement) {
        if (!knobElement || !(knobElement instanceof HTMLElement) || this.knobsInitialized.has(knobElement)) return;
        const paramName = knobElement.dataset.param || 'unknown';
        const dial = knobElement.querySelector('.knob-dial');
        const valueDisplay = knobElement.querySelector('.knob-value');
        if (!dial || !valueDisplay) { return; }

        let isDragging = false, startY = 0, startValueLinear = 0;
        let min = 0, max = 1, step = 0.01, isLog = false;

        try {
            min = parseFloat(knobElement.dataset.min ?? 0);
            max = parseFloat(knobElement.dataset.max ?? 1);
            step = parseFloat(knobElement.dataset.step ?? 0.01);
            isLog = knobElement.dataset.log === 'true';
            if (isNaN(min) || isNaN(max) || isNaN(step)) throw new Error("NaN parsed");
            if (max <= min) { min = 0; max = 1; }
            if (step <= 0) { step = 0.01; }
            if (isLog && min <= 0) { isLog = false; console.warn(`[SidePanel.initKnob] Log scale for ${paramName} disabled due to min <= 0.`); }
        } catch (e) { console.error(`[SidePanel.initKnob] Error parsing data for ${paramName}:`, e); }

        const scaleToValue = (linearValue) => {
            const clampedLinear = Math.max(0, Math.min(1, linearValue));
            if (isLog) return min * Math.pow(max / min, clampedLinear);
            return min + clampedLinear * (max - min);
        };
        const valueToScale = (value) => {
            const clampedValue = Math.max(min, Math.min(max, value));
            if (isLog) {
                if (clampedValue <= min || max <= min) return 0;
                return Math.log(clampedValue / min) / Math.log(max / min);
            }
            if (max - min === 0) return 0;
            return (clampedValue - min) / (max - min);
        };

        const updateKnobUI = (valueToDisplay, triggerChangeEvent = true) => {
            let steppedValue = Math.round(valueToDisplay / step) * step;
            steppedValue = parseFloat(steppedValue.toFixed(5));
            steppedValue = Math.max(min, Math.min(max, steppedValue));

            const linearValue = valueToScale(steppedValue);
            const rotation = linearValue * 270 - 135;
            dial.style.transform = `translateX(-50%) rotate(${rotation}deg)`;

            let displayFormat;
            if (Math.abs(steppedValue) >= 10000 && isLog) displayFormat = (steppedValue / 1000).toFixed(1) + 'k';
            else if (Math.abs(steppedValue) >= 1000) displayFormat = Math.round(steppedValue).toString();
            else if (step >= 1) displayFormat = Math.round(steppedValue).toString();
            else if (step >= 0.1) displayFormat = steppedValue.toFixed(1);
            else if (step >= 0.01) displayFormat = steppedValue.toFixed(2);
            else displayFormat = steppedValue.toFixed(3);
            valueDisplay.textContent = displayFormat;
            knobElement.dataset.currentValue = steppedValue.toString();

            if (triggerChangeEvent) {
                knobElement.dispatchEvent(new CustomEvent('knob-change', { detail: { value: steppedValue }, bubbles: true }));
            }
        };

        const onPointerDown = (e) => {
            if (e.pointerType === 'mouse' && e.button !== 0) return;
            e.preventDefault(); e.stopPropagation();
            isDragging = true; startY = e.clientY;
            startValueLinear = valueToScale(parseFloat(knobElement.dataset.currentValue ?? knobElement.dataset.default ?? min));
            try { knobElement.setPointerCapture(e.pointerId); } catch (err) {}
            knobElement.style.cursor = 'ns-resize'; document.body.style.cursor = 'ns-resize';
        };
        const onPointerMove = (e) => {
            if (!isDragging || (e.pointerId !== knobElement._capturedPointerId && knobElement._capturedPointerId !== undefined)) return;
            e.preventDefault(); e.stopPropagation();
            const deltaY = startY - e.clientY;
            const sensitivityFactor = knobElement.classList.contains('small') ? 250 : 200;
            let newLinearValue = startValueLinear + (deltaY / sensitivityFactor);
            newLinearValue = Math.max(0, Math.min(1, newLinearValue));
            updateKnobUI(scaleToValue(newLinearValue), true);
        };
        const onPointerUp = (e) => {
            if (!isDragging || (e.pointerId !== knobElement._capturedPointerId && knobElement._capturedPointerId !== undefined)) return;
            e.stopPropagation(); isDragging = false;
            if (knobElement.hasPointerCapture(e.pointerId)) { try { knobElement.releasePointerCapture(e.pointerId); } catch (err) {} }
            knobElement.style.cursor = 'ns-resize'; document.body.style.cursor = '';
            delete knobElement._capturedPointerId;
        };

        knobElement.addEventListener('pointerdown', onPointerDown);
        document.addEventListener('pointermove', onPointerMove, {passive: false});
        document.addEventListener('pointerup', onPointerUp);
        knobElement.addEventListener('pointercancel', onPointerUp);
        knobElement.addEventListener('gotpointercapture', (e) => { knobElement._capturedPointerId = e.pointerId; });
        knobElement.addEventListener('lostpointercapture', (e) => { if (isDragging && e.pointerId === knobElement._capturedPointerId) { onPointerUp(e); }});

        knobElement.setValue = (value, triggerEvent = true) => { updateKnobUI(value, triggerEvent); };
        knobElement.getValue = () => parseFloat(knobElement.dataset.currentValue ?? min);
        updateKnobUI(parseFloat(knobElement.dataset.default ?? knobElement.dataset.currentValue ?? min), false);
        this.knobsInitialized.add(knobElement);
    },

    setKnobValue(knobElement, value, triggerEvent = false) {
         if (knobElement && typeof knobElement.setValue === 'function') {
             knobElement.setValue(value, triggerEvent);
         }
    },

    getKnobValue(knobElement) {
        if (knobElement && typeof knobElement.getValue === 'function') {
            return knobElement.getValue();
        }
        return knobElement?.dataset?.currentValue ? parseFloat(knobElement.dataset.currentValue) : 0;
    },

    updateScaleDisplay(scaleId) {
        if (this.scaleSelectDisplay && scaleId) {
            const scaleName = i18n.translate(scaleId, scaleId.charAt(0).toUpperCase() + scaleId.slice(1));
            this.scaleSelectDisplay.textContent = scaleName;
            console.log(`[SidePanel] Scale display updated to: ${scaleName} (ID: ${scaleId})`);
        } else if (this.scaleSelectDisplay) {
            this.scaleSelectDisplay.textContent = i18n.translate('select_option', 'Select Scale');
        }
    }
};
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\soundpresets.js
// Файл: app/src/main/assets/js/soundpresets.js
// Manages the Sound Library Panel UI (Preset Grid ONLY)
const soundPresets = {
    panelElement: null,
    presetGridElement: null,
    currentPresetId: null,
    userPresetPrefix: 'user_',

    init() {
        console.log('[SoundPresets v3] Initializing (Grid + Colors Mode)...'); // Версия лога
        this.panelElement = document.getElementById('sound-library-panel');
        if (!this.panelElement) {
            console.error("[SoundPresets v3] Panel element (#sound-library-panel) not found!");
            return;
        }

        this.presetGridElement = document.getElementById('preset-grid');
        if (!this.presetGridElement) {
            console.error("[SoundPresets v3] Preset grid element (#preset-grid) not found!");
            return;
        }

        this.addEventListeners();
        this.populatePresetGrid(); // Заполняем сетку при инициализации

        console.log('[SoundPresets v3] Initialized successfully (Grid + Colors Mode).');
    },

    addEventListeners() { // Без изменений по сравнению с v2
        console.log('[SoundPresets v3] Adding event listeners (Grid Mode)...');
        if (this.presetGridElement) {
            this.presetGridElement.addEventListener('click', (e) => {
                const cube = e.target.closest('.preset-cube');
                if (cube && cube.dataset.presetId) {
                    const presetId = cube.dataset.presetId;
                    this.handlePresetSelection(presetId);
                }
            });
        } else {
            console.warn("[SoundPresets v3] Preset grid element not found for listener.");
        }
        console.log('[SoundPresets v3] Event listeners added (Grid Mode).');
    },

    handlePresetSelection(presetId) { // Без изменений по сравнению с v2
        if (presetId && presetId !== this.currentPresetId) {
            console.log(`[SoundPresets v3] Preset selected: ${presetId}`);
            app.applySoundPreset(presetId); // app вызовет updateActivePresetCube
        } else if (!presetId) {
            console.warn("[SoundPresets v3] Invalid presetId received from click event.");
        } else {
            // console.log(`[SoundPresets v3] Preset ${presetId} already active.`); // Менее подробный лог
        }
    },

    async populatePresetGrid() { // <-- ОБНОВЛЕНО: Добавлено применение цветов
        console.log('[SoundPresets v3] Populating preset grid...');
        if (!this.presetGridElement) {
            console.error('[SoundPresets v3] Preset grid element is null!');
            return;
        }
        this.presetGridElement.innerHTML = ''; // Очищаем сетку

        try {
            const presets = await moduleManager.getModules('soundpreset', true);

            if (!presets || presets.length === 0) {
                console.warn('[SoundPresets v3] No sound presets found.');
                this.presetGridElement.innerHTML = `<div class="preset-cube disabled">${i18n.translate('no_presets_found', 'No presets found.')}</div>`;
                return;
            }

            console.log(`[SoundPresets v3] Found ${presets.length} presets.`);
            presets.sort((a, b) => (a.name || a.id).localeCompare(b.name || b.id));

            presets.forEach(preset => {
                const cube = document.createElement('div');
                cube.className = 'preset-cube';
                cube.dataset.presetId = preset.id;
                cube.textContent = preset.name || preset.id;
                cube.title = preset.name || preset.id;

                // --- НОВОЕ: Применение цветов ---
                const presetColors = preset.data?.data?.colors; // Получаем объект colors
                if (presetColors && typeof presetColors === 'object') {
                    // Пример: Устанавливаем основной цвет фона
                    if (presetColors.primary) {
                        cube.style.backgroundColor = presetColors.primary;
                    }
                    // Пример: Устанавливаем цвет текста
                    if (presetColors.text) {
                        cube.style.color = presetColors.text;
                    }
                    // Пример: Устанавливаем цвет границы (если нужно)
                    if (presetColors.secondary) {
                        cube.style.borderColor = presetColors.secondary;
                    }
                    // Альтернатива: Использовать CSS переменные для большей гибкости
                    // if (presetColors.primary) cube.style.setProperty('--preset-bg-color', presetColors.primary);
                    // if (presetColors.text) cube.style.setProperty('--preset-text-color', presetColors.text);
                } else {
                    // Используем дефолтные стили из CSS, если цвета не заданы
                    // console.warn(`[SoundPresets v3] No colors found for preset: ${preset.id}`);
                }
                // --- КОНЕЦ НОВОГО ---

                this.presetGridElement.appendChild(cube);
            });

            this.updateActivePresetCube(app.state.soundPreset);

        } catch (error) {
            console.error('[SoundPresets v3] Error populating preset grid:', error, error.stack);
            this.presetGridElement.innerHTML = `<div class="preset-cube disabled">${i18n.translate('error_loading_presets', 'Error loading presets.')}</div>`;
        }
    },

    updateActivePresetCube(presetId) { // Без изменений по сравнению с v2
        this.currentPresetId = presetId;
        // console.log(`[SoundPresets v3] Updating active preset cube UI to: ${presetId}`); // Менее подробный лог
        if (!this.presetGridElement) return;

        const cubes = this.presetGridElement.querySelectorAll('.preset-cube');
        let found = false;
        cubes.forEach(cube => {
            const isActive = cube.dataset.presetId === presetId;
            cube.classList.toggle('active', isActive);
            if (cube.textContent.endsWith('*')) { // Убираем звездочку модификации (если была)
                 cube.textContent = cube.textContent.slice(0, -1);
            }
            if (isActive) found = true;
        });

        if (!found && presetId && cubes.length > 0) {
            console.warn(`[SoundPresets v3] Preset ID "${presetId}" not found in grid.`);
        }
    },

}; // Конец объекта soundPresets
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\synth.js
// Файл: app/src/main/assets/js/synth.js
// ВЕРСИЯ С Master Volume Control, Polyphony Scaling И ГИБКИМ Y-Axis (Часть 1 и 2)

const synth = {
    voices: [],
    voiceState: [],
    effects: {},
    fxBus: null,
    analyser: null,
    masterVolume: null,
    limiter: null,
    isReady: false,
    activeVoices: new Map(), // Map<touchId, { frequency, noteId, voiceIndex, lastY }>
    silentTimeout: null,
    silentCheckInterval: 3000,
    currentFxChainData: null, // Кэш для данных текущей FX-цепочки (для макросов)
    _activeVoiceCountChanged: false, // Новый флаг
    _previousActiveVoiceCount: 0,    // Для отслеживания изменений

    config: {
        polyphony: 4, // Было 10. Для теста ASR ошибки уменьшено до 4.
        defaultPreset: { // Расширяем дефолтный пресет
            oscillator: { params: { type: 'triangle' } },
            amplitudeEnv: { params: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.5 } },
            filter: { params: { frequency: 5000, Q: 1, type: 'lowpass' } },
            outputGain: { params: { gain: 0 } }, // gain 0 = тишина по умолчанию
            pitchEnvelope: { enabled: false, params: { amount: 100, attack: 0.1, decay:0.1, sustain:0.5, release: 0.2 } },
            filterEnvelope: { enabled: false, params: { amount: 0, attack: 0.1, decay:0.1, sustain:0.5, release: 0.2 } },
            lfo1: { enabled: false, params: { rate: 5, depth: 0, target: 'filter.frequency', type: 'sine' } },
            portamento: { enabled: false, time: 0.05 },
            yAxisEffectsSendConfig: {
                minOutput: -45, // dB
                maxOutput: 0, // dB
                yThreshold: 0.1,
                curveType: 'exponential',
                curveFactor: 2.0,
                outputType: 'db'
            }
        },
        effectDefinitions: { // Расширяем определения эффектов
            delay: {
                constructor: Tone.FeedbackDelay,
                params: ['delayTime', 'feedback', 'wet'],
                defaults: { delayTime: 0.25, feedback: 0.5, wet: 0 }
            },
            reverb: { // Оставляем JCReverb
                constructor: Tone.JCReverb,
                params: ['roomSize', 'wet'], // JCReverb имеет roomSize, а не decay/preDelay напрямую
                defaults: { roomSize: 0.5, wet: 0 }
            },
            chorus: { // Новый
                constructor: Tone.Chorus,
                params: ['frequency', 'depth', 'delayTime', 'wet'],
                defaults: { frequency: 1.5, depth: 0.7, delayTime: 3.5, wet: 0 }
            },
            distortion: { // Новый
                constructor: Tone.Distortion,
                params: ['distortion', 'wet'], // 'oversample' можно добавить позже
                defaults: { distortion: 0.4, wet: 0 }
            },
            filter: { // Глобальный фильтр, новый
                constructor: Tone.Filter,
                params: ['frequency', 'Q', 'type', 'gain', 'rolloff', 'wet'],
                defaults: { frequency: 1000, Q: 1, type: 'lowpass', gain: 0, rolloff: -12, wet: 1 }
            }
            // Можно добавить Phaser, Flanger и т.д. позже
        },
        debug: true
    },

    init() {
        console.log('[Synth v7 - YAxisFlex] Initializing...');
        try {
            this.masterVolume = new Tone.Volume(Tone.gainToDb(1.0)).toDestination();
            this.limiter = new Tone.Limiter(-1).connect(this.masterVolume);
            this.analyser = new Tone.Analyser({ type: 'waveform', size: 1024 });
            this.fxBus = new Tone.Channel({ volume: 0, pan: 0, channelCount: 2 }).connect(this.limiter);

            this.voices = [];
            this.voiceState = [];
            const initialPreset = JSON.parse(JSON.stringify(this.config.defaultPreset));

            for (let i = 0; i < this.config.polyphony; i++) {
                const voiceBuildResult = voiceBuilder.buildVoiceChain(initialPreset);
                if (!voiceBuildResult || !voiceBuildResult.components?.outputGain || voiceBuildResult.errorState?.outputGain) {
                    console.error(`[Synth v7] Failed to create initial voice slot ${i}. Errors:`, voiceBuildResult?.errorState);
                    this.voices.push({ components: null, errorState: voiceBuildResult?.errorState || { critical: "Build failed" }, fxSend: null, currentPresetData: null });
                } else {
                    const fxSend = new Tone.Channel({ volume: -Infinity, channelCount: 2 }).connect(this.fxBus);
                    const outputNode = voiceBuildResult.components.outputGain.audioOutput;
                    if (outputNode) {
                        outputNode.fan(fxSend, this.analyser, this.limiter);
                    } else {
                       console.error(`[Synth v7 init] Output node not found for voice ${i}! FX send disabled.`);
                       fxSend.dispose();
                       if(voiceBuildResult.errorState) voiceBuildResult.errorState.outputGain = "Output node missing";
                    }
                    this.voices.push({
                        components: voiceBuildResult.components,
                        errorState: voiceBuildResult.errorState,
                        fxSend: outputNode ? fxSend : null,
                        currentPresetData: JSON.parse(JSON.stringify(initialPreset))
                    });
                }
                this.voiceState.push({ isBusy: false, touchId: null, noteId: null, startTime: 0 });
            }
            console.log(`[Synth v7 init] Initialized ${this.voices.filter(v => v.components).length}/${this.config.polyphony} voice slots.`);

            if (this.analyser && this.limiter && !this.analyser.numberOfOutputs) {
                 try { this.analyser.connect(this.limiter); } catch (e) { console.error("[Synth v7 init] Error connecting analyser (fallback):", e); }
            }

            console.log("[Synth v7 init] Creating global effect instances...");
            this.effects = {};
            const globalEffectOrder = ['delay', 'chorus', 'distortion', 'filter', 'reverb']; // Определяем порядок
            for (const effectName of globalEffectOrder) {
                 const def = this.config.effectDefinitions[effectName];
                 if (def && def.constructor) {
                      try {
                           // Для Tone.Filter и других эффектов, где 'wet' может быть проблемой в конструкторе,
                           // создаем с дефолтами БЕЗ 'wet', а 'wet' устанавливаем отдельно.
                           const constructorParams = { ...def.defaults };
                           delete constructorParams.wet;

                           const effectInstance = new def.constructor(constructorParams);

                           // Устанавливаем wet отдельно, если он есть в Tone.js API узла
                           if (effectInstance.wet && effectInstance.wet instanceof Tone.Param) {
                               effectInstance.wet.value = 0;
                           } else if (effectName === 'filter' && def.defaults.wet === 1) {
                               // Для фильтра, если wet по умолчанию 1, это значит, он должен быть всегда "включен"
                               // и не имеет стандартного .wet параметра для микса.
                               // Его "включенность" регулируется только наличием в цепочке.
                               // Поэтому здесь ничего не делаем с wet для Tone.Filter
                           }

                           this.effects[effectName] = effectInstance;
                           console.log(`[Synth Init FX] Created global effect: ${effectName} (${effectInstance.constructor.name}), initial wet: ${effectInstance.wet ? effectInstance.wet.value.toFixed(2) : 'N/A (no wet param)'}`);
                      } catch (effectError) {
                           console.error(`[Synth v7 init] Failed to create global effect '${effectName}':`, effectError);
                      }
                 } else if (def) { // Если определение есть, но нет конструктора
                     console.warn(`[Synth v7 init] No constructor found for effect definition '${effectName}'. Skipping.`);
                 }
                 // Если def не найден, это нормально, если не все эффекты из списка реализованы
            }

            this.isReady = true;
            console.log('[Synth v7 init] Synth engine marked as READY.');

            this.applyFxChain([]); // Применяем пустую цепочку, чтобы корректно соединить fxBus с limiter
            this.applyMasterVolumeSettings(); // Применяем начальные настройки мастер-громкости
            this.startSilentNotesCheck();
            this._previousActiveVoiceCount = 0;

        } catch (error) {
            console.error('[Synth v7 init] Initialization failed:', error, error.stack);
            this.isReady = false;
        }
    },

    applyMasterVolumeSettings() {
        if (!this.isReady || !this.masterVolume || !app || !app.state) {
            console.warn("[Synth applyMasterVolumeSettings] Not ready or masterVolume/app.state missing.");
            return;
        }
        let finalMasterGain = app.state.masterVolumeCeiling ?? 1.0;

        if (app.state.enablePolyphonyVolumeScaling) {
            const numTouches = this.activeVoices.size;
            if (numTouches > 1) { // Уменьшение начинается со второго активного касания
                const reductionFactor = Math.max(0.1, 1.0 - (numTouches - 1) * 0.05);
                finalMasterGain *= reductionFactor;
            }
        }
        // Преобразовать линейный гейн в dB для Tone.Volume
        const finalMasterDb = Tone.gainToDb(Math.max(0.0001, finalMasterGain)); // Предотвращаем -Infinity
        this.masterVolume.volume.value = finalMasterDb; // Используем .value для немедленного применения

        if (this.config.debug) {
            console.log(`[Synth MasterVol] Ceiling: ${app.state.masterVolumeCeiling.toFixed(2)}, PolyScale: ${app.state.enablePolyphonyVolumeScaling}, Touches: ${this.activeVoices.size}, Final Gain: ${finalMasterGain.toFixed(3)} (${finalMasterDb.toFixed(1)}dB)`);
        }
    },

    calculateGenericYParameter(yPosition, config) {
        const {
            minOutput = 0,
            maxOutput = 1,
            yThreshold = 0.0,
            curveType = 'linear',
            curveFactor = 1.0,
        } = config || {};

        const yNorm = Math.max(0, Math.min(1, yPosition));

        if (yNorm < yThreshold) {
            return (config?.outputType === 'db') ? -Infinity : minOutput;
        }

        const effectiveY = (yThreshold >= 1.0) ? 0 : (yNorm - yThreshold) / (1.0 - yThreshold);
        let scaledValue;

        switch (curveType) {
            case 'exponential':
                scaledValue = Math.pow(effectiveY, Math.max(0.1, curveFactor));
                break;
            case 'logarithmic':
                scaledValue = 1 - Math.pow(1 - effectiveY, Math.max(0.1, curveFactor));
                break;
            case 'sCurve':
                const k = (curveFactor - 0.1) / (5.0 - 0.1) * 10.0 - 5.0; // Преобразуем 0.1-5 в -5 до 5
                const val = 1 / (1 + Math.exp(-k * (effectiveY - 0.5)));
                const sMin = 1 / (1 + Math.exp(k * 0.5));
                const sMax = 1 / (1 + Math.exp(-k * 0.5));
                if (sMax - sMin !== 0) {
                   scaledValue = (val - sMin) / (sMax - sMin);
                } else {
                   scaledValue = effectiveY;
                }
                break;
            case 'linear':
            default:
                scaledValue = effectiveY;
                break;
        }
        scaledValue = Math.max(0, Math.min(1, scaledValue));
        let finalOutput = minOutput + scaledValue * (maxOutput - minOutput);
        return Math.max(minOutput, Math.min(maxOutput, finalOutput));
    },

    applyPreset(presetData, forceRecreation = false) {
        const t0 = performance.now();
        if (!this.isReady || !presetData) {
            console.warn('[Synth v7] Cannot apply preset. Synth not ready or presetData is null.');
            return;
        }
        if (this.config.debug) console.log('[Synth v7] Applying preset to all voices:', presetData);

        const safePresetData = {};
        const defaultPresetCopy = JSON.parse(JSON.stringify(this.config.defaultPreset));
        for (const compId in defaultPresetCopy) {
            safePresetData[compId] = { ...defaultPresetCopy[compId] };
            if (defaultPresetCopy[compId].params) {
                safePresetData[compId].params = { ...defaultPresetCopy[compId].params };
            }
        }
        for (const compId in presetData) {
            if (!safePresetData[compId]) safePresetData[compId] = {};
            if (presetData[compId].hasOwnProperty('enabled')) {
                safePresetData[compId].enabled = presetData[compId].enabled;
            }
            if (presetData[compId].params) {
                if (!safePresetData[compId].params) safePresetData[compId].params = {};
                safePresetData[compId].params = { ...safePresetData[compId].params, ...presetData[compId].params };
            } else if (typeof presetData[compId] === 'object' && presetData[compId] !== null &&
                       !presetData[compId].hasOwnProperty('enabled') && !presetData[compId].hasOwnProperty('params')) {
                if (!safePresetData[compId].params) safePresetData[compId].params = {};
                safePresetData[compId].params = { ...safePresetData[compId].params, ...presetData[compId] };
            }
        }
        if (presetData.portamento) {
            safePresetData.portamento = { ...defaultPresetCopy.portamento, ...presetData.portamento };
        }

        let t1 = performance.now();
        this.voices.forEach((voiceData, index) => {
            if (!voiceData) return;
            try {
                const oldPresetData = voiceData.currentPresetData || this.config.defaultPreset;
                let needsRecreation = forceRecreation || !voiceData.components;
                let t2 = performance.now();
                // Сравнение типа осциллятора с учетом undefined/null
                const oldOscType = oldPresetData.oscillator?.params?.type ?? null;
                const newOscType = safePresetData.oscillator?.params?.type ?? null;
                if (!needsRecreation && oldOscType !== newOscType) {
                    if (this.config.debug) console.log(`[Synth applyPreset] Reason for recreation: Oscillator type changed ('${oldOscType}' -> '${newOscType}')`);
                    needsRecreation = true;
                }
                const optionalComponents = ['pitchEnvelope', 'filterEnvelope', 'lfo1'];
                for (const optCompId of optionalComponents) {
                    const oldEnabled = oldPresetData[optCompId]?.enabled ?? (this.config.defaultPreset[optCompId]?.enabled ?? false);
                    const newEnabled = safePresetData[optCompId]?.enabled ?? (this.config.defaultPreset[optCompId]?.enabled ?? false);
                    if (oldEnabled !== newEnabled) {
                        if (this.config.debug) console.log(`[Synth applyPreset] Reason for recreation: Optional component '${optCompId}' enabled state changed (${oldEnabled} -> ${newEnabled})`);
                        needsRecreation = true;
                        break;
                    }
                }
                if (!needsRecreation) {
                    const oldPortaEnabled = oldPresetData.portamento?.enabled ?? (this.config.defaultPreset.portamento?.enabled ?? false);
                    const newPortaEnabled = safePresetData.portamento?.enabled ?? (this.config.defaultPreset.portamento?.enabled ?? false);
                    if (oldPortaEnabled !== newPortaEnabled) {
                        if (this.config.debug) console.log(`[Synth applyPreset] Reason for recreation: Portamento enabled state changed (${oldPortaEnabled} -> ${newPortaEnabled})`);
                        needsRecreation = true;
                    }
                }
                let t3 = performance.now();
                if (needsRecreation) {
                    if (this.config.debug) console.log(`[Synth applyPreset] RECREATING voice ${index}.`);
                    if (this.voiceState[index]?.isBusy) { this.triggerRelease(this.voiceState[index].touchId); }
                    voiceBuilder.disposeComponents(voiceData.components);
                    if (voiceData.fxSend) voiceData.fxSend.dispose();

                    const newVoiceBuildResult = voiceBuilder.buildVoiceChain(safePresetData);
                    if (newVoiceBuildResult && newVoiceBuildResult.components?.outputGain && !newVoiceBuildResult.errorState?.outputGain) {
                        const fxSend = new Tone.Channel({ volume: -Infinity, channelCount: 2 }).connect(this.fxBus);
                        const outputNode = newVoiceBuildResult.components.outputGain.audioOutput;
                        if (outputNode) {
                             outputNode.fan(fxSend, this.analyser, this.limiter);
                             this.voices[index] = {
                                 components: newVoiceBuildResult.components,
                                 errorState: newVoiceBuildResult.errorState,
                                 fxSend: fxSend,
                                 currentPresetData: JSON.parse(JSON.stringify(safePresetData))
                             };
                        } else { throw new Error("Output node missing after recreation for voice " + index); }
                    } else {
                        console.error(`[Synth v7 applyPreset] Failed to recreate voice slot ${index}. Errors:`, newVoiceBuildResult?.errorState);
                        this.voices[index] = { components: null, errorState: newVoiceBuildResult?.errorState || { critical: "Recreation failed" }, fxSend: null, currentPresetData: null };
                        this.releaseVoice(index);
                    }
                } else {
                    if (this.config.debug) console.log(`[Synth applyPreset] UPDATING voice ${index} parameters.`);
                    const components = voiceData.components;
                    const errorState = voiceData.errorState || {};
                    for (const componentId in safePresetData) {
                        const manager = audioConfig.getManager(componentId);
                        const compData = components[componentId];
                        const newSettings = safePresetData[componentId];
                        if (!manager || !compData || errorState[componentId]) continue;
                        let paramsToUpdate = null;
                        if (newSettings.params) {
                            paramsToUpdate = { ...newSettings.params };
                        } else if (typeof newSettings === 'object' && newSettings !== null && !newSettings.hasOwnProperty('enabled')) {
                            if (componentId === 'oscillator' || componentId === 'amplitudeEnv' || componentId === 'filter' || componentId === 'outputGain') {
                                paramsToUpdate = { ...newSettings };
                            }
                        }
                        if (componentId === 'oscillator') {
                            if (!paramsToUpdate) paramsToUpdate = {};
                            paramsToUpdate.portamento = (safePresetData.portamento?.enabled && safePresetData.portamento.time !== undefined)
                                                      ? safePresetData.portamento.time
                                                      : 0;
                            if (this.config.debug) console.log(`[Synth applyPreset] Updating oscillator for voice ${index} with portamento: ${paramsToUpdate.portamento}`);
                        }
                        if (paramsToUpdate && Object.keys(paramsToUpdate).length > 0 && typeof manager.update === 'function') {
                            if (!manager.update(compData.nodes, paramsToUpdate)) {
                                errorState[componentId] = "Update failed";
                            }
                        }
                    }
                    voiceData.currentPresetData = JSON.parse(JSON.stringify(safePresetData));
                    voiceData.errorState = errorState;
                }
                let t4 = performance.now();
                if (this.config.debug) {
                    console.log(`[Synth.applyPreset] Voice ${index} timings: prep=${(t2-t1).toFixed(2)}ms, checkRecreate=${(t3-t2).toFixed(2)}ms, buildOrUpdate=${(t4-t3).toFixed(2)}ms, totalVoice=${(t4-t1).toFixed(2)}ms`);
                }
            } catch (error) {
                console.error(`[Synth v7 applyPreset] Error applying preset to voice ${index}:`, error, error.stack);
                this.releaseVoice(index);
                if (voiceData) {
                    voiceData.components = null;
                    voiceData.errorState = { critical: `Apply preset failed: ${error.message}` };
                }
            }
        });
        if (this.config.debug) console.log('[Synth v7] Preset applied.');
        const t2 = performance.now();
        const duration = t2 - t0;
        if (duration > 10) {
            console.warn(`[Synth.applyPreset] Long execution: ${duration.toFixed(2)}ms`);
        }
    },

    startNote(frequency, velocity, yPosition, touchId) {
        const t0 = performance.now();
        if (!this.isReady) { console.warn("[Synth v7] startNote called but synth not ready."); return; }
        if (frequency <= 0) { console.warn(`[Synth v7] Invalid frequency ${frequency} passed to startNote.`); return; }
        let t1 = performance.now();
        const voiceIndex = this.getFreeVoiceIndex(touchId);
        let t2 = performance.now();
        if (voiceIndex === -1) { console.warn(`[Synth v7] No free voice found for touchId ${touchId}.`); return; }
        const voiceData = this.voices[voiceIndex];
        if (!voiceData || !voiceData.components || voiceData.errorState?.critical || voiceData.errorState?.oscillator || voiceData.errorState?.amplitudeEnv || voiceData.errorState?.outputGain) {
            console.error(`[Synth v7] Voice slot ${voiceIndex} invalid or critical component error. Errors:`, voiceData?.errorState);
            this.releaseVoice(voiceIndex);
            return;
        }
        let t3 = performance.now();
        const components = voiceData.components; const errorState = voiceData.errorState; const noteId = `${frequency.toFixed(1)}_${touchId}_${Date.now()}`;
        const yAxisVolConfig = app.state.yAxisControls.volume;
        const yAxisFxConfig = app.state.yAxisControls.effects;
        const calculatedVolume = this.calculateGenericYParameter(yPosition, yAxisVolConfig);
        const calculatedSendLevel = this.calculateGenericYParameter(yPosition, yAxisFxConfig);
        if (this.config.debug) console.log(`>>> [Synth.startNote v7] Freq=${frequency?.toFixed(1)}, Y=${yPosition?.toFixed(2)}, TouchID=${touchId}, Voice=${voiceIndex}, Vol=${calculatedVolume.toFixed(2)}, Send=${calculatedSendLevel.toFixed(1)}dB`);
        let t4 = performance.now();
        try {
            const oscManager = audioConfig.getManager('oscillator');
            const ampEnvManager = audioConfig.getManager('amplitudeEnv');
            const outputGainManager = audioConfig.getManager('outputGain');
            const pitchEnvManager = audioConfig.getManager('pitchEnvelope');
            const filterEnvManager = audioConfig.getManager('filterEnvelope');
            const lfo1Manager = audioConfig.getManager('lfo1');
            // Обновляем осциллятор и выходной гейн
            if (oscManager && components.oscillator && !errorState.oscillator) {
                let oscUpdateParams = { frequency: frequency };
                if (!oscManager.update(components.oscillator.nodes, oscUpdateParams)) errorState.oscillator = "Update failed";
            }
            let t5 = performance.now();
            if (outputGainManager && components.outputGain && !errorState.outputGain) {
                if (!outputGainManager.update(components.outputGain.nodes, { gain: calculatedVolume })) errorState.outputGain = "Update failed";
            }
            let t6 = performance.now();
            if (voiceData.fxSend) voiceData.fxSend.volume.value = calculatedSendLevel;
            let t7 = performance.now();
            // Триггерим огибающие
            if (ampEnvManager && components.amplitudeEnv && !errorState.amplitudeEnv) {
                ampEnvManager.triggerAttack(components.amplitudeEnv.nodes, Tone.now(), velocity);
            } else { throw new Error("Amplitude Envelope invalid or has error."); }
            let t8 = performance.now();
            if (pitchEnvManager && components.pitchEnvelope && !errorState.pitchEnvelope && voiceData.currentPresetData?.pitchEnvelope?.enabled) {
                if (!pitchEnvManager.triggerAttack(components.pitchEnvelope.nodes, Tone.now())) errorState.pitchEnvelope = "TriggerAttack failed";
            }
            let t9 = performance.now();
            if (filterEnvManager && components.filterEnvelope && !errorState.filterEnvelope && voiceData.currentPresetData?.filterEnvelope?.enabled) {
                if (!filterEnvManager.triggerAttack(components.filterEnvelope.nodes, Tone.now())) errorState.filterEnvelope = "TriggerAttack failed";
            }
            let t10 = performance.now();
            // Запускаем/перезапускаем LFO, если нужно
            if (lfo1Manager && components.lfo1 && !errorState.lfo1 && voiceData.currentPresetData?.lfo1?.enabled) {
                if (!lfo1Manager.enable(components.lfo1.nodes, true, { retrigger: voiceData.currentPresetData.lfo1.params?.retrigger ?? false })) {
                    errorState.lfo1 = "Enable/Retrigger failed";
                }
            }
            let t11 = performance.now();
            this.voiceState[voiceIndex].isBusy = true;
            this.voiceState[voiceIndex].touchId = touchId;
            this.voiceState[voiceIndex].noteId = noteId;
            this.voiceState[voiceIndex].startTime = Tone.now();
            this.activeVoices.set(touchId, { frequency: frequency, noteId: noteId, voiceIndex: voiceIndex, lastY: yPosition });
            if (this.activeVoices.size !== this._previousActiveVoiceCount) {
                this.applyMasterVolumeSettings();
                this._previousActiveVoiceCount = this.activeVoices.size;
            }
            let t12 = performance.now();
            if (this.config.debug) {
                console.log(`[Synth.startNote] Timings: getFreeVoiceIndex=${(t2-t1).toFixed(2)}ms, voiceCheck=${(t3-t2).toFixed(2)}ms, paramCalc=${(t4-t3).toFixed(2)}ms, oscUpdate=${(t5-t4).toFixed(2)}ms, gainUpdate=${(t6-t5).toFixed(2)}ms, fxSend=${(t7-t6).toFixed(2)}ms, ampEnv=${(t8-t7).toFixed(2)}ms, pitchEnv=${(t9-t8).toFixed(2)}ms, filterEnv=${(t10-t9).toFixed(2)}ms, lfo=${(t11-t10).toFixed(2)}ms, bookkeeping+vol=${(t12-t11).toFixed(2)}ms, total=${(t12-t0).toFixed(2)}ms`);
            }
        } catch (error) {
            console.error(`[Synth v7] Error triggering attack for voice ${voiceIndex}:`, error, error.stack);
            this.releaseVoice(voiceIndex);
        }
    },

    updateNote(frequency, velocity, yPosition, touchId) {
        const t0 = performance.now();
        if (!this.isReady) return;
        const voiceIndex = this.findVoiceIndex(touchId);
        if (voiceIndex === -1) return;
        let t1 = performance.now();
        const voiceData = this.voices[voiceIndex];
        if (!voiceData || !voiceData.components || voiceData.errorState?.critical) return;
        const components = voiceData.components;
        const errorState = voiceData.errorState;
        const activeVoice = this.activeVoices.get(touchId);
        let t2 = performance.now();
        let needUpdateY = true;
        if (activeVoice) {
            if (activeVoice.lastY === yPosition) {
                needUpdateY = false;
            }
        }
        let calculatedVolume, calculatedSendLevel;
        let t3 = performance.now();
        if (needUpdateY) {
            const yAxisVolConfig = app.state.yAxisControls.volume;
            const yAxisFxConfig = app.state.yAxisControls.effects;
            calculatedVolume = this.calculateGenericYParameter(yPosition, yAxisVolConfig);
            calculatedSendLevel = this.calculateGenericYParameter(yPosition, yAxisFxConfig);
            if (activeVoice) activeVoice.lastY = yPosition;
        } else {
            // Если Y не изменился, не пересчитываем значения и не обновляем параметры
            if (this.config.debug) {
                const t4 = performance.now();
                console.log(`[Synth.updateNote] Skipped update for unchanged Y. Timings: findVoiceIndex=${(t1-t0).toFixed(2)}ms, getVoice=${(t2-t1).toFixed(2)}ms, checkY=${(t3-t2).toFixed(2)}ms, total=${(t4-t0).toFixed(2)}ms`);
            }
            return;
        }
        let t4 = performance.now();
        try {
            const oscManager = audioConfig.getManager('oscillator');
            const outputGainManager = audioConfig.getManager('outputGain');
            if (activeVoice && activeVoice.frequency !== frequency && oscManager && components.oscillator && !errorState.oscillator) {
                if (!oscManager.update(components.oscillator.nodes, { frequency: frequency })) {
                    errorState.oscillator = "Update failed";
                } else {
                    activeVoice.frequency = frequency;
                }
            }
            let t5 = performance.now();
            if (outputGainManager && components.outputGain && !errorState.outputGain) {
                if (!outputGainManager.update(components.outputGain.nodes, { gain: calculatedVolume })) {
                     errorState.outputGain = "Update failed";
                }
            }
            let t6 = performance.now();
            if (voiceData.fxSend) {
                voiceData.fxSend.volume.rampTo(calculatedSendLevel, 0.02);
            }
            let t7 = performance.now();
            if (this.config.debug) {
                console.log(`[Synth.updateNote] Timings: findVoiceIndex=${(t1-t0).toFixed(2)}ms, getVoice=${(t2-t1).toFixed(2)}ms, checkY=${(t3-t2).toFixed(2)}ms, paramCalc=${(t4-t3).toFixed(2)}ms, oscUpdate=${(t5-t4).toFixed(2)}ms, gainUpdate=${(t6-t5).toFixed(2)}ms, fxSend=${(t7-t6).toFixed(2)}ms, total=${(t7-t0).toFixed(2)}ms`);
            }
        } catch(e) {
            console.error(`[Synth v7] Error ramping parameters for voice ${voiceIndex}:`, e);
        }
    },

    updateAllActiveVoiceMainLevels() {
        if (!this.isReady || !app || !app.state) return;
        const yAxisVolConfig = app.state.yAxisControls.volume;
        this.activeVoices.forEach((voiceInfo) => {
            const voiceIndex = voiceInfo.voiceIndex;
            const voiceData = this.voices[voiceIndex];
            if (voiceData && voiceData.components?.outputGain && !voiceData.errorState?.outputGain) {
                const yPosition = voiceInfo.lastY ?? 0.5; // Используем последнее известное Y
                const calculatedVolume = this.calculateGenericYParameter(yPosition, yAxisVolConfig);
                const outputGainManager = audioConfig.getManager('outputGain');
                if (outputGainManager && typeof outputGainManager.update === 'function') { // Проверка на существование update
                    outputGainManager.update(voiceData.components.outputGain.nodes, { gain: calculatedVolume });
                }
            }
        });
    },

    triggerRelease(touchId) {
        const t0 = performance.now();
        if (!this.isReady) return;
        const voiceIndex = this.findVoiceIndex(touchId);
        if (voiceIndex === -1) return;
        let t1 = performance.now();
        const voiceData = this.voices[voiceIndex];
        if (!voiceData || !voiceData.components?.amplitudeEnv || voiceData.errorState?.amplitudeEnv) {
           console.warn(`[Synth v7 triggerRelease] Voice slot ${voiceIndex} invalid AmpEnv or error state. Forcing release.`);
           this.releaseVoice(voiceIndex);
           this.activeVoices.delete(touchId);
           if (this.activeVoices.size !== this._previousActiveVoiceCount) {
               this.applyMasterVolumeSettings();
               this._previousActiveVoiceCount = this.activeVoices.size;
           }
           let t2 = performance.now();
           let t3 = performance.now();
           if (this.config.debug) {
               console.log(`[Synth.triggerRelease] Timings: findVoiceIndex=${(t1-t0).toFixed(2)}ms, releaseVoice=${(t2-t1).toFixed(2)}ms, deleteActiveVoice=${(t3-t2).toFixed(2)}ms, masterVol=${(t3-t0).toFixed(2)}ms`);
           }
           return;
        }
        const components = voiceData.components;
        const errorState = voiceData.errorState;
        let t2 = performance.now();
        try {
            const ampEnvManager = audioConfig.getManager('amplitudeEnv');
            const pitchEnvManager = audioConfig.getManager('pitchEnvelope');
            const filterEnvManager = audioConfig.getManager('filterEnvelope');
            let t3 = performance.now();
            if (ampEnvManager) {
                ampEnvManager.triggerRelease(components.amplitudeEnv.nodes, Tone.now());
            } else { throw new Error("AmpEnv manager not found."); }
            let t4 = performance.now();
            if (pitchEnvManager && components.pitchEnvelope && !errorState.pitchEnvelope && voiceData.currentPresetData?.pitchEnvelope?.enabled) {
                if (!pitchEnvManager.triggerRelease(components.pitchEnvelope.nodes, Tone.now())) {
                    errorState.pitchEnvelope = "TriggerRelease failed";
                }
            }
            let t5 = performance.now();
            if (filterEnvManager && components.filterEnvelope && !errorState.filterEnvelope && voiceData.currentPresetData?.filterEnvelope?.enabled) {
                if (!filterEnvManager.triggerRelease(components.filterEnvelope.nodes, Tone.now())) {
                    errorState.filterEnvelope = "TriggerRelease failed";
                }
            }
            let t6 = performance.now();
            this.releaseVoice(voiceIndex);
            let t7 = performance.now();
            this.activeVoices.delete(touchId);
            let t8 = performance.now();
            if (this.activeVoices.size !== this._previousActiveVoiceCount) {
                this.applyMasterVolumeSettings();
                this._previousActiveVoiceCount = this.activeVoices.size;
            }
            let t9 = performance.now();
            if (this.config.debug) {
                console.log(`[Synth.triggerRelease] Timings: findVoiceIndex=${(t1-t0).toFixed(2)}ms, mgrs=${(t3-t2).toFixed(2)}ms, ampEnv=${(t4-t3).toFixed(2)}ms, pitchEnv=${(t5-t4).toFixed(2)}ms, filterEnv=${(t6-t5).toFixed(2)}ms, releaseVoice=${(t7-t6).toFixed(2)}ms, deleteActiveVoice=${(t8-t7).toFixed(2)}ms, masterVol=${(t9-t8).toFixed(2)}ms, total=${(t9-t0).toFixed(2)}ms`);
            }
        } catch (error) {
            console.error(`[Synth v7] Error triggering release for voice ${voiceIndex}:`, error, error.stack);
            this.releaseVoice(voiceIndex);
            let t7 = performance.now();
            this.activeVoices.delete(touchId);
            let t8 = performance.now();
            if (this.activeVoices.size !== this._previousActiveVoiceCount) {
                this.applyMasterVolumeSettings();
                this._previousActiveVoiceCount = this.activeVoices.size;
            }
            let t9 = performance.now();
            if (this.config.debug) {
                console.log(`[Synth.triggerRelease] Timings (error): findVoiceIndex=${(t1-t0).toFixed(2)}ms, releaseVoice=${(t7-t2).toFixed(2)}ms, deleteActiveVoice=${(t8-t7).toFixed(2)}ms, masterVol=${(t9-t8).toFixed(2)}ms, total=${(t9-t0).toFixed(2)}ms`);
            }
        }
    },

    updateActiveVoicesParameter(paramPath, value) {
        if (!this.isReady) return;
        const pathParts = paramPath.split('.');
        if (pathParts.length < 2) {
            console.warn(`[Synth v7] Invalid paramPath for updateActiveVoicesParameter: ${paramPath}`);
            return;
        }
        const componentId = pathParts[0];
        const manager = audioConfig.getManager(componentId);
        if (!manager || typeof manager.update !== 'function') {
            console.warn(`[Synth v7] No valid manager or update function for componentId: ${componentId}`);
            return;
        }

        const settingsUpdate = {};
        let currentLevel = settingsUpdate;
        for(let i = 1; i < pathParts.length - 1; i++) {
            const part = pathParts[i];
            if (!currentLevel[part]) currentLevel[part] = {};
            currentLevel = currentLevel[part];
        }
        currentLevel[pathParts[pathParts.length - 1]] = value;

        this.activeVoices.forEach(voiceInfo => {
            const voiceIndex = voiceInfo.voiceIndex;
            const voiceData = this.voices[voiceIndex];
            if (voiceData && voiceData.components && voiceData.components[componentId] && !(voiceData.errorState && voiceData.errorState[componentId])) {
                try {
                    if (!manager.update(voiceData.components[componentId].nodes, settingsUpdate)) {
                        if (voiceData.errorState) voiceData.errorState[componentId] = "Update failed during active voice update";
                    }
                } catch (e) {
                    if (voiceData.errorState) voiceData.errorState[componentId] = `Update error during active voice update: ${e.message}`;
                    console.error(`[Synth v7] Error updating param ${paramPath} for active voice ${voiceIndex}:`, e);
                }
            }
        });

        // Обновляем кэш пресета для всех голосов, чтобы при следующей смене пресета не было сюрпризов
        this.voices.forEach((voiceData) => {
            if (voiceData && voiceData.currentPresetData) {
                try {
                    let current = voiceData.currentPresetData;
                    if (!current[componentId]) current[componentId] = { params: {} };
                    if (!current[componentId].params) current[componentId].params = {};

                    let targetParams = current[componentId].params;
                    let currentLevelParams = targetParams;
                    for(let i = 1; i < pathParts.length - 1; i++) {
                        const part = pathParts[i];
                        if (!currentLevelParams[part]) currentLevelParams[part] = {};
                        currentLevelParams = currentLevelParams[part];
                    }
                    currentLevelParams[pathParts[pathParts.length - 1]] = value;

                    // Синхронизация Q и resonance, если это фильтр
                    if (componentId === 'filter' && targetParams) {
                        if (paramPath === 'filter.Q') targetParams.resonance = value;
                        if (paramPath === 'filter.resonance') targetParams.Q = value;
                    }
                } catch (e) {
                    console.error("[Synth v7] Error updating voice presetData cache during active voice update:", e);
                }
            }
        });
    },

    stopAllNotes() {
        if (!this.isReady) return;
        const activeTouchIds = [...this.activeVoices.keys()];
        activeTouchIds.forEach(touchId => {
            this.triggerRelease(touchId); // triggerRelease уже вызывает applyMasterVolumeSettings
        });
        // Убедимся, что все голоса действительно освобождены
        this.voiceState.forEach((state, index) => {
            if (state?.isBusy) {
                this.releaseVoice(index);
            }
        });
        this.activeVoices.clear();
        this.applyMasterVolumeSettings(); // Финальный вызов на случай, если activeVoices уже был пуст
    },

    forceStopAllNotes() {
        console.warn('[Synth v7] Force releasing ALL notes (soft attempt first)...');
        this.activeVoices.forEach((voiceInfo, touchId) => {
            const voiceIndex = this.findVoiceIndex(touchId);
            if (voiceIndex !== -1) {
                console.log(`[Synth ForceStop] Soft releasing voice ${voiceIndex} for touch ${touchId}`);
                const voiceData = this.voices[voiceIndex];
                if (voiceData && voiceData.components) {
                    const ampEnvManager = audioConfig.getManager('amplitudeEnv');
                    if (ampEnvManager && voiceData.components.amplitudeEnv) {
                        ampEnvManager.triggerRelease(voiceData.components.amplitudeEnv.nodes, Tone.now());
                    }
                    const pitchEnvManager = audioConfig.getManager('pitchEnvelope');
                    if (pitchEnvManager && voiceData.components.pitchEnvelope && voiceData.currentPresetData?.pitchEnvelope?.enabled) {
                        pitchEnvManager.triggerRelease(voiceData.components.pitchEnvelope.nodes, Tone.now());
                    }
                    const filterEnvManager = audioConfig.getManager('filterEnvelope');
                    if (filterEnvManager && voiceData.components.filterEnvelope && voiceData.currentPresetData?.filterEnvelope?.enabled) {
                        filterEnvManager.triggerRelease(voiceData.components.filterEnvelope.nodes, Tone.now());
                    }
                }
                this.releaseVoice(voiceIndex);
            }
        });
        this.activeVoices.clear();
        this.applyMasterVolumeSettings();
        console.log('[Synth v7] All notes soft-released.');
        setTimeout(() => {
            let stillBusy = false;
            this.voiceState.forEach((state, index) => {
                if (state.isBusy) {
                    console.error(`[Synth ForceStop] Voice ${index} STILL BUSY after soft release! Disposing components.`);
                    if (this.voices[index] && this.voices[index].components) {
                        voiceBuilder.disposeComponents(this.voices[index].components);
                        this.voices[index].components = null;
                        this.voices[index].errorState = { critical: "Hard force stopped" };
                    }
                    this.releaseVoice(index);
                    stillBusy = true;
                }
            });
            if (stillBusy) this.applyMasterVolumeSettings();
        }, 1000);
    },

    applyFxChain(fullFxChainData) {
        this.currentFxChainData = fullFxChainData ? JSON.parse(JSON.stringify(fullFxChainData)) : null;
        const fxChainSettingsArray = fullFxChainData ? fullFxChainData.effects : [];
        console.log(`[Synth FX ApplyChain] Applying FX Chain. App State ChainID: ${app.state.fxChain}. Received full data: ${!!fullFxChainData}, Effects array length: ${fxChainSettingsArray ? fxChainSettingsArray.length : 'null/undefined'}`);

        if (this.config.debug && fxChainSettingsArray && fxChainSettingsArray.length > 0) {
            console.log('[Synth FX ApplyChain] FX Settings Details (raw array):', fxChainSettingsArray);
            fxChainSettingsArray.forEach((eff, idx) => {
                let paramsString = '[Could not stringify params]';
                try { paramsString = JSON.stringify(eff.params || {}); } catch (e) {}
                console.log(`[Synth FX ApplyChain] Detail for effect ${idx} (type ${eff.type}): enabled=${eff.enabled !== false}, params=${paramsString}, targetWet=${eff.params?.wet ?? (this.config.effectDefinitions[eff.type]?.defaults.wet ?? 0)}`);
            });
        }
        if (!this.isReady) { console.warn("[Synth v7] Cannot apply FX chain, synth not ready."); return; }
        if (this.config.debug) console.log('[Synth v7] Applying FX chain settings to global effects:', fxChainSettingsArray);

        // Отсоединяем всё от fxBus и эффекты друг от друга
        this.fxBus.disconnect();
        Object.values(this.effects).forEach(effect => { if(effect && typeof effect.disconnect === 'function') effect.disconnect(); });

        // Сброс параметров эффектов к их дефолтам (особенно wet=0)
        for (const effectName in this.effects) {
            const effectInstance = this.effects[effectName];
            const def = this.config.effectDefinitions[effectName];
            if (effectInstance && def && def.defaults) {
                try {
                    effectInstance.set({ ...def.defaults, wet: 0 });
                } catch (e) { console.warn(`[Synth v7] Could not reset effect '${effectName}' to defaults:`, e); }
            }
        }

        const activeEffectNodes = [];
        if (Array.isArray(fxChainSettingsArray)) {
            fxChainSettingsArray.forEach(fxSetting => {
                const effectName = fxSetting.type;
                const effectInstance = this.effects[effectName];
                const definition = this.config.effectDefinitions[effectName];

                if (effectInstance && definition) {
                    let paramsToApply = { ...(fxSetting.params || {}) };
                    if (fxSetting.enabled !== false) {
                        if (!paramsToApply.hasOwnProperty('wet')) {
                            if (effectName !== 'filter') {
                                paramsToApply.wet = 0;
                                console.log(`[Synth FX ApplyChain] Effect '${effectName}' enabled, 'wet' not in params, defaulted to 0.`);
                            } else {
                                if (paramsToApply.hasOwnProperty('wet')) {
                                    console.warn(`[Synth FX ApplyChain] 'wet' parameter found for Tone.Filter in chain, but Tone.Filter does not use it directly. Params:`, paramsToApply);
                                }
                            }
                        }
                    }
                    if (this.config.debug) console.log(`[Synth FX ApplyChain] Configuring effect '${effectName}'. Enabled: ${fxSetting.enabled !== false}. Final Params:`, JSON.parse(JSON.stringify(paramsToApply)));
                    if (effectName === 'reverb' && paramsToApply.hasOwnProperty('decay')) {
                        const decay = paramsToApply.decay;
                        paramsToApply.roomSize = Math.max(0.01, Math.min(0.99, 0.01 + (Math.max(0.1, Math.min(10, decay)) / 10) * 0.98));
                        delete paramsToApply.decay;
                        if (paramsToApply.hasOwnProperty('preDelay')) {
                            console.warn(`[Synth applyFxChain] 'preDelay' param for Reverb (JCReverb) is ignored.`);
                            delete paramsToApply.preDelay;
                        }
                    }
                    try {
                        if (Object.keys(paramsToApply).length > 0) {
                            effectInstance.set(paramsToApply);
                        }
                        if (fxSetting.enabled !== false) {
                            if (effectName !== 'filter' && paramsToApply.wet > 0) {
                                activeEffectNodes.push(effectInstance);
                            } else if (effectName === 'filter') {
                                activeEffectNodes.push(effectInstance);
                            }
                        } else {
                            if (this.config.debug) console.log(`[Synth v7] Effect '${effectName}' is disabled in chain.`);
                        }
                    } catch (e) {
                        console.warn(`[Synth v7] Could not apply settings to global effect '${effectName}':`, e, paramsToApply);
                    }
                } else {
                    console.warn(`[Synth v7] Effect type '${effectName}' not found in global effects or definitions.`);
                }
            });
        } else {
            console.warn("[Synth v7] applyFxChain received invalid settings format (expected array):", fxChainSettingsArray);
        }

        // Соединяем активные эффекты в цепочку
        try {
            if (activeEffectNodes.length > 0) {
                this.fxBus.chain(...activeEffectNodes, this.limiter);
                console.log('[Synth FX ApplyChain] FX Bus Chaining Complete. Active effect nodes connected:', activeEffectNodes.map(n => n.constructor.name).join(', '));
            } else {
                this.fxBus.connect(this.limiter); // Если нет эффектов, fxBus идет напрямую в лимитер
                if (this.config.debug) console.log('[Synth v7] No active global effects. FX Bus connected to limiter.');
            }
        } catch (chainError) {
            console.error('[Synth v7] Error chaining global effects:', chainError);
            try { this.fxBus.connect(this.limiter); } catch(e){} // Fallback
        }

        if (this.config.debug) console.log('[Synth v7] FX chain applied.');
        this.updateAllActiveVoiceSendLevels();

        if (typeof fxChains !== 'undefined' && typeof fxChains.updateMacroKnobsFromChain === 'function') {
            fxChains.updateMacroKnobsFromChain(this.currentFxChainData);
        }
    },

    async setMacro(macroName, value) {
        if (this.config.debug) console.log(`[Synth FX Macro] setMacro called with Name: '${macroName}', Value: ${value.toFixed(3)}. CurrentChainID: ${this.currentChainId}`);
        if (!this.currentFxChainData || !this.currentFxChainData.macroMappings) {
            if (this.config.debug && this.currentChainId) console.warn(`[Synth FX Macro] No macroMappings in currentFxChainData ('${this.currentChainId}') or data is null.`);
            return;
        }
        const mappings = this.currentFxChainData.macroMappings[macroName];
        if (!mappings || !Array.isArray(mappings)) {
            if(this.config.debug) console.warn(`[Synth FX Macro] No valid mapping array found for macro: '${macroName}' in chain '${this.currentChainId}'. Mappings object:`, this.currentFxChainData.macroMappings);
            return;
        }
        // ... остальная логика применения маппингов ...
    },

    updateAllActiveVoiceSendLevels() {
        if (!this.isReady || !app || !app.state) return;
        const yAxisFxConfig = app.state.yAxisControls.effects;
        const lastY = (typeof pad !== 'undefined' && typeof pad.getLastYPosition === 'function') ? pad.getLastYPosition() : 0.5; // Дефолтное значение, если pad не доступен

        // Рассчитываем уровень посыла для текущей Y позиции
        const calculatedSendLevel = this.calculateGenericYParameter(lastY, yAxisFxConfig);

        this.activeVoices.forEach((voiceInfo) => {
            const voiceIndex = voiceInfo.voiceIndex;
            const voiceData = this.voices[voiceIndex];
            if (voiceData && voiceData.components?.outputGain && !voiceData.errorState?.outputGain) {
                const yPosForVoice = voiceInfo.lastY ?? lastY; // Используем Y голоса, если есть, иначе общий
                const individualSendLevel = this.calculateGenericYParameter(yPosForVoice, yAxisFxConfig);

                if (this.voices[voiceIndex]?.fxSend?.volume) {
                    this.voices[voiceIndex].fxSend.volume.rampTo(individualSendLevel, 0.05);
                }
            }
        });
    },
    getAnalyser() { return this.analyser; },
    getCurrentFxSettings() {
        const settings = [];
        if (!this.isReady) return settings;
        // Используем порядок из effectDefinitions или заданный массив, чтобы гарантировать порядок
        const globalEffectOrder = Object.keys(this.config.effectDefinitions); // Или ваш массив ['delay', 'reverb', ...]

        for (const effectName of globalEffectOrder) {
            if (this.effects[effectName] && this.config.effectDefinitions[effectName]) {
                const effect = this.effects[effectName];
                const def = this.config.effectDefinitions[effectName];
                const effectSetting = { type: effectName, params: {} };

                def.params.forEach(paramName => {
                    try {
                        let currentValue = (effect[paramName] instanceof Tone.Param || effect[paramName] instanceof Tone.Signal)
                                          ? effect[paramName].value
                                          : effect[paramName];
                        if (typeof currentValue === 'number') {
                            effectSetting.params[paramName] = parseFloat(currentValue.toFixed(4));
                        } else {
                            effectSetting.params[paramName] = currentValue; // Для нечисловых (напр. oversample)
                        }
                    } catch (e) {
                        effectSetting.params[paramName] = def.defaults[paramName]; // Fallback
                    }
                });

                // Wet параметр
                if (effect.wet instanceof Tone.Param) {
                    effectSetting.wet = parseFloat(effect.wet.value.toFixed(4));
                } else if (effect.wet !== undefined) { // Для случаев, когда wet не Param (хотя обычно это так)
                    effectSetting.wet = effect.wet;
                }
                settings.push(effectSetting);
            }
        }
        return settings;
    },
    getFreeVoiceIndex(touchId) {
        // Сначала ищем полностью свободный голос
        for (let i = 0; i < this.config.polyphony; i++) {
            if (!this.voiceState[i]?.isBusy && this.voices[i]?.components && !this.voices[i]?.errorState?.critical) {
                return i;
            }
        }
        // Если свободных нет, ищем самый старый голос (voice stealing)
        let oldestVoiceIndex = -1;
        let oldestStartTime = Infinity;
        for (let i = 0; i < this.config.polyphony; i++) {
            if (this.voiceState[i]?.isBusy && this.voiceState[i].touchId !== touchId && this.voices[i]?.components && !this.voices[i]?.errorState?.critical) {
                if (this.voiceState[i].startTime < oldestStartTime) {
                    oldestStartTime = this.voiceState[i].startTime;
                    oldestVoiceIndex = i;
                }
            }
        }
        if (oldestVoiceIndex !== -1) {
            const oldTouchId = this.voiceState[oldestVoiceIndex].touchId;
            if (this.config.debug) console.warn(`[Synth v7] Stealing voice ${oldestVoiceIndex} from touch ${oldTouchId}`);
            // --- МЯГКАЯ КРАЖА ---
            const voiceToSteal = this.voices[oldestVoiceIndex];
            if (voiceToSteal && voiceToSteal.components) {
                const outputGainManager = audioConfig.getManager('outputGain');
                if (outputGainManager && voiceToSteal.components.outputGain?.nodes) {
                    outputGainManager.update(voiceToSteal.components.outputGain.nodes, { gain: 0 });
                }
                if (voiceToSteal.fxSend?.volume) {
                    voiceToSteal.fxSend.volume.value = -Infinity;
                }
                const lfoManager = audioConfig.getManager('lfo1');
                if (lfoManager && voiceToSteal.components.lfo1?.nodes && voiceToSteal.currentPresetData?.lfo1?.enabled) {
                    lfoManager.enable(voiceToSteal.components.lfo1.nodes, false);
                }
                // Можно добавить отключение других LFO, если есть
            }
            // Помечаем для отложенного полного релиза
            this.voiceState[oldestVoiceIndex]._stolenForFullRelease = oldTouchId;
            this.releaseVoice(oldestVoiceIndex); // Быстро освобождает слот
            this.activeVoices.delete(oldTouchId);
            setTimeout(() => {
                if (this.voiceState[oldestVoiceIndex] && this.voiceState[oldestVoiceIndex]._stolenForFullRelease === oldTouchId) {
                    const stolenVoiceData = this.voices[oldestVoiceIndex];
                    if (stolenVoiceData && stolenVoiceData.components) {
                        console.log(`[Synth] Performing full deferred release for stolen voice ${oldestVoiceIndex}`);
                        const ampEnvManager = audioConfig.getManager('amplitudeEnv');
                        if (ampEnvManager && stolenVoiceData.components.amplitudeEnv) {
                            ampEnvManager.triggerRelease(stolenVoiceData.components.amplitudeEnv.nodes, Tone.now());
                        }
                        const pitchEnvManager = audioConfig.getManager('pitchEnvelope');
                        if (pitchEnvManager && stolenVoiceData.components.pitchEnvelope && stolenVoiceData.currentPresetData?.pitchEnvelope?.enabled) {
                            pitchEnvManager.triggerRelease(stolenVoiceData.components.pitchEnvelope.nodes, Tone.now());
                        }
                        const filterEnvManager = audioConfig.getManager('filterEnvelope');
                        if (filterEnvManager && stolenVoiceData.components.filterEnvelope && stolenVoiceData.currentPresetData?.filterEnvelope?.enabled) {
                            filterEnvManager.triggerRelease(stolenVoiceData.components.filterEnvelope.nodes, Tone.now());
                        }
                    }
                    delete this.voiceState[oldestVoiceIndex]._stolenForFullRelease;
                }
            }, 50);
            return oldestVoiceIndex;
        }
        console.error("[Synth v7] Could not find any voice to assign/steal!");
        return -1;
    },
    findVoiceIndex(touchId) {
        for (let i = 0; i < this.config.polyphony; i++) {
            if (this.voiceState[i]?.isBusy && this.voiceState[i].touchId === touchId) {
                return i;
            }
        }
        return -1;
    },
    releaseVoice(voiceIndex) {
        if (voiceIndex >= 0 && voiceIndex < this.config.polyphony && this.voiceState[voiceIndex]) {
            this.voiceState[voiceIndex].isBusy = false;
            this.voiceState[voiceIndex].touchId = null;
            this.voiceState[voiceIndex].noteId = null;
            this.voiceState[voiceIndex].startTime = 0;

            const voiceData = this.voices[voiceIndex];
            try {
                // Устанавливаем гейн в 0 и посыл на FX в -Infinity
                const outputGainManager = audioConfig.getManager('outputGain');
                if (outputGainManager && voiceData?.components?.outputGain && !voiceData.errorState?.outputGain) {
                    if (voiceData.components.outputGain.nodes?.gainNode) {
                        outputGainManager.update(voiceData.components.outputGain.nodes, { gain: 0 });
                    }
                }
                if (voiceData?.fxSend?.volume) { // fxSend может быть null, если голос не создался
                    voiceData.fxSend.volume.value = -Infinity;
                }

                // Останавливаем LFO, если он был активен для этого голоса
                const lfoManager = audioConfig.getManager('lfo1'); // Пример для lfo1
                if (lfoManager && voiceData?.components?.lfo1 && !voiceData.errorState?.lfo1) {
                    lfoManager.enable(voiceData.components.lfo1.nodes, false);
                }
                // Добавить аналогично для других LFO, если они есть
            } catch(e) {
                console.error(`[Synth v7] Error resetting gain/send/lfo for voice ${voiceIndex}:`, e);
            }
        }
    },
    startSilentNotesCheck() {
         if (this.silentTimeout) { clearInterval(this.silentTimeout); }
         this.silentTimeout = setInterval(() => {
             let busyVoiceCount = this.voiceState.filter(vs => vs?.isBusy).length;
             // Используем activeTouchesInternal из pad.js, если доступно
             const activePadTouches = (typeof pad !== 'undefined' && pad.activeTouchesInternal) ? pad.activeTouchesInternal.size : this.activeVoices.size;

             if (busyVoiceCount > 0 && activePadTouches === 0 && pad && !pad.hasRecentActivity()) {
                 if (this.config.debug) {
                     console.warn(`[Synth v7 Watchdog] Detected ${busyVoiceCount} potential stuck notes (Pad touches: ${activePadTouches}). Forcing release.`);
                 }
                 this.forceStopAllNotes();
             }
         }, this.silentCheckInterval);
    }
};

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\topbar.js
// Файл: app/src/main/assets/js/topbar.js
const topbar = {
    buttons: {
        menu: null,
        soundLibrary: null,
        tonality: null,
        effects: null,
        reloadApp: null,
        padModes: null // НОВАЯ КНОПКА
    },
    isReloadingAppFlag: false, // Используем другое имя для флага, чтобы не конфликтовать с app

    init() {
        console.log('[Topbar.init PadModes] Initializing...');
        this.buttons.menu = document.getElementById('menu-button');
        this.buttons.soundLibrary = document.getElementById('sound-library-button');
        this.buttons.tonality = document.getElementById('tonality-button');
        this.buttons.effects = document.getElementById('effects-button');
        this.buttons.reloadApp = document.getElementById('reload-app-button'); // ID из HTML
        this.buttons.padModes = document.getElementById('pad-modes-button'); // Инициализация новой кнопки

        if (!this.buttons.padModes) console.warn("[Topbar.init PadModes] Pad Modes button ('pad-modes-button') not found.");
        if (!this.buttons.reloadApp) console.warn("[Topbar.init ReloadLogic] Reload App button ('reload-app-button') not found.");
        if (!this.buttons.menu) console.warn("[Topbar.init] Menu button not found.");
        if (!this.buttons.soundLibrary) console.warn("[Topbar.init] Sound Library button not found.");
        if (!this.buttons.tonality) console.warn("[Topbar.init] Tonality button not found.");
        if (!this.buttons.effects) console.warn("[Topbar.init] Effects button not found.");
        if (!this.buttons.restart) console.warn("[Topbar.init] Restart Audio button not found.");

        this.addEventListeners();
        console.log('[Topbar.init PadModes] Initialized successfully.');
    },

    addEventListeners() {
        console.log('[Topbar.addEventListeners PadModes] Adding listeners...');

        const addPanelToggleListener = (button, panelId) => {
            if (button) {
                button.addEventListener('click', () => {
                    if (this.isReloadingAppFlag) return; // Не даем открывать панели во время перезагрузки
                    console.log(`[Topbar] Button for panel '${panelId}' clicked.`);
                    if (typeof sidePanel !== 'undefined' && sidePanel.isPanelOpen) {
                        if (sidePanel.isPanelOpen(panelId)) {
                            sidePanel.hidePanel(panelId);
                        } else {
                            sidePanel.showPanel(panelId);
                        }
                    } else {
                        console.error("[Topbar] sidePanel or sidePanel.isPanelOpen is not available!");
                    }
                });
            }
        };

        addPanelToggleListener(this.buttons.menu, 'settings');
        addPanelToggleListener(this.buttons.soundLibrary, 'soundLibrary');
        addPanelToggleListener(this.buttons.tonality, 'tonality');
        addPanelToggleListener(this.buttons.effects, 'effects');
        addPanelToggleListener(this.buttons.padModes, 'padModes'); // Добавляем обработчик для новой кнопки
        // --- КОНЕЦ ИЗМЕНЕНИЯ ---

        if (this.buttons.reloadApp) {
            this.buttons.reloadApp.addEventListener('click', async () => {
                if (this.isReloadingAppFlag) return;

                this.isReloadingAppFlag = true;
                this.buttons.reloadApp.disabled = true;
                this.buttons.reloadApp.classList.add('reloading'); // Для CSS анимации

                const icon = this.buttons.reloadApp.querySelector('.restart-icon');
                if (icon) {
                    icon.style.animation = 'none';
                    // eslint-disable-next-line no-unused-expressions
                    icon.offsetHeight;
                    icon.style.animation = 'spinReload 2s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards'; // Убедитесь, что имя анимации 'spinReload'
                }

                console.log("[Topbar] Reload App button clicked. Calling app.triggerFullReload().");
                if (typeof app !== 'undefined' && typeof app.triggerFullReload === 'function') {
                    // Не нужно try-catch здесь, если app.triggerFullReload уже обрабатывает ошибки
                    app.triggerFullReload();
                    // После этого страница перезагрузится, сброс isReloadingAppFlag не нужен
                } else {
                    console.error("[Topbar] app или app.triggerFullReload не доступна!");
                    this.isReloadingAppFlag = false; // Сброс, если функция не найдена
                    this.buttons.reloadApp.disabled = false;
                    this.buttons.reloadApp.classList.remove('reloading');
                    if (icon) icon.style.animation = 'none';
                }
            });
        }
        console.log('[Topbar.addEventListeners PadModes] Listeners added.');
    },

    /**
     * Updates the visual state of the record button.
     * @param {boolean} isRecording - True if recording is active.
     */
    updateRecordButton(isRecording) {
        if (!this.buttons.restart) {
            console.warn("[Topbar.updateRecordButton] Restart Audio button not found.");
            return;
        }
        console.log(`[Topbar.updateRecordButton] Setting recording state to: ${isRecording}`);
        try {
            if (isRecording) {
                this.buttons.restart.classList.add('recording');
                this.buttons.restart.textContent = '■';
                const titleText = (typeof i18n !== 'undefined')
                    ? i18n.translate('stop_recording_button', 'Stop Recording')
                    : 'Stop Recording';
                this.buttons.restart.title = titleText;
                this.buttons.restart.setAttribute('aria-label', titleText);
            } else {
                this.buttons.restart.classList.remove('recording');
                this.buttons.restart.textContent = '●';
                 const titleText = (typeof i18n !== 'undefined')
                    ? i18n.translate('record_button', 'Record')
                    : 'Record';
                this.buttons.restart.title = titleText;
                 this.buttons.restart.setAttribute('aria-label', titleText);
            }
        } catch (error) {
            console.error("[Topbar.updateRecordButton] Error updating record button:", error);
        }
    },

    /**
     * Returns the corresponding topbar button element for a given panel ID.
     * @param {string} panelId - The ID of the panel ('settings', 'soundLibrary', 'tonality', 'effects').
     * @returns {HTMLElement | null} - The button element or null if not found.
     */
    getButtonForPanel(panelId) {
        switch (panelId) {
            case 'settings': return this.buttons.menu;
            case 'soundLibrary': return this.buttons.soundLibrary;
            case 'tonality': return this.buttons.tonality;
            case 'effects': return this.buttons.effects;
            case 'padModes': return this.buttons.padModes; // Возвращаем новую кнопку
            default:
                return null;
        }
    },

     deactivateAllButtons() {
         for (const key in this.buttons) {
             if (key !== 'reloadApp' && this.buttons[key] && this.buttons[key].classList.contains('topbar-button')) {
                 this.buttons[key].classList.remove('active');
             }
         }
     }
};
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\touchEffects\ballLightningLinkEffect.js
class BallLightningLinkEffect {
    constructor() {
        this.ctx = null;
        this.canvas = null;
        this.settings = {
            // Настройки по умолчанию, будут перезаписаны из JSON
            colorSourceAura: 'note', coreBaseColor: '#FFFFFF', coreMinRadius: 8, coreRadiusYMultiplier: 15,
            corePulseSpeed: 1.5, corePulseAmount: 0.15, auraRadiusFactor: 2.5, auraBaseOpacity: 0.3,
            sparkEmitInterval: 50, sparksPerEmitBase: 2, sparksPerEmitYMultiplier: 4, sparkMaxLifetime: 400,
            sparkBaseLength: 15, sparkLengthYMultiplier: 30, sparkSegments: 3, sparkJitter: 8,
            sparkBranchChance: 0.1, sparkCoreColor: '#FFFFFF', sparkGlowOpacity: 0.7, sparkRotationSpeed: 0.01,
            sparkBundleSpread: Math.PI / 2, sparkAngleFactor: 3, sparkGlowWidthFactor: 3, sparkCoreWidthFactor: 1,
            attractionRadiusPx: 150, linkCoreColorStart: '#FFFFFF', linkCoreColorEnd: '#FFFFFF',
            linkGlowOpacity: 0.8, linkBaseThickness: 4, linkThicknessYMultiplier: 3, linkSegments: 7,
            linkJitter: 15, linkGlowThicknessFactor: 1.8, linkBranchChance: 0.05, linkSecondarySparks: true,
            linkSecondarySparkInterval: 100, linkSecondarySparkCount: 1,
            fadeDurationCore: 300, fadeDurationSparks: 200, fadeDurationLink: 250,
            compositeOperation: 'lighter'
        };
        this.themeColors = {};
        this.globalVisualizerRef = null;

        // Структуры данных
        // ballLightnings: Map<touchId, BallLightningObject>
        // BallLightningObject: { id, x, y, currentY, noteInfo, coreRadius, currentCoreRadius, auraColor,
        //                        sparks: Array<SparkObject>, lastSparkEmitTime, sparkBundleAngle,
        //                        isActive, fadeStartTime, activeLinkCount }
        // SparkObject: { startX, startY, basePoints: Array<{x,y}>, length, lifetime, startTime, color (если нужен свой) }
        this.ballLightnings = new Map();

        // activeLinks: Map<linkKey, LinkObject>
        // LinkObject: { key, id1, id2, points: [], branches: [], secondarySparks: [], thickness,
        //               color1, color2, isActive, fadeStartTime, fadeProgress,
        //               lastSecondarySparkTime, lastX1, lastY1, lastX2, lastY2 }
        this.activeLinks = new Map();
        this.lastDrawTime = performance.now();
    }

    init(ctx, canvas, initialSettings, themeColors, globalVisualizerRef) {
        this.ctx = ctx;
        this.canvas = canvas;
        this.settings = { ...this.settings, ...initialSettings };
        this.themeColors = themeColors || {};
        this.globalVisualizerRef = globalVisualizerRef;
        this.ballLightnings.clear();
        this.activeLinks.clear();
        this.lastDrawTime = performance.now();
        console.log("[BallLightningLinkEffect v1.2-multi-final] Initialized with settings:", JSON.parse(JSON.stringify(this.settings)));
    }

    onThemeChange(themeColors) {
        this.themeColors = themeColors;
        this.ballLightnings.forEach(bl => {
            if (this.settings.colorSourceAura !== 'note') { // Обновляем только если цвет ауры не от ноты
                bl.auraColor = this._getAuraColor(null); // Передаем null, чтобы взять из темы
            }
        });
    }

    onSettingsChange(newSettings) {
        this.settings = { ...this.settings, ...newSettings };
    }

    // --- Вспомогательные функции ---
    _getAuraColor(noteInfo) {
        let color = this.themeColors.primary || '#007bff'; // Дефолт
        if (this.settings.colorSourceAura === 'accent') {
            color = this.themeColors.accent || '#ff4081';
        } else if (this.settings.colorSourceAura === 'note' && noteInfo?.midiNote !== undefined) {
            const noteIndex = noteInfo.midiNote % 12;
            // Убедимся, что noteColors существует в globalVisualizerRef
            const noteColors = this.globalVisualizerRef?.noteColors ||
                { 0: '#FF0000', 1: '#FF4500', 2: '#FFA500', 3: '#FFD700', 4: '#FFFF00', 5: '#9ACD32', 6: '#32CD32', 7: '#00BFFF', 8: '#0000FF', 9: '#8A2BE2', 10: '#FF00FF', 11: '#FF1493' };
            color = noteColors[noteIndex] || color; // Fallback на текущий color (который из темы)
        }
        return color;
    }

    _generateSparkBasePoints(length, segments, jitter, mainAngle) {
        // Генерирует "скелет" искры от (0,0) в заданном направлении
        const points = [{ x: 0, y: 0 }];
        let currentX = 0;
        let currentY = 0;
        const segmentLen = length / segments;

        for (let i = 0; i < segments; i++) {
            // Добавляем дрожание к углу каждого сегмента относительно основного направления
            const angle = mainAngle + (Math.random() - 0.5) * (this.settings.sparkSegmentAngleJitter || 0.5); // jitter в радианах
            currentX += Math.cos(angle) * segmentLen;
            currentY += Math.sin(angle) * segmentLen;
            points.push({ x: currentX, y: currentY });
        }
        return points;
    }

    _drawSpark(spark, auraColor, coreColor, now) {
        const lifeProgress = Math.min((now - spark.startTime) / spark.lifetime, 1);
        if (lifeProgress >= 1) return false;

        // Анимация: искра "вырастает" до своей полной длины, а затем "втягивается" или исчезает
        let displayProgress;
        const growthDurationFactor = 0.3; // 30% времени на рост
        const shrinkStartTimeFactor = 0.7; // 70% времени существует, потом втягивается/исчезает

        if (lifeProgress < growthDurationFactor) { // Фаза роста
            displayProgress = lifeProgress / growthDurationFactor;
        } else if (lifeProgress < shrinkStartTimeFactor) { // Фаза существования
            displayProgress = 1.0;
        } else { // Фаза втягивания/исчезновения
            displayProgress = 1.0 - (lifeProgress - shrinkStartTimeFactor) / (1.0 - shrinkStartTimeFactor);
        }
        displayProgress = Math.max(0, Math.min(1, displayProgress)); // Clamp

        const currentLength = spark.length * displayProgress;
        const opacity = (1 - lifeProgress) * this.settings.sparkGlowOpacity;

        if (opacity <= 0.01 || currentLength < 1) return false;

        this.ctx.save();
        this.ctx.translate(spark.startX, spark.startY); // Перемещаемся к началу искры

        // Масштабируем и поворачиваем базовые точки для создания текущего вида искры
        // Рисуем от начала (0,0 в текущей системе координат)
        const dynamicPoints = [{x:0, y:0}];
        let currentX = 0;
        let currentY = 0;
        const segmentLen = currentLength / (spark.basePoints.length -1);

        for(let i = 1; i < spark.basePoints.length; i++){
            // Используем относительные координаты из basePoints
            const dxBase = spark.basePoints[i].x - spark.basePoints[i-1].x;
            const dyBase = spark.basePoints[i].y - spark.basePoints[i-1].y;
            const originalSegmentLength = Math.hypot(dxBase, dyBase);
            if (originalSegmentLength === 0) continue;

            // Масштабируем смещение сегмента
            currentX += (dxBase / originalSegmentLength) * segmentLen;
            currentY += (dyBase / originalSegmentLength) * segmentLen;
            dynamicPoints.push({x: currentX, y: currentY});
        }

        if (dynamicPoints.length < 2) {
             this.ctx.restore();
             return true; // Еще нечего рисовать, но искра жива
        }

        // Свечение искры
        this.ctx.beginPath();
        this.ctx.moveTo(dynamicPoints[0].x, dynamicPoints[0].y);
        for (let i = 1; i < dynamicPoints.length; i++) this.ctx.lineTo(dynamicPoints[i].x, dynamicPoints[i].y);
        this.ctx.strokeStyle = this.globalVisualizerRef.getColorWithAlpha(auraColor, opacity * 0.7);
        this.ctx.lineWidth = Math.max(0.5, (this.settings.sparkGlowWidthFactor || 3) * displayProgress);
        this.ctx.stroke();

        // Ядро искры
        this.ctx.beginPath();
        this.ctx.moveTo(dynamicPoints[0].x, dynamicPoints[0].y);
        for (let i = 1; i < dynamicPoints.length; i++) this.ctx.lineTo(dynamicPoints[i].x, dynamicPoints[i].y);
        this.ctx.strokeStyle = this.globalVisualizerRef.getColorWithAlpha(coreColor, opacity);
        this.ctx.lineWidth = Math.max(0.3, (this.settings.sparkCoreWidthFactor || 1) * displayProgress);
        this.ctx.stroke();

        this.ctx.restore();
        return true;
    }

    _generateLinkPoints(x1, y1, x2, y2, segments, jitter) {
        const points = [{x:x1, y:y1}];
        for (let i = 1; i < segments; i++) {
            const t = i / segments;
            // Дрожание максимально в центре дуги и уменьшается к концам
            const currentJitter = jitter * Math.sin(Math.PI * t);
            points.push({
                x: x1 + (x2 - x1) * t + (Math.random() - 0.5) * currentJitter,
                y: y1 + (y2 - y1) * t + (Math.random() - 0.5) * currentJitter
            });
        }
        points.push({x:x2, y:y2});
        return points;
    }

    _drawLinkSecondaryEffects(link, now, linkOpacity) {
        // Вторичные искры вдоль дуги
        if (this.settings.linkSecondarySparks && link.isActive) { // Только для активных дуг
            if (!link.lastSecondarySparkTime || (now - link.lastSecondarySparkTime > this.settings.linkSecondarySparkInterval)) {
                link.lastSecondarySparkTime = now;
                if (!link.secondarySparks) link.secondarySparks = [];

                for (let i = 0; i < this.settings.linkSecondarySparkCount; i++) {
                    if (link.points.length < 2) continue;
                    const pIndex = Math.floor(Math.random() * (link.points.length - 1));
                    const p1 = link.points[pIndex];
                    const p2 = link.points[pIndex + 1];
                    const startX = (p1.x + p2.x) / 2;
                    const startY = (p1.y + p2.y) / 2;

                    const tangentAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                    const angle = tangentAngle + (Math.PI / 2) * (Math.random() < 0.5 ? 1 : -1) + (Math.random()-0.5)*0.5;
                    const length = (this.settings.sparkBaseLength || 15) * 0.6 * (0.5 + Math.random() * 0.5);
                    const sparkColor = Math.random() < 0.5 ? link.color1 : link.color2;

                    link.secondarySparks.push({
                        startX: startX, startY: startY,
                        basePoints: this._generateSparkBasePoints(length, Math.max(1, Math.floor(this.settings.sparkSegments / 2)), this.settings.sparkJitter / 2, angle),
                        length: length,
                        lifetime: (this.settings.sparkMaxLifetime || 400) * 0.4,
                        startTime: now,
                        color: sparkColor
                    });
                }
            }
        }
        if (link.secondarySparks) {
            link.secondarySparks = link.secondarySparks.filter(spark =>
                 this._drawSpark(spark, spark.color, spark.color, now)
            );
        }

        // Ответвления от основной дуги
        if (this.settings.linkBranchChance > 0 && link.isActive && Math.random() < this.settings.linkBranchChance) {
             if (!link.mainBranches) link.mainBranches = [];
             if (link.points.length < 2) return;
             const pIndex = Math.floor(Math.random() * (link.points.length - 1));
             const p1 = link.points[pIndex];
             const startX = p1.x;
             const startY = p1.y;
             const angle = Math.random() * Math.PI * 2; // Случайный угол
             const length = (this.settings.sparkBaseLength || 15) * (0.7 + Math.random() * 0.6);
             const branchColor = Math.random() < 0.5 ? link.color1 : link.color2;

             link.mainBranches.push({
                startX: startX, startY: startY,
                basePoints: this._generateSparkBasePoints(length, this.settings.sparkSegments, this.settings.sparkJitter, angle),
                length: length,
                lifetime: (this.settings.sparkMaxLifetime || 400) * 0.6,
                startTime: now,
                color: branchColor
             });
        }
         if (link.mainBranches) {
            link.mainBranches = link.mainBranches.filter(spark =>
                 this._drawSpark(spark, spark.color, spark.color, now)
            );
        }
    }

    _drawLinkArc(link, now) {
        const bl1 = this.ballLightnings.get(link.id1);
        const bl2 = this.ballLightnings.get(link.id2);

        if ((!bl1 || !bl1.isActive) && (!bl2 || !bl2.isActive) && link.isActive) {
            link.isActive = false;
            link.fadeStartTime = now;
        } else if ((!bl1 && bl2?.isActive && link.isActive) || (bl1?.isActive && !bl2 && link.isActive)) {
             if (link.isActive) {
                link.isActive = false;
                link.fadeStartTime = now;
            }
        }

        let currentOpacity = this.settings.linkGlowOpacity;
        let currentThickness = link.thickness;

        if (!link.isActive) {
            if (!link.fadeStartTime) link.fadeStartTime = now;
            link.fadeProgress = Math.min((now - link.fadeStartTime) / this.settings.fadeDurationLink, 1);
            if (link.fadeProgress >= 1) return false;
            currentOpacity *= (1 - link.fadeProgress);
            currentThickness *= (1 - link.fadeProgress);
        }

        if (currentOpacity <= 0.01 || currentThickness < 0.5) return false;

        const x1 = bl1 ? bl1.x : link.lastX1;
        const y1 = bl1 ? bl1.y : link.lastY1;
        const x2 = bl2 ? bl2.x : link.lastX2;
        const y2 = bl2 ? bl2.y : link.lastY2;

        link.lastX1 = x1; link.lastY1 = y1;
        link.lastX2 = x2; link.lastY2 = y2;

        const points = this._generateLinkPoints(x1, y1, x2, y2, this.settings.linkSegments, this.settings.linkJitter);
        link.points = points;
        if (points.length < 2) return true; // Нечего рисовать, но дуга может быть еще жива

        const color1 = bl1 ? bl1.auraColor : link.color1;
        const color2 = bl2 ? bl2.auraColor : link.color2;

        this.ctx.lineCap = 'round';
        // Свечение дуги
        this.ctx.beginPath();
        this.ctx.moveTo(points[0].x, points[0].y);
        for(let i=1; i < points.length; i++) this.ctx.lineTo(points[i].x, points[i].y);
        const grad = this.ctx.createLinearGradient(x1, y1, x2, y2);
        grad.addColorStop(0, this.globalVisualizerRef.getColorWithAlpha(color1, currentOpacity));
        grad.addColorStop(0.5, this.globalVisualizerRef.getColorWithAlpha(this.globalVisualizerRef.mixColors(color1, color2, 0.5), currentOpacity * 0.8)); // Центр чуть тусклее для глубины
        grad.addColorStop(1, this.globalVisualizerRef.getColorWithAlpha(color2, currentOpacity));
        this.ctx.strokeStyle = grad;
        this.ctx.lineWidth = currentThickness * (this.settings.linkGlowThicknessFactor || 1.8);
        this.ctx.stroke();

        // Ядро дуги
        this.ctx.beginPath();
        this.ctx.moveTo(points[0].x, points[0].y);
        for(let i=1; i < points.length; i++) this.ctx.lineTo(points[i].x, points[i].y);
        const coreGrad = this.ctx.createLinearGradient(x1, y1, x2, y2);
        coreGrad.addColorStop(0, this.globalVisualizerRef.getColorWithAlpha(this.settings.linkCoreColorStart, currentOpacity * 1.1)); // Ярче
        coreGrad.addColorStop(1, this.globalVisualizerRef.getColorWithAlpha(this.settings.linkCoreColorEnd, currentOpacity * 1.1)); // Ярче
        this.ctx.strokeStyle = coreGrad;
        this.ctx.lineWidth = currentThickness;
        this.ctx.stroke();

        if (link.isActive || link.fadeProgress < 0.7) { // Вторичные эффекты только для активных или не сильно затухших дуг
             this._drawLinkSecondaryEffects(link, now, currentOpacity);
        }
        return true;
    }

    // --- Основные методы обработки касаний ---
    onTouchDown(touchData) {
        if (!this.ctx || !this.canvas) return;

        let bl = this.ballLightnings.get(touchData.id);
        const x = touchData.x * this.canvas.width;
        const y = (1 - touchData.y) * this.canvas.height;

        if (bl) { // Если шаровая молния уже существует (например, быстрое повторное касание)
            bl.x = x; bl.y = y; bl.currentY = touchData.y;
            bl.coreRadius = this.settings.coreMinRadius + touchData.y * this.settings.coreRadiusYMultiplier;
            bl.isActive = true;
            bl.fadeStartTime = 0; // Сбрасываем затухание
            bl.noteInfo = touchData.noteInfo; // Обновляем информацию о ноте
            bl.auraColor = this._getAuraColor(touchData.noteInfo); // Обновляем цвет ауры
            // Важно: не сбрасываем activeLinkCount здесь, updateLinks это сделает
        } else {
            bl = {
                id: touchData.id, x: x, y: y, currentY: touchData.y,
                noteInfo: touchData.noteInfo,
                coreRadius: this.settings.coreMinRadius + touchData.y * this.settings.coreRadiusYMultiplier,
                currentCoreRadius: this.settings.coreMinRadius + touchData.y * this.settings.coreRadiusYMultiplier,
                auraColor: this._getAuraColor(touchData.noteInfo),
                sparks: [], lastSparkEmitTime: performance.now(), sparkBundleAngle: Math.random() * Math.PI * 2,
                isActive: true, fadeStartTime: 0, activeLinkCount: 0
            };
            this.ballLightnings.set(touchData.id, bl);
        }
        this.updateLinks();
    }

    onTouchMove(touchData) {
        const bl = this.ballLightnings.get(touchData.id);
        if (bl && bl.isActive) {
            bl.x = touchData.x * this.canvas.width;
            bl.y = (1 - touchData.y) * this.canvas.height;
            bl.currentY = touchData.y;
            bl.coreRadius = this.settings.coreMinRadius + bl.currentY * this.settings.coreRadiusYMultiplier;

            const newAuraColor = this._getAuraColor(touchData.noteInfo);
            if (bl.auraColor !== newAuraColor) {
                bl.auraColor = newAuraColor;
                // Обновить цвета связанных дуг
                this.activeLinks.forEach(link => {
                    if (link.id1 === bl.id) link.color1 = newAuraColor;
                    if (link.id2 === bl.id) link.color2 = newAuraColor;
                });
            }
            bl.noteInfo = touchData.noteInfo; // Обновляем инфо о ноте
            this.updateLinks();
        }
    }

    onTouchUp(touchId) {
        const bl = this.ballLightnings.get(touchId);
        if (bl) {
            bl.isActive = false;
            if (!bl.fadeStartTime) bl.fadeStartTime = performance.now(); // Начинаем затухание, если еще не началось

            // Связанные дуги также должны начать затухать
            this.activeLinks.forEach(link => {
                if ((link.id1 === touchId || link.id2 === touchId) && link.isActive) {
                    link.isActive = false;
                    if (!link.fadeStartTime) link.fadeStartTime = performance.now();
                }
            });
        }
        // this.updateLinks(); // Не обязательно, drawActiveEffects справится
    }

    updateLinks() {
        const activeBLs = Array.from(this.ballLightnings.values()).filter(bl => bl.isActive);
        const attractionRadiusSq = this.settings.attractionRadiusPx * this.settings.attractionRadiusPx;

        // Сначала обнуляем счетчики связей у всех (даже неактивных, на всякий случай)
        this.ballLightnings.forEach(bl => bl.activeLinkCount = 0);

        const currentActiveLinkKeys = new Set();

        for (let i = 0; i < activeBLs.length; i++) {
            for (let j = i + 1; j < activeBLs.length; j++) {
                const bl1 = activeBLs[i];
                const bl2 = activeBLs[j];

                const dx = bl1.x - bl2.x;
                const dy = bl1.y - bl2.y;
                const distSq = dx * dx + dy * dy;
                const linkKey = [bl1.id, bl2.id].sort().join('-');

                if (distSq < attractionRadiusSq) {
                    currentActiveLinkKeys.add(linkKey);
                    bl1.activeLinkCount++;
                    bl2.activeLinkCount++;

                    let link = this.activeLinks.get(linkKey);
                    if (!link || !link.isActive) { // Если линка нет ИЛИ он был неактивен (затухал)
                        link = {
                            key: linkKey, id1: bl1.id, id2: bl2.id,
                            points: [], branches: [], secondarySparks: [],
                            thickness: this.settings.linkBaseThickness + ((bl1.currentY + bl2.currentY) / 2) * this.settings.linkThicknessYMultiplier,
                            color1: bl1.auraColor, color2: bl2.auraColor,
                            isActive: true, fadeStartTime: 0, fadeProgress: -1,
                            lastSecondarySparkTime: 0,
                            lastX1: bl1.x, lastY1: bl1.y, lastX2: bl2.x, lastY2: bl2.y
                        };
                        this.activeLinks.set(linkKey, link);
                    } else { // Линк уже существует и активен, просто обновляем цвета и толщину
                        link.color1 = bl1.auraColor;
                        link.color2 = bl2.auraColor;
                        link.thickness = this.settings.linkBaseThickness + ((bl1.currentY + bl2.currentY) / 2) * this.settings.linkThicknessYMultiplier;
                    }
                }
            }
        }

        // Деактивируем линки, которые больше не соответствуют условиям
        this.activeLinks.forEach((link, key) => {
            if (link.isActive && !currentActiveLinkKeys.has(key)) {
                link.isActive = false;
                if (!link.fadeStartTime) link.fadeStartTime = performance.now();
            }
        });
    }

    // --- Основной цикл отрисовки ---
    drawActiveEffects() {
        if (!this.ctx || !this.canvas || !this.globalVisualizerRef) return;

        const now = performance.now();
        const deltaTime = Math.min(32, now - this.lastDrawTime) / 1000; // Ограничиваем deltaTime, в секундах
        this.lastDrawTime = now;

        this.ctx.globalCompositeOperation = this.settings.compositeOperation;

        this.updateLinks(); // Обновляем состояние связей перед отрисовкой

        // 1. Отрисовка связей
        this.activeLinks.forEach((link, key) => {
            if (!this._drawLinkArc(link, now)) {
                this.activeLinks.delete(key);
                // При удалении дуги activeLinkCount у связанных BL уже должен был быть обновлен в updateLinks,
                // либо будет обновлен на следующей итерации updateLinks, если BL еще активны.
            }
        });

        // 2. Отрисовка шаровых молний
        this.ballLightnings.forEach((bl, id) => {
            let coreOpacity = this.settings.baseOpacity ?? 1.0;
            let auraOpacity = this.settings.auraBaseOpacity ?? 0.3;
            let sparkEmissionAllowed = bl.isActive && bl.activeLinkCount === 0;

            if (!bl.isActive) {
                if(!bl.fadeStartTime) bl.fadeStartTime = now;
                const fadeProgress = Math.min((now - bl.fadeStartTime) / this.settings.fadeDurationCore, 1);

                coreOpacity *= (1 - fadeProgress);
                auraOpacity *= (1 - fadeProgress);
                bl.currentCoreRadius = bl.coreRadius * (1 - fadeProgress);

                if (fadeProgress >= 1 && bl.sparks.length === 0 && bl.activeLinkCount === 0) {
                    this.ballLightnings.delete(id);
                    return;
                }
            } else {
                const pulseFactor = (Math.sin(now * 0.001 * this.settings.corePulseSpeed) + 1) / 2;
                bl.currentCoreRadius = bl.coreRadius * (1 - this.settings.corePulseAmount / 2 + this.settings.corePulseAmount * pulseFactor);
            }

            if (bl.currentCoreRadius < 0.5 && !bl.isActive) {
                 if (bl.sparks.length === 0 && bl.activeLinkCount === 0) {
                    this.ballLightnings.delete(id); return;
                 }
            }

            // Рисуем Ауру
            if (auraOpacity > 0.01 && bl.currentCoreRadius > 0.5) {
                const auraRadius = bl.currentCoreRadius * this.settings.auraRadiusFactor;
                const auraGradient = this.ctx.createRadialGradient(bl.x, bl.y, bl.currentCoreRadius * 0.7, bl.x, bl.y, auraRadius);
                auraGradient.addColorStop(0, this.globalVisualizerRef.getColorWithAlpha(bl.auraColor, auraOpacity * 0.8));
                auraGradient.addColorStop(1, this.globalVisualizerRef.getColorWithAlpha(bl.auraColor, 0));
                this.ctx.fillStyle = auraGradient;
                this.ctx.beginPath();
                this.ctx.arc(bl.x, bl.y, auraRadius, 0, Math.PI * 2);
                this.ctx.fill();
            }

            // Рисуем Ядро
            if (coreOpacity > 0.01 && bl.currentCoreRadius > 0.5) {
                const coreGradient = this.ctx.createRadialGradient(bl.x, bl.y, 0, bl.x, bl.y, bl.currentCoreRadius);
                let coreColor = this.settings.coreBaseColor;
                // Делаем ядро чуть темнее/цветнее, если оно в цветной зоне
                if(this.settings.coreColorFromAura && bl.auraColor !== this.settings.coreBaseColor) {
                    coreColor = this.globalVisualizerRef.mixColors(this.settings.coreBaseColor, bl.auraColor, 0.3);
                }

                coreGradient.addColorStop(0, this.globalVisualizerRef.getColorWithAlpha(coreColor, coreOpacity));
                coreGradient.addColorStop(0.7, this.globalVisualizerRef.getColorWithAlpha(coreColor, coreOpacity * 0.6));
                coreGradient.addColorStop(1, this.globalVisualizerRef.getColorWithAlpha(coreColor, 0));
                this.ctx.fillStyle = coreGradient;
                this.ctx.beginPath();
                this.ctx.arc(bl.x, bl.y, bl.currentCoreRadius, 0, Math.PI * 2);
                this.ctx.fill();
            }

            // Генерация и отрисовка исходящих искр
            if (sparkEmissionAllowed) {
                if (now - bl.lastSparkEmitTime > this.settings.sparkEmitInterval) {
                    bl.lastSparkEmitTime = now;
                    const numSparks = this.settings.sparksPerEmitBase + Math.floor(bl.currentY * this.settings.sparksPerEmitYMultiplier);
                    bl.sparkBundleAngle = (bl.sparkBundleAngle + this.settings.sparkRotationSpeed * deltaTime * 60);

                    for (let i = 0; i < numSparks; i++) {
                        const angle = bl.sparkBundleAngle + (Math.random() - 0.5) * (this.settings.sparkBundleSpread) + (i / numSparks) * (Math.PI * 2 / (this.settings.sparkAngleFactor));
                        const length = (this.settings.sparkBaseLength + bl.currentY * this.settings.sparkLengthYMultiplier) * (0.7 + Math.random() * 0.6);

                        bl.sparks.push({
                            startX: bl.x, startY: bl.y,
                            basePoints: this._generateSparkBasePoints(length, this.settings.sparkSegments, this.settings.sparkJitter, angle),
                            length: length,
                            lifetime: this.settings.sparkMaxLifetime * (0.8 + Math.random() * 0.4),
                            startTime: now,
                        });
                    }
                }
            }

            const sparkCoreRenderColor = this.settings.sparkCoreColorFromAura ? bl.auraColor : this.settings.sparkCoreColor;
            bl.sparks = bl.sparks.filter(spark => {
                let sparkIsAlive = this._drawSpark(spark, bl.auraColor, sparkCoreRenderColor, now);
                if (!bl.isActive) { // Если шаровая молния затухает, ее искры тоже должны быстро исчезать
                    const fadeProgressCore = Math.min((now - bl.fadeStartTime) / this.settings.fadeDurationSparks, 1);
                    if (fadeProgressCore > 0.3) sparkIsAlive = false; // Ускоренное исчезновение искр
                }
                return sparkIsAlive;
            });

            if (!bl.isActive && bl.activeLinkCount === 0 && bl.sparks.length === 0 &&
                ((now - bl.fadeStartTime) >= this.settings.fadeDurationCore)) {
                this.ballLightnings.delete(id);
            }
        });
        this.ctx.globalCompositeOperation = 'source-over';
    }

    dispose() {
        this.ballLightnings.clear();
        this.activeLinks.clear();
        this.ctx = null;
        this.canvas = null;
        console.log("[BallLightningLinkEffect v1.2-multi-final] Disposed.");
    }
}

// Self-registration
if (typeof visualizer !== 'undefined' && typeof visualizer.registerTouchEffectRenderer === 'function') {
    visualizer.registerTouchEffectRenderer('BallLightningLinkEffect', BallLightningLinkEffect);
} else {
    window.BallLightningLinkEffect = BallLightningLinkEffect;
    console.warn('[BallLightningLinkEffect v1.2-multi-final] Registered globally as visualizer object was not available at load time.');
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\touchEffects\energyEffect.js
class EnergyEffect {
    constructor() {
        this.ctx = null;
        this.canvas = null;
        this.settings = {
            colorSource: 'note',
            baseOpacity: 1.0,
            energySpeed: 2,
            energyInterval: 200,
            maxRadius: 150,
            fadeDuration: 1000,
            spikes: 8,
            innerRadiusFactor: 0.5,
            spawnSpread: 5,
            strokeWidth: 0,
            compositeOperation: "lighter"
        };
        this.themeColors = {};
        this.energySystems = new Map();
        this.globalVisualizerRef = null;
    }

    init(ctx, canvas, initialSettings, themeColors, globalVisualizerRef) {
        this.ctx = ctx;
        this.canvas = canvas;
        this.settings = { ...this.settings, ...initialSettings };
        this.themeColors = themeColors || {};
        this.globalVisualizerRef = globalVisualizerRef;
        this.energySystems.clear();
        console.log("[EnergyEffect] Initialized with settings:", this.settings);
    }

    onThemeChange(themeColors) {
        this.themeColors = themeColors;
    }

    onSettingsChange(newSettings) {
        this.settings = { ...this.settings, ...newSettings };
    }

    _createEnergy(system) {
        return {
            xOffset: (Math.random() - 0.5) * this.settings.spawnSpread,
            yOffset: (Math.random() - 0.5) * this.settings.spawnSpread,
            radius: 0,
            opacity: this.settings.baseOpacity,
            speed: this.settings.energySpeed * (0.8 + Math.random() * 0.4),
            angle: Math.random() * Math.PI * 2,
            rotationSpeed: (0.05 + Math.random() * 0.1) * (Math.random() < 0.5 ? 1 : -1),
            life: 1.0
        };
    }

    onTouchDown(touchData) {
        if (!this.ctx || !this.canvas) return;
        this.energySystems.delete(touchData.id);

        let color = this.themeColors.primary || 'blue';
        if (this.settings.colorSource === 'accent') {
            color = this.themeColors.accent || 'red';
        } else if (this.settings.colorSource === 'note' && touchData.noteInfo?.midiNote !== undefined) {
            const noteIndex = touchData.noteInfo.midiNote % 12;
            const noteColors = this.globalVisualizerRef?.noteColors || 
                { 0: '#FF0000', 1: '#FF4500', 2: '#FFA500', 3: '#FFD700', 4: '#FFFF00', 5: '#9ACD32', 6: '#32CD32', 7: '#00BFFF', 8: '#0000FF', 9: '#8A2BE2', 10: '#FF00FF', 11: '#FF1493' };
            color = noteColors[noteIndex] || this.themeColors.primary;
        }

        const newSystem = {
            id: touchData.id,
            x: touchData.x * this.canvas.width,
            y: (1 - touchData.y) * this.canvas.height,
            color: color,
            isActive: true,
            energies: [this._createEnergy()],
            lastEmitTime: performance.now(),
            fadeStartTime: 0
        };

        this.energySystems.set(touchData.id, newSystem);
    }

    onTouchMove(touchData) {
        const system = this.energySystems.get(touchData.id);
        if (system && system.isActive) {
            system.x = touchData.x * this.canvas.width;
            system.y = (1 - touchData.y) * this.canvas.height;

            if (this.settings.colorSource === 'note' && touchData.noteInfo?.midiNote !== undefined) {
                const noteIndex = touchData.noteInfo.midiNote % 12;
                const noteColors = this.globalVisualizerRef?.noteColors || 
                    { 0: '#FF0000', 1: '#FF4500', 2: '#FFA500', 3: '#FFD700', 4: '#FFFF00', 5: '#9ACD32', 6: '#32CD32', 7: '#00BFFF', 8: '#0000FF', 9: '#8A2BE2', 10: '#FF00FF', 11: '#FF1493' };
                const newColor = noteColors[noteIndex] || this.themeColors.primary;
                
                if (newColor !== system.color) {
                    system.color = newColor;
                }
            }
        }
    }

    onTouchUp(touchId) {
        const system = this.energySystems.get(touchId);
        if (system) {
            system.isActive = false;
            system.fadeStartTime = performance.now();
        }
    }

    drawActiveEffects() {
        if (!this.ctx || !this.canvas || this.energySystems.size === 0 || !this.globalVisualizerRef) return;

        const now = performance.now();
        this.ctx.globalCompositeOperation = this.settings.compositeOperation || 'lighter';

        this.energySystems.forEach((system, systemId) => {
            let systemOpacityMultiplier = 1.0;

            if (system.isActive) {
                if (now - system.lastEmitTime > this.settings.energyInterval) {
                    system.energies.push(this._createEnergy(system));
                    system.lastEmitTime = now;
                }
            } else {
                const fadeElapsed = now - system.fadeStartTime;
                systemOpacityMultiplier = 1.0 - Math.min(fadeElapsed / this.settings.fadeDuration, 1);

                if (systemOpacityMultiplier <= 0.01 && system.energies.length === 0) {
                    this.energySystems.delete(systemId);
                    return;
                }
            }

            system.energies = system.energies.filter(energy => {
                energy.radius += energy.speed;
                energy.angle += energy.rotationSpeed;
                energy.life -= 0.01;

                if (energy.life <= 0 || energy.opacity <= 0.01) return false;
                
                if (energy.radius > this.settings.maxRadius) return false;

                const currentOpacity = energy.opacity * systemOpacityMultiplier * energy.life;
                if (currentOpacity <= 0.01) return false;

                const points = [];
                const spikes = this.settings.spikes;
                const innerRadius = energy.radius * this.settings.innerRadiusFactor;
                const outerRadius = energy.radius;

                for (let i = 0; i < spikes * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const angle = (i * Math.PI) / spikes + energy.angle;
                    points.push({
                        x: system.x + energy.xOffset + Math.cos(angle) * radius,
                        y: system.y + energy.yOffset + Math.sin(angle) * radius
                    });
                }

                this.ctx.beginPath();
                this.ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    this.ctx.lineTo(points[i].x, points[i].y);
                }
                this.ctx.closePath();

                const gradient = this.ctx.createRadialGradient(
                    system.x + energy.xOffset, system.y + energy.yOffset, 0,
                    system.x + energy.xOffset, system.y + energy.yOffset, outerRadius
                );
                gradient.addColorStop(0, this.globalVisualizerRef.getColorWithAlpha(system.color, currentOpacity));
                gradient.addColorStop(0.7, this.globalVisualizerRef.getColorWithAlpha(system.color, currentOpacity * 0.5));
                gradient.addColorStop(1, this.globalVisualizerRef.getColorWithAlpha(system.color, 0));
                
                this.ctx.fillStyle = gradient;
                this.ctx.fill();
                
                if (this.settings.strokeWidth > 0) {
                    this.ctx.strokeStyle = this.globalVisualizerRef.getColorWithAlpha(system.color, currentOpacity * 0.7);
                    this.ctx.lineWidth = this.settings.strokeWidth;
                    this.ctx.stroke();
                }

                return true;
            });

            if (!system.isActive && system.energies.length === 0) {
                this.energySystems.delete(systemId);
            }
        });

        this.ctx.globalCompositeOperation = 'source-over';
    }

    dispose() {
        this.energySystems.clear();
        this.ctx = null;
        this.canvas = null;
        console.log("[EnergyEffect] Disposed.");
    }
}

// Self-registration
if (typeof visualizer !== 'undefined' && typeof visualizer.registerTouchEffectRenderer === 'function') {
    visualizer.registerTouchEffectRenderer('EnergyEffect', EnergyEffect);
} else {
    window.EnergyEffect = EnergyEffect;
    console.warn('[EnergyEffect] Registered globally as visualizer object was not available at load time.');
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\touchEffects\geometricShardsEffect.js
class GeometricShardsEffect {
    constructor() {
        this.ctx = null;
        this.canvas = null;
        this.settings = {
            colorSource: 'note', emitRate: 15, maxActiveShardsPerTouch: 50,
            shardTypes: ["triangle", "rectangle", "line"], shardMaxSize: 18, shardMinSize: 5,
            shardLife: 800, launchSpeedBase: 0.5, launchSpeedYMultiplier: 1.5,
            rotationSpeed: 0.03, shrinkFactor: 0.98, fadeOutFactor: 0.97,
            gravity: 0.02, baseOpacity: 0.9, compositeOperation: 'lighter',
            fadeDurationOnUp: 300
        };
        this.themeColors = {};
        // activeTouches: Map<touchId, TouchData>
        // TouchData: { x, y, currentY, color, isActive, shards: Array<ShardObject>, lastEmitTime, fadeStartTime }
        // ShardObject: { x, y, vx, vy, life, initialLife, rotation, rotationSpeed, size, initialSize, type, opacity, color }
        this.activeTouches = new Map();
        this.globalVisualizerRef = null;
        this.lastDrawTime = performance.now();
    }

    init(ctx, canvas, initialSettings, themeColors, globalVisualizerRef) {
        this.ctx = ctx;
        this.canvas = canvas;
        this.settings = { ...this.settings, ...initialSettings };
        this.themeColors = themeColors;
        this.globalVisualizerRef = globalVisualizerRef;
        this.activeTouches.clear();
        this.lastDrawTime = performance.now();
        console.log("[GeometricShardsEffect v1.1-live] Initialized:", this.settings);
    }

    onThemeChange(themeColors) {
        this.themeColors = themeColors;
        this.activeTouches.forEach(touch => {
            if (this.settings.colorSource !== 'note') {
                touch.color = this._getBaseColor(null); // Обновить цвет, если не от ноты
            }
        });
    }

    onSettingsChange(newSettings) {
        this.settings = { ...this.settings, ...newSettings };
    }

    _getBaseColor(noteInfo) {
        let color = this.themeColors.primary || '#007bff';
        if (this.settings.colorSource === 'accent') {
            color = this.themeColors.accent || '#FF00FF';
        } else if (this.settings.colorSource === 'note' && noteInfo?.midiNote !== undefined) {
            const noteIndex = noteInfo.midiNote % 12;
            color = (this.globalVisualizerRef?.noteColors || {})[noteIndex] || color;
        }
        return color;
    }

    _createShard(touchSystem) {
        const angle = Math.random() * Math.PI * 2;
        const speed = this.settings.launchSpeedBase + touchSystem.currentY * this.settings.launchSpeedYMultiplier;
        const size = Math.random() * (this.settings.shardMaxSize - this.settings.shardMinSize) + this.settings.shardMinSize;
        const type = this.settings.shardTypes[Math.floor(Math.random() * this.settings.shardTypes.length)];

        return {
            x: touchSystem.x,
            y: touchSystem.y,
            vx: Math.cos(angle) * speed * (0.5 + Math.random() * 0.5),
            vy: Math.sin(angle) * speed * (0.5 + Math.random() * 0.5),
            life: this.settings.shardLife,
            initialLife: this.settings.shardLife,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * this.settings.rotationSpeed * 2,
            size: size,
            initialSize: size,
            type: type,
            opacity: this.settings.baseOpacity,
            color: touchSystem.color // Осколок наследует цвет системы касания
        };
    }

    onTouchDown(touchData) {
        if (!this.ctx || !this.canvas) return;

        const x = touchData.x * this.canvas.width;
        const y = (1 - touchData.y) * this.canvas.height;

        let touchSystem = this.activeTouches.get(touchData.id);
        if (touchSystem) { // Если касание уже было (например, быстрое перекасание)
            touchSystem.x = x;
            touchSystem.y = y;
            touchSystem.currentY = touchData.y;
            touchSystem.isActive = true;
            touchSystem.fadeStartTime = 0; // Сбросить затухание
            touchSystem.color = this._getBaseColor(touchData.noteInfo); // Обновить цвет
        } else {
            touchSystem = {
                id: touchData.id,
                x: x,
                y: y,
                currentY: touchData.y,
                color: this._getBaseColor(touchData.noteInfo),
                isActive: true,
                shards: [],
                lastEmitTime: performance.now(),
                fadeStartTime: 0
            };
            this.activeTouches.set(touchData.id, touchSystem);
        }
        // Эмиттируем начальную пачку осколков
        const initialEmitCount = Math.floor(this.settings.emitRate / 4) + 1; // Например, четверть секунды эмиссии сразу
        for (let i = 0; i < initialEmitCount; i++) {
            if (touchSystem.shards.length < this.settings.maxActiveShardsPerTouch) {
                touchSystem.shards.push(this._createShard(touchSystem));
            }
        }
    }

    onTouchMove(touchData) {
        const touchSystem = this.activeTouches.get(touchData.id);
        if (touchSystem && touchSystem.isActive) {
            touchSystem.x = touchData.x * this.canvas.width;
            touchSystem.y = (1 - touchData.y) * this.canvas.height;
            touchSystem.currentY = touchData.y;
            // Обновляем цвет, если он зависит от ноты
            if (this.settings.colorSource === 'note') {
                touchSystem.color = this._getBaseColor(touchData.noteInfo);
            }
        }
    }

    onTouchUp(touchId) {
        const touchSystem = this.activeTouches.get(touchId);
        if (touchSystem) {
            touchSystem.isActive = false;
            touchSystem.fadeStartTime = performance.now();
        }
    }

    drawActiveEffects() {
        if (!this.ctx || !this.canvas || this.activeTouches.size === 0 || !this.globalVisualizerRef) return;

        const now = performance.now();
        const deltaTime = Math.min(33, now - this.lastDrawTime); // мс, ограничиваем для стабильности
        this.lastDrawTime = now;

        this.ctx.globalCompositeOperation = this.settings.compositeOperation;

        this.activeTouches.forEach((touchSystem, touchId) => {
            // 1. Эмиссия новых осколков, если касание активно
            if (touchSystem.isActive) {
                const emitInterval = 1000 / this.settings.emitRate; // мс
                if (now - touchSystem.lastEmitTime >= emitInterval) {
                    const numToEmit = Math.floor((now - touchSystem.lastEmitTime) / emitInterval);
                    for (let i = 0; i < numToEmit; i++) {
                        if (touchSystem.shards.length < this.settings.maxActiveShardsPerTouch) {
                            touchSystem.shards.push(this._createShard(touchSystem));
                        } else {
                            break; // Достигнут лимит
                        }
                    }
                    touchSystem.lastEmitTime = now;
                }
            }

            // 2. Обновление и отрисовка существующих осколков
            touchSystem.shards = touchSystem.shards.filter(shard => {
                shard.x += shard.vx * (deltaTime / 16.66); // Нормализация по времени
                shard.y += shard.vy * (deltaTime / 16.66);
                shard.vy += this.settings.gravity * (deltaTime / 16.66);
                shard.rotation += shard.rotationSpeed * (deltaTime / 16.66);
                shard.life -= deltaTime;

                if (touchSystem.isActive) { // Если касание активно
                    shard.size *= Math.pow(this.settings.shrinkFactor, deltaTime / 16.66);
                    shard.opacity *= Math.pow(this.settings.fadeOutFactor, deltaTime / 16.66);
                } else { // Если касание отпущено, ускоряем затухание
                    const fadeProgress = Math.min((now - touchSystem.fadeStartTime) / this.settings.fadeDurationOnUp, 1);
                    shard.opacity *= (1 - fadeProgress);
                    shard.size *= (1 - fadeProgress * 0.5); // Уменьшаются быстрее
                }

                if (shard.life <= 0 || shard.opacity <= 0.01 || shard.size < 0.5) {
                    return false; // Удаляем мертвый осколок
                }

                this.ctx.save();
                this.ctx.translate(shard.x, shard.y);
                this.ctx.rotate(shard.rotation);

                this.ctx.fillStyle = this.globalVisualizerRef.getColorWithAlpha(shard.color, shard.opacity);

                // Опциональная обводка
                if (this.settings.strokeWidth > 0) {
                    this.ctx.strokeStyle = this.globalVisualizerRef.getColorWithAlpha(shard.color, shard.opacity * 0.7);
                    this.ctx.lineWidth = this.settings.strokeWidth;
                }


                if (shard.type === 'triangle') {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, -shard.size / 1.5); // Более вытянутый треугольник
                    this.ctx.lineTo(shard.size / 2, shard.size / 3);
                    this.ctx.lineTo(-shard.size / 2, shard.size / 3);
                    this.ctx.closePath();
                } else if (shard.type === 'rectangle') {
                    this.ctx.beginPath();
                    this.ctx.rect(-shard.size / 1.5, -shard.size / 3, shard.size * 1.33, shard.size * 0.66); // Более тонкий
                } else if (shard.type === 'line') {
                    this.ctx.beginPath();
                    this.ctx.moveTo(-shard.size / 2, 0);
                    this.ctx.lineTo(shard.size / 2, 0);
                     // Для линии используем stroke вместо fill для видимости
                    this.ctx.strokeStyle = this.globalVisualizerRef.getColorWithAlpha(shard.color, shard.opacity);
                    this.ctx.lineWidth = Math.max(1, shard.size / 4); // Толщина линии
                    this.ctx.stroke();
                    this.ctx.restore();
                    return true; // Для линии fill не нужен
                }

                this.ctx.fill();
                if (this.settings.strokeWidth > 0) this.ctx.stroke();
                this.ctx.restore();
                return true;
            });

            // Если касание отпущено и все осколки исчезли, удаляем систему
            if (!touchSystem.isActive && touchSystem.shards.length === 0) {
                this.activeTouches.delete(touchId);
            }
        });
        this.ctx.globalCompositeOperation = 'source-over';
    }

    dispose() {
        this.activeTouches.clear();
        this.ctx = null;
        this.canvas = null;
        console.log("[GeometricShardsEffect v1.1-live] Disposed.");
    }
}

// Self-registration
if (typeof visualizer !== 'undefined' && typeof visualizer.registerTouchEffectRenderer === 'function') {
    visualizer.registerTouchEffectRenderer('GeometricShardsEffect', GeometricShardsEffect);
} else {
    window.GeometricShardsEffect = GeometricShardsEffect;
    console.warn('[GeometricShardsEffect v1.1-live] Registered globally.');
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\touchEffects\glowEffect.js
class GlowEffect {
    constructor() {
        this.ctx = null;
        this.canvas = null;
        this.settings = {};
        this.themeColors = {};
        this.activeGlows = []; // Array of { id, x, y, color, startTime, isActive, growth }
        this.globalVisualizerRef = null;
    }

    init(ctx, canvas, initialSettings, themeColors, globalVisualizerRef) {
        this.ctx = ctx;
        this.canvas = canvas;
        this.settings = initialSettings || {};
        this.themeColors = themeColors || {};
        this.globalVisualizerRef = globalVisualizerRef;
        this.activeGlows = [];
        console.log("[GlowEffect] Initialized with settings:", this.settings);
    }

    onThemeChange(themeColors) {
        this.themeColors = themeColors;
        this.activeGlows.forEach(glow => {
            if (this.settings.colorSource === 'primary') {
                glow.color = this.themeColors.primary || 'blue';
            } else if (this.settings.colorSource === 'accent') {
                glow.color = this.themeColors.accent || 'red';
            }
        });
    }

    onSettingsChange(newSettings) {
        this.settings = { ...this.settings, ...newSettings };
    }

    onTouchDown(touchData) {
        if (!this.ctx || !this.canvas) return;

        let color = this.themeColors.primary || 'blue';
        if (this.settings.colorSource === 'accent') {
            color = this.themeColors.accent || 'red';
        } else if (this.settings.colorSource === 'note' && touchData.noteInfo?.midiNote !== undefined) {
            const noteIndex = touchData.noteInfo.midiNote % 12;
            const defaultNoteColors = { 0: '#FF0000', 1: '#FF4500', 2: '#FFA500', 3: '#FFD700', 4: '#FFFF00', 5: '#9ACD32', 6: '#32CD32', 7: '#00BFFF', 8: '#0000FF', 9: '#8A2BE2', 10: '#FF00FF', 11: '#FF1493' };
            color = defaultNoteColors[noteIndex] || this.themeColors.primary;
        }

        this.activeGlows.push({
            id: touchData.id,
            x: touchData.x * this.canvas.width,
            y: (1 - touchData.y) * this.canvas.height,
            color: color,
            startTime: performance.now(),
            isActive: true,
            growth: 0
        });
    }

    onTouchMove(touchData) {
        if (!this.ctx || !this.canvas) return;
        const glow = this.activeGlows.find(g => g.id === touchData.id);
        if (glow) {
            glow.x = touchData.x * this.canvas.width;
            glow.y = (1 - touchData.y) * this.canvas.height;
        }
    }

    onTouchUp(touchId) {
        const glow = this.activeGlows.find(g => g.id === touchId);
        if (glow) {
            glow.isActive = false;
            glow.fadeStartTime = performance.now();
        }
    }

    drawActiveEffects() {
        if (!this.ctx || !this.canvas || this.activeGlows.length === 0 || !this.globalVisualizerRef) return;

        const now = performance.now();
        this.ctx.globalCompositeOperation = 'lighter';

        this.activeGlows = this.activeGlows.filter(glow => {
            if (!glow.isActive) {
                // Анимация исчезновения
                const fadeElapsed = now - glow.fadeStartTime;
                const fadeProgress = Math.min(fadeElapsed / 500, 1);
                if (fadeProgress >= 1) return false;

                const baseOpacity = this.settings.baseOpacity || 1.0;
                const alpha = baseOpacity * (1 - fadeProgress);
                const radius = (this.settings.maxRadius || 100) * (1 - fadeProgress * 0.5);

                const gradient = this.ctx.createRadialGradient(
                    glow.x, glow.y, 0,
                    glow.x, glow.y, radius
                );
                gradient.addColorStop(0, this.globalVisualizerRef.getColorWithAlpha(glow.color, alpha));
                gradient.addColorStop(0.5, this.globalVisualizerRef.getColorWithAlpha(glow.color, alpha * 0.5));
                gradient.addColorStop(1, this.globalVisualizerRef.getColorWithAlpha(glow.color, 0));

                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(glow.x, glow.y, radius, 0, Math.PI * 2);
                this.ctx.fill();

                return true;
            }

            // Увеличиваем рост со временем
            const elapsed = now - glow.startTime;
            glow.growth = Math.min(elapsed / 2000, 1); // Рост за 2 секунды

            const baseOpacity = this.settings.baseOpacity || 1.0;
            const pulseSpeed = this.settings.pulseSpeed || 2;
            const maxRadius = this.settings.maxRadius || 100;
            const minRadius = this.settings.minRadius || 60;

            // Комбинируем пульсацию с ростом
            const pulse = (Math.sin(now * 0.001 * pulseSpeed) + 1) * 0.5;
            const radius = (minRadius + (maxRadius - minRadius) * pulse) * (1 + glow.growth);
            const alpha = baseOpacity * (0.5 + pulse * 0.5);

            // Рисуем свечение
            const gradient = this.ctx.createRadialGradient(
                glow.x, glow.y, 0,
                glow.x, glow.y, radius
            );
            gradient.addColorStop(0, this.globalVisualizerRef.getColorWithAlpha(glow.color, alpha));
            gradient.addColorStop(0.5, this.globalVisualizerRef.getColorWithAlpha(glow.color, alpha * 0.5));
            gradient.addColorStop(1, this.globalVisualizerRef.getColorWithAlpha(glow.color, 0));

            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(glow.x, glow.y, radius, 0, Math.PI * 2);
            this.ctx.fill();
            
            return true;
        });

        this.ctx.globalCompositeOperation = 'source-over';
    }

    dispose() {
        this.activeGlows = [];
        this.ctx = null;
        this.canvas = null;
        console.log("[GlowEffect] Disposed.");
    }
}

// Self-registration
if (typeof visualizer !== 'undefined' && typeof visualizer.registerTouchEffectRenderer === 'function') {
    visualizer.registerTouchEffectRenderer('GlowEffect', GlowEffect);
} else {
    window.GlowEffect = GlowEffect;
    console.warn('[GlowEffect] Registered globally as visualizer object was not available at load time.');
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\touchEffects\markerEffect.js
class MarkerEffect {
    constructor() {
        this.ctx = null;
        this.canvas = null;
        this.settings = {};
        this.themeColors = {};
        this.activeMarkers = []; // Array of { id, x, y, color, startTime, isActive, points }
        this.globalVisualizerRef = null;
    }

    init(ctx, canvas, initialSettings, themeColors, globalVisualizerRef) {
        this.ctx = ctx;
        this.canvas = canvas;
        this.settings = initialSettings || {};
        this.themeColors = themeColors || {};
        this.globalVisualizerRef = globalVisualizerRef;
        this.activeMarkers = [];
        console.log("[MarkerEffect] Initialized with settings:", this.settings);
    }

    onThemeChange(themeColors) {
        this.themeColors = themeColors;
        this.activeMarkers.forEach(marker => {
            if (this.settings.colorSource === 'primary') {
                marker.color = this.themeColors.primary || 'blue';
            } else if (this.settings.colorSource === 'accent') {
                marker.color = this.themeColors.accent || 'red';
            }
        });
    }

    onSettingsChange(newSettings) {
        this.settings = { ...this.settings, ...newSettings };
    }

    onTouchDown(touchData) {
        if (!this.ctx || !this.canvas) return;

        let color = this.themeColors.primary || 'blue';
        if (this.settings.colorSource === 'accent') {
            color = this.themeColors.accent || 'red';
        } else if (this.settings.colorSource === 'note' && touchData.noteInfo?.midiNote !== undefined) {
            const noteIndex = touchData.noteInfo.midiNote % 12;
            const defaultNoteColors = { 0: '#FF0000', 1: '#FF4500', 2: '#FFA500', 3: '#FFD700', 4: '#FFFF00', 5: '#9ACD32', 6: '#32CD32', 7: '#00BFFF', 8: '#0000FF', 9: '#8A2BE2', 10: '#FF00FF', 11: '#FF1493' };
            color = defaultNoteColors[noteIndex] || this.themeColors.primary;
        }

        this.activeMarkers.push({
            id: touchData.id,
            x: touchData.x * this.canvas.width,
            y: (1 - touchData.y) * this.canvas.height,
            color: color,
            startTime: performance.now(),
            isActive: true,
            points: [{
                x: touchData.x * this.canvas.width,
                y: (1 - touchData.y) * this.canvas.height,
                time: performance.now()
            }]
        });
    }

    onTouchMove(touchData) {
        if (!this.ctx || !this.canvas) return;
        const marker = this.activeMarkers.find(m => m.id === touchData.id);
        if (marker) {
            marker.x = touchData.x * this.canvas.width;
            marker.y = (1 - touchData.y) * this.canvas.height;
            
            // Добавляем новую точку в след
            marker.points.push({
                x: marker.x,
                y: marker.y,
                time: performance.now()
            });

            // Ограничиваем количество точек
            const maxPoints = this.settings.maxPoints || 50;
            if (marker.points.length > maxPoints) {
                marker.points.shift();
            }
        }
    }

    onTouchUp(touchId) {
        const marker = this.activeMarkers.find(m => m.id === touchId);
        if (marker) {
            marker.isActive = false;
            marker.fadeStartTime = performance.now();
        }
    }

    drawActiveEffects() {
        if (!this.ctx || !this.canvas || this.activeMarkers.length === 0 || !this.globalVisualizerRef) return;

        const now = performance.now();
        this.ctx.globalCompositeOperation = 'lighter';

        this.activeMarkers = this.activeMarkers.filter(marker => {
            if (!marker.isActive) {
                // Анимация исчезновения
                const fadeElapsed = now - marker.fadeStartTime;
                const fadeProgress = Math.min(fadeElapsed / 2000, 1); // 2 секунды на исчезновение
                if (fadeProgress >= 1) return false;

                // Рисуем след с затуханием
                this.drawTrail(marker, 1 - fadeProgress);
                return true;
            }

            // Рисуем активный след
            this.drawTrail(marker, 1);
            return true;
        });

        this.ctx.globalCompositeOperation = 'source-over';
    }

    drawTrail(marker, fadeMultiplier) {
        if (marker.points.length < 2) return;

        const baseOpacity = this.settings.baseOpacity || 1.0;
        const maxWidth = this.settings.maxWidth || 20;
        const minWidth = this.settings.minWidth || 5;

        // Рисуем линию
        this.ctx.beginPath();
        this.ctx.moveTo(marker.points[0].x, marker.points[0].y);

        for (let i = 1; i < marker.points.length; i++) {
            const point = marker.points[i];
            const progress = i / (marker.points.length - 1);
            const width = minWidth + (maxWidth - minWidth) * (1 - progress);
            const alpha = baseOpacity * fadeMultiplier * (1 - progress * 0.5);

            this.ctx.lineWidth = width;
            this.ctx.strokeStyle = this.globalVisualizerRef.getColorWithAlpha(marker.color, alpha);
            this.ctx.lineTo(point.x, point.y);
        }

        this.ctx.stroke();

        // Добавляем свечение в конце
        const lastPoint = marker.points[marker.points.length - 1];
        const glowRadius = maxWidth * 2;
        const gradient = this.ctx.createRadialGradient(
            lastPoint.x, lastPoint.y, 0,
            lastPoint.x, lastPoint.y, glowRadius
        );
        gradient.addColorStop(0, this.globalVisualizerRef.getColorWithAlpha(marker.color, baseOpacity * fadeMultiplier));
        gradient.addColorStop(1, this.globalVisualizerRef.getColorWithAlpha(marker.color, 0));

        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(lastPoint.x, lastPoint.y, glowRadius, 0, Math.PI * 2);
        this.ctx.fill();
    }

    dispose() {
        this.activeMarkers = [];
        this.ctx = null;
        this.canvas = null;
        console.log("[MarkerEffect] Disposed.");
    }
}

// Self-registration
if (typeof visualizer !== 'undefined' && typeof visualizer.registerTouchEffectRenderer === 'function') {
    visualizer.registerTouchEffectRenderer('MarkerEffect', MarkerEffect);
} else {
    window.MarkerEffect = MarkerEffect;
    console.warn('[MarkerEffect] Registered globally as visualizer object was not available at load time.');
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\touchEffects\novaSparkEffect.js
// Файл: app/src/main/assets/js/touchEffects/novaSparkEffect.js
class NovaSparkEffect {
    constructor() {
        this.ctx = null;
        this.canvas = null;
        this.settings = { /* Заполнится из init */ };
        this.themeColors = {};
        this.activeEffects = new Map();
        this.globalVisualizerRef = null;
        this.lastDrawTime = 0;
    }

    init(ctx, canvas, initialSettings, themeColors, globalVisualizerRef) {
        this.ctx = ctx;
        this.canvas = canvas;
        const defaultSettings = { /* Копипаста из JSON NovaSparkEffect v1.0 */
            coreColorSource: "note", coreBrightnessFactor: 0.95, coreMinRadius: 7, coreMaxRadiusYFactor: 15,
            corePulseSpeed: 2.0, corePulseAmount: 0.15, auraGlowColorSource: "note",
            auraRadiusFactor: 2.2, auraOpacityFactor: 0.35, sparkEmitIntervalMs: 40, sparksPerEmit: 2,
            sparkCoreBrightnessFactor: 0.9, sparkGlowColorSource: "note", sparkLineWidthBase: 1.0,
            sparkLineWidthYFactor: 0.6, sparkMaxSegments: 3, sparkSegmentLengthBase: 12,
            sparkSegmentLengthYFactor: 35, sparkJitter: 7, sparkLifeTimeMs: 400,
            sparkOpacityCore: 0.8, sparkOpacityGlow: 0.6, sparkAngleSpreadDeg: 140, sparkBranchChance: 0.1,
            connectionCoreCenterColor: "rgba(255, 255, 255, 1.0)", connectionCoreEdgeBrightnessFactor: 0.85,
            connectionGlowColorMixType: "gradient", connectionLineWidthBase: 3.0,
            connectionLineWidthYFactor: 2.0, connectionWidthBoost: 1.9, connectionMaxSegments: 9,
            connectionJitter: 20, connectionBranchChanceMain: 0.12, connectionBranchColorSource: "mixed",
            opacityConnectionCore: 1.0, opacityConnectionGlow: 0.9,
            lineGlowRadiusFactor: 1.6, lineGlowOpacityFactor: 0.65,
            attractionRadiusPx: 180, targetAttractionFactor: 0.3,
            fadeDurationMs: 200, compositeOperation: "lighter"
        };
        this.settings = { ...defaultSettings, ...initialSettings };
        this.themeColors = themeColors || {};
        this.globalVisualizerRef = globalVisualizerRef;
        this.activeEffects.clear();
        this.lastDrawTime = performance.now();
        console.log("[NovaSparkEffect v1.0] Initialized. Settings:", JSON.parse(JSON.stringify(this.settings)));
    }

    onThemeChange(themeColors) {
        this.themeColors = themeColors;
        this.activeEffects.forEach(effect => {
            if (effect.originalTouchData) {
                effect.coreColor = this._getAdjustedNoteColor(effect.originalTouchData, 'coreColorSource', 'coreBrightnessFactor');
                effect.auraColor = this._getAdjustedNoteColor(effect.originalTouchData, 'auraGlowColorSource', 1.0); // Аура может быть обычным цветом ноты
                effect.sparkGlowColor = this._getAdjustedNoteColor(effect.originalTouchData, 'sparkGlowColorSource', 1.0);
            }
        });
    }

    onSettingsChange(newSettings) {
        this.settings = { ...this.settings, ...newSettings };
    }

    _getAdjustedNoteColor(touchData, colorSourceSettingKey, brightnessFactorSettingKey) {
        const colorSource = this.settings[colorSourceSettingKey] || 'note';
        let baseColorHex = this.themeColors.accent || '#00AEEF';
        const brightnessFactor = this.settings[brightnessFactorSettingKey] || 1.0;

        if (!touchData || !this.settings || !this.globalVisualizerRef) return baseColorHex;

        if (colorSource === 'primary') {
            baseColorHex = this.themeColors.primary || '#007BFF';
        } else if (colorSource === 'note' && touchData.noteInfo?.midiNote !== undefined) {
            const noteIndex = touchData.noteInfo.midiNote % 12;
            const noteColors = this.globalVisualizerRef.noteColors;
            if (noteColors && typeof noteColors === 'object' && noteColors[noteIndex]) {
                baseColorHex = noteColors[noteIndex];
            }
        }

        // Преобразуем в RGB и делаем светлее
        const rgb = this.globalVisualizerRef.hexToRgb(baseColorHex);
        if (rgb) {
            const r = Math.min(255, Math.floor(rgb.r + (255 - rgb.r) * (1 - brightnessFactor)));
            const g = Math.min(255, Math.floor(rgb.g + (255 - rgb.g) * (1 - brightnessFactor)));
            const b = Math.min(255, Math.floor(rgb.b + (255 - rgb.b) * (1 - brightnessFactor)));
            return `rgb(${r},${g},${b})`;
        }
        return baseColorHex; // Фоллбэк
    }

    _getCoreColorForSpark(touchData){
         const noteColor = this._getAdjustedNoteColor(touchData, 'sparkGlowColorSource', this.settings.sparkCoreBrightnessFactor);
         // Можно смешать с белым для ядра искры
         const whiteRgb = {r: 255, g: 255, b: 255};
         const noteRgb = this.globalVisualizerRef.hexToRgb(noteColor) || whiteRgb;
         const coreR = Math.floor(noteRgb.r * 0.5 + whiteRgb.r * 0.5);
         const coreG = Math.floor(noteRgb.g * 0.5 + whiteRgb.g * 0.5);
         const coreB = Math.floor(noteRgb.b * 0.5 + whiteRgb.b * 0.5);
         return `rgb(${coreR},${coreG},${coreB})`;
    }


    onTouchDown(touchData) {
        if (!this.ctx || !this.canvas || !this.globalVisualizerRef) return;

        const touchX = touchData.x * this.canvas.width;
        const touchY = (1 - touchData.y) * this.canvas.height;

        const effectData = {
            id: touchData.id,
            touchX: touchX, touchY: touchY, normY: touchData.y,
            originalTouchData: JSON.parse(JSON.stringify(touchData)),
            coreColor: this._getAdjustedNoteColor(touchData, 'coreColorSource', 'coreBrightnessFactor'),
            auraColor: this._getAdjustedNoteColor(touchData, 'auraGlowColorSource', 1.0), // Яркость ауры управляется opacity
            sparkGlowColor: this._getAdjustedNoteColor(touchData, 'sparkGlowColorSource', 1.0),
            sparkCoreColor: this._getCoreColorForSpark(touchData),
            isActive: true,
            coreRadius: 0, currentCorePulse: Math.random(),
            sparks: [], lastSparkEmitTime: 0, currentSparkAngleOffset: Math.random() * Math.PI * 2,
            targetPoint: null, // { id, x, y, coreColor: targetCoreColor, auraColor: targetAuraColor }
            connectionPath: { points: [], mainBranches: [], secondarySparks: [] },
            currentConnectionEndPoint: { x: touchX, y: touchY },
            fadeStartTime: 0, overallAlpha: 1.0
        };
        this.activeEffects.set(touchData.id, effectData);
    }

    onTouchMove(touchData) {
        const effect = this.activeEffects.get(touchData.id);
        if (effect && effect.isActive) {
            effect.touchX = touchData.x * this.canvas.width;
            effect.touchY = (1 - touchData.y) * this.canvas.height;
            effect.normY = touchData.y;

            const oldNoteMidi = effect.originalTouchData.noteInfo?.midiNote;
            effect.originalTouchData = JSON.parse(JSON.stringify(touchData));
            if (touchData.noteInfo?.midiNote !== oldNoteMidi) {
                effect.coreColor = this._getAdjustedNoteColor(effect.originalTouchData, 'coreColorSource', 'coreBrightnessFactor');
                effect.auraColor = this._getAdjustedNoteColor(effect.originalTouchData, 'auraGlowColorSource', 1.0);
                effect.sparkGlowColor = this._getAdjustedNoteColor(effect.originalTouchData, 'sparkGlowColorSource', 1.0);
                effect.sparkCoreColor = this._getCoreColorForSpark(effect.originalTouchData);
            }
        }
    }

    onTouchUp(touchId) {
        const effect = this.activeEffects.get(touchId);
        if (effect) {
            effect.isActive = false;
            effect.fadeStartTime = performance.now();
        }
    }

    // --- Генерация Геометрии (без изменений от BallLightningEffect v1.1) ---
    _generateSparkPath(startX, startY, angle, length, maxSegments, jitter) { /* ... как в BallLightningEffect v1.1 ... */
        const points = [{ x: startX, y: startY }];
        let currentX = startX; let currentY = startY;
        const numSegments = Math.max(1, Math.min(maxSegments, Math.floor(length / (this.settings.sparkSegmentLengthBase * 0.3)) + 1));
        const segmentLen = length / numSegments;
        for (let i = 0; i < numSegments; i++) {
            const segAngle = angle + (Math.random() - 0.5) * (jitter / Math.max(1,length)) * Math.PI * 0.3 * (i / numSegments + 0.2);
            currentX += Math.cos(segAngle) * segmentLen;
            currentY += Math.sin(segAngle) * segmentLen;
            points.push({ x: currentX, y: currentY });
        }
        return points;
    }
    _generateMainArcPath(startX, startY, endX, endY, maxSegments, jitter) { /* ... как в BallLightningEffect v1.1 ... */
        const points = [{ x: startX, y: startY }];
        const dxTotal = endX - startX; const dyTotal = endY - startY;
        const totalDistance = Math.hypot(dxTotal, dyTotal);
        if (totalDistance < 1) { points.push({ x: endX, y: endY }); return points; }
        const numSegments = Math.max(2, maxSegments);
        for (let i = 1; i < numSegments; i++) {
            const t = i / numSegments;
            const currentJitter = jitter * Math.sin(t * Math.PI) * 0.7;
            const currentX = startX + dxTotal * t + (Math.random() - 0.5) * currentJitter;
            const currentY = startY + dyTotal * t + (Math.random() - 0.5) * currentJitter;
            points.push({ x: currentX, y: currentY });
        }
        points.push({ x: endX, y: endY });
        return points;
    }

    // --- Обновление состояния ---
    _updateCoreAndAura(effect, now, deltaTimeMs) { /* ... как в BallLightningEffect v1.1 ... */
        const baseCoreRadius = this.settings.coreMinRadius + effect.normY * this.settings.coreMaxRadiusYFactor;
        effect.currentCorePulse = (effect.currentCorePulse + deltaTimeMs * 0.001 * this.settings.corePulseSpeed) % 1;
        const pulseFactor = 1 + Math.sin(effect.currentCorePulse * Math.PI * 2) * this.settings.corePulseAmount;
        effect.coreRadius = baseCoreRadius * pulseFactor;
    }

    _updateSparks(effect, now) { /* ... как в BallLightningEffect v1.1 (но используем effect.sparkGlowColor) ... */
        effect.sparks = effect.sparks.filter(spark => {
            const age = now - spark.creationTime;
            spark.life = 1.0 - Math.min(age / this.settings.sparkLifeTimeMs, 1.0);
            return spark.life > 0;
        });
        if (effect.isActive && (now - effect.lastSparkEmitTime > this.settings.sparkEmitIntervalMs)) {
            const angleSpreadRad = this.settings.sparkAngleSpreadDeg * (Math.PI / 180);
            for (let i = 0; i < this.settings.sparksPerEmit; i++) {
                effect.currentSparkAngleOffset += (Math.random() - 0.5) * angleSpreadRad * 0.15;
                const angle = effect.currentSparkAngleOffset + (Math.random() - 0.5) * angleSpreadRad;
                const length = (this.settings.sparkSegmentLengthBase + this.settings.sparkSegmentLengthYFactor * effect.normY) * (0.6 + Math.random() * 0.7);
                effect.sparks.push({
                    points: this._generateSparkPath(effect.touchX, effect.touchY, angle, length, this.settings.sparkMaxSegments, this.settings.sparkJitter),
                    creationTime: now, life: 1.0, opacityMultiplier: 0.7 + Math.random()*0.3
                });
            }
            effect.lastSparkEmitTime = now;
        }
    }

    _updateConnectionPath(effect, targetEffect) { /* ... как в BallLightningEffect v1.1, но переименовано ... */
        const pathData = { points: [], mainBranches: [], secondarySparks: [] };
        pathData.points = this._generateMainArcPath(
            effect.touchX, effect.touchY,
            effect.currentConnectionEndPoint.x, effect.currentConnectionEndPoint.y,
            this.settings.connectionMaxSegments, this.settings.connectionJitter
        );
        if (pathData.points.length > 2 && Math.random() < this.settings.connectionBranchChanceMain) {
            const branchFromIndex = Math.floor(1 + Math.random() * (pathData.points.length - 2));
            const p = pathData.points[branchFromIndex];
            const angleToTarget = Math.atan2(targetEffect.touchY - p.y, targetEffect.touchX - p.x);
            const branchAngle = angleToTarget + (Math.random() - 0.5) * Math.PI * 0.8;
            const branchLength = (this.settings.sparkSegmentLengthBase + this.settings.sparkSegmentLengthYFactor * effect.normY) *
                                 (this.settings.connectionBranchMaxSegments || 3) * (0.2 + Math.random() * 0.3);
            pathData.mainBranches.push(
                this._generateSparkPath(p.x, p.y, branchAngle, branchLength,
                                       this.settings.connectionBranchMaxSegments || 3, this.settings.connectionJitter * 0.7)
            );
        }
        if(this.settings.connectionSecondarySparks && Math.random() < 0.5 && pathData.points.length > 1){
             const sparkStartIdx = Math.floor(Math.random() * (pathData.points.length -1));
             const sparkEndIdx = Math.min(pathData.points.length -1, sparkStartIdx + 1 + Math.floor(Math.random()*2));
             const subPath = pathData.points.slice(sparkStartIdx, sparkEndIdx +1);
             if(subPath.length > 1) {
                 pathData.secondarySparks.push({
                     points: subPath,
                     color: Math.random() < 0.5 ? effect.auraColor : targetEffect.auraColor,
                     life: 1.0
                 });
             }
        }
        effect.connectionPath = pathData;
    }

    // --- Отрисовка ---
    _drawRawPath(ctx, points, lineWidth, strokeStyleColor, alpha) { /* ... как в BallLightningEffect v1.1 ... */
        if (points.length < 2 || alpha <= 0.01 || lineWidth < 0.1) return;
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = this.globalVisualizerRef.getColorWithAlpha(strokeStyleColor, alpha);
        ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            const p1 = points[i-1], p2 = points[i];
            const midX = (p1.x + p2.x) / 2 + (Math.random() - 0.5) * lineWidth * 0.1;
            const midY = (p1.y + p2.y) / 2 + (Math.random() - 0.5) * lineWidth * 0.1;
            ctx.quadraticCurveTo(p1.x, p1.y, midX, midY);
        }
        ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
        ctx.stroke();
    }

    _drawStyledPath(ctx, pathPoints, lineWidth, coreColor, glowColor, glowRadiusFactor, coreOpacityFactor, glowOpacityFactor, overallAlpha) {
        // ... как в BallLightningEffect v1.1 ...
        if (pathPoints.length < 2 || overallAlpha <= 0.01) return;
        const glowRadius = Math.max(0.1, lineWidth * glowRadiusFactor);
        const finalGlowOpacity = this.settings.opacity * glowOpacityFactor * this.settings.lineGlowOpacityFactor * overallAlpha;
        const coreAlphaMatch = coreColor.match(/rgba?\([\d\s,]+(?:,\s*([\d.]+))?\)/i);
        const coreBaseAlphaFromColor = coreAlphaMatch && coreAlphaMatch[1] ? parseFloat(coreAlphaMatch[1]) : 1.0;
        const finalCoreOpacity = coreBaseAlphaFromColor * this.settings.opacity * coreOpacityFactor * overallAlpha;

        if (glowRadius > 0.5 && finalGlowOpacity > 0.01) {
            ctx.save(); ctx.filter = `blur(${glowRadius}px)`;
            this._drawRawPath(ctx, pathPoints, lineWidth, glowColor, finalGlowOpacity); // Свечение той же толщины, блюр расширит
            ctx.restore();
        }
        if (finalCoreOpacity > 0.01) {
            this._drawRawPath(ctx, pathPoints, lineWidth, coreColor, finalCoreOpacity);
        }
    }

    // Новый метод для отрисовки градиентной соединительной дуги
    _drawGradientConnectionArc(ctx, pathPoints, lineWidth, coreCenterColor, startGlowColor, endGlowColor, glowRadiusFactor, coreOpacityFactor, glowOpacityFactor, overallAlpha) {
        if (pathPoints.length < 2 || overallAlpha <= 0.01) return;

        const finalGlowOpacity = this.settings.opacity * glowOpacityFactor * this.settings.lineGlowOpacityFactor * overallAlpha;
        const finalCoreOpacity = this.settings.opacity * coreOpacityFactor * overallAlpha;
        const glowRadius = Math.max(0.1, lineWidth * glowRadiusFactor);

        // --- Отрисовка свечения с градиентом ---
        if (glowRadius > 0.5 && finalGlowOpacity > 0.01) {
            const gradient = ctx.createLinearGradient(pathPoints[0].x, pathPoints[0].y, pathPoints[pathPoints.length - 1].x, pathPoints[pathPoints.length - 1].y);
            gradient.addColorStop(0, this.globalVisualizerRef.getColorWithAlpha(startGlowColor, finalGlowOpacity));
            if (startGlowColor !== endGlowColor && this.settings.connectionGlowColorMixType === 'gradient') {
                 gradient.addColorStop(0.5, this.globalVisualizerRef.getColorWithAlpha(startGlowColor, finalGlowOpacity * 0.7)); // Можно добавить промежуточные цвета
                 gradient.addColorStop(0.5, this.globalVisualizerRef.getColorWithAlpha(endGlowColor, finalGlowOpacity * 0.7));
            }
            gradient.addColorStop(1, this.globalVisualizerRef.getColorWithAlpha(endGlowColor, finalGlowOpacity));

            ctx.save();
            ctx.strokeStyle = gradient;
            ctx.lineWidth = lineWidth; // Свечение рисуем той же толщиной, что и ядро
            ctx.filter = `blur(${glowRadius}px)`;
            this._drawRawPath(ctx, pathPoints, lineWidth, "rgba(0,0,0,0)", 1); // Рисуем путь для блюра
            ctx.restore();
        }

        // --- Отрисовка ядра с градиентом ---
        if (finalCoreOpacity > 0.01) {
            const coreGradient = ctx.createLinearGradient(pathPoints[0].x, pathPoints[0].y, pathPoints[pathPoints.length - 1].x, pathPoints[pathPoints.length - 1].y);
            const startCoreColor = this._getAdjustedNoteColor({ noteInfo: { midiNote: this.activeEffects.get(this.globalVisualizerRef.activeTouchPointsMap.get(pathPoints[0].originalTouchId)?.id)?.originalTouchData.noteInfo.midiNote } } , 'coreColorSource', this.settings.connectionCoreEdgeBrightnessFactor); // Цвет ноты на краю
            const endCoreColor = this._getAdjustedNoteColor({ noteInfo: { midiNote: this.activeEffects.get(this.globalVisualizerRef.activeTouchPointsMap.get(pathPoints[pathPoints.length-1].originalTouchId)?.id)?.originalTouchData.noteInfo.midiNote } } , 'coreColorSource', this.settings.connectionCoreEdgeBrightnessFactor); // Цвет ноты на краю

            coreGradient.addColorStop(0, this.globalVisualizerRef.getColorWithAlpha(startCoreColor, finalCoreOpacity));
            coreGradient.addColorStop(0.4, this.globalVisualizerRef.getColorWithAlpha(coreCenterColor, finalCoreOpacity)); // Белый к центру
            coreGradient.addColorStop(0.6, this.globalVisualizerRef.getColorWithAlpha(coreCenterColor, finalCoreOpacity)); // Белый от центра
            coreGradient.addColorStop(1, this.globalVisualizerRef.getColorWithAlpha(endCoreColor, finalCoreOpacity));

            this._drawRawPath(ctx, pathPoints, lineWidth, coreGradient, 1.0); // Alpha уже в градиенте
        }
    }


    drawActiveEffects() {
        if (!this.ctx || !this.canvas || !this.globalVisualizerRef?.activeTouchPointsMap) return;
        const now = performance.now();
        const deltaTimeMs = now - this.lastDrawTime;
        this.lastDrawTime = now;

        this.ctx.globalCompositeOperation = this.settings.compositeOperation;
        this.ctx.lineCap = 'round'; this.ctx.lineJoin = 'round';

        // 1. Обновление состояний и определение целей
        this.activeEffects.forEach(effect => { /* ... как в v1.1 ... */
            if (!effect.isActive) {
                effect.overallAlpha = 1.0 - Math.min((now - effect.fadeStartTime) / this.settings.fadeDurationMs, 1);
                if (effect.overallAlpha <= 0.01 && effect.sparks.length === 0) {
                    this.activeEffects.delete(effect.id); return;
                }
            } else { effect.overallAlpha = 1.0; }
            this._updateCoreAndAura(effect, now, deltaTimeMs);

            effect.targetPoint = null;
            if (effect.isActive && this.globalVisualizerRef.activeTouchPointsMap.size > 1) {
                let closestDistSq = Math.pow(this.settings.attractionRadiusPx, 2);
                this.globalVisualizerRef.activeTouchPointsMap.forEach(otherMapPoint => {
                    if (otherMapPoint.id !== effect.id) {
                        const otherEffect = this.activeEffects.get(otherMapPoint.id);
                        if (otherEffect && otherEffect.isActive && (!otherEffect.targetPoint || otherEffect.targetPoint.id === effect.id)) {
                            const distSq = Math.pow(effect.touchX - otherMapPoint.x, 2) + Math.pow(effect.touchY - otherMapPoint.y, 2);
                            if (distSq < closestDistSq) {
                                closestDistSq = distSq;
                                effect.targetPoint = {
                                    id: otherMapPoint.id, x: otherMapPoint.x, y: otherMapPoint.y,
                                    auraColor: this._getAdjustedNoteColor(otherEffect.originalTouchData, 'auraGlowColorSource', 1.0), // Цвет ауры цели
                                    coreColor: this._getAdjustedNoteColor(otherEffect.originalTouchData, 'coreColorSource', 'coreBrightnessFactor') // Цвет ядра цели
                                };
                            }
                        }
                    }
                });
            }
            let targetCX = effect.touchX, targetCY = effect.touchY;
            if(effect.targetPoint) { targetCX = effect.targetPoint.x; targetCY = effect.targetPoint.y; }
            effect.currentConnectionEndPoint.x += (targetCX - effect.currentConnectionEndPoint.x) * this.settings.targetAttractionFactor;
            effect.currentConnectionEndPoint.y += (targetCY - effect.currentConnectionEndPoint.y) * this.settings.targetAttractionFactor;
        });

        // 2. Отрисовка
        let drawnConnections = new Set(); // Чтобы не рисовать соединение дважды

        this.activeEffects.forEach(effect => {
            if (effect.overallAlpha <= 0.01 && !effect.isActive && effect.sparks.length === 0) return;

            // A. Рисуем Ядро и Ауру "Новы"
            const finalCoreRadius = Math.max(0.1, effect.coreRadius * effect.overallAlpha);
            if (finalCoreRadius > 0.1) {
                const auraRadius = finalCoreRadius * this.settings.auraRadiusFactor;
                const auraAlpha = this.settings.auraOpacityFactor * effect.overallAlpha;
                if (auraAlpha > 0.01 && auraRadius > 0.5) {
                    const auraGradient = this.ctx.createRadialGradient(effect.touchX, effect.touchY, finalCoreRadius * 0.7, effect.touchX, effect.touchY, auraRadius);
                    auraGradient.addColorStop(0, this.globalVisualizerRef.getColorWithAlpha(effect.auraColor, auraAlpha * 0.8));
                    auraGradient.addColorStop(1, this.globalVisualizerRef.getColorWithAlpha(effect.auraColor, 0));
                    this.ctx.fillStyle = auraGradient;
                    this.ctx.beginPath(); this.ctx.arc(effect.touchX, effect.touchY, auraRadius, 0, Math.PI * 2); this.ctx.fill();
                }
                const coreGradient = this.ctx.createRadialGradient(effect.touchX, effect.touchY, 0, effect.touchX, effect.touchY, finalCoreRadius);
                const coreEffectiveColor = effect.isActive ? effect.coreColor : this.settings.coreBaseColor; // При затухании ядро может стать белым
                const coreFinalAlpha = effect.isActive ? 1.0 : effect.overallAlpha; // Ядро не затухает пока активно

                coreGradient.addColorStop(0, this.globalVisualizerRef.getColorWithAlpha(coreEffectiveColor, 1.0 * coreFinalAlpha));
                coreGradient.addColorStop(0.8, this.globalVisualizerRef.getColorWithAlpha(coreEffectiveColor, 0.5 * coreFinalAlpha));
                coreGradient.addColorStop(1, this.globalVisualizerRef.getColorWithAlpha(coreEffectiveColor, 0));
                this.ctx.fillStyle = coreGradient;
                this.ctx.beginPath(); this.ctx.arc(effect.touchX, effect.touchY, finalCoreRadius, 0, Math.PI * 2); this.ctx.fill();
            }

            const glowRadiusForLines = (this.settings.glowRadiusBase + this.settings.glowRadiusYFactor * effect.normY);

            // B. Соединительная дуга или Искры
            if (effect.targetPoint) {
                const targetEffect = this.activeEffects.get(effect.targetPoint.id);
                // Рисуем соединение, только если оно взаимное и мы "меньший" ID, или если цель уже неактивна/не целится в нас
                const canDrawConnection = targetEffect && targetEffect.isActive && targetEffect.targetPoint?.id === effect.id && effect.id < targetEffect.id;
                const isStretchingToInactiveTarget = !targetEffect || !targetEffect.isActive;

                if (canDrawConnection || isStretchingToInactiveTarget) {
                    const connKey = effect.id < (targetEffect?.id || effect.targetPoint.id) ? `${effect.id}-${targetEffect?.id || effect.targetPoint.id}` : `${targetEffect?.id || effect.targetPoint.id}-${effect.id}`;
                    if (!drawnConnections.has(connKey)) {
                        this._updateConnectionPath(effect, targetEffect || effect.targetPoint); // Передаем effect.targetPoint если targetEffect уже нет

                        const avgNormY = targetEffect ? (effect.normY + targetEffect.normY) / 2 : effect.normY;
                        let lineWidth = (this.settings.connectionLineWidthBase + this.settings.connectionLineWidthYFactor * avgNormY) * this.settings.connectionWidthBoost;
                        lineWidth = Math.max(0.1, lineWidth * effect.overallAlpha);

                        // --- Используем новый метод для градиентной дуги ---
                        this._drawGradientConnectionArc(this.ctx, effect.connectionPath.points, lineWidth,
                            this.settings.connectionCoreCenterColor,
                            effect.auraColor, // Цвет свечения от текущей точки
                            effect.targetPoint.auraColor || effect.auraColor, // Цвет свечения от целевой точки
                            this.settings.lineGlowRadiusFactor,
                            this.settings.opacityConnectionCore,
                            this.settings.opacityConnectionGlow,
                            effect.overallAlpha
                        );
                        // --- Конец использования нового метода ---

                        // Ветви основной дуги
                        effect.connectionPath.mainBranches.forEach(branchPoints => {
                             this._drawStyledPath(this.ctx, branchPoints, lineWidth * 0.35,
                                 this.settings.coreColorSpark, effect.auraColor, // Ветви от цвета текущей точки
                                 glowRadiusForLines * 0.5, this.settings.sparkOpacityCore,
                                 this.settings.sparkOpacityGlow, effect.overallAlpha);
                        });
                        // Вторичные искры
                        if(this.settings.connectionSecondarySparks){ /* ... как в v1.1 ... */ }

                        drawnConnections.add(connKey);
                    }
                }
                if (effect.isActive) effect.sparks = [];
            } else { // Режим Искр
                this._updateSparks(effect, now);
                effect.sparks.forEach(spark => {
                    if (spark.life > 0 && spark.points.length >= 2) {
                        const sparkLineWidth = this.settings.sparkLineWidthBase + this.settings.sparkLineWidthYFactor * effect.normY;
                        const sparkTotalAlpha = spark.opacityMultiplier * spark.life * effect.overallAlpha;

                        this._drawStyledPath(this.ctx, spark.points, sparkLineWidth,
                                             effect.sparkCoreColor, effect.sparkGlowColor,
                                             glowRadiusForLines * 0.6,
                                             this.settings.sparkOpacityCore,
                                             this.settings.sparkOpacityGlow,
                                             sparkTotalAlpha);
                    }
                });
                effect.connectionPath = { points: [], mainBranches: [], secondarySparks: [] };
            }
        });
        this.ctx.globalCompositeOperation = 'source-over';
    }

    dispose() { /* ... как в v1.1 ... */
        this.activeEffects.clear(); this.ctx = null; this.canvas = null;
        console.log("[NovaSparkEffect v1.0] Disposed.");
    }
}

// Self-registration
if (typeof visualizer !== 'undefined' && typeof visualizer.registerTouchEffectRenderer === 'function') {
    visualizer.registerTouchEffectRenderer('NovaSparkEffect', NovaSparkEffect); // Имя КЛАССА!
} else {
    window.NovaSparkEffect = NovaSparkEffect;
    console.warn('[NovaSparkEffect v1.0] Registered globally.');
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\touchEffects\rippleEffect.js
class RippleEffect {
    constructor() {
        this.ctx = null;
        this.canvas = null;
        this.settings = {};
        this.themeColors = {};
        this.activeRipples = []; // Array of { id, x, y, startTime, duration, maxRadius, color, rings }
        this.globalVisualizerRef = null;
    }

    init(ctx, canvas, initialSettings, themeColors, globalVisualizerRef) {
        this.ctx = ctx;
        this.canvas = canvas;
        this.settings = initialSettings || {};
        this.themeColors = themeColors || {};
        this.globalVisualizerRef = globalVisualizerRef;
        this.activeRipples = [];
        console.log("[RippleEffect] Initialized with settings:", this.settings);
    }

    onThemeChange(themeColors) {
        this.themeColors = themeColors;
        this.activeRipples.forEach(ripple => {
            if (this.settings.colorSource === 'primary') {
                ripple.color = this.themeColors.primary || 'blue';
            } else if (this.settings.colorSource === 'accent') {
                ripple.color = this.themeColors.accent || 'red';
            }
        });
    }

    onSettingsChange(newSettings) {
        this.settings = { ...this.settings, ...newSettings };
    }

    onTouchDown(touchData) {
        if (!this.ctx || !this.canvas) return;

        this.activeRipples = this.activeRipples.filter(r => r.id !== touchData.id);

        let color = this.themeColors.primary || 'blue';
        if (this.settings.colorSource === 'accent') {
            color = this.themeColors.accent || 'red';
        } else if (this.settings.colorSource === 'note' && touchData.noteInfo?.midiNote !== undefined) {
            const noteIndex = touchData.noteInfo.midiNote % 12;
            const defaultNoteColors = { 0: '#FF0000', 1: '#FF4500', 2: '#FFA500', 3: '#FFD700', 4: '#FFFF00', 5: '#9ACD32', 6: '#32CD32', 7: '#00BFFF', 8: '#0000FF', 9: '#8A2BE2', 10: '#FF00FF', 11: '#FF1493' };
            color = defaultNoteColors[noteIndex] || this.themeColors.primary;
        }

        this.activeRipples.push({
            id: touchData.id,
            x: touchData.x * this.canvas.width,
            y: (1 - touchData.y) * this.canvas.height,
            startTime: performance.now(),
            duration: this.settings.duration || 1000,
            maxRadius: this.settings.maxRadius || 100,
            color: color,
            rings: this.settings.rings || 3,
            ringSpacing: this.settings.ringSpacing || 0.2
        });
    }

    onTouchMove(touchData) {
        if (!this.ctx || !this.canvas) return;
        const ripple = this.activeRipples.find(r => r.id === touchData.id);
        if (ripple) {
            ripple.x = touchData.x * this.canvas.width;
            ripple.y = (1 - touchData.y) * this.canvas.height;
        }
    }

    onTouchUp(touchId) {
        const ripple = this.activeRipples.find(r => r.id === touchId);
        if (ripple) {
            ripple.fadeStartTime = performance.now();
        }
    }

    drawActiveEffects() {
        if (!this.ctx || !this.canvas || this.activeRipples.length === 0 || !this.globalVisualizerRef) return;

        const now = performance.now();
        this.ctx.globalCompositeOperation = 'lighter';

        this.activeRipples = this.activeRipples.filter(ripple => {
            const elapsed = now - ripple.startTime;
            if (elapsed >= ripple.duration) return false;

            const progress = elapsed / ripple.duration;
            const baseOpacity = this.settings.baseOpacity || 0.6;

            for (let i = 0; i < ripple.rings; i++) {
                const ringProgress = (progress + i * ripple.ringSpacing) % 1;
                if (ringProgress < 0) continue;

                const ringRadius = ripple.maxRadius * ringProgress;
                const ringAlpha = baseOpacity * (1 - ringProgress);

                if (ringAlpha <= 0.01) continue;

                this.ctx.beginPath();
                this.ctx.strokeStyle = this.globalVisualizerRef.getColorWithAlpha(ripple.color, ringAlpha);
                this.ctx.lineWidth = 2;
                this.ctx.arc(ripple.x, ripple.y, ringRadius, 0, Math.PI * 2);
                this.ctx.stroke();

                // Добавляем внутреннее свечение
                const glowGradient = this.ctx.createRadialGradient(
                    ripple.x, ripple.y, ringRadius - 2,
                    ripple.x, ripple.y, ringRadius + 2
                );
                glowGradient.addColorStop(0, this.globalVisualizerRef.getColorWithAlpha(ripple.color, ringAlpha * 0.3));
                glowGradient.addColorStop(1, this.globalVisualizerRef.getColorWithAlpha(ripple.color, 0));
                this.ctx.fillStyle = glowGradient;
                this.ctx.fill();
            }

            return true;
        });

        this.ctx.globalCompositeOperation = 'source-over';
    }

    dispose() {
        this.activeRipples = [];
        this.ctx = null;
        this.canvas = null;
        console.log("[RippleEffect] Disposed.");
    }
}

// Self-registration
if (typeof visualizer !== 'undefined' && typeof visualizer.registerTouchEffectRenderer === 'function') {
    visualizer.registerTouchEffectRenderer('RippleEffect', RippleEffect);
} else {
    window.RippleEffect = RippleEffect;
    console.warn('[RippleEffect] Registered globally as visualizer object was not available at load time.');
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\touchEffects\sparkEffect.js
class SparkEffect {
    constructor() {
        this.ctx = null;
        this.canvas = null;
        this.settings = {
            colorSource: 'note',
            baseOpacity: 1.0,
            sparkCount: 8,
            minLength: 10,
            maxLength: 50,
            reactToAudio: true,
            audioReactivity: {
                lengthMultiplier: 1.5,
                opacityMultiplier: 1.2
            }
        };
        this.themeColors = {};
        this.activeSparks = []; // Array of { id, x, y, color, startTime, isActive, sparks }
        this.globalVisualizerRef = null;
    }

    init(ctx, canvas, initialSettings, themeColors, globalVisualizerRef) {
        this.ctx = ctx;
        this.canvas = canvas;
        this.settings = initialSettings || {};
        this.themeColors = themeColors || {};
        this.globalVisualizerRef = globalVisualizerRef;
        this.activeSparks = [];
        console.log("[SparkEffect] Initialized with settings:", this.settings);
    }

    onThemeChange(themeColors) {
        this.themeColors = themeColors;
        this.activeSparks.forEach(spark => {
            if (this.settings.colorSource === 'primary') {
                spark.color = this.themeColors.primary || 'blue';
            } else if (this.settings.colorSource === 'accent') {
                spark.color = this.themeColors.accent || 'red';
            }
        });
    }

    onSettingsChange(newSettings) {
        this.settings = { ...this.settings, ...newSettings };
    }

    createSpark(x, y, color) {
        const angle = Math.random() * Math.PI * 2;
        const length = Math.random() * (this.settings.maxLength || 50) + (this.settings.minLength || 10);
        const segments = Math.floor(Math.random() * 3) + 2;
        const points = [];
        let currentX = x;
        let currentY = y;

        for (let i = 0; i < segments; i++) {
            const segmentLength = length / segments;
            const segmentAngle = angle + (Math.random() - 0.5) * Math.PI / 2;
            currentX += Math.cos(segmentAngle) * segmentLength;
            currentY += Math.sin(segmentAngle) * segmentLength;
            points.push({ x: currentX, y: currentY });
        }

        return {
            points: points,
            life: 1.0,
            speed: Math.random() * 2 + 1
        };
    }

    onTouchDown(touchData) {
        if (!this.ctx || !this.canvas) return;

        let color = this.themeColors.primary || 'blue';
        if (this.settings.colorSource === 'accent') {
            color = this.themeColors.accent || 'red';
        } else if (this.settings.colorSource === 'note' && touchData.noteInfo?.midiNote !== undefined) {
            const noteIndex = touchData.noteInfo.midiNote % 12;
            const defaultNoteColors = { 0: '#FF0000', 1: '#FF4500', 2: '#FFA500', 3: '#FFD700', 4: '#FFFF00', 5: '#9ACD32', 6: '#32CD32', 7: '#00BFFF', 8: '#0000FF', 9: '#8A2BE2', 10: '#FF00FF', 11: '#FF1493' };
            color = defaultNoteColors[noteIndex] || this.themeColors.primary;
        }

        const x = touchData.x * this.canvas.width;
        const y = (1 - touchData.y) * this.canvas.height;
        const sparks = [];

        // Создаем начальные искры
        const sparkCount = this.settings.sparkCount || 8;
        for (let i = 0; i < sparkCount; i++) {
            sparks.push(this.createSpark(x, y, color));
        }

        this.activeSparks.push({
            id: touchData.id,
            x: x,
            y: y,
            color: color,
            startTime: performance.now(),
            isActive: true,
            sparks: sparks
        });
    }

    onTouchMove(touchData) {
        if (!this.ctx || !this.canvas) return;
        const spark = this.activeSparks.find(s => s.id === touchData.id);
        if (spark) {
            spark.x = touchData.x * this.canvas.width;
            spark.y = (1 - touchData.y) * this.canvas.height;

            // Добавляем новые искры при движении
            if (Math.random() < 0.3) { // 30% шанс создания новой искры
                spark.sparks.push(this.createSpark(spark.x, spark.y, spark.color));
            }
        }
    }

    onTouchUp(touchId) {
        const spark = this.activeSparks.find(s => s.id === touchId);
        if (spark) {
            spark.isActive = false;
            spark.fadeStartTime = performance.now();
        }
    }

    drawActiveEffects() {
        if (!this.ctx || !this.canvas || this.activeSparks.length === 0 || !this.globalVisualizerRef) return;

        const now = performance.now();
        this.ctx.globalCompositeOperation = 'lighter';

        this.activeSparks = this.activeSparks.filter(spark => {
            if (!spark.isActive) {
                // Анимация исчезновения
                const fadeElapsed = now - spark.fadeStartTime;
                const fadeProgress = Math.min(fadeElapsed / 500, 1);
                if (fadeProgress >= 1) return false;

                spark.sparks.forEach(s => {
                    s.life = 1 - fadeProgress;
                });
            }

            // Обновляем и рисуем искры
            spark.sparks = spark.sparks.filter(s => {
                s.life -= 0.02;

                if (s.life <= 0) return false;

                const alpha = (this.settings.baseOpacity || 1.0) * s.life;

                // Рисуем искру
                this.ctx.beginPath();
                this.ctx.moveTo(spark.x, spark.y);

                s.points.forEach((point, index) => {
                    const progress = index / (s.points.length - 1);
                    const pointAlpha = alpha * (1 - progress * 0.5);
                    this.ctx.strokeStyle = this.globalVisualizerRef.getColorWithAlpha(spark.color, pointAlpha);
                    this.ctx.lineWidth = 2 * (1 - progress);
                    this.ctx.lineTo(point.x, point.y);
                });

                this.ctx.stroke();

                return true;
            });

            return spark.sparks.length > 0;
        });

        this.ctx.globalCompositeOperation = 'source-over';
    }

    dispose() {
        this.activeSparks = [];
        this.ctx = null;
        this.canvas = null;
        console.log("[SparkEffect] Disposed.");
    }
}

// Self-registration
if (typeof visualizer !== 'undefined' && typeof visualizer.registerTouchEffectRenderer === 'function') {
    visualizer.registerTouchEffectRenderer('SparkEffect', SparkEffect);
} else {
    window.SparkEffect = SparkEffect;
    console.warn('[SparkEffect] Registered globally as visualizer object was not available at load time.');
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\touchEffects\trailEffect.js
class TrailEffect {
    constructor() {
        this.ctx = null;
        this.canvas = null;
        this.settings = {};
        this.themeColors = {};
        this.activeTrails = []; // Array of { id, points, color, lastUpdate, isActive }
        this.globalVisualizerRef = null;
    }

    init(ctx, canvas, initialSettings, themeColors, globalVisualizerRef) {
        this.ctx = ctx;
        this.canvas = canvas;
        this.settings = initialSettings || {};
        this.themeColors = themeColors || {};
        this.globalVisualizerRef = globalVisualizerRef;
        this.activeTrails = [];
        console.log("[TrailEffect] Initialized with settings:", this.settings);
    }

    onThemeChange(themeColors) {
        this.themeColors = themeColors;
        this.activeTrails.forEach(trail => {
            if (this.settings.colorSource === 'primary') {
                trail.color = this.themeColors.primary || 'blue';
            } else if (this.settings.colorSource === 'accent') {
                trail.color = this.themeColors.accent || 'red';
            }
        });
    }

    onSettingsChange(newSettings) {
        this.settings = { ...this.settings, ...newSettings };
    }

    onTouchDown(touchData) {
        if (!this.ctx || !this.canvas) return;

        let color = this.themeColors.primary || 'blue';
        if (this.settings.colorSource === 'accent') {
            color = this.themeColors.accent || 'red';
        } else if (this.settings.colorSource === 'note' && touchData.noteInfo?.midiNote !== undefined) {
            const noteIndex = touchData.noteInfo.midiNote % 12;
            const defaultNoteColors = { 0: '#FF0000', 1: '#FF4500', 2: '#FFA500', 3: '#FFD700', 4: '#FFFF00', 5: '#9ACD32', 6: '#32CD32', 7: '#00BFFF', 8: '#0000FF', 9: '#8A2BE2', 10: '#FF00FF', 11: '#FF1493' };
            color = defaultNoteColors[noteIndex] || this.themeColors.primary;
        }

        this.activeTrails.push({
            id: touchData.id,
            points: [{
                x: touchData.x * this.canvas.width,
                y: (1 - touchData.y) * this.canvas.height,
                time: performance.now()
            }],
            color: color,
            lastUpdate: performance.now(),
            isActive: true
        });
    }

    onTouchMove(touchData) {
        if (!this.ctx || !this.canvas) return;
        const trail = this.activeTrails.find(t => t.id === touchData.id);
        if (trail) {
            const now = performance.now();
            if (now - trail.lastUpdate > (this.settings.updateInterval || 16)) {
                trail.points.push({
                    x: touchData.x * this.canvas.width,
                    y: (1 - touchData.y) * this.canvas.height,
                    time: now
                });
                trail.lastUpdate = now;

                // Ограничиваем количество точек
                const maxPoints = this.settings.maxPoints || 50;
                if (trail.points.length > maxPoints) {
                    trail.points = trail.points.slice(-maxPoints);
                }
            }
        }
    }

    onTouchUp(touchId) {
        const trail = this.activeTrails.find(t => t.id === touchId);
        if (trail) {
            trail.isActive = false;
            trail.fadeStartTime = performance.now();
        }
    }

    drawActiveEffects() {
        if (!this.ctx || !this.canvas || this.activeTrails.length === 0 || !this.globalVisualizerRef) return;

        const now = performance.now();
        this.ctx.globalCompositeOperation = 'lighter';

        this.activeTrails = this.activeTrails.filter(trail => {
            if (trail.points.length < 2) return false;

            const baseOpacity = this.settings.baseOpacity || 0.8;
            const trailDuration = this.settings.trailDuration || 1000;

            // Рисуем след
            this.ctx.beginPath();
            this.ctx.moveTo(trail.points[0].x, trail.points[0].y);

            for (let i = 1; i < trail.points.length; i++) {
                const point = trail.points[i];
                const elapsed = now - point.time;
                const progress = elapsed / trailDuration;
                
                if (!trail.isActive && progress >= 1) {
                    trail.points = trail.points.slice(i);
                    break;
                }

                const alpha = trail.isActive ? baseOpacity : baseOpacity * (1 - progress);
                const width = trail.isActive ? this.settings.maxWidth || 4 : (this.settings.maxWidth || 4) * (1 - progress);

                this.ctx.strokeStyle = this.globalVisualizerRef.getColorWithAlpha(trail.color, alpha);
                this.ctx.lineWidth = width;
                this.ctx.lineTo(point.x, point.y);
            }

            this.ctx.stroke();

            // Добавляем свечение в конце следа
            if (trail.points.length > 0) {
                const lastPoint = trail.points[trail.points.length - 1];
                const elapsed = now - lastPoint.time;
                const progress = elapsed / trailDuration;
                const alpha = trail.isActive ? baseOpacity : baseOpacity * (1 - progress);

                const glowGradient = this.ctx.createRadialGradient(
                    lastPoint.x, lastPoint.y, 0,
                    lastPoint.x, lastPoint.y, this.settings.glowRadius || 20
                );
                glowGradient.addColorStop(0, this.globalVisualizerRef.getColorWithAlpha(trail.color, alpha * 0.3));
                glowGradient.addColorStop(1, this.globalVisualizerRef.getColorWithAlpha(trail.color, 0));

                this.ctx.fillStyle = glowGradient;
                this.ctx.beginPath();
                this.ctx.arc(lastPoint.x, lastPoint.y, this.settings.glowRadius || 20, 0, Math.PI * 2);
                this.ctx.fill();
            }

            return trail.points.length > 0;
        });

        this.ctx.globalCompositeOperation = 'source-over';
    }

    dispose() {
        this.activeTrails = [];
        this.ctx = null;
        this.canvas = null;
        console.log("[TrailEffect] Disposed.");
    }
}

// Self-registration
if (typeof visualizer !== 'undefined' && typeof visualizer.registerTouchEffectRenderer === 'function') {
    visualizer.registerTouchEffectRenderer('TrailEffect', TrailEffect);
} else {
    window.TrailEffect = TrailEffect;
    console.warn('[TrailEffect] Registered globally as visualizer object was not available at load time.');
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\touchEffects\waveEffect.js
class WaveEffect {
    constructor() {
        this.ctx = null;
        this.canvas = null;
        this.settings = {
            colorSource: 'note',
            baseOpacity: 1.0,
            waveSpeed: 3,
            waveInterval: 300,
            maxRadius: 1000,
            minRadius: 40,
            fadeDuration: 1000,
            compositeOperation: "lighter"
        };
        this.themeColors = {};
        this.waveSystems = new Map();
        this.globalVisualizerRef = null;
    }

    init(ctx, canvas, initialSettings, themeColors, globalVisualizerRef) {
        this.ctx = ctx;
        this.canvas = canvas;
        this.settings = { ...this.settings, ...initialSettings };
        this.themeColors = themeColors || {};
        this.globalVisualizerRef = globalVisualizerRef;
        this.waveSystems.clear();
        console.log("[WaveEffect] Initialized with settings:", this.settings);
    }

    onThemeChange(themeColors) {
        this.themeColors = themeColors;
    }

    onSettingsChange(newSettings) {
        this.settings = { ...this.settings, ...newSettings };
    }

    _createWave(system) {
        return {
            radius: this.settings.minRadius,
            opacity: this.settings.baseOpacity,
            startTime: performance.now()
        };
    }

    onTouchDown(touchData) {
        if (!this.ctx || !this.canvas) return;
        this.waveSystems.delete(touchData.id);

        let color = this.themeColors.primary || 'blue';
        if (this.settings.colorSource === 'accent') {
            color = this.themeColors.accent || 'red';
        } else if (this.settings.colorSource === 'note' && touchData.noteInfo?.midiNote !== undefined) {
            const noteIndex = touchData.noteInfo.midiNote % 12;
            const noteColors = this.globalVisualizerRef?.noteColors || 
                { 0: '#FF0000', 1: '#FF4500', 2: '#FFA500', 3: '#FFD700', 4: '#FFFF00', 5: '#9ACD32', 6: '#32CD32', 7: '#00BFFF', 8: '#0000FF', 9: '#8A2BE2', 10: '#FF00FF', 11: '#FF1493' };
            color = noteColors[noteIndex] || this.themeColors.primary;
        }

        const newSystem = {
            id: touchData.id,
            x: touchData.x * this.canvas.width,
            y: (1 - touchData.y) * this.canvas.height,
            color: color,
            isActive: true,
            waves: [this._createWave()],
            lastEmitTime: performance.now(),
            fadeStartTime: 0
        };

        this.waveSystems.set(touchData.id, newSystem);
    }

    onTouchMove(touchData) {
        const system = this.waveSystems.get(touchData.id);
        if (system && system.isActive) {
            system.x = touchData.x * this.canvas.width;
            system.y = (1 - touchData.y) * this.canvas.height;

            if (this.settings.colorSource === 'note' && touchData.noteInfo?.midiNote !== undefined) {
                const noteIndex = touchData.noteInfo.midiNote % 12;
                const noteColors = this.globalVisualizerRef?.noteColors || 
                    { 0: '#FF0000', 1: '#FF4500', 2: '#FFA500', 3: '#FFD700', 4: '#FFFF00', 5: '#9ACD32', 6: '#32CD32', 7: '#00BFFF', 8: '#0000FF', 9: '#8A2BE2', 10: '#FF00FF', 11: '#FF1493' };
                const newColor = noteColors[noteIndex] || this.themeColors.primary;
                
                if (newColor !== system.color) {
                    system.color = newColor;
                }
            }
        }
    }

    onTouchUp(touchId) {
        const system = this.waveSystems.get(touchId);
        if (system) {
            system.isActive = false;
            system.fadeStartTime = performance.now();
        }
    }

    drawActiveEffects() {
        if (!this.ctx || !this.canvas || this.waveSystems.size === 0 || !this.globalVisualizerRef) return;

        const now = performance.now();
        this.ctx.globalCompositeOperation = this.settings.compositeOperation || 'lighter';

        this.waveSystems.forEach((system, systemId) => {
            let systemOpacityMultiplier = 1.0;

            if (system.isActive) {
                if (now - system.lastEmitTime > this.settings.waveInterval) {
                    system.waves.push(this._createWave());
                    system.lastEmitTime = now;
                }
            } else {
                const fadeElapsed = now - system.fadeStartTime;
                systemOpacityMultiplier = 1.0 - Math.min(fadeElapsed / this.settings.fadeDuration, 1);

                if (systemOpacityMultiplier <= 0.01 && system.waves.length === 0) {
                    this.waveSystems.delete(systemId);
                    return;
                }
            }

            system.waves = system.waves.filter(wave => {
                const elapsed = now - wave.startTime;
                const progress = elapsed / (this.settings.waveInterval * 2);
                
                if (progress >= 1) return false;

                wave.radius = this.settings.minRadius + (this.settings.maxRadius - this.settings.minRadius) * progress;
                const alpha = wave.opacity * (1 - progress) * systemOpacityMultiplier;

                if (alpha <= 0.01) return false;

                const gradient = this.ctx.createRadialGradient(
                    system.x, system.y, 0,
                    system.x, system.y, wave.radius
                );

                gradient.addColorStop(0, this.globalVisualizerRef.getColorWithAlpha(system.color, alpha));
                gradient.addColorStop(0.6, this.globalVisualizerRef.getColorWithAlpha(system.color, alpha * 0.4));
                gradient.addColorStop(1, this.globalVisualizerRef.getColorWithAlpha(system.color, 0));

                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(system.x, system.y, wave.radius, 0, Math.PI * 2);
                this.ctx.fill();

                return true;
            });

            if (!system.isActive && system.waves.length === 0) {
                this.waveSystems.delete(systemId);
            }
        });

        this.ctx.globalCompositeOperation = 'source-over';
    }

    dispose() {
        this.waveSystems.clear();
        this.ctx = null;
        this.canvas = null;
        console.log("[WaveEffect] Disposed.");
    }
}

// Self-registration
if (typeof visualizer !== 'undefined' && typeof visualizer.registerTouchEffectRenderer === 'function') {
    visualizer.registerTouchEffectRenderer('WaveEffect', WaveEffect);
} else {
    window.WaveEffect = WaveEffect;
    console.warn('[WaveEffect] Registered globally as visualizer object was not available at load time.');
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\visualizer.js
const visualizer = {
    canvas: null,
    ctx: null,
    analyser: null,
    currentVizType: 'waves',
    currentTouchEffectType: 'glow',
    activeRenderer: null,
    activeTouchEffectRenderer: null,
    vizModuleSettings: {},
    touchEffectModuleSettings: {},
    animationFrameId: null,
    isReady: false,
    activeTouchPointsMap: new Map(),
    themeColors: {
        primary: 'rgba(33, 150, 243, 0.7)',
        accent: 'rgba(255, 64, 129, 0.7)',
        background: 'rgba(255, 255, 255, 0)',
        text: '#333333',
        border: 'rgba(224, 224, 224, 1)'
    },
    renderersRegistry: {},
    touchEffectRenderersRegistry: {},
    _padHints: [], // Храним текущие активные сияния/индикаторы
    padHintsRendererInstance: null,
    _padHintsToDraw: [], // --- НОВОЕ СВОЙСТВО ДЛЯ ПОДСКАЗОК ПЭДА ---
    _prevPadHintsToDraw: null,
    _fadingPadHints: [],
     debugMode: false,

    async init(canvasElement, analyserInstance = null) {
        console.log('[Visualizer v4.1 Modular with PadHints] Initializing...');
        if (!canvasElement) {
            console.error('[Visualizer v4.1] Canvas element not provided!');
            this.isReady = false;
            return;
        }
        this.canvas = canvasElement;
        this.activeTouchPointsMap = new Map(); // Инициализируем здесь, если не было
        try {
            this.ctx = this.canvas.getContext('2d');
            if (!this.ctx) throw new Error("Failed to get 2D context.");
        } catch (error) {
            console.error('[Visualizer v4.1] Failed to get canvas context:', error);
            this.isReady = false;
            return;
        }

        this.isReady = false; // Устанавливаем в false, пока не получим analyser
        this.analyser = analyserInstance;

        if (!this.analyser) {
            console.warn('[Visualizer v4.1 init] Analyser instance not provided directly.');
            if (typeof synth !== 'undefined' && typeof synth.getAnalyser === 'function' && synth.isReady) {
                this.analyser = synth.getAnalyser();
            }
        }

        if (this.analyser) {
            console.log('[Visualizer v4.1 init] Analyser obtained/provided.');
            this.isReady = true;
        } else {
            console.error('[Visualizer v4.1 init] Analyser node still not available!');
        }
        
        this._padHintsToDraw = []; // Инициализируем пустым массивом

        if (this.isReady) {
            if (typeof padHintsRenderer !== 'undefined' && typeof padHintsRenderer.init === 'function') {
                this.padHintsRendererInstance = Object.create(padHintsRenderer);
                this.padHintsRendererInstance.init(this.ctx, this.canvas, this.themeColors, this);
                console.log('[Visualizer v4.1] PadHintsRenderer initialized.');
            } else {
                console.warn('[Visualizer v4.1] padHintsRenderer.js not found or invalid.');
            }
            this.resizeCanvas();
            window.addEventListener('resize', this.resizeCanvas.bind(this));
            console.log('[Visualizer v4.1] Initialized successfully (isReady=true).');
        } else {
             console.error('[Visualizer v4.1] Failed to initialize fully due to missing analyser (isReady=false).');
        }
    },

    registerRenderer(name, rendererClass) {
        if (typeof name === 'string' && typeof rendererClass === 'function') {
            this.renderersRegistry[name] = rendererClass;
            console.log(`[Visualizer v4.0] Registered visualizer renderer: ${name}`);
        } else {
            console.error(`[Visualizer v4.0] Failed to register visualizer renderer: Invalid name or class.`);
        }
    },

    registerTouchEffectRenderer(name, effectClass) {
        if (typeof name === 'string' && typeof effectClass === 'function') {
            this.touchEffectRenderersRegistry[name] = effectClass;
            console.log(`[Visualizer v4.0] Registered touch effect renderer: ${name}`);
        } else {
            console.error(`[Visualizer v4.0] Failed to register touch effect renderer: Invalid name or class.`);
        }
    },

    resizeCanvas() {
        if (!this.canvas || !this.canvas.parentElement) return;
        requestAnimationFrame(() => {
            const parent = this.canvas.parentElement;
            const newWidth = parent.clientWidth;
            const newHeight = parent.clientHeight;

            if (newWidth > 0 && newHeight > 0) {
                if (this.canvas.width !== newWidth || this.canvas.height !== newHeight) {
                    this.canvas.width = newWidth;
                    this.canvas.height = newHeight;
                    console.log(`[Visualizer v4.0] Canvas resized to ${this.canvas.width}x${this.canvas.height}`);
                    if (this.activeRenderer && typeof this.activeRenderer.onResize === 'function') {
                        this.activeRenderer.onResize(newWidth, newHeight);
                    }
                    if (this.activeTouchEffectRenderer && typeof this.activeTouchEffectRenderer.onResize === 'function') {
                        this.activeTouchEffectRenderer.onResize(newWidth, newHeight);
                    }
                }
            }
        });
    },

    async setVisualizerType(typeId) {
        if (!typeId) {
            console.warn('[Visualizer v4.0] setVisualizerType called with null/empty typeId. Retaining current.');
            return;
        }
        console.log(`[Visualizer v4.0] Setting visualizer type to ${typeId}`);
        this.currentVizType = typeId;

        // Сначала останавливаем предыдущий цикл, если он был, и освобождаем ресурсы
        this.stop();
        if (this.activeRenderer && typeof this.activeRenderer.dispose === 'function') {
            this.activeRenderer.dispose();
        }
        this.activeRenderer = null;

        try {
            const vizModuleInfo = await moduleManager.getModule(typeId);
            console.log(`[Visualizer v4.0 DEBUG] Loaded module info for ${typeId}:`, vizModuleInfo ? JSON.parse(JSON.stringify(vizModuleInfo)) : 'null');

            if (!vizModuleInfo || !vizModuleInfo.data || !vizModuleInfo.data.data) {
                console.error(`[Visualizer v4.0] Module info or core data block (module.data.data) not found for visualizer: ${typeId}`);
                return;
            }

            const coreData = vizModuleInfo.data.data;
            const rendererScriptName = coreData.rendererScript;
            this.vizModuleSettings = coreData.settings || {};

            console.log(`[Visualizer v4.0 DEBUG] Renderer script name for ${typeId}: ${rendererScriptName}`);
            console.log(`[Visualizer v4.0 DEBUG] Settings for ${typeId}:`, JSON.parse(JSON.stringify(this.vizModuleSettings)));

            if (!rendererScriptName) {
                console.error(`[Visualizer v4.0] rendererScript is missing in module data for ${typeId}`);
                return;
            }

            const RendererClass = this._getRendererClassFromRegistry(rendererScriptName, this.renderersRegistry);

            if (RendererClass) {
                if (!this.analyser) {
                    console.warn(`[Visualizer] Analyser is null before initializing ${RendererClass.name}. Attempting to fetch again or wait...`);
                    if (typeof synth !== 'undefined' && typeof synth.getAnalyser === 'function') {
                        this.analyser = synth.getAnalyser();
                    }
                    if (!this.analyser) {
                        await new Promise(resolve => setTimeout(resolve, 200));
                        if (typeof synth !== 'undefined' && typeof synth.getAnalyser === 'function') {
                            this.analyser = synth.getAnalyser();
                        }
                    }
                }

                if (!this.analyser) {
                    console.error(`[Visualizer] CRITICAL: Analyser STILL NULL for ${RendererClass.name}. Renderer might fail or not display audio data.`);
                } else {
                    console.log(`[Visualizer] Analyser is available for ${RendererClass.name}. Type: ${this.analyser.type}`);
                }

                if (this.canvas.width === 0 || this.canvas.height === 0) {
                    console.warn(`[Visualizer] Canvas dimensions are zero before initializing ${RendererClass.name}. Attempting resize.`);
                    this.resizeCanvas();
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                if (this.canvas.width === 0 || this.canvas.height === 0) {
                     console.error(`[Visualizer] Canvas dimensions STILL ZERO for ${RendererClass.name}. Renderer WILL LIKELY FAIL.`);
                }

                this.activeRenderer = new RendererClass();
                this.activeRenderer.init(this.ctx, this.canvas, this.vizModuleSettings, this.themeColors, this, this.analyser);
                if (typeof this.activeRenderer.onThemeChange === 'function') {
                    this.activeRenderer.onThemeChange(this.themeColors);
                }
                console.log(`[Visualizer v4.0] Visualizer renderer '${typeId}' (class: ${RendererClass.name}) activated.`);
                this.start();
            } else {
                console.error(`[Visualizer v4.0] Renderer class not found for ${rendererScriptName}. Make sure it's registered or named correctly.`);
            }
        } catch (error) {
            console.error(`[Visualizer v4.0] Error setting visualizer type ${typeId}:`, error);
            this.activeRenderer = null;
        }
        this.configureAnalyser();
    },

    async setTouchEffectType(typeId) {
        const targetEffectId = typeId || 'none';
        console.log(`[Visualizer v4.0] Setting touch effect type to ${targetEffectId}`);
        this.currentTouchEffectType = targetEffectId;

        if (this.activeTouchEffectRenderer && typeof this.activeTouchEffectRenderer.dispose === 'function') {
            this.activeTouchEffectRenderer.dispose();
        }
        this.activeTouchEffectRenderer = null;

        if (targetEffectId === 'none') {
            console.log(`[Visualizer v4.0] Touch effects disabled.`);
            return;
        }

        try {
            console.log(`[Visualizer v4.0] Fetching module info for touch effect ${targetEffectId}...`);
            const effectModuleInfo = await moduleManager.getModule(targetEffectId);
            console.log(`[Visualizer v4.0 DEBUG] Loaded module info for touch effect ${targetEffectId}:`, effectModuleInfo ? JSON.parse(JSON.stringify(effectModuleInfo)) : 'null');

            if (!effectModuleInfo || !effectModuleInfo.data || !effectModuleInfo.data.data) {
                console.error(`[Visualizer v4.0] Module info or core data block (module.data.data) not found for touch effect: ${targetEffectId}`);
                return;
            }

            const coreData = effectModuleInfo.data.data;
            const rendererScriptName = coreData.rendererScript;
            this.touchEffectModuleSettings = coreData.settings || {};

            console.log(`[Visualizer v4.0 DEBUG] Renderer script name for ${targetEffectId}: ${rendererScriptName}`);
            console.log(`[Visualizer v4.0 DEBUG] Settings for ${targetEffectId}:`, JSON.parse(JSON.stringify(this.touchEffectModuleSettings)));

            if (!rendererScriptName) {
                console.warn(`[Visualizer v4.0] rendererScript is missing for touch effect module ${targetEffectId}. Assuming no visual effect.`);
                return;
            }

            console.log(`[Visualizer v4.0] Looking for effect renderer class for ${rendererScriptName}...`);
            const EffectRendererClass = this._getRendererClassFromRegistry(rendererScriptName, this.touchEffectRenderersRegistry);

            if (EffectRendererClass) {
                console.log(`[Visualizer v4.0] Creating new instance of ${EffectRendererClass.name}...`);
                this.activeTouchEffectRenderer = new EffectRendererClass();
                this.activeTouchEffectRenderer.init(this.ctx, this.canvas, this.touchEffectModuleSettings, this.themeColors, this);
                if (typeof this.activeTouchEffectRenderer.onThemeChange === 'function') {
                    this.activeTouchEffectRenderer.onThemeChange(this.themeColors);
                }
                console.log(`[Visualizer v4.0] Touch effect renderer '${targetEffectId}' (class: ${EffectRendererClass.name}) activated.`);
                if (!this.animationFrameId && this.isReady) this.start();
            } else {
                console.error(`[Visualizer v4.0] Touch Effect Renderer class not found for ${rendererScriptName}.`);
            }
        } catch (error) {
            console.error(`[Visualizer v4.0] Error setting touch effect type ${targetEffectId}:`, error);
            this.activeTouchEffectRenderer = null;
        }
    },

    _getRendererClassFromRegistry(scriptPath, registry) {
        if (!scriptPath || typeof scriptPath !== 'string') {
            console.error("[Visualizer v4.0 _getRendererClassFromRegistry] Invalid scriptPath provided:", scriptPath);
            return null;
        }
        const parts = scriptPath.split('/');
        const fileNameWithExtension = parts[parts.length - 1];

        let classNamePrefix = "";
        if (fileNameWithExtension.endsWith('Renderer.js')) {
            classNamePrefix = fileNameWithExtension.replace('Renderer.js', '');
        } else if (fileNameWithExtension.endsWith('Effect.js')) {
            classNamePrefix = fileNameWithExtension.replace('Effect.js', '');
        } else {
            console.warn(`[Visualizer v4.0 _getRendererClassFromRegistry] Unknown script extension for ${scriptPath}. Trying to derive class name.`);
            const dotJsIndex = fileNameWithExtension.lastIndexOf('.js');
            if (dotJsIndex !== -1) {
                classNamePrefix = fileNameWithExtension.substring(0, dotJsIndex);
            } else {
                classNamePrefix = fileNameWithExtension;
            }
        }

        let expectedClassName = classNamePrefix.charAt(0).toUpperCase() + classNamePrefix.slice(1);
        if (scriptPath.includes('/visualizers/')) {
            expectedClassName += "Renderer";
        } else if (scriptPath.includes('/touchEffects/')) {
            expectedClassName += "Effect";
        }

        const RendererClass = registry[expectedClassName];
        if (RendererClass) {
            console.log(`[Visualizer v4.0 _getRendererClassFromRegistry] Found ${expectedClassName} in registry for path ${scriptPath}.`);
            return RendererClass;
        }

        if (window[expectedClassName]) {
            console.warn(`[Visualizer v4.0 _getRendererClassFromRegistry] Found ${expectedClassName} in window scope (fallback) for path ${scriptPath}. Consider registering it.`);
            return window[expectedClassName];
        }

        console.error(`[Visualizer v4.0 _getRendererClassFromRegistry] Class ${expectedClassName} not found in registry or window scope for path ${scriptPath}.`);
        return null;
    },

    configureAnalyser() {
        if (this.analyser) {
            try {
                const fftBasedTypes = ['spectrum', 'circular_spectrum', 'reactive_grid']; // типы, требующие FFT
                let mainVizRequiresFFT = this.activeRenderer && this.vizModuleSettings?.analyserType === 'fft';
                if (!mainVizRequiresFFT && this.currentVizType) { // Проверяем по имени типа, если analyserType не задан в настройках
                    mainVizRequiresFFT = fftBasedTypes.includes(this.currentVizType);
                }

                let targetType = mainVizRequiresFFT ? 'fft' : 'waveform';

                // Если активен какой-то фоновый визуализатор, который требует FFT, переключаемся на FFT
                if (this.activeRenderer && this.vizModuleSettings?.backgroundVisualizer && fftBasedTypes.includes(this.vizModuleSettings.backgroundVisualizer) && targetType !== 'fft') {
                    console.log(`[Visualizer v4.0] Background visualizer '${this.vizModuleSettings.backgroundVisualizer}' requires FFT. Overriding main analyser type.`);
                    targetType = 'fft';
                }

                const settingsToUse = this.vizModuleSettings || {};
                const targetSize = (targetType === 'fft') ? (settingsToUse.fftSize || 512) : 1024;
                const smoothing = settingsToUse.smoothingTimeConstant ?? settingsToUse.smoothing ?? 0.8;

                if (this.analyser.type !== targetType) this.analyser.type = targetType;
                if (this.analyser.size !== targetSize) this.analyser.size = targetSize;
                if (this.analyser.smoothing !== smoothing) this.analyser.smoothing = smoothing;

                console.log(`[Visualizer v4.0 configureAnalyser] Analyser set to: type=${this.analyser.type}, size=${this.analyser.size}, smoothing=${this.analyser.smoothing}`);

            } catch (error) {
                console.error(`[Visualizer v4.0 configureAnalyser] Error:`, error);
            }
        }
    },

    updateTheme() {
        if (!this.isReady) return;
        requestAnimationFrame(() => {
            try {
                const computedStyle = getComputedStyle(document.body);
                this.themeColors.primary = computedStyle.getPropertyValue('--color-primary').trim() || this.themeColors.primary;
                this.themeColors.accent = computedStyle.getPropertyValue('--color-accent').trim() || this.themeColors.accent;
                const bgRgb = computedStyle.getPropertyValue('--color-background-rgb').trim();
                this.themeColors.background = bgRgb ? `rgba(${bgRgb}, 0)` : this.themeColors.background;
                this.themeColors.text = computedStyle.getPropertyValue('--color-text-primary').trim() || this.themeColors.text;
                this.themeColors.border = computedStyle.getPropertyValue('--color-border').trim() || this.themeColors.border;

                if (this.activeRenderer && typeof this.activeRenderer.onThemeChange === 'function') {
                    this.activeRenderer.onThemeChange(this.themeColors);
                }
                if (this.activeTouchEffectRenderer && typeof this.activeTouchEffectRenderer.onThemeChange === 'function') {
                    this.activeTouchEffectRenderer.onThemeChange(this.themeColors);
                }
                if (this.padHintsRendererInstance && typeof this.padHintsRendererInstance.onThemeChange === 'function') {
                    this.padHintsRendererInstance.onThemeChange(this.themeColors);
                }
            } catch (e) {
                console.error("[Visualizer v4.0 updateTheme] Failed to read theme CSS variables:", e);
            }
        });
    },

    start() {
        if (!this.isReady || this.animationFrameId) return;
        if (!this.activeRenderer && !this.activeTouchEffectRenderer) {
            console.log('[Visualizer v4.0] No active renderers to start animation loop.');
            return;
        }
        console.log('[Visualizer v4.0] Starting animation loop.');
        this.animationFrameId = requestAnimationFrame(this.draw.bind(this));
    },

    stop() {
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
            console.log('[Visualizer v4.0] Animation loop stopped.');
        }
    },

    draw() {
        if (this.debugMode && this._padHintsToDraw.length > 0) { // Показываем, только если есть подсказки И включен debugMode
            console.log(`[Visualizer.draw DBG] _padHintsToDraw (${this._padHintsToDraw.length}) items:`);
            this._padHintsToDraw.forEach((h, i) => {
                console.log(`  [Visualizer DBG] Hint ${i}: zoneIndex=${h.zoneIndex}, type='${h.type}', style='${h.style}', color='${h.color}', note='${h.noteName || (h.notes ? h.notes.join(',') : 'N/A')}'`);
            });
        }
        this.animationFrameId = requestAnimationFrame(this.draw.bind(this));
        if (!this.isReady || !this.ctx || !this.canvas || this.canvas.width === 0 || this.canvas.height === 0) return;

        const audioData = (this.analyser && (this.activeRenderer || this.analyser.type === 'fft')) ? this.analyser.getValue() : null;
        const activeTouchStates = (typeof pad !== 'undefined' && pad.getActiveTouchStates) ? pad.getActiveTouchStates() : [];

        this.ctx.save();
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // 1. Основной визуализатор
        if (this.activeRenderer && typeof this.activeRenderer.draw === 'function') {
            try {
                this.activeRenderer.draw(audioData, activeTouchStates);
            } catch (e) {
                console.error(`[Visualizer v4.1] Error in activeRenderer.draw for ${this.currentVizType}:`, e);
            }
        }
        // 1. Рисуем fading-маркеры (fade-out)
        if (Array.isArray(this._fadingPadHints) && this._fadingPadHints.length > 0) {
            const now = performance.now();
            this._fadingPadHints = this._fadingPadHints.filter(hint => {
                const elapsed = now - (hint.fadeOutStart || now);
                const duration = hint.fadeOutDuration || 600; // мс, можно сделать настройкой
                const fadeAlpha = 1 - Math.min(1, elapsed / duration);
                if (fadeAlpha <= 0.01) return false;
                // Рисуем faded hint с уменьшенной альфой
                const zoneData = pad._currentDisplayedZones[hint.zoneIndex];
                if (zoneData) {
                    const zoneRect = {
                        x: zoneData.startX * this.canvas.width,
                        y: 0,
                        width: (zoneData.endX - zoneData.startX) * this.canvas.width,
                        height: this.canvas.height
                    };
                    const styleRendererMethodName = `_renderMarker_${hint.style}`;
                    if (typeof this[styleRendererMethodName] === 'function') {
                        this[styleRendererMethodName](zoneRect, hint, [], fadeAlpha * 0.7);
                    } else {
                        this._renderMarker_GlowFromNote(zoneRect, hint, [], fadeAlpha * 0.7);
                    }
                }
                return true;
            });
        }
        // 2. RocketMode: гармонические маркеры и подсветка
        //console.log(`[Visualizer.draw] Frame. ActiveRenderer: ${this.activeRenderer ? this.currentVizType : 'none'}, TouchEffect: ${this.activeTouchEffectRenderer ? this.currentTouchEffectType : 'none'}, HintsToDraw: ${this._padHintsToDraw.length}`);
        const originalCompositeOp = this.ctx.globalCompositeOperation;
        this.ctx.globalCompositeOperation = 'lighter';
        try {
            this._drawHarmonicMarkers(activeTouchStates);
        } catch (e) {
            console.error(`[Visualizer.draw] Error in _drawHarmonicMarkers:`, e);
        }
        this.ctx.globalCompositeOperation = originalCompositeOp;
        // 3. Эффекты касания
        if (this.activeTouchEffectRenderer && typeof this.activeTouchEffectRenderer.drawActiveEffects === 'function') {
            try {
                this.activeTouchEffectRenderer.drawActiveEffects();
            } catch (e) {
                console.error(`[Visualizer v4.1] Error in activeTouchEffectRenderer.drawActiveEffects for ${this.currentTouchEffectType}:`, e);
            }
        }
        this.ctx.restore();
    },

    _drawHarmonicMarkers(activeTouchStates) {
        // Группируем hints по zoneIndex
        const zoneHintsMap = {};
        this._padHintsToDraw.forEach(hint => {
            if (!zoneHintsMap[hint.zoneIndex]) zoneHintsMap[hint.zoneIndex] = [];
            zoneHintsMap[hint.zoneIndex].push(hint);
        });
        if (!this.isReady || !this.ctx || !this.canvas || !pad?._currentDisplayedZones || this._padHintsToDraw.length === 0) {
            return;
        }
        const rocketSettings = (typeof app !== 'undefined' && app.state && app.state.rocketModeSettings)
            ? app.state.rocketModeSettings
            : { highlightActiveNotes: true, showDirectionalMarkers: true, markerStyle: "GlowFromNote", showOnlyForValidChords: false, animateMarkerFadeOut: true, showChordName: true };
        Object.entries(zoneHintsMap).forEach(([zoneIdx, hints]) => {
            const zoneData = pad._currentDisplayedZones[zoneIdx];
            if (!zoneData) return;
            const zoneRect = {
                x: zoneData.startX * this.canvas.width,
                y: 0,
                width: (zoneData.endX - zoneData.startX) * this.canvas.width,
                height: this.canvas.height
            };
            // Для каждой подсказки рисуем с небольшим смещением/разным радиусом
            hints.forEach((hint, i) => {
                // Смещение для нескольких маркеров: радиус, угол, прозрачность
                const offset = i * 10;
                const fadeAlpha = 1 - i * 0.18;
                if (hint.type === 'active_note_highlight' && rocketSettings.highlightActiveNotes) {
                    this._drawActiveNoteHighlight(zoneRect, hint, fadeAlpha);
                } else if (hint.type === 'harmonic_suggestion' && rocketSettings.showDirectionalMarkers) {
                    const styleRendererMethodName = `_renderMarker_${hint.style}`;
                    if (typeof this[styleRendererMethodName] === 'function') {
                        this[styleRendererMethodName](zoneRect, {...hint, _offset: offset}, activeTouchStates, fadeAlpha);
                    } else {
                        this._renderMarker_GlowFromNote(zoneRect, {...hint, _offset: offset}, activeTouchStates, fadeAlpha);
                    }
                }
                // Подпись
                if (hint.label) {
                    this.ctx.save();
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'top';
                    this.ctx.globalAlpha = 0.85;
                    this.ctx.fillStyle = hint.color || '#FFF';
                    this.ctx.strokeStyle = '#222';
                    this.ctx.lineWidth = 2;
                    const centerX = zoneRect.x + zoneRect.width / 2;
                    const labelY = zoneRect.y + zoneRect.height * 0.01 + i * 18;
                    this.ctx.strokeText(hint.label, centerX, labelY);
                    this.ctx.fillText(hint.label, centerX, labelY);
                    this.ctx.restore();
                }
            });
        });
    },

    _drawActiveNoteHighlight(zoneRect, hint, fadeAlpha = 1) {
        // Красивый glow с blur и плавным градиентом, усиливается при удержании
        if (!this.ctx) return;
        const glowColor = hint.color || "#FFFFFF";
        // Усиление свечения: максимум при 2 сек удержания
        const holdBoost = Math.min(1.0, (hint.holdTimeMs || 0) / 2000);
        const opacity = (0.7 + 0.7 * holdBoost) * (hint._fadeAlpha !== undefined ? hint._fadeAlpha : fadeAlpha);
        const baseRadius = zoneRect.width * (0.6 + 0.4 * holdBoost) + (hint._offset || 0);
        this.ctx.save();
        this.ctx.globalAlpha = opacity;
        this.ctx.shadowColor = glowColor;
        this.ctx.shadowBlur = 32 + 32 * holdBoost + (hint._offset || 0);
        this.ctx.beginPath();
        this.ctx.arc(zoneRect.x + zoneRect.width / 2, zoneRect.y + zoneRect.height * 0.13 + (hint._offset || 0), baseRadius * 0.5, 0, Math.PI * 2);
        this.ctx.fillStyle = this.getColorWithAlpha(glowColor, 0.5 + 0.3 * holdBoost);
        this.ctx.fill();
        this.ctx.restore();
    },

    _renderMarker_GlowFromNote(zoneRect, hint, activeTouchStates, fadeAlpha = 1) {
        // Мягкое сияние с blur и цветным градиентом
        if (!this.ctx) return;
        const color = hint.color || this.themeColors.accent;
        const opacity = 0.6 * (hint._fadeAlpha !== undefined ? hint._fadeAlpha : fadeAlpha);
        const centerX = zoneRect.x + zoneRect.width / 2;
        const startY = zoneRect.y + zoneRect.height * 0.08 + (hint._offset || 0);
        const endRadius = zoneRect.height * 0.22 + (hint._offset || 0);
        this.ctx.save();
        this.ctx.globalAlpha = opacity;
        this.ctx.shadowColor = color;
        this.ctx.shadowBlur = 24 + (hint._offset || 0);
        const gradient = this.ctx.createRadialGradient(
            centerX, startY, zoneRect.width * 0.1,
            centerX, startY, endRadius
        );
        gradient.addColorStop(0, this.getColorWithAlpha(color, 0.9));
        gradient.addColorStop(0.7, this.getColorWithAlpha(color, 0.2));
        gradient.addColorStop(1, this.getColorWithAlpha(color, 0));
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(centerX, startY, endRadius, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.restore();
    },

    _renderMarker_PulseRing(zoneRect, hint, activeTouchStates, fadeAlpha = 1) {
        // Кольцо с glow и прозрачностью
        if (!this.ctx) return;
        const color = hint.color || '#8A2BE2';
        const opacity = 0.7 * (hint._fadeAlpha !== undefined ? hint._fadeAlpha : fadeAlpha);
        const centerX = zoneRect.x + zoneRect.width / 2;
        const startY = zoneRect.y + zoneRect.height * 0.08 + (hint._offset || 0);
        const radius = zoneRect.width * 0.28 + (hint._offset || 0);
        this.ctx.save();
        this.ctx.globalAlpha = opacity;
        this.ctx.shadowColor = color;
        this.ctx.shadowBlur = 18 + (hint._offset || 0);
        this.ctx.beginPath();
        this.ctx.arc(centerX, startY, radius, 0, Math.PI * 2);
        this.ctx.lineWidth = 6;
        this.ctx.strokeStyle = this.getColorWithAlpha(color, 0.7);
        this.ctx.stroke();
        this.ctx.restore();
    },

    _renderMarker_WaveToNote(zoneRect, hint, activeTouchStates, fadeAlpha = 1) {
        // Волна с плавным градиентом и blur
        if (!this.ctx) return;
        const color = hint.color || this.themeColors.primary;
        const opacity = 0.7 * (hint._fadeAlpha !== undefined ? hint._fadeAlpha : fadeAlpha);
        const centerX = zoneRect.x + zoneRect.width / 2;
        const startY = zoneRect.y + zoneRect.height * 0.08 + (hint._offset || 0);
        const waveHeight = zoneRect.height * 0.13 + (hint._offset || 0);
        this.ctx.save();
        this.ctx.globalAlpha = opacity;
        this.ctx.shadowColor = color;
        this.ctx.shadowBlur = 14 + (hint._offset || 0);
        this.ctx.lineWidth = 5;
        this.ctx.beginPath();
        for (let i = 0; i <= 1; i += 0.04) {
            const x = zoneRect.x + i * zoneRect.width;
            const y = startY + Math.sin(i * Math.PI * 2) * waveHeight;
            if (i === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.strokeStyle = this.getColorWithAlpha(color, 0.8);
        this.ctx.stroke();
        this.ctx.restore();
    },

    _renderMarker_SparkTrail(zoneRect, hint, activeTouchStates, fadeAlpha = 1) {
        // Искры с blur и разными цветами
        if (!this.ctx) return;
        const color = hint.color || '#FFD700';
        const opacity = 0.8 * (hint._fadeAlpha !== undefined ? hint._fadeAlpha : fadeAlpha);
        const centerX = zoneRect.x + zoneRect.width / 2;
        const startY = zoneRect.y + zoneRect.height * 0.08 + (hint._offset || 0);
        this.ctx.save();
        this.ctx.globalAlpha = opacity;
        for (let i = 0; i < 8; i++) {
            const angle = (Math.PI * 2 / 8) * i + (hint._offset || 0) * 0.1;
            const len = 18 + (hint._offset || 0) + Math.random() * 10;
            const x2 = centerX + Math.cos(angle) * len;
            const y2 = startY - Math.sin(angle) * len;
            this.ctx.strokeStyle = this.getColorWithAlpha(color, 0.7 + 0.3 * Math.random());
            this.ctx.shadowColor = color;
            this.ctx.shadowBlur = 10 + (hint._offset || 0);
            this.ctx.lineWidth = 2.2;
            this.ctx.beginPath();
            this.ctx.moveTo(centerX, startY);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
        this.ctx.restore();
    },

    _renderMarker_ShadowDrop(zoneRect, hint, activeTouchStates, fadeAlpha = 1) {
        // Мягкая тень с blur
        if (!this.ctx) return;
        const color = hint.color || '#333333';
        const opacity = 0.5 * (hint._fadeAlpha !== undefined ? hint._fadeAlpha : fadeAlpha);
        const centerX = zoneRect.x + zoneRect.width / 2;
        const startY = zoneRect.y + zoneRect.height * 0.08 + (hint._offset || 0);
        this.ctx.save();
        this.ctx.globalAlpha = opacity;
        this.ctx.shadowColor = color;
        this.ctx.shadowBlur = 22 + (hint._offset || 0);
        this.ctx.beginPath();
        this.ctx.arc(centerX, startY, zoneRect.width * 0.22 + (hint._offset || 0), 0, Math.PI * 2);
        this.ctx.fillStyle = this.getColorWithAlpha(color, 0.5);
        this.ctx.fill();
        this.ctx.restore();
    },

    notifyTouchDown(touchData) {
        if (this.canvas) {
            this.activeTouchPointsMap.set(touchData.id, {
                id: touchData.id,
                x: touchData.x * this.canvas.width,
                y: (1 - touchData.y) * this.canvas.height,
                noteInfo: touchData.noteInfo ? { ...touchData.noteInfo } : null
            });
        }

        if (this.activeTouchEffectRenderer && typeof this.activeTouchEffectRenderer.onTouchDown === 'function') {
            try {
                this.activeTouchEffectRenderer.onTouchDown(touchData);
            } catch (e) {
                console.error(`[Visualizer v4.0] Error in activeTouchEffectRenderer.onTouchDown for ${this.currentTouchEffectType}:`, e);
            }
        }
    },

    notifyTouchMove(touchData) {
        const point = this.activeTouchPointsMap.get(touchData.id);
        if (point && this.canvas) {
            point.x = touchData.x * this.canvas.width;
            point.y = (1 - touchData.y) * this.canvas.height;
            point.noteInfo = touchData.noteInfo ? { ...touchData.noteInfo } : null;
        }

        if (this.activeTouchEffectRenderer && typeof this.activeTouchEffectRenderer.onTouchMove === 'function') {
            try {
                this.activeTouchEffectRenderer.onTouchMove(touchData);
            } catch (e) {
                console.error(`[Visualizer v4.0] Error in activeTouchEffectRenderer.onTouchMove for ${this.currentTouchEffectType}:`, e);
            }
        }
    },

    mixColors(hex1, hex2, factor) {
        factor = Math.max(0, Math.min(1, factor));
        const c1 = this.hexToRgb(hex1);
        const c2 = this.hexToRgb(hex2);
        if (!c1 || !c2) return hex1; // fallback

        const r = Math.round(c1.r + (c2.r - c1.r) * factor);
        const g = Math.round(c1.g + (c2.g - c1.g) * factor);
        const b = Math.round(c1.b + (c2.b - c1.b) * factor);
        return `rgb(${r},${g},${b})`;
    },

    notifyTouchUp(touchId) {
        this.activeTouchPointsMap.delete(touchId);

        if (this.activeTouchEffectRenderer && typeof this.activeTouchEffectRenderer.onTouchUp === 'function') {
            try {
                this.activeTouchEffectRenderer.onTouchUp(touchId);
            } catch (e) {
                console.error(`[Visualizer v4.0] Error in activeTouchEffectRenderer.onTouchUp for ${this.currentTouchEffectType}:`, e);
            }
        }
    },

    getColorWithAlpha(colorString, alpha) {
        const clampedAlpha = Math.max(0, Math.min(1, parseFloat(alpha.toFixed(3))));
        if (!colorString) colorString = this.themeColors.primary;

        const themeColorValue = this.themeColors[colorString];
        if (themeColorValue && (themeColorValue.startsWith('#') || themeColorValue.startsWith('rgb') || themeColorValue.startsWith('hsl'))) {
            colorString = themeColorValue;
        }

        if (typeof colorString === 'string' && colorString.startsWith('#')) {
            const rgb = this.hexToRgb(colorString);
            return rgb ? `rgba(${rgb.r},${rgb.g},${rgb.b},${clampedAlpha})` : `rgba(0,0,0,${clampedAlpha})`;
        } else if (typeof colorString === 'string' && colorString.startsWith('rgba')) {
            return colorString.replace(/[\d\.]+\)$/g, `${clampedAlpha})`);
        } else if (typeof colorString === 'string' && colorString.startsWith('rgb')) {
            return colorString.replace('rgb', 'rgba').replace(')', `, ${clampedAlpha})`);
        } else if (typeof colorString === 'string' && colorString.startsWith('hsla')) {
            return colorString.replace(/[\d\.]+\)$/g, `${clampedAlpha})`);
        } else if (typeof colorString === 'string' && colorString.startsWith('hsl')) {
            return colorString.replace('hsl', 'hsla').replace(')', `, ${clampedAlpha})`);
        }

        console.warn(`[Visualizer getColorWithAlpha] Unknown color format: ${colorString}. Using fallback.`);
        const fallbackRgb = this.hexToRgb(this.themeColors.primary);
        return fallbackRgb ? `rgba(${fallbackRgb.r},${fallbackRgb.g},${fallbackRgb.b},${clampedAlpha})` : `rgba(0,0,255,${clampedAlpha})`;
    },

    hexToRgb(hexInput) {
        if (!hexInput || typeof hexInput !== 'string') return null;
        const hex = this.themeColors[hexInput] || hexInput;

        let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        const expandedHex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
        let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(expandedHex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    },

    updatePadHints(newHintsArray) {
        console.log(`[Visualizer.updatePadHints] ----- RECEIVED newHintsArray (${newHintsArray ? newHintsArray.length : 'null/undefined'}) -----`);
        if (Array.isArray(newHintsArray)) {
            newHintsArray.forEach((h, i) => {
                console.log(`  [Visualizer RCV] Hint ${i}: zoneIndex=${h.zoneIndex}, type='${h.type}', style='${h.style}', color='${h.color}', note='${h.noteName || (h.notes ? h.notes.join(',') : 'N/A')}'`);
            });
        }
        // Если были старые hints, и они исчезли — переносим их в fading
        if (Array.isArray(this._padHintsToDraw) && this._padHintsToDraw.length > 0 && Array.isArray(newHintsArray) && newHintsArray.length === 0) {
            const now = performance.now();
            this._fadingPadHints = this._padHintsToDraw.map(hint => ({
                ...hint,
                fadeOutStart: now,
                fadeOutDuration: 600 // мс, можно сделать настройкой
            }));
        }
        this._padHintsToDraw = Array.isArray(newHintsArray) ? newHintsArray : [];
        console.log(`[Visualizer.updatePadHints] _padHintsToDraw is NOW (${this._padHintsToDraw.length}):`);
        this._padHintsToDraw.forEach((h, i) => {
            console.log(`  [Visualizer _padHintsToDraw] Item ${i}: zoneIndex=${h.zoneIndex}, type='${h.type}', style='${h.style}', color='${h.color}', note='${h.noteName || (h.notes ? h.notes.join(',') : 'N/A')}'`);
        });
    },

    dispose() {
        this.stop();
        if (this.activeRenderer && typeof this.activeRenderer.dispose === 'function') this.activeRenderer.dispose();
        if (this.activeTouchEffectRenderer && typeof this.activeTouchEffectRenderer.dispose === 'function') this.activeTouchEffectRenderer.dispose();
        // Не нужно вызывать dispose для _padHintsToDraw, так как это просто массив данных
        
        this.activeRenderer = null;
        this.activeTouchEffectRenderer = null;
        this._padHintsToDraw = []; // Очищаем массив
        
        this.ctx = null; // Обнуляем контекст и канвас
        this.canvas = null;
        this.analyser = null;
        this.isReady = false;
        this.activeTouchPointsMap.clear();
        window.removeEventListener('resize', this.resizeCanvas.bind(this)); // Удаляем обработчик
        console.log('[Visualizer v4.1] Disposed all renderers and state.');
    },
};
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\visualizers\nebulaRenderer.js
class NebulaRenderer {
    constructor() {
        this.ctx = null;
        this.canvas = null;
        this.settings = {};
        this.themeColors = {};
        this.globalVisualizerRef = null;
        this.analyserNodeRef = null;
        this.stars = [];
        this.nebulaBackground = null; // Offscreen canvas for static nebula background
    }

    _generateNebulaBackground() {
        if (!this.canvas) {
            console.error("[Nebula] _generateNebulaBackground: Canvas is null!");
            return;
        }
        // debugger; // Точка останова для отладки DOMException - Закомментируем пока
        const width = this.canvas.width;
        const height = this.canvas.height;
        console.log(`[Nebula INTERNAL] _generateNebulaBackground: Canvas dimensions ${width}x${height}`); // Новый лог
        console.log(`[Nebula] _generateNebulaBackground: Canvas dimensions before offscreen ${width}x${height}`);
        if (width === 0 || height === 0) {
            console.warn("[Nebula] _generateNebulaBackground: Canvas dimensions are zero, skipping offscreen creation.");
            this.nebulaBackground = null;
            return;
        }
        const offscreen = document.createElement('canvas');
        offscreen.width = width;
        offscreen.height = height;
        console.log(`[Nebula] _generateNebulaBackground: Offscreen canvas dimensions ${offscreen.width}x${offscreen.height}`);
        const ctx = offscreen.getContext('2d');
        // Несколько цветных пятен/градиентов
        const nebulaColors = [
            this.themeColors.primary || '#b388ff',
            this.themeColors.accent || '#ffd180',
            '#b3e5fc', '#ff8a80', '#fffbe6', '#ffe0b2'
        ];
        for (let i = 0; i < 3; i++) {
            const cx = width * (0.2 + 0.6 * Math.random());
            const cy = height * (0.2 + 0.6 * Math.random());
            const r = width * (0.2 + 0.2 * Math.random());
            const color = nebulaColors[Math.floor(Math.random() * nebulaColors.length)];
            const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
            grad.addColorStop(0, this.globalVisualizerRef.getColorWithAlpha(color, 0.8));
            grad.addColorStop(1, this.globalVisualizerRef.getColorWithAlpha(color, 0));
            ctx.globalAlpha = 0.25;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fillStyle = grad;
            ctx.fill();
        }
        ctx.globalAlpha = 1.0;
        this.nebulaBackground = offscreen;
    }

    init(ctx, canvas, initialSettings, themeColors, globalVisualizerRef, analyserNodeRef) {
        this.ctx = ctx;
        this.canvas = canvas;
        this.settings = initialSettings || {};
        this.themeColors = themeColors || {};
        this.globalVisualizerRef = globalVisualizerRef;
        this.analyserNodeRef = analyserNodeRef;
        this.stars = [];
        console.log("[NebulaRenderer] Initializing. Canvas dimensions on init:", this.canvas?.width, this.canvas?.height);
        this._initNebula();
        // this._generateNebulaBackground(); // НЕ вызываем здесь, отложим до первого draw или resize
        console.log("[NebulaRenderer] Initialized with settings:", this.settings);
        console.log("[NebulaRenderer] AnalyserNodeRef:", this.analyserNodeRef);
    }

    _createStar() {
        const minRadius = this.settings.starMinRadius || 2;
        const maxRadius = this.settings.starMaxRadius || 5;
        const radius = Math.random() * (maxRadius - minRadius) + minRadius;
        const minSpeed = this.settings.starMinSpeed || 0.1;
        const maxSpeed = this.settings.starMaxSpeed || 0.5;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * (maxSpeed - minSpeed) + minSpeed;
        // Цвет звезды
        let starColors = this.settings.starColors || [this.themeColors.text || '#fff'];
        const color = starColors[Math.floor(Math.random() * starColors.length)];
        // Фаза для плавного мерцания
        const twinklePhase = Math.random() * Math.PI * 2;
        return {
            x: Math.random() * this.canvas.width,
            y: Math.random() * this.canvas.height,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            radius,
            baseAlpha: Math.random() * 0.5 + 0.5,
            mass: radius * radius,
            color,
            twinklePhase,
        };
    }

    _initNebula() {
        if (!this.canvas || this.canvas.width === 0 || this.canvas.height === 0) return;
        this.stars = [];
        const maxStars = this.settings.starCount || 200;
        for (let i = 0; i < maxStars; i++) {
            this.stars.push(this._createStar());
        }
    }

    _applyGravityAndCollisions(activeTouchStates) {
        const gravityStrength = this.settings.gravityStrength || 0.08;
        const touchGravityStrength = this.settings.touchGravityStrength || 8;
        const collisionShrinkFactor = this.settings.collisionShrinkFactor || 0.7;
        const width = this.canvas.width;
        const height = this.canvas.height;
        for (let i = 0; i < this.stars.length; i++) {
            let starA = this.stars[i];
            for (let j = i + 1; j < this.stars.length; j++) {
                let starB = this.stars[j];
                let dx = starB.x - starA.x;
                let dy = starB.y - starA.y;
                let distSq = dx * dx + dy * dy;
                let dist = Math.sqrt(distSq) + 0.01;
                if (dist < starA.radius + starB.radius) {
                    starA.radius *= collisionShrinkFactor;
                    starB.radius *= collisionShrinkFactor;
                    let overlap = (starA.radius + starB.radius) - dist;
                    let nx = dx / dist;
                    let ny = dy / dist;
                    starA.x -= nx * overlap / 2;
                    starA.y -= ny * overlap / 2;
                    starB.x += nx * overlap / 2;
                    starB.y += ny * overlap / 2;
                }
                let force = gravityStrength * starA.mass * starB.mass / distSq;
                let fx = force * dx / dist;
                let fy = force * dy / dist;
                starA.vx += fx / starA.mass;
                starA.vy += fy / starA.mass;
                starB.vx -= fx / starB.mass;
                starB.vy -= fy / starB.mass;
            }
            // Мощная гравитация от касания (почти не зависит от расстояния)
            if (activeTouchStates && Array.isArray(activeTouchStates)) {
                for (const touch of activeTouchStates) {
                    let tx = touch.x * width;
                    let ty = touch.y * height;
                    let dx = tx - starA.x;
                    let dy = ty - starA.y;
                    let distSq = dx * dx + dy * dy + 1;
                    let dist = Math.sqrt(distSq);
                    // Сила почти не убывает с расстоянием
                    let force = touchGravityStrength * starA.mass / (Math.pow(dist, 0.7) + 10);
                    let fx = force * dx / dist;
                    let fy = force * dy / dist;
                    starA.vx += fx / starA.mass;
                    starA.vy += fy / starA.mass;
                }
            }
        }
        for (let star of this.stars) {
            star.x += star.vx;
            star.y += star.vy;
            if (star.x < 0) { star.x = 0; star.vx *= -1; }
            if (star.x > width) { star.x = width; star.vx *= -1; }
            if (star.y < 0) { star.y = 0; star.vy *= -1; }
            if (star.y > height) { star.y = height; star.vy *= -1; }
            if (star.radius < (this.settings.starMinRadius || 2) * 0.5) {
                Object.assign(star, this._createStar());
            }
        }
    }

    onThemeChange(themeColors) {
        this.themeColors = themeColors;
        this._generateNebulaBackground(); // При смене темы фон перегенерируем
    }

    onSettingsChange(newSettings) {
        const oldStarCount = this.settings.starCount;
        this.settings = { ...this.settings, ...newSettings };
        if (this.settings.starCount !== oldStarCount) {
            this._initNebula();
        }
        this._generateNebulaBackground(); // При смене настроек фон перегенерируем
    }

    draw(audioData, activeTouchStates) {
        if (!this.ctx || !this.canvas) return;

        // Логика отложенного создания фона
        if (!this.nebulaBackground && this.canvas.width > 0 && this.canvas.height > 0) { // Создаем фон при первом вызове draw с корректными размерами
            console.log("[Nebula] Lazily generating nebula background in draw()");
            this._generateNebulaBackground();
        }

        // === СТАТИЧНЫЙ ФОН-ТУМАННОСТЬ ===
        if (this.nebulaBackground) {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.drawImage(this.nebulaBackground, 0, 0, this.canvas.width, this.canvas.height);
        } else {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
        // === ФИЗИКА ===
        this._applyGravityAndCollisions(activeTouchStates);
        let energy = 0;
        if (audioData && this.analyserNodeRef) {
            if (this.analyserNodeRef.type === 'waveform' && audioData instanceof Float32Array) {
                energy = audioData.reduce((sum, val) => sum + Math.abs(val), 0) / audioData.length;
            } else if (this.analyserNodeRef.type === 'fft' && audioData instanceof Float32Array) {
                const minDb = this.analyserNodeRef.minDecibels ?? -100;
                const dbRange = (this.analyserNodeRef.maxDecibels ?? -30) - minDb;
                if (dbRange > 0) {
                    const dbSum = audioData.reduce((sum, val) => sum + Math.max(0, (val - minDb) / dbRange), 0);
                    energy = Math.min(1, dbSum / (audioData.length * 0.7));
                }
            }
        }
        const intensity = Math.min(1, energy * (this.settings.energyMultiplier || 3));
        const baseOpacity = this.settings.opacity || 0.5;
        const starBrightnessMultiplier = 1 + intensity * (this.settings.starBrightnessMultiplier || 0.5);
        if (!this.globalVisualizerRef || typeof this.globalVisualizerRef.getColorWithAlpha !== 'function') {
            console.error("[NebulaRenderer] globalVisualizerRef.getColorWithAlpha is not available");
            return;
        }
        // === ОТРИСОВКА ЗВЁЗД ===
        const now = performance.now() / 1000;
        if (this.stars.length > 0) {
            for (let star of this.stars) {
                this.ctx.save();
                this.ctx.beginPath();
                // Плавное мерцание радиуса и альфы
                const twinkle = 1 + 0.25 * Math.sin(now * 6 + star.twinklePhase) + (Math.random() - 0.5) * (this.settings.starTwinkleFactor || 0.2);
                const drawRadius = star.radius * (0.95 + 0.1 * twinkle);
                const alpha = Math.min(1, star.baseAlpha * starBrightnessMultiplier * (0.8 + 0.4 * twinkle));
                this.ctx.arc(star.x, star.y, drawRadius, 0, Math.PI * 2);
                this.ctx.fillStyle = this.globalVisualizerRef.getColorWithAlpha(star.color, alpha);
                this.ctx.shadowColor = star.color;
                this.ctx.shadowBlur = 8 + 8 * twinkle;
                this.ctx.fill();
                this.ctx.restore();
            }
        }
        // === ОБЛАКО ===
        // УДАЛЕНО: не рисуем облако поверх фона
        // if (intensity > 0.01) {
        //     const cloudRadius = this.canvas.width * ((this.settings.cloudBaseSize || 0.4) + intensity * (this.settings.cloudSizeReact || 0.4));
        //     const gradient = this.ctx.createRadialGradient(
        //         this.canvas.width / 2, this.canvas.height / 2, 0,
        //         this.canvas.width / 2, this.canvas.height / 2, cloudRadius
        //     );
        //     const primaryAlpha = Math.min(1, (this.settings.primaryAlpha || 0.3) * baseOpacity * (1 + intensity));
        //     const accentAlpha = Math.min(1, (this.settings.accentAlpha || 0.1) * baseOpacity * (1 + intensity));
        //     const primaryColorWithAlpha = this.globalVisualizerRef.getColorWithAlpha(this.themeColors.primary, primaryAlpha);
        //     const accentColorWithAlpha = this.globalVisualizerRef.getColorWithAlpha(this.themeColors.accent, accentAlpha);
        //     const backgroundColorWithAlpha = this.globalVisualizerRef.getColorWithAlpha(this.themeColors.background || 'rgba(0,0,0,0)', 0);
        //     gradient.addColorStop(0, primaryColorWithAlpha);
        //     gradient.addColorStop(this.settings.gradientMidpoint || 0.5, accentColorWithAlpha);
        //     gradient.addColorStop(1, backgroundColorWithAlpha);
        //     this.ctx.fillStyle = gradient;
        //     this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        // }
    }

    onResize(newWidth, newHeight) { 
        console.log("[Nebula] Resized to", newWidth, newHeight, ", regenerating nebula background.");
        // Проверяем, что размеры ненулевые перед перегенерацией
        if (newWidth > 0 && newHeight > 0) {
             this._generateNebulaBackground();
        }
        // Переинициализируем звезды, т.к. их позиции зависят от размеров канваса
        this._initNebula();
    }

    dispose() {
        this.stars = [];
        this.ctx = null;
        this.canvas = null;
        this.analyserNodeRef = null;
        console.log("[NebulaRenderer] Disposed.");
    }
}

// Self-registration
if (typeof visualizer !== 'undefined' && typeof visualizer.registerRenderer === 'function') {
    visualizer.registerRenderer('NebulaRenderer', NebulaRenderer);
} else {
    window.NebulaRenderer = NebulaRenderer;
    console.warn('[NebulaRenderer] Registered globally as visualizer object was not available at load time.');
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\visualizers\particlesRenderer.js
class SchoolOfFishRenderer {
    constructor() {
        this.ctx = null;
        this.canvas = null;
        this.settings = {};
        this.themeColors = {};
        this.globalVisualizerRef = null;
        this.analyserNodeRef = null;
        this.fish = [];
    }

    init(ctx, canvas, initialSettings, themeColors, globalVisualizerRef, analyserNodeRef) {
        this.ctx = ctx;
        this.canvas = canvas;
        this.settings = initialSettings || {};
        this.themeColors = themeColors || {};
        this.globalVisualizerRef = globalVisualizerRef;
        this.analyserNodeRef = analyserNodeRef;
        this.fish = [];
        this._initFish();
        console.log("[SchoolOfFishRenderer] Initialized with settings:", this.settings);
    }

    _getRandomColor() {
        const palette = this.settings.particleColors || [
            '#fffbe6', '#ffe0b2', '#b3e5fc', '#ffd180', '#ff8a80', '#b388ff', '#69f0ae', '#ffd54f', '#ff5252', '#40c4ff'
        ];
        return palette[Math.floor(Math.random() * palette.length)];
    }

    _applyBoidsPhysics(activeTouchStates) {
        const boids = this.fish;
        const width = this.canvas.width;
        const height = this.canvas.height;
        const neighborDist = 60;
        const separationDist = 18;
        const maxSpeed = 8.0;
        const maxForce = 0.5;
        const alignmentWeight = 1.0;
        const cohesionWeight = 0.7;
        const separationWeight = 1.5;
        const fearWeight = 40.0;
        const fearRadius = 180;
        const killRadius = 32;
        let toRemove = new Set();
        if (!this._touchOnFishFrames) this._touchOnFishFrames = {};
        for (let i = 0; i < boids.length; i++) {
            let b = boids[i];
            let steerAlign = {x:0, y:0}, steerCohesion = {x:0, y:0}, steerSeparation = {x:0, y:0};
            let countAlign = 0, countCohesion = 0, countSeparation = 0;
            for (let j = 0; j < boids.length; j++) {
                if (i === j) continue;
                let other = boids[j];
                let dx = other.x - b.x;
                let dy = other.y - b.y;
                if (dx > width/2) dx -= width;
                if (dx < -width/2) dx += width;
                if (dy > height/2) dy -= height;
                if (dy < -height/2) dy += height;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < neighborDist) {
                    steerAlign.x += other.vx;
                    steerAlign.y += other.vy;
                    countAlign++;
                    steerCohesion.x += other.x;
                    steerCohesion.y += other.y;
                    countCohesion++;
                }
                if (dist < separationDist) {
                    steerSeparation.x -= (other.x - b.x) / (dist+0.1);
                    steerSeparation.y -= (other.y - b.y) / (dist+0.1);
                    countSeparation++;
                }
            }
            if (countAlign > 0) {
                steerAlign.x /= countAlign;
                steerAlign.y /= countAlign;
                let mag = Math.sqrt(steerAlign.x*steerAlign.x + steerAlign.y*steerAlign.y);
                if (mag > 0) {
                    steerAlign.x = (steerAlign.x / mag) * maxSpeed - b.vx;
                    steerAlign.y = (steerAlign.y / mag) * maxSpeed - b.vy;
                }
            }
            if (countCohesion > 0) {
                steerCohesion.x = (steerCohesion.x / countCohesion) - b.x;
                steerCohesion.y = (steerCohesion.y / countCohesion) - b.y;
                let mag = Math.sqrt(steerCohesion.x*steerCohesion.x + steerCohesion.y*steerCohesion.y);
                if (mag > 0) {
                    steerCohesion.x = (steerCohesion.x / mag) * maxSpeed - b.vx;
                    steerCohesion.y = (steerCohesion.y / mag) * maxSpeed - b.vy;
                }
            }
            if (countSeparation > 0) {
                steerSeparation.x /= countSeparation;
                steerSeparation.y /= countSeparation;
                let mag = Math.sqrt(steerSeparation.x*steerSeparation.x + steerSeparation.y*steerSeparation.y);
                if (mag > 0) {
                    steerSeparation.x = (steerSeparation.x / mag) * maxSpeed - b.vx;
                    steerSeparation.y = (steerSeparation.y / mag) * maxSpeed - b.vy;
                }
            }
            let ax = 0, ay = 0;
            ax += steerAlign.x * alignmentWeight;
            ay += steerAlign.y * alignmentWeight;
            ax += steerCohesion.x * cohesionWeight;
            ay += steerCohesion.y * cohesionWeight;
            ax += steerSeparation.x * separationWeight;
            ay += steerSeparation.y * separationWeight;
            let fishTouched = false;
            if (activeTouchStates && activeTouchStates.length > 0) {
                for (const touch of activeTouchStates) {
                    let tx = touch.x * width;
                    let ty = touch.y * height;
                    let dx = b.x - tx;
                    let dy = b.y - ty;
                    if (dx > width/2) dx -= width;
                    if (dx < -width/2) dx += width;
                    if (dy > height/2) dy -= height;
                    if (dy < -height/2) dy += height;
                    let dist = Math.sqrt(dx*dx + dy*dy) + 1;
                    if (dist < killRadius) {
                        fishTouched = true;
                    } else if (dist < fearRadius) {
                        b.scaredTimer = 60;
                        let vAway = maxSpeed * 1.2;
                        b.vx = (dx / dist) * vAway;
                        b.vy = (dy / dist) * vAway;
                    }
                    if (b.scaredTimer && b.scaredTimer > 0) {
                        let force = fearWeight * (1 / (dist * dist)) * 2000;
                        ax += (dx / dist) * force;
                        ay += (dy / dist) * force;
                    }
                }
            }
            if (fishTouched) {
                this._touchOnFishFrames[i] = (this._touchOnFishFrames[i] || 0) + 1;
                if (this._touchOnFishFrames[i] >= 2) {
                    toRemove.add(i);
                }
            } else {
                this._touchOnFishFrames[i] = 0;
            }
            let amag = Math.sqrt(ax*ax + ay*ay);
            if (amag > maxForce) {
                ax = (ax / amag) * maxForce;
                ay = (ay / amag) * maxForce;
            }
            b.vx += ax;
            b.vy += ay;
            let vmag = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
            if (vmag > maxSpeed) {
                b.vx = (b.vx / vmag) * maxSpeed;
                b.vy = (b.vy / vmag) * maxSpeed;
            }
        }
        if (toRemove.size > 0) {
            this.fish = this.fish.filter((_, idx) => !toRemove.has(idx));
        }
    }

    _initFish() {
        if (!this.canvas || this.canvas.width === 0 || this.canvas.height === 0) return;
        this.fish = [];
        const maxFish = this.settings.count || 100;
        const minRadius = this.settings.minRadius || 1;
        const maxRadius = this.settings.maxRadius || 3;
        for (let i = 0; i < maxFish; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1.2 + Math.random() * 0.5;
            this.fish.push({
                x: Math.random() * this.canvas.width,
                y: Math.random() * this.canvas.height,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius: Math.random() * (maxRadius - minRadius) + minRadius,
                color: this._getRandomColor(),
                baseAlpha: Math.random() * 0.5 + 0.2
            });
        }
    }

    onThemeChange(themeColors) {
        this.themeColors = themeColors;
    }

    onSettingsChange(newSettings) {
        const oldCount = this.settings.count;
        this.settings = { ...this.settings, ...newSettings };
        if (this.settings.count !== oldCount) {
            this._initFish(); // Re-initialize if count changes
        }
    }

    draw(audioData, activeTouchStates) {
        if (!this.ctx || !this.canvas || this.fish.length === 0) return;
        this._applyBoidsPhysics(activeTouchStates);
        for (let p of this.fish) {
            p.x += p.vx;
            p.y += p.vy;
            if (p.scaredTimer && p.scaredTimer > 0) {
                let bounced = false;
                if (p.x < 0) { p.x = 0; p.vx = Math.abs(p.vx); bounced = true; }
                if (p.x > this.canvas.width) { p.x = this.canvas.width; p.vx = -Math.abs(p.vx); bounced = true; }
                if (p.y < 0) { p.y = 0; p.vy = Math.abs(p.vy); bounced = true; }
                if (p.y > this.canvas.height) { p.y = this.canvas.height; p.vy = -Math.abs(p.vy); bounced = true; }
                if (bounced) {
                    const angle = Math.atan2(p.vy, p.vx);
                    const delta = (Math.random() - 0.5) * (Math.PI / 4);
                    const speed = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
                    const newAngle = angle + delta;
                    p.vx = Math.cos(newAngle) * speed;
                    p.vy = Math.sin(newAngle) * speed;
                    const cx = this.canvas.width / 2;
                    const cy = this.canvas.height / 2;
                    const dx = cx - p.x;
                    const dy = cy - p.y;
                    const dist = Math.sqrt(dx*dx + dy*dy) + 1;
                    p.vx += (dx / dist) * 1.5;
                    p.vy += (dy / dist) * 1.5;
                }
            } else {
                if (p.x < 0) p.x += this.canvas.width;
                if (p.x > this.canvas.width) p.x -= this.canvas.width;
                if (p.y < 0) p.y += this.canvas.height;
                if (p.y > this.canvas.height) p.y -= this.canvas.height;
            }
            if (p.scaredTimer && p.scaredTimer > 0) p.scaredTimer--;
        }
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        for (let p of this.fish) {
            this.ctx.save();
            this.ctx.translate(p.x, p.y);
            const angle = Math.atan2(p.vy, p.vx);
            this.ctx.rotate(angle);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, p.radius * 1.5, p.radius * 0.7, 0, 0, Math.PI * 2);
            const alpha = Math.min(1, p.baseAlpha);
            this.ctx.fillStyle = this.globalVisualizerRef.getColorWithAlpha(p.color, alpha);
            this.ctx.shadowColor = p.color;
            this.ctx.shadowBlur = 8;
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
            this.ctx.restore();
        }
    }
    dispose() {
        this.fish = [];
        this.ctx = null;
        this.canvas = null;
        this.analyserNodeRef = null;
        console.log("[SchoolOfFishRenderer] Disposed.");
    }
}

// Self-registration
if (typeof visualizer !== 'undefined' && typeof visualizer.registerRenderer === 'function') {
    visualizer.registerRenderer('SchoolOfFishRenderer', SchoolOfFishRenderer);
} else {
    window.SchoolOfFishRenderer = SchoolOfFishRenderer;
    console.warn('[SchoolOfFishRenderer] Registered globally as visualizer object was not available at load time.');
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\visualizers\reactiveRipplesRenderer.js
class ReactiveRipplesRenderer {
    constructor() {
        this.ctx = null;
        this.canvas = null;
        this.settings = {};
        this.themeColors = {};
        this.globalVisualizerRef = null;
        this.analyserNodeRef = null;
        this.ripples = [];
    }

    init(ctx, canvas, initialSettings, themeColors, globalVisualizerRef, analyserNodeRef) {
        this.ctx = ctx;
        this.canvas = canvas;
        this.settings = initialSettings || {};
        this.themeColors = themeColors || {};
        this.globalVisualizerRef = globalVisualizerRef;
        this.analyserNodeRef = analyserNodeRef;
        this.ripples = [];
        console.log("[ReactiveRipplesRenderer] Initialized with settings:", this.settings);
    }

    onThemeChange(themeColors) {
        this.themeColors = themeColors;
    }

    onSettingsChange(newSettings) {
        this.settings = { ...this.settings, ...newSettings };
    }

    draw(audioData, activeTouchStates) {
        if (!this.ctx || !this.canvas) return;

        let energy = 0;
        if (audioData && this.analyserNodeRef) {
            if (this.analyserNodeRef.type === 'waveform' && audioData instanceof Float32Array) {
                energy = audioData.reduce((sum, val) => sum + Math.abs(val), 0) / audioData.length;
            } else if (this.analyserNodeRef.type === 'fft' && audioData instanceof Float32Array) {
                const minDb = this.analyserNodeRef.minDecibels ?? -100;
                const dbRange = (this.analyserNodeRef.maxDecibels ?? -30) - minDb;
                if (dbRange > 0) {
                    const dbSum = audioData.reduce((sum, val) => sum + Math.max(0, (val - minDb) / dbRange), 0);
                    energy = Math.min(1, dbSum / (audioData.length * 0.7));
                }
            }
        }

        const intensity = Math.min(1, energy * (this.settings.energyMultiplier || 3));
        const baseOpacity = this.settings.opacity || 0.5;

        if (!this.globalVisualizerRef || typeof this.globalVisualizerRef.getColorWithAlpha !== 'function') {
            console.error("[ReactiveRipplesRenderer] globalVisualizerRef.getColorWithAlpha is not available");
            return;
        }

        // Обработка активных касаний
        if (this.settings.reactToTouches && activeTouchStates && activeTouchStates.length > 0) {
            activeTouchStates.forEach(touch => {
                this.ripples.push({
                    x: touch.x * this.canvas.width,
                    y: (1 - touch.y) * this.canvas.height,
                    radius: 0,
                    maxRadius: this.settings.rippleMaxRadius || 100,
                    startTime: performance.now(),
                    duration: this.settings.rippleDuration || 1000,
                    color: this.settings.rippleColor || this.themeColors.primary
                });
            });
        }

        // Отрисовка и обновление ряби
        const now = performance.now();
        this.ripples = this.ripples.filter(ripple => {
            const elapsed = now - ripple.startTime;
            if (elapsed >= ripple.duration) return false;

            const progress = elapsed / ripple.duration;
            const currentRadius = ripple.maxRadius * progress;
            const alpha = baseOpacity * (1 - progress);

            this.ctx.beginPath();
            this.ctx.arc(ripple.x, ripple.y, currentRadius, 0, Math.PI * 2);
            this.ctx.strokeStyle = this.globalVisualizerRef.getColorWithAlpha(ripple.color, alpha);
            this.ctx.lineWidth = this.settings.rippleLineWidth || 2;
            this.ctx.stroke();

            return true;
        });

        // Автоматическое создание ряби при наличии аудио
        if (this.settings.reactToAudio && intensity > 0.1) {
            const centerX = this.canvas.width / 2;
            const centerY = this.canvas.height / 2;
            this.ripples.push({
                x: centerX,
                y: centerY,
                radius: 0,
                maxRadius: this.settings.rippleMaxRadius * (1 + intensity),
                startTime: now,
                duration: this.settings.rippleDuration * (1 - intensity * 0.5),
                color: this.settings.rippleColor || this.themeColors.primary
            });
        }
    }

    dispose() {
        this.ripples = [];
        this.ctx = null;
        this.canvas = null;
        this.analyserNodeRef = null;
        console.log("[ReactiveRipplesRenderer] Disposed.");
    }
}

// Self-registration
if (typeof visualizer !== 'undefined' && typeof visualizer.registerRenderer === 'function') {
    visualizer.registerRenderer('ReactiveRipplesRenderer', ReactiveRipplesRenderer);
} else {
    window.ReactiveRipplesRenderer = ReactiveRipplesRenderer;
    console.warn('[ReactiveRipplesRenderer] Registered globally as visualizer object was not available at load time.');
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\visualizers\spectrumRenderer.js
class SpectrumRenderer {
    constructor() {
        this.ctx = null;
        this.canvas = null;
        this.settings = {};
        this.themeColors = {};
        this.globalVisualizerRef = null;
        this.analyserNodeRef = null;
        this.particles = [];
        this.lastSpawn = 0;
    }

    init(ctx, canvas, initialSettings, themeColors, globalVisualizerRef, analyserNodeRef) {
        this.ctx = ctx;
        this.canvas = canvas;
        this.settings = initialSettings || {};
        this.themeColors = themeColors || {};
        this.globalVisualizerRef = globalVisualizerRef;
        this.analyserNodeRef = analyserNodeRef;
        this.particles = [];
        this.lastSpawn = 0;
        console.log("[SpectrumRenderer] Initialized with settings:", this.settings);
    }

    onThemeChange(themeColors) {
        this.themeColors = themeColors;
    }

    onSettingsChange(newSettings) {
        this.settings = { ...this.settings, ...newSettings };
    }

    _getBackgroundGradient() {
        const ctx = this.ctx;
        const w = this.canvas.width, h = this.canvas.height;
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, this.themeColors.background || '#181c2a');
        grad.addColorStop(1, this.themeColors.primary || '#23234a');
        return grad;
    }

    _getParticleGradient(x, y, r, touchColors) {
        const ctx = this.ctx;
        const grad = ctx.createRadialGradient(x, y, 0, x, y, r);
        if (touchColors && touchColors.length > 1) {
            for (let i = 0; i < touchColors.length; i++) {
                grad.addColorStop(i / (touchColors.length - 1), touchColors[i]);
            }
        } else if (touchColors && touchColors.length === 1) {
            grad.addColorStop(0, touchColors[0]);
            grad.addColorStop(1, this.themeColors.accent || '#fffbe6');
        } else {
            grad.addColorStop(0, this.themeColors.primary || '#69f0ae');
            grad.addColorStop(1, this.themeColors.accent || '#b388ff');
        }
        return grad;
    }

    draw(audioData, activeTouchStates) {
        if (!this.ctx || !this.canvas || !this.analyserNodeRef) return;
        if (!(audioData instanceof Float32Array) || audioData.length === 0) return;
        // === ФОН ===
        this.ctx.globalAlpha = 1.0;
        this.ctx.fillStyle = this._getBackgroundGradient();
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        // === Fade trails ===
        this.ctx.globalAlpha = 0.18;
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.globalAlpha = 1.0;
        // === Цвета для нот/касаний ===
        let noteColors = [];
        if (activeTouchStates && activeTouchStates.length > 0) {
            for (const t of activeTouchStates) {
                if (t.noteInfo && t.noteInfo.color) {
                    noteColors.push(t.noteInfo.color);
                } else if (this.themeColors.accent) {
                    noteColors.push(this.themeColors.accent);
                }
            }
        }
        if (noteColors.length === 0) {
            noteColors = [this.themeColors.primary || '#69f0ae', this.themeColors.accent || '#b388ff'];
        }
        // === Генерация новых частиц ===
        const downsample = 4;
        const bufferLength = Math.floor(audioData.length / downsample);
        const minDb = this.analyserNodeRef.minDecibels ?? -100;
        const maxDb = this.analyserNodeRef.maxDecibels ?? -30;
        const dbRange = maxDb - minDb;
        let zoneCount = noteColors.length;
        let zoneWidth = Math.floor(bufferLength / zoneCount);
        for (let i = 0; i < bufferLength; i++) {
            const srcIdx = i * downsample;
            const dbValue = audioData[srcIdx];
            const normalized = dbRange > 0 ? Math.max(0, Math.min(1, (dbValue - minDb) / dbRange)) : 0;
            if (normalized > 0.18 && Math.random() < normalized * 0.7) {
                const x = (i + 0.5) * (this.canvas.width / bufferLength) + (Math.random() - 0.5) * 4;
                const y = this.canvas.height + 2;
                let zoneIdx = Math.min(zoneCount - 1, Math.floor(i / zoneWidth));
                let color = noteColors[zoneIdx];
                const r = 2 + normalized * 3 + Math.random() * 1.2;
                const g = 0.38 + 0.12 * Math.random();
                const maxHeight = this.canvas.height * (0.25 + 0.65 * normalized);
                const v0 = -Math.sqrt(2 * g * maxHeight);
                // Для вспышки на пике
                const willFlash = Math.random() < 0.04 && normalized > 0.7;
                this.particles.push({
                    x, y, r,
                    vy: v0,
                    g,
                    alpha: 0.9,
                    color,
                    life: 0,
                    maxLife: (-v0) / g,
                    flash: willFlash,
                    flashed: false
                });
            }
        }
        // === Анимация и удаление частиц ===
        const dt = 1 / 60;
        let nextParticles = [];
        for (let p of this.particles) {
            p.y += p.vy;
            p.vy += p.g;
            p.life += dt;
            // Альфа линейно убывает к моменту достижения вершины
            p.alpha = Math.max(0, 1 - p.life / p.maxLife);
            // === Вспышка на пике ===
            if (p.flash && !p.flashed && p.life > p.maxLife * 0.95) {
                p.alpha = 1.0;
                p.r *= 1.7;
                p.flashed = true;
            }
            if (p.y < -10 || p.y > this.canvas.height + 10 || p.alpha < 0.05 || p.life > p.maxLife) continue;
            nextParticles.push(p);
        }
        this.particles = nextParticles.slice(-500);
        // === Отрисовка частиц ===
        const now = performance.now() / 1000;
        for (let p of this.particles) {
            // === Пульсация радиуса ===
            const pulse = 0.85 + 0.18 * Math.sin(now * 3 + p.x * 0.01 + p.life * 6);
            let drawR = p.r * pulse;
            // === Градиент цвета по высоте ===
            let grad = this.ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, drawR);
            grad.addColorStop(0, p.color);
            grad.addColorStop(1, '#fffbe6');
            this.ctx.save();
            this.ctx.globalAlpha = p.alpha;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, drawR, 0, Math.PI * 2);
            this.ctx.fillStyle = grad;
            this.ctx.shadowColor = p.color;
            this.ctx.shadowBlur = 8;
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
            this.ctx.restore();
        }
    }

    dispose() {
        this.ctx = null;
        this.canvas = null;
        console.log("[SpectrumRenderer] Disposed.");
    }
}

// Self-registration
if (typeof visualizer !== 'undefined' && typeof visualizer.registerRenderer === 'function') {
    visualizer.registerRenderer('SpectrumRenderer', SpectrumRenderer);
} else {
    window.SpectrumRenderer = SpectrumRenderer;
    console.warn('[SpectrumRenderer] Registered globally as visualizer object was not available at load time.');
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\visualizers\touchTrailsRenderer.js
class TouchTrailsRenderer {
    constructor() {
        this.ctx = null;
        this.canvas = null;
        this.settings = {};
        this.themeColors = {};
        this.globalVisualizerRef = null;
        this.analyserNodeRef = null;
        this.touchHistories = new Map(); // Map для хранения истории касаний
    }

    init(ctx, canvas, initialSettings, themeColors, globalVisualizerRef, analyserNodeRef) {
        this.ctx = ctx;
        this.canvas = canvas;
        this.settings = initialSettings || {};
        this.themeColors = themeColors || {};
        this.globalVisualizerRef = globalVisualizerRef;
        this.analyserNodeRef = analyserNodeRef;
        this.touchHistories.clear();
        console.log("[TouchTrailsRenderer] Initialized with settings:", this.settings);
    }

    onThemeChange(themeColors) {
        this.themeColors = themeColors;
    }

    onSettingsChange(newSettings) {
        this.settings = { ...this.settings, ...newSettings };
    }

    draw(audioData, activeTouchStates) {
        if (!this.ctx || !this.canvas) return;

        let energy = 0;
        if (audioData && this.analyserNodeRef) {
            if (this.analyserNodeRef.type === 'waveform' && audioData instanceof Float32Array) {
                energy = audioData.reduce((sum, val) => sum + Math.abs(val), 0) / audioData.length;
            } else if (this.analyserNodeRef.type === 'fft' && audioData instanceof Float32Array) {
                const minDb = this.analyserNodeRef.minDecibels ?? -100;
                const dbRange = (this.analyserNodeRef.maxDecibels ?? -30) - minDb;
                if (dbRange > 0) {
                    const dbSum = audioData.reduce((sum, val) => sum + Math.max(0, (val - minDb) / dbRange), 0);
                    energy = Math.min(1, dbSum / (audioData.length * 0.7));
                }
            }
        }

        const intensity = Math.min(1, energy * (this.settings.energyMultiplier || 3));
        const baseOpacity = this.settings.opacity || 0.7;

        if (!this.globalVisualizerRef || typeof this.globalVisualizerRef.getColorWithAlpha !== 'function') {
            console.error("[TouchTrailsRenderer] globalVisualizerRef.getColorWithAlpha is not available");
            return;
        }

        // Обновление истории касаний
        if (activeTouchStates && activeTouchStates.length > 0) {
            activeTouchStates.forEach(touch => {
                if (!this.touchHistories.has(touch.id)) {
                    this.touchHistories.set(touch.id, []);
                }
                const history = this.touchHistories.get(touch.id);
                history.push({
                    x: touch.x * this.canvas.width,
                    y: (1 - touch.y) * this.canvas.height,
                    time: performance.now(),
                    noteInfo: touch.noteInfo
                });
                // Ограничиваем длину истории
                const maxLength = this.settings.trailLength || 15;
                if (history.length > maxLength) {
                    history.shift();
                }
            });
        }

        // Отрисовка трейлов
        this.touchHistories.forEach((history, touchId) => {
            if (history.length < 2) return;

            let color = this.themeColors.primary;
            if (this.settings.trailColorSource === 'accent') {
                color = this.themeColors.accent;
            } else if (this.settings.trailColorSource === 'note' && history[history.length - 1].noteInfo?.midiNote !== undefined) {
                const noteIndex = history[history.length - 1].noteInfo.midiNote % 12;
                const defaultNoteColors = { 0: '#FF0000', 1: '#FF4500', 2: '#FFA500', 3: '#FFD700', 4: '#FFFF00', 5: '#9ACD32', 6: '#32CD32', 7: '#00BFFF', 8: '#0000FF', 9: '#8A2BE2', 10: '#FF00FF', 11: '#FF1493' };
                color = defaultNoteColors[noteIndex] || this.themeColors.primary;
            }

            this.ctx.beginPath();
            this.ctx.moveTo(history[0].x, history[0].y);

            for (let i = 1; i < history.length; i++) {
                const point = history[i];
                const prevPoint = history[i - 1];
                const progress = i / (history.length - 1);
                const width = this.settings.trailBaseWidth * (1 + progress * (this.settings.trailWidthMultiplierY || 2));
                const alpha = baseOpacity * (1 - progress) * (1 + intensity * (this.settings.audioReactivity?.opacityMultiplier || 1));

                this.ctx.strokeStyle = this.globalVisualizerRef.getColorWithAlpha(color, alpha);
                this.ctx.lineWidth = width;
                this.ctx.lineTo(point.x, point.y);
            }

            this.ctx.stroke();
        });

        // Очистка старых трейлов
        const now = performance.now();
        this.touchHistories.forEach((history, touchId) => {
            const lastPoint = history[history.length - 1];
            if (now - lastPoint.time > (this.settings.trailDuration || 1000)) {
                this.touchHistories.delete(touchId);
            }
        });
    }

    dispose() {
        this.touchHistories.clear();
        this.ctx = null;
        this.canvas = null;
        this.analyserNodeRef = null;
        console.log("[TouchTrailsRenderer] Disposed.");
    }
}

// Self-registration
if (typeof visualizer !== 'undefined' && typeof visualizer.registerRenderer === 'function') {
    visualizer.registerRenderer('TouchTrailsRenderer', TouchTrailsRenderer);
} else {
    window.TouchTrailsRenderer = TouchTrailsRenderer;
    console.warn('[TouchTrailsRenderer] Registered globally as visualizer object was not available at load time.');
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\visualizers\wavesRenderer.js
class WavesRenderer {
    constructor() {
        this.ctx = null;
        this.canvas = null;
        this.settings = {};
        this.themeColors = {};
        this.globalVisualizerRef = null; // Ссылка на основной объект visualizer
    }

    init(ctx, canvas, initialSettings, themeColors, globalVisualizerRef) {
        this.ctx = ctx;
        this.canvas = canvas;
        this.settings = initialSettings || {};
        this.themeColors = themeColors || {};
        this.globalVisualizerRef = globalVisualizerRef;
        console.log("[WavesRenderer] Initialized with settings:", this.settings);
    }

    onThemeChange(themeColors) {
        this.themeColors = themeColors;
    }

    onSettingsChange(newSettings) {
        this.settings = { ...this.settings, ...newSettings };
    }

    draw(audioData, activeTouchStates) {
        if (!this.ctx || !this.canvas) return;
        if (!(audioData instanceof Float32Array) || audioData.length === 0) {
            return;
        }

        const bufferLength = audioData.length;
        const sliceWidth = this.canvas.width / bufferLength;
        let x = 0;

        this.ctx.lineWidth = this.settings.lineWidth || 2;
        const opacity = this.settings.opacity || 0.7;
        let strokeColor = this.themeColors.primary || 'blue';

        if (this.settings.reactToTouches && activeTouchStates && activeTouchStates.length > 0) {
            const colorSource = this.settings.touchColorSource || 'note';
            const lastTouch = activeTouchStates[activeTouchStates.length - 1];
            if (colorSource === 'note' && lastTouch.noteInfo?.midiNote !== undefined) {
                const noteIndex = lastTouch.noteInfo.midiNote % 12;
                const defaultNoteColors = { 0: '#FF0000', 1: '#FF4500', 2: '#FFA500', 3: '#FFD700', 4: '#FFFF00', 5: '#9ACD32', 6: '#32CD32', 7: '#00BFFF', 8: '#0000FF', 9: '#8A2BE2', 10: '#FF00FF', 11: '#FF1493' };
                strokeColor = defaultNoteColors[noteIndex] || this.themeColors.primary;
            } else if (this.settings.lineColor === 'accent') {
                strokeColor = this.themeColors.accent || 'red';
            }
        } else if (this.settings.lineColor === 'accent') {
            strokeColor = this.themeColors.accent || 'red';
        }
        
        if (!this.globalVisualizerRef || typeof this.globalVisualizerRef.getColorWithAlpha !== 'function') {
            console.error("[WavesRenderer] globalVisualizerRef.getColorWithAlpha is not available");
            return;
        }

        this.ctx.strokeStyle = this.globalVisualizerRef.getColorWithAlpha(strokeColor, opacity);

        this.ctx.beginPath();
        this.ctx.moveTo(0, this.canvas.height / 2);

        for (let i = 0; i < bufferLength; i++) {
            const v = audioData[i];
            const y = (v * 0.5 + 0.5) * this.canvas.height;
            this.ctx.lineTo(x, y);
            x += sliceWidth;
        }
        this.ctx.lineTo(this.canvas.width, this.canvas.height / 2);
        this.ctx.stroke();

        if (this.settings.fill) {
            const fillColor = this.settings.fillColor === 'accent' ? (this.themeColors.accent || 'red') : strokeColor;
            const fillAlpha = this.settings.fillAlpha || 0.1;
            this.ctx.lineTo(this.canvas.width, this.canvas.height);
            this.ctx.lineTo(0, this.canvas.height);
            this.ctx.closePath();
            this.ctx.fillStyle = this.globalVisualizerRef.getColorWithAlpha(fillColor, fillAlpha);
            this.ctx.fill();
        }
    }

    dispose() {
        this.ctx = null;
        this.canvas = null;
        console.log("[WavesRenderer] Disposed.");
    }
}

// Self-registration
if (typeof visualizer !== 'undefined' && typeof visualizer.registerRenderer === 'function') {
    visualizer.registerRenderer('WavesRenderer', WavesRenderer);
} else {
    window.WavesRenderer = WavesRenderer;
    console.warn('[WavesRenderer] Registered globally as visualizer object was not available at load time.');
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\voiceBuilder.js
// Файл: app/src/main/assets/js/voiceBuilder.js
// Отвечает за построение цепочки аудио-узлов для одного голоса синтезатора,
// используя менеджеры компонентов из audioConfig.
// ВЕРСИЯ С ДОБАВЛЕНИЕМ LFO, FilterEnvelope, Portamento

const voiceBuilder = {

    /**
     * Строит полную аудио-цепочку для одного голоса на основе пресета.
     * Использует менеджеры компонентов для создания и соединения узлов.
     * @param {object} presetData - Полные данные пресета (включая вложенные объекты для компонентов).
     * @returns {{ components: object, errorState: object } | null} - Объект с компонентами и их состоянием ошибки, или null при критической ошибке.
     *         `components` = { oscillator: { nodes, ... }, amplitudeEnv: { nodes, ... }, ... }
     *         `errorState` = { oscillator: null | string, amplitudeEnv: null | string, ... }
     */
    buildVoiceChain(presetData) {
        console.log("[VoiceBuilder v2] Building voice chain with preset:", presetData);
        const components = {};
        const errorState = {};
        const chainOrder = audioConfig.voiceAudioChainOrder;

        if (!chainOrder || chainOrder.length === 0) {
            console.error("[VoiceBuilder v2] voiceAudioChainOrder is empty in audioConfig! Cannot build chain.");
            return null;
        }

        // --- Шаг 1: Создание всех компонентов ---
        console.log("[VoiceBuilder v2] --- Creating Components ---");
        const componentIdsToCreate = new Set(chainOrder);

        // Добавляем опциональные компоненты, если они включены в пресете
        if (presetData.pitchEnvelope?.enabled) componentIdsToCreate.add('pitchEnvelope');
        if (presetData.filterEnvelope?.enabled) componentIdsToCreate.add('filterEnvelope'); // Новый
        if (presetData.lfo1?.enabled) componentIdsToCreate.add('lfo1'); // Новый (пример ID)
        // Добавить другие LFO (lfo2, etc.) или VoiceFX по аналогии

        for (const componentId of componentIdsToCreate) {
            const manager = audioConfig.getManager(componentId);
            if (componentId === 'filterEnvelope') {
                console.log(`[VoiceBuilder DEBUG] Attempting to create 'filterEnvelope'. Manager found: ${!!manager}, manager.create is func: ${typeof manager?.create === 'function'}`);
                console.log(`[VoiceBuilder DEBUG] Settings for 'filterEnvelope':`, JSON.parse(JSON.stringify(presetData[componentId]?.params || presetData[componentId] || {})));
            }
            if (!manager || typeof manager.create !== 'function') {
                console.error(`[VoiceBuilder v2] Manager not found or invalid for component ID: ${componentId}`);
                errorState[componentId] = `Manager not found or invalid for ${componentId}`;
                components[componentId] = { nodes: null, error: errorState[componentId] };
                continue;
            }

            const componentSettings = presetData[componentId]?.params || presetData[componentId] || {};
            if (presetData[componentId]?.hasOwnProperty('enabled')) {
                 componentSettings.enabled = presetData[componentId].enabled;
            }
            // Специальная обработка для Portamento (если он часть oscillator)
            if (componentId === 'oscillator' && presetData.portamento?.enabled && presetData.portamento.time !== undefined) {
                componentSettings.portamento = presetData.portamento.time;
            }


            console.log(`[VoiceBuilder v2] Creating component: ${componentId} with settings:`, componentSettings);
            try {
                const result = manager.create(componentSettings);
                components[componentId] = result;
                errorState[componentId] = result.error;
                if (componentId === 'filterEnvelope') {
                    // Безопасное логирование результата создания компонента
                    if (components[componentId]) {
                        const compResult = components[componentId];
                        console.log(`[VoiceBuilder DEBUG] Result for '${componentId}': error='${compResult.error}', hasNodes=${!!compResult.nodes}, hasModOutputs=${!!compResult.modOutputs}, modOutputsKeys=${compResult.modOutputs ? Object.keys(compResult.modOutputs).join(',') : 'N/A'}`);
                    } else {
                        console.warn(`[VoiceBuilder DEBUG] Component '${componentId}' was null/undefined after create attempt.`);
                    }
                }
                if (result.error) {
                    console.error(`[VoiceBuilder v2] Error creating component ${componentId}: ${result.error}`);
                } else {
                    console.log(`[VoiceBuilder v2] Component ${componentId} created successfully.`);
                }
            } catch (e) {
                console.error(`[VoiceBuilder v2] Critical error calling manager.create for ${componentId}:`, e);
                const errorMsg = `Critical error in manager.create for ${componentId}: ${e.message}`;
                components[componentId] = { nodes: null, error: errorMsg };
                errorState[componentId] = errorMsg;
            }
        }

        // --- Шаг 2: Соединение аудио-цепочки ---
        console.log("[VoiceBuilder v2] --- Connecting Audio Chain ---");
        let previousOutputNode = null;

        for (let i = 0; i < chainOrder.length; i++) {
            const componentId = chainOrder[i];
            const componentData = components[componentId];
            const manager = audioConfig.getManager(componentId);

            if (!componentData || componentData.error || !componentData.nodes) {
                console.warn(`[VoiceBuilder v2] Skipping connection for broken/missing component: ${componentId}`);
                continue;
            }

            if (previousOutputNode === null) {
                if (componentData.audioOutput) {
                    previousOutputNode = componentData.audioOutput;
                    console.log(`[VoiceBuilder v2] Chain starts with output of: ${componentId}`);
                } else {
                    console.warn(`[VoiceBuilder v2] First component ${componentId} has no audio output. Chain might be broken.`);
                }
                continue;
            }

            if (componentData.audioInput) {
                console.log(`[VoiceBuilder v2] Connecting output of previous node to input of: ${componentId}`);
                // Для основной цепочки используем прямое соединение, менеджер connectPeers здесь не нужен
                // менеджер connectPeers используется для внутренних соединений компонента, если они есть.
                try {
                    previousOutputNode.connect(componentData.audioInput);
                    console.log(`[VoiceBuilder v2] Connected: Previous -> ${componentId}.Input`);
                } catch (e) {
                    console.error(`[VoiceBuilder v2] Error connecting Previous -> ${componentId}.Input:`, e);
                    errorState[componentId] = `Connection error: ${e.message}`;
                    continue;
                }
            } else {
                 console.log(`[VoiceBuilder v2] Component ${componentId} has no audio input. Skipping input connection.`);
            }

            if (componentData.audioOutput) {
                previousOutputNode = componentData.audioOutput;
                console.log(`[VoiceBuilder v2] Output for next connection is now from: ${componentId}`);
            } else {
                 console.log(`[VoiceBuilder v2] Component ${componentId} has no audio output. Previous output remains.`);
            }
        }

        // --- Шаг 3: Соединение модуляторов ---
        console.log("[VoiceBuilder v2] --- Connecting Modulators ---");

        for (const modId of audioConfig.modulatorComponents) {
            const modComp = components[modId];
            if (!presetData[modId]?.enabled || !modComp || modComp.error) {
                console.warn(`[VB ConnectMod] ${modId} is not enabled or has error. Skipping connection.`);
                continue;
            }
            // Определяем целевой компонент и параметр для подключения
            let targetInfo = null;
            if (modId === 'pitchEnvelope') {
                targetInfo = { comp: components['oscillator'], param: 'detune', manager: audioConfig.getManager('oscillator') };
            } else if (modId === 'filterEnvelope') {
                targetInfo = { comp: components['filter'], param: 'frequency', manager: audioConfig.getManager('filter') };
            } else if (modId === 'lfo1') {
                const lfoSettings = presetData.lfo1?.params;
                if (lfoSettings?.target) {
                    const [targetComponentId, targetParamName] = lfoSettings.target.split('.');
                    targetInfo = { comp: components[targetComponentId], param: targetParamName, manager: audioConfig.getManager(targetComponentId) };
                }
            }
            if (targetInfo && targetInfo.comp && !targetInfo.comp.error && targetInfo.manager?.connectModulator && modComp.modOutputs?.output && targetInfo.comp.modInputs?.[targetInfo.param]) {
                console.log(`[VoiceBuilder v2] Attempting to connect ${modId} -> ${targetInfo.comp ? targetInfo.comp : 'UNKNOWN'}.${targetInfo.param}`);
                if (!targetInfo.manager.connectModulator(targetInfo.comp.nodes, targetInfo.param, modComp.modOutputs.output)) {
                    console.error(`[VoiceBuilder v2] Failed to connect ${modId} to ${targetInfo.comp ? targetInfo.comp : 'UNKNOWN'}.${targetInfo.param}.`);
                    errorState[modId] = (errorState[modId] || "") + ` Failed to connect to ${targetInfo.comp ? targetInfo.comp : 'UNKNOWN'}.${targetInfo.param};`;
                }
            } else {
                console.warn(`[VB ConnectMod] ${modId} target not found or not connectable.`);
            }
        }

        // --- Финальная проверка ---
        if (!components.outputGain || components.outputGain.error) {
            console.error("[VoiceBuilder v2] Critical error: OutputGain component is missing or failed to create. Voice unusable.");
            this.disposeComponents(components);
            return null;
        }

        console.log("[VoiceBuilder v2] Voice chain build process completed.");
        return { components, errorState };
    },

    findParamByPath(components, pathString) {
        // ... (без изменений) ...
        if (!components || !pathString) return null;
        const parts = pathString.split('.');
        let target = null;
        let currentComponentId = null;
        try {
            currentComponentId = parts[0];
            const componentData = components[currentComponentId];
            if (!componentData || !componentData.nodes) return null;
            target = componentData.nodes;
            for (let i = 1; i < parts.length; i++) {
                const part = parts[i];
                if (target && target.hasOwnProperty(part)) {
                    target = target[part];
                } else {
                    target = null;
                    break;
                }
            }
            if (parts.length === 1 && target === componentData.nodes) {
                 console.warn(`[VoiceBuilder v2.findParamByPath] Path '${pathString}' points to the component nodes object, not a specific parameter.`);
                 return null;
            }
            return target;
        } catch (e) {
            console.error(`[VoiceBuilder v2.findParamByPath] Error accessing path '${pathString}':`, e);
            return null;
        }
    },

    disposeComponents(components) {
        // ... (без изменений) ...
        if (!components) return;
        console.log("[VoiceBuilder v2] Disposing voice components...");
        for (const componentId in components) {
            const componentData = components[componentId];
            const manager = audioConfig.getManager(componentId);
            if (manager && typeof manager.dispose === 'function' && componentData && componentData.nodes) {
                try {
                    console.log(`[VoiceBuilder v2] Disposing component: ${componentId}`);
                    manager.dispose(componentData.nodes);
                } catch (e) {
                    console.error(`[VoiceBuilder v2] Error disposing component ${componentId}:`, e);
                }
            } else if (componentData && componentData.nodes) {
                 console.warn(`[VoiceBuilder v2] Cannot dispose component ${componentId}: Manager or dispose method not found.`);
                 for (const nodeKey in componentData.nodes) {
                      const node = componentData.nodes[nodeKey];
                      if (node && typeof node.dispose === 'function') {
                           try { node.dispose(); } catch(e) {}
                      }
                 }
            }
        }
        console.log("[VoiceBuilder v2] Voice components disposal complete.");
    }
};

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\voiceManager.js

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\zonesManager_JS.js
// Файл: app/src/main/assets/js/zonesManager_JS.js
// JavaScript аналог ZonesManager для расчета зон XY-пада
const zonesManagerJS = {
    isInitialized: false,

    /**
     * Загружает данные о гаммах из модулей 'scale'.
     */
    async loadScales() {
        console.log("[ZonesManagerJS.loadScales] Loading available scale names...");
        this.availableScaleNames = []; // Очищаем
        try {
            const scaleModules = await moduleManager.getModules('scale', true);
            if (Array.isArray(scaleModules)) {
                scaleModules.forEach(mod => {
                    if (mod?.id && typeof mod.id === 'string') { // mod.id - это имя строя для Tonal.js
                        this.availableScaleNames.push(mod.id);
                    }
                });
                // Добавим стандартные, если их нет в модулях, на всякий случай
                ['major', 'minor', 'chromatic', 'pentatonic', 'blues'].forEach(stdScale => {
                    if (!this.availableScaleNames.includes(stdScale)) {
                        this.availableScaleNames.push(stdScale);
                    }
                });
                console.log(`[ZonesManagerJS.loadScales] Available scale names:`, this.availableScaleNames);
            } else {
                console.error("[ZonesManagerJS.loadScales] Failed to load scale modules.");
                this.availableScaleNames = ['major', 'minor', 'chromatic']; // Fallback
            }
        } catch (error) {
            console.error("[ZonesManagerJS.loadScales] Error loading scales:", error);
            this.availableScaleNames = ['major', 'minor', 'chromatic']; // Fallback
        }
        this.isInitialized = true;
    },

    /**
     * Рассчитывает зоны на основе текущего состояния app.state
     * @returns {Array<object>} - Массив объектов зон или пустой массив
     */
    async calculateZones() { // Делаем асинхронной, т.к. getNotesForScale асинхронный
        // ... (получение scaleIdToUse, octaveOffset, zoneCount из app.state как раньше) ...
        // ---> НОВОЕ: Получение тоники
        const { scale: scaleIdToUse = 'chromatic', octaveOffset = 0, zoneCount = 12 } = app.state; // Получаем из app.state
        const currentTonic = app.state.currentTonic || "C4"; // "C4" как дефолт

        console.log(`[ZonesManagerJS.calculateZones] Input - Tonic: ${currentTonic}, Scale: ${scaleIdToUse}, Offset: ${octaveOffset}, Count: ${zoneCount}`);

        if (!MusicTheoryService.isTonalJsLoaded) {
            console.error("[ZonesManagerJS.calculateZones] MusicTheoryService (Tonal.js) not available.");
            return [];
        }

        // Получаем одну октаву нот строя от заданной тоники
        // MusicTheoryService.getNotesForScale должен быть доработан, чтобы корректно обрабатывать это
        // и возвращать ноты с правильными октавами.
        // Например, Tonal.Scale.rangeOf(tonicPitchClass + " " + scaleName)(tonic, Tonal.Note.transpose(tonic, "P8"))
        // или Tonal.Mode.notes(scaleName, tonic) - но это даст только одну октаву
        console.log(`[ZonesManagerJS.calculateZones] Calling MusicTheoryService.getNotesForScale("${currentTonic}", "${scaleIdToUse}")`);
        const scaleNotesInfo = await MusicTheoryService.getNotesForScale(currentTonic, scaleIdToUse);
        console.log(`[ZonesManagerJS.calculateZones] MusicTheoryService.getNotesForScale result:`, scaleNotesInfo);

        if (!scaleNotesInfo || scaleNotesInfo.length === 0) {
            console.error("[ZMJSCalc] No notes from MusicTheoryService.");
            return [];
        }
        console.log("[ZMJSCalc] scaleNotesInfo from MTS:", JSON.parse(JSON.stringify(scaleNotesInfo)));

        const zones = [];
        const zoneWidth = 1.0 / zoneCount;

        for (let i = 0; i < zoneCount; i++) {
            // Простая логика для теста: берем ноты по кругу из полученного массива
            const noteIndexInScale = i % scaleNotesInfo.length;
            const baseNote = scaleNotesInfo[noteIndexInScale];
            const octaveShift = Math.floor(i / scaleNotesInfo.length); // Для смещения октав, если zoneCount > нот в строе

            // Нужно получить ПОЛНОЕ имя ноты с правильной октавой
            // Если baseNote уже содержит правильную октаву, это проще.
            // Если baseNote - это pitch class, нужно его комбинировать с октавой тоники + octaveShift
            // Предположим, baseNote уже содержит имя с начальной октавой.
            let currentNoteName = baseNote.name;
            if (octaveShift > 0) {
                // Tonal.Interval.fromSemitones expects an interval string like "12st" for 12 semitones (1 octave)
                // Need to handle potential errors if transpose fails
                try {
                     currentNoteName = Tonal.Note.transpose(baseNote.name, Tonal.Interval.fromSemitones(octaveShift * 12));
                } catch (e) {
                     console.error(`[ZMJSCalc] Error transposing note ${baseNote.name} by ${octaveShift} octaves:`, e);
                     currentNoteName = null; // Indicate failure
                }

            }
            const noteDetails = currentNoteName ? MusicTheoryService.getNoteDetails(currentNoteName) : null;

            if (noteDetails) {
                console.log(`[ZMJSCalc] Zone ${i}: MIDI=${noteDetails.midi}, Freq=${noteDetails.freq.toFixed(1)}, Name=${noteDetails.name}`);
                zones.push({
                    index: i,
                    startX: i * zoneWidth,
                    endX: (i + 1) * zoneWidth,
                    noteName: noteDetails.name,
                    frequency: noteDetails.freq,
                    midiNote: noteDetails.midi,
                    isSharpFlat: noteDetails.acc !== "" // или MusicTheoryService.isSharpOrFlat(noteDetails.name)
                });
            } else {
                console.warn(`[ZMJSCalc] Could not get details for note ${currentNoteName || 'derived name'} for zone ${i}. Original baseNote: ${baseNote.name}. Skipping zone ${i}.`);
            }
        }
        console.log(`[ZMJSCalc] Generated zones:`, JSON.parse(JSON.stringify(zones)));
        return zones;
    },

    // Методы midiToFrequency и midiToNoteName удалены.
};

// Инициализация вызывается из app.js
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\audioComponent\ampEnv.json
{
  "id": "amplitudeEnv",
  "type": "audioComponent",
  "name": "Amplitude Envelope",
  "version": "1.0.0",
  "description": "Controls the volume over time",
  "active": true,
  "managerScript": "js/managers/ampEnvManager.js",
  "category": "core",
  "isOptional": false,
  "parameters": [
    {"name": "attack", "label": "Attack", "min": 0.001, "max": 5, "default": 0.01, "step": 0.001, "logScale": true},
    {"name": "decay", "label": "Decay", "min": 0.001, "max": 5, "default": 0.1, "step": 0.001, "logScale": true},
    {"name": "sustain", "label": "Sustain", "min": 0, "max": 1, "default": 0.7, "step": 0.01},
    {"name": "release", "label": "Release", "min": 0.001, "max": 10, "default": 0.5, "step": 0.001, "logScale": true},
    {"name": "attackCurve", "label": "Attack Curve", "options": ["linear", "exponential", "sine", "cosine", "bounce", "ripple", "step"], "default": "linear"},
    {"name": "decayCurve", "label": "Decay Curve", "options": ["linear", "exponential"], "default": "exponential"},
    {"name": "releaseCurve", "label": "Release Curve", "options": ["linear", "exponential", "sine", "cosine", "bounce", "ripple", "step"], "default": "exponential"}
  ],
  "defaultSettings": {
    "attack": 0.01, "decay": 0.1, "sustain": 0.7, "release": 0.5,
    "attackCurve": "linear", "decayCurve": "exponential", "releaseCurve": "exponential"
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\audioComponent\filter.json
{
  "id": "filter",
  "type": "audioComponent",
  "name": "Filter",
  "version": "1.0.0",
  "description": "Shapes the sound spectrum",
  "active": true,
  "managerScript": "js/managers/filterManager.js",
  "category": "core",
  "isOptional": false,
  "parameters": [
    {"name": "frequency", "label": "Frequency", "min": 20, "max": 20000, "default": 5000, "step": 1, "logScale": true},
    {"name": "Q", "label": "Q / Resonance", "min": 0.01, "max": 20, "default": 1, "step": 0.01},
    {"name": "type", "label": "Type", "options": ["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "notch", "allpass", "peaking"], "default": "lowpass"},
    {"name": "rolloff", "label": "Rolloff", "options": [-12, -24, -48, -96], "default": -12},
    {"name": "gain", "label": "Gain (dB)", "min": -40, "max": 40, "default": 0, "step": 0.1}
  ],
  "defaultSettings": {
    "frequency": 5000, "Q": 1, "type": "lowpass", "rolloff": -12, "gain": 0
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\audioComponent\filterEnvelope.json
{
  "id": "filterEnvelope",
  "type": "audioComponent",
  "name": "Filter Envelope",
  "version": "1.0.0",
  "description": "Envelope for filter modulation",
  "active": true,
  "managerScript": "js/managers/filterEnvelopeManager.js",
  "category": "optionalModulator",
  "isOptional": true,
  "parameters": [
    {"name": "attack", "label": "Attack", "min": 0.001, "max": 5, "default": 0.1, "step": 0.001, "logScale": true},
    {"name": "decay", "label": "Decay", "min": 0.001, "max": 5, "default": 0.2, "step": 0.001, "logScale": true},
    {"name": "sustain", "label": "Sustain", "min": 0, "max": 1, "default": 0.5, "step": 0.01},
    {"name": "release", "label": "Release", "min": 0.001, "max": 10, "default": 0.5, "step": 0.001, "logScale": true},
    {"name": "amount", "label": "Amount (cents/ratio)", "min": -7200, "max": 7200, "default": 1200, "step": 10},
    {"name": "attackCurve", "label": "Attack Curve", "options": ["linear", "exponential", "sine", "cosine"], "default": "linear"}
  ],
  "defaultSettings": {
    "attack": 0.1, "decay": 0.2, "sustain": 0.5, "release": 0.5,
    "amount": 0, "attackCurve": "linear"
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\audioComponent\lfo1.json
{
  "id": "lfo1",
  "type": "audioComponent",
  "name": "LFO 1",
  "version": "1.0.0",
  "description": "Low Frequency Oscillator for modulation",
  "active": true,
  "managerScript": "js/managers/lfoManager.js",
  "category": "optionalModulator",
  "isOptional": true,
  "parameters": [
    {"name": "type", "label": "Type", "options": ["sine", "square", "sawtooth", "triangle", "pulse"], "default": "sine"},
    {"name": "rate", "label": "Rate (Hz)", "min": 0.01, "max": 50, "default": 5, "step": 0.01, "logScale": true},
    {"name": "depth", "label": "Depth", "min": 0, "max": 1, "default": 0.5, "step": 0.01},
    {"name": "phase", "label": "Phase", "min": 0, "max": 360, "default": 0, "step": 1},
    {"name": "target", "label": "Target", "options": [
      "oscillator.detune", "oscillator.frequency",
      "filter.frequency", "filter.Q",
      "amplitudeEnv.attack", "amplitudeEnv.release", "outputGain.gain"
    ], "default": "filter.frequency", "type": "string"},
    {"name": "retrigger", "label": "Retrigger", "type": "boolean", "default": false}
  ],
  "defaultSettings": {
    "type": "sine",
    "rate": 5,
    "depth": 0,
    "phase": 0,
    "target": "filter.frequency",
    "retrigger": false
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\audioComponent\oscillator.json
{
  "id": "oscillator",
  "type": "audioComponent",
  "name": "Oscillator",
  "version": "1.0.1",
  "description": "Core sound generator with portamento support",
  "active": true,
  "managerScript": "js/managers/oscillatorManager.js",
  "category": "core",
  "isOptional": false,
  "parameters": [
    {"name": "type", "label": "Type", "options": ["sine", "square", "sawtooth", "triangle", "pwm", "pulse", "fatsine", "fatsquare", "fatsawtooth", "fattriangle", "amsine", "amsquare", "amsawtooth", "amtriangle", "fmsine", "fmsquare", "fmsawtooth", "fmtriangle", "white", "pink", "brown"], "default": "triangle"},
    {"name": "phase", "label": "Phase", "min": 0, "max": 360, "default": 0, "step": 1},

    {"name": "portamento", "label": "Portamento", "min": 0, "max": 2, "default": 0, "step": 0.01},

    {"name": "width", "label": "Width (Pulse)", "min": 0, "max": 1, "default": 0.5, "step": 0.01},
    {"name": "modulationFrequency", "label": "Mod Freq (PWM)", "min": 0.1, "max": 20, "default": 0.5, "step": 0.1, "logScale": true},
    {"name": "harmonicity", "label": "Harmonicity (FM/AM)", "min": 0.1, "max": 10, "default": 1, "step": 0.01},
    {"name": "modulationIndex", "label": "Mod Index (FM)", "min": 0.1, "max": 100, "default": 10, "step": 0.1, "logScale": true},
    {"name": "modulationType", "label": "Mod Type (FM/AM)", "options": ["sine", "square", "sawtooth", "triangle"], "default": "square"},
    {"name": "count", "label": "Count (Fat)", "min": 1, "max": 8, "default": 3, "step": 1},
    {"name": "spread", "label": "Spread (Fat, cents)", "min": 0, "max": 100, "default": 20, "step": 1}
  ],
  "defaultSettings": {
    "type": "triangle",
    "phase": 0,
    "portamento": 0
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\audioComponent\outputGain.json
{
  "id": "outputGain",
  "type": "audioComponent",
  "name": "Output Gain",
  "version": "1.0.0",
  "description": "Final gain stage for the voice",
  "active": true,
  "managerScript": "js/managers/outputGainManager.js",
  "category": "core",
  "isOptional": false,
  "parameters": [
    {"name": "gain", "label": "Gain", "min": 0, "max": 1, "default": 0, "step": 0.01}
  ],
  "defaultSettings": {
    "gain": 0
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\effect\chorus.json
{
  "id": "chorus",
  "type": "effect",
  "name": "Chorus",
  "version": "1.0.0",
  "description": "A chorus effect for adding richness and depth",
  "active": true,
  "data": {
    "parameters": [
      {
        "name": "wet",
        "label": "Wet",
        "min": 0,
        "max": 1,
        "default": 0.3,
        "step": 0.01
      },
      {
        "name": "frequency",
        "label": "Frequency",
        "min": 0.1,
        "max": 10,
        "default": 4,
        "step": 0.1
      },
      {
        "name": "depth",
        "label": "Depth",
        "min": 0,
        "max": 1,
        "default": 0.7,
        "step": 0.01
      },
      {
        "name": "delayTime",
        "label": "Delay Time",
        "min": 2,
        "max": 20,
        "default": 3.5,
        "step": 0.1
      }
    ]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\effect\delay.json
{
  "id": "delay",
  "type": "effect",
  "name": "Delay",
  "version": "1.0.0",
  "description": "A feedback delay effect.",
  "active": true,
  "data": {
    "parameters": [
      { "name": "delayTime", "label": "Time", "min": 0.01, "max": 1.0, "default": 0.25, "step": 0.01 },
      { "name": "feedback", "label": "Feedback", "min": 0, "max": 0.95, "default": 0.5, "step": 0.01 },
      { "name": "wet", "label": "Mix", "min": 0, "max": 1, "default": 0.5, "step": 0.01 }

    ]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\effect\distortion.json
{
  "id": "distortion",
  "type": "effect",
  "name": "Distortion",
  "version": "1.0.0",
  "description": "A distortion effect.",
  "active": true,
  "data": {
    "parameters": [
      { "name": "distortion", "label": "Amount", "min": 0, "max": 1, "default": 0.4, "step": 0.01 },
      { "name": "wet", "label": "Mix", "min": 0, "max": 1, "default": 1.0, "step": 0.01 },
      { "name": "oversample", "label": "Oversample", "options": ["none", "2x", "4x"], "default": "none" }
    ]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\effect\filter.json
{
  "id": "filter",
  "type": "effect",
  "name": "Filter",
  "version": "1.0.0",
  "description": "A versatile filter effect for sound shaping",
  "active": true,
  "data": {
    "parameters": [
      {
        "name": "wet",
        "label": "Wet",
        "min": 0,
        "max": 1,
        "default": 0.5,
        "step": 0.01
      },
      {
        "name": "frequency",
        "label": "Frequency",
        "min": 20,
        "max": 20000,
        "default": 1000,
        "step": 1,
        "logScale": true
      },
      {
        "name": "Q",
        "label": "Q",
        "min": 0.1,
        "max": 10,
        "default": 1,
        "step": 0.1
      },
      {
        "name": "type",
        "label": "Type",
        "options": ["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "notch", "allpass", "peaking"],
        "default": "lowpass"
      },
      {
        "name": "gain",
        "label": "Gain",
        "min": -40,
        "max": 40,
        "default": 0,
        "step": 0.1
      },
      {
        "name": "rolloff",
        "label": "Rolloff",
        "options": [-12, -24, -48, -96],
        "default": -12
      }
    ]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\effect\reverb.json
{
  "id": "reverb",
  "type": "effect",
  "name": "Reverb",
  "version": "1.0.0",
  "description": "A spacious reverb effect",
  "active": true,
  "data": {
    "parameters": [
      {
        "name": "wet",
        "label": "Wet",
        "min": 0,
        "max": 1,
        "default": 0.3,
        "step": 0.01
      },
      {
        "name": "decay",
        "label": "Decay",
        "min": 0.1,
        "max": 10,
        "default": 3,
        "step": 0.1
      },
      {
        "name": "preDelay",
        "label": "PreDelay",
        "min": 0,
        "max": 0.2,
        "default": 0.01,
        "step": 0.01
      }
    ]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\fxchain\ambient_dreamscape.json
{
  "id": "ambient_dreamscape",
  "type": "fxchain",
  "name": "Ambient Dreamscape",
  "version": "1.0.0",
  "description": "Lush and spacious ambient textures with long reverb and evolving delays.",
  "active": false,
  "data": {
    "effects": [
      {
        "type": "delay",
        "enabled": true,
        "params": {
          "delayTime": 0.75,
          "feedback": 0.65,
          "wet": 0.55
        }
      },
      {
        "type": "reverb",
        "enabled": true,
        "params": {
          "roomSize": 0.9,
          "wet": 0.7
        }
      },
      {
        "type": "chorus",
        "enabled": true,
        "params": {
          "frequency": 0.2,
          "depth": 0.4,
          "delayTime": 7.5,
          "wet": 0.35
        }
      },
      {
        "type": "filter",
        "enabled": true,
        "params": {
          "type": "lowpass",
          "frequency": 6000,
          "Q": 0.7,
          "wet": 1.0
        }
      },
      {
        "type": "distortion",
        "enabled": false,
        "params": {
          "distortion": 0.1,
          "wet": 0
        }
      }
    ],
    "yAxisControls": {
      "volume": {
        "minOutput": 0.0,
        "maxOutput": 1.0,
        "yThreshold": 0.0,
        "curveType": "linear",
        "curveFactor": 1.0,
        "outputType": "gain"
      },
      "effects": {
        "minOutput": -40,
        "maxOutput": -3,
        "yThreshold": 0.1,
        "curveType": "sCurve",
        "curveFactor": 2.5,
        "outputType": "db"
      }
    },
    "macroDefaults": {
      "Space": 0.7,
      "Time": 0.6,
      "Motion": 0.3,
      "Tone": 0.7
    },
    "macroMappings": {
      "Space": [
        { "effect": "reverb", "param": "roomSize", "range": [0.5, 0.98] },
        { "effect": "reverb", "param": "wet", "range": [0.3, 0.9] }
      ],
      "Time": [
        { "effect": "delay", "param": "delayTime", "range": [0.3, 1.0] },
        { "effect": "delay", "param": "feedback", "range": [0.4, 0.75] }
      ],
      "Motion": [
        { "effect": "chorus", "param": "depth", "range": [0.1, 0.8] },
        { "effect": "chorus", "param": "wet", "range": [0.1, 0.5] }
      ],
      "Tone": [
        { "effect": "filter", "param": "frequency", "range": [2000, 12000], "curve": "logarithmic" }
      ]
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\fxchain\dirty_vintage_lead.json
{
  "id": "dirty_vintage_lead",
  "type": "fxchain",
  "name": "Dirty Vintage Lead",
  "version": "1.0.0",
  "description": "Gritty distortion with a touch of chorus for a classic lead sound.",
  "active": false,
  "data": {
    "effects": [
      {
        "type": "distortion",
        "enabled": true,
        "params": {
          "distortion": 0.6,
          "wet": 0.7
        }
      },
      {
        "type": "chorus",
        "enabled": true,
        "params": {
          "frequency": 0.8,
          "depth": 0.3,
          "delayTime": 5.0,
          "wet": 0.25
        }
      },
      {
        "type": "filter",
        "enabled": true,
        "params": {
          "type": "peaking",
          "frequency": 1500,
          "Q": 1.2,
          "gain": 3,
          "wet": 1.0
        }
      },
      {
        "type": "delay",
        "enabled": false,
        "params": {
          "wet": 0
        }
      },
      {
        "type": "reverb",
        "enabled": false,
        "params": {
          "wet": 0
        }
      }
    ],
    "yAxisControls": {
      "volume": {
        "minOutput": 0.1,
        "maxOutput": 1.0,
        "yThreshold": 0.0,
        "curveType": "linear",
        "curveFactor": 1.0,
        "outputType": "gain"
      },
      "effects": {
        "minOutput": -45,
        "maxOutput": -5,
        "yThreshold": 0.1,
        "curveType": "sCurve",
        "curveFactor": 2.2,
        "outputType": "db"
      }
    },
    "macroDefaults": {
      "Space": 0.1,
      "Time": 0.2,
      "Motion": 0.6,
      "Tone": 0.6
    },
    "macroMappings": {
      "Space": [
        { "effect": "chorus", "param": "wet", "range": [0.0, 0.5] }
      ],
      "Time": [
        { "effect": "chorus", "param": "frequency", "range": [0.2, 2.0] }
      ],
      "Motion": [
        { "effect": "distortion", "param": "distortion", "range": [0.2, 0.9] }
      ],
      "Tone": [
        { "effect": "filter", "param": "frequency", "range": [500, 5000] },
        { "effect": "filter", "param": "gain", "range": [-6, 6] }
      ]
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\fxchain\rhythmic_filter_groove.json
{
  "id": "rhythmic_filter_groove",
  "type": "fxchain",
  "name": "Rhythmic Filter Groove",
  "version": "1.0.0",
  "description": "Pulsating rhythmic delays combined with a sweeping filter.",
  "active": false,
  "data": {
    "effects": [
      {
        "type": "delay",
        "enabled": true,
        "params": {
          "delayTime": 0.25,
          "feedback": 0.5,
          "wet": 0.6
        }
      },
      {
        "type": "filter",
        "enabled": true,
        "params": {
          "type": "bandpass",
          "frequency": 800,
          "Q": 5,
          "wet": 1.0,
          "rolloff": -24
        }
      },
      {
        "type": "reverb",
        "enabled": false,
        "params": {
          "roomSize": 0.3,
          "wet": 0
        }
      },
      {
        "type": "chorus",
        "enabled": false,
        "params": {
          "wet": 0
        }
      },
      {
        "type": "distortion",
        "enabled": false,
        "params": {
          "wet": 0
        }
      }
    ],
    "yAxisControls": {
      "volume": {
        "minOutput": 0.0,
        "maxOutput": 1.0,
        "yThreshold": 0.0,
        "curveType": "linear",
        "curveFactor": 1.0,
        "outputType": "gain"
      },
      "effects": {
        "minOutput": -50,
        "maxOutput": -6,
        "yThreshold": 0.05,
        "curveType": "exponential",
        "curveFactor": 1.8,
        "outputType": "db"
      }
    },
    "macroDefaults": {
      "Space": 0.3,
      "Time": 0.25,
      "Motion": 0.5,
      "Tone": 0.4
    },
    "macroMappings": {
      "Space": [
        { "effect": "delay", "param": "wet", "range": [0.1, 0.8] }
      ],
      "Time": [
        { "effect": "delay", "param": "delayTime", "range": [0.05, 0.6] }
      ],
      "Motion": [
        { "effect": "delay", "param": "feedback", "range": [0.2, 0.85] },
        { "effect": "filter", "param": "Q", "range": [1, 15] }
      ],
      "Tone": [
        { "effect": "filter", "param": "frequency", "range": [200, 7000], "curve": "logarithmic" }
      ]
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\fxchain\subtle_polish.json
{
  "id": "subtle_polish",
  "type": "fxchain",
  "name": "Subtle Polish",
  "version": "1.0.0",
  "description": "A gentle touch of reverb and filtering to enhance clarity.",
  "active": false,
  "data": {
    "effects": [
      {
        "type": "reverb",
        "enabled": true,
        "params": {
          "roomSize": 0.3,
          "wet": 0.15
        }
      },
      {
        "type": "filter",
        "enabled": true,
        "params": {
          "type": "highpass",
          "frequency": 80,
          "Q": 0.7,
          "wet": 1.0
        }
      },
      {
        "type": "delay",
        "enabled": false,
        "params": {"wet": 0}
      },
      {
        "type": "chorus",
        "enabled": false,
        "params": {"wet": 0}
      },
      {
        "type": "distortion",
        "enabled": false,
        "params": {"wet": 0}
      }
    ],
    "yAxisControls": {
      "volume": {
        "minOutput": 0.0,
        "maxOutput": 1.0,
        "yThreshold": 0.0,
        "curveType": "linear",
        "curveFactor": 1.0,
        "outputType": "gain"
      },
      "effects": {
        "minOutput": -60,
        "maxOutput": -15,
        "yThreshold": 0.2,
        "curveType": "linear",
        "curveFactor": 1.0,
        "outputType": "db"
      }
    },
    "macroDefaults": {
      "Space": 0.2,
      "Time": 0.5,
      "Motion": 0.5,
      "Tone": 0.1
    },
    "macroMappings": {
      "Space": [
        { "effect": "reverb", "param": "wet", "range": [0.0, 0.4] },
        { "effect": "reverb", "param": "roomSize", "range": [0.1, 0.6] }
      ],
      "Time": [],
      "Motion": [],
      "Tone": [
        { "effect": "filter", "param": "frequency", "range": [40, 200] }
      ]
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\fxchain\wide_chorus_wash.json
{
  "id": "wide_chorus_wash",
  "type": "fxchain",
  "name": "Wide Chorus Wash",
  "version": "1.0.0",
  "description": "A wide and enveloping chorus effect, great for pads and synths.",
  "active": false,
  "data": {
    "effects": [
      {
        "type": "chorus",
        "enabled": true,
        "params": {
          "frequency": 1.2,
          "depth": 0.85,
          "delayTime": 6.0,
          "wet": 0.75
        }
      },
      {
        "type": "reverb",
        "enabled": true,
        "params": {
          "roomSize": 0.6,
          "wet": 0.25
        }
      },
      {
        "type": "delay",
        "enabled": false,
        "params": {"wet": 0}
      },
      {
        "type": "distortion",
        "enabled": false,
        "params": {"wet": 0}
      },
      {
        "type": "filter",
        "enabled": false,
        "params": {"wet": 0}
      }
    ],
    "yAxisControls": {
      "volume": {
        "minOutput": 0.0,
        "maxOutput": 1.0,
        "yThreshold": 0.0,
        "curveType": "linear",
        "curveFactor": 1.0,
        "outputType": "gain"
      },
      "effects": {
        "minOutput": -50,
        "maxOutput": -4,
        "yThreshold": 0.0,
        "curveType": "linear",
        "curveFactor": 1.0,
        "outputType": "db"
      }
    },
    "macroDefaults": {
      "Space": 0.4,
      "Time": 0.5,
      "Motion": 0.7,
      "Tone": 0.5
    },
    "macroMappings": {
      "Space": [
        { "effect": "chorus", "param": "wet", "range": [0.2, 1.0] },
        { "effect": "reverb", "param": "wet", "range": [0.0, 0.5] }
      ],
      "Time": [
        { "effect": "chorus", "param": "delayTime", "range": [2.5, 10.0] }
      ],
      "Motion": [
        { "effect": "chorus", "param": "depth", "range": [0.3, 1.0] },
        { "effect": "chorus", "param": "frequency", "range": [0.5, 3.0] }
      ],
      "Tone": [
        { "effect": "reverb", "param": "roomSize", "range": [0.2, 0.8] }
      ]
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\language\de.json
{
  "id": "de",
  "type": "language",
  "name": "Deutsch",
  "version": "1.0.5",
  "description": "German language pack (Updated 25.05.2025)",
  "active": false,
  "data": {
    "strings": {
      "presets_panel_title": "Presets",
      "app_title": "Prismtone",
      "menu_button": "Menü",
      "sound_library_button": "Sound-Bibliothek",
      "tonality_button": "Tonalität",
      "effects_button": "Effekte",
      "record_button": "Aufnahme",
      "stop_recording_button": "Aufnahme Stoppen",
      "settings_title": "Einstellungen",
      "language_label": "Sprache",
      "theme_label": "Thema",
      "visualizer_label": "Visualisierer",
      "touch_effect_label": "Touch-Effekt",
      "display_options_header": "Anzeige & Verhalten",
      "show_note_names": "Notennamen Anzeigen",
      "show_lines": "Gitterlinien Anzeigen",
      "multi_touch": "Multitouch",
      "enable_polyphony_scaling": "Polyphonie-Lautst. Skalierung",
      "haptic_feedback": "Haptisches Feedback",
      "enable_vibration": "Vibration Aktivieren",
      "highlight_sharps_flats": "Vorzeichen Hervorheben",
      "tonality_title": "Tonalität",
      "octave_label": "Oktave",
      "scale_label": "Tonleiter",
      "size_label": "Größe",
      "effects_title": "Effekte",
      "fx_chain_label": "Effektkette",
      "save_chain": "Kette Speichern",
      "delete_chain": "Kette Löschen",
      "reset_fx": "Effekte Zurücksetzen",
      "y_axis_controls": "Y-Achsen Steuerung",
      "volume_min": "Min. Lautstärke",
      "volume_max": "Max. Lautstärke",
      "volume_curve": "Kurve",
      "effects_min": "FX Send Min. (dB)",
      "effects_max": "FX Send Max. (dB)",
      "effects_curve": "Kurve",
      "linear": "Linear",
      "exponential": "Exponentiell",
      "delay": "Delay",
      "reverb": "Hall",
      "chorus": "Chorus",
      "distortion": "Verzerrung",
      "filter": "Filter",
      "phaser": "Phaser",
      "pitchShift": "Tonhöhenverschiebung",
      "wet": "Mix",
      "time": "Zeit",
      "delayTime": "Zeit",
      "feedback": "Feedback",
      "decay": "Abklingen",
      "preDelay": "Pre-Delay",
      "frequency": "Frequenz",
      "depth": "Tiefe",
      "Q": "Q",
      "type": "Typ",
      "gain": "Gain",
      "rolloff": "Flankensteilheit",
      "pitch": "Tonhöhe",
      "octaves": "Oktaven",
      "baseFrequency": "Grundfrequenz",
      "sound_library_title": "Sound-Bibliothek",
      "presets_title": "Presets",
      "save_preset": "Neuen Sound Speichern",
      "delete_preset": "Sound Löschen",
      "synth_controls": "Synth-Steuerung",
      "synth_type": "Synth-Typ",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "Oszillator-Typ",
      "sine": "Sinus",
      "square": "Rechteck",
      "sawtooth": "Sägezahn",
      "triangle": "Dreieck",
      "fat_sine": "Fat Sinus",
      "fat_square": "Fat Rechteck",
      "fat_sawtooth": "Fat Sägezahn",
      "fat_triangle": "Fat Dreieck",
      "fm_sine": "FM Sinus",
      "fm_square": "FM Rechteck",
      "fm_sawtooth": "FM Sägezahn",
      "fm_triangle": "FM Dreieck",
      "am_sine": "AM Sinus",
      "am_square": "AM Rechteck",
      "am_sawtooth": "AM Sägezahn",
      "am_triangle": "AM Dreieck",
      "pwm": "PWM",
      "pulse": "Puls",
      "noise_white": "Weißes Rauschen",
      "noise_pink": "Rosa Rauschen",
      "noise_brown": "Braunes Rauschen",
      "oscillator_params": "Oszillator-Parameter",
      "phase": "Phase",
      "count": "Anzahl",
      "spread": "Streuung",
      "width": "Breite",
      "mod_freq_short": "Mod.-Frequenz",
      "harmonicity": "Harmonizität",
      "mod_index": "Mod.-Index",
      "mod_type": "Mod.-Typ",
      "noise_type": "Rauschtyp",
      "envelope": "Hüllkurve",
      "attack": "Attack",
      "sustain": "Sustain",
      "release": "Release",
      "envelope_curves": "Hüllkurvenformen",
      "attack_curve": "Attack",
      "decay_curve": "Decay",
      "release_curve": "Release",
      "filter_advanced": "Erw. Filter",
      "filter_rolloff": "Flankensteilheit",
      "filter_gain": "Gain (dB)",
      "filter_envelope": "Filterhüllkurve",
      "base_frequency": "Grundfrequenz",
      "exponent": "Exponent",
      "modulation": "Modulation",
      "modulation_envelope": "Modulationshüllkurve",
      "special_parameters": "Spezialparameter",
      "pitch_decay": "Tonhöhenabfall",
      "attack_noise": "Attack-Rauschen",
      "dampening": "Dämpfung",
      "resonance": "Resonanz",
      "lfo": "LFO",
      "lfo_type": "Typ",
      "lfo_target": "Ziel",
      "lfo_min": "Min.",
      "lfo_max": "Max.",
      "save_preset_title": "Sound-Preset Speichern",
      "preset_name_label": "Preset-Name:",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_fx_chain_title": "Effektkette Speichern",
      "fx_chain_name_label": "Name der Kette:",
      "fx_chain_name_placeholder": "Meine Effektkette",
      "cancel": "Abbrechen",
      "save": "Speichern",
      "major": "Dur",
      "minor": "Moll",
      "pentatonic": "Pentatonisch",
      "blues": "Blues",
      "chromatic": "Chromatisch",
      "dorian": "Dorisch",
      "phrygian": "Phrygisch",
      "lydian": "Lydisch",
      "mixolydian": "Mixolydisch",
      "locrian": "Lokrisch",
      "day": "Tag",
      "night": "Nacht",
      "neon": "Neon",
      "retro": "Retro",
      "pastel": "Pastell",
      "aurora": "Aurora",
      "ocean": "Ozean",
      "cyberpunk": "Cyberpunk",
      "fire": "Feuer",
      "matrix": "Matrix",
      "hologram": "Hologramm",
      "crystal": "Kristall",
      "galaxy": "Galaxie",
      "waves": "Wellen",
      "spectrum": "Spektrum",
      "particles": "Fischschwarm",
      "nebula": "Nebel",
      "reactive_ripples": "Reaktive Wellen",
      "touch_trails": "Touch-Spuren",
      "loading": "Laden...",
      "initializing": "Initialisiere...",
      "loading_bridge": "Verbinde...",
      "loading_settings": "Lade Einstellungen...",
      "loading_modules": "Lade Module...",
      "loading_ui": "Initialisiere UI...",
      "loading_presets": "Wende Einstellungen an...",
      "loading_audio": "Lade Sounds...",
      "tap_to_start": "Tippen, um Audio zu starten",
      "starting_audio": "Starte Audio...",
      "audio_suspended": "Audio pausiert. Tippen zum Fortsetzen.",
      "loading_preset": "Lade Preset...",
      "loading_fxchain": "Lade FX-Kette...",
      "saving_preset_progress": "Speichere Preset...",
      "saving_fxchain_progress": "Speichere FX-Kette...",
      "deleting_preset_progress": "Lösche Preset...",
      "deleting_fxchain_progress": "Lösche FX-Kette...",
      "hit_play_vibe": "Drück Play, Fühl den Vibe",
      "error_bridge_failed": "Fehler: Bridge-Verbindung fehlgeschlagen.",
      "error_init_failed": "Initialisierungsfehler. Konsole prüfen.",
      "error_init_failed_details": "Initialisierungsfehler: ${error}. Konsole prüfen.",
      "error_fatal_init": "Kritischer Initialisierungsfehler. Bitte neu starten.",
      "error_audio_failed_retry": "Fehler beim Starten von Audio. Bitte erneut tippen.",
      "error_audio_resume": "Audio konnte nicht fortgesetzt werden.",
      "error_apply_preset": "Fehler beim Anwenden des Presets.",
      "error_apply_fxchain": "Fehler beim Anwenden der FX-Kette.",
      "error_loading_presets": "Fehler beim Laden der Presets.",
      "error_loading_fxchains": "Fehler beim Laden der Ketten",
      "error_loading_effects_ui": "Fehler beim Laden der Effekt-UI.",
      "no_presets_found": "Keine Presets gefunden.",
      "no_fxchains_found": "Keine FX-Ketten gefunden",
      "no_effects_available": "Keine Effekte verfügbar.",
      "enter_preset_name": "Bitte gib einen Preset-Namen ein.",
      "enter_fxchain_name": "Bitte gib einen FX-Ketten-Namen ein.",
      "preset_saved_success": "Preset \"${name}\" erfolgreich gespeichert!",
      "fxchain_saved_success": "FX-Kette \"${name}\" erfolgreich gespeichert!",
      "error_saving_preset": "Fehler beim Speichern des Presets: ${error}",
      "error_saving_fxchain": "Fehler beim Speichern der FX-Kette: ${error}",
      "exception_saving_preset": "Ausnahme beim Speichern des Presets: ${error}",
      "exception_saving_fxchain": "Ausnahme beim Speichern der FX-Kette: ${error}",
      "confirm_delete_preset": "Preset \"${name}\" wirklich löschen?",
      "confirm_delete_fxchain": "FX-Kette \"${name}\" wirklich löschen?",
      "cannot_delete_default_preset": "Standard-Presets können nicht gelöscht werden.",
      "cannot_delete_default_fxchain": "Standard-FX-Ketten können nicht gelöscht werden.",
      "preset_deleted_success": "Preset gelöscht.",
      "fxchain_deleted_success": "FX-Kette gelöscht.",
      "preset_delete_failed": "Preset konnte nicht gelöscht werden.",
      "fxchain_delete_failed": "FX-Kette konnte nicht gelöscht werden.",
      "exception_deleting_preset": "Ausnahme beim Löschen des Presets: ${error}",
      "exception_deleting_fxchain": "Ausnahme beim Löschen der FX-Kette: ${error}",
      "audio_not_ready_record": "Audio nicht bereit. Aufnahme kann nicht gestartet werden.",
      "pitch_envelope": "Tonhöhen-Hüllkurve",
      "pitch_amount_cents": "Betrag (Cents)",
      "macro_controls_title": "Makro-Regler",
      "macro_space": "Raum",
      "macro_time": "Zeit",
      "macro_motion": "Bewegung",
      "macro_tone": "Klangfarbe",
      "macro_drive": "Drive",
      "effects_intensity_min": "FX-Intensität Min. (dB)",
      "effects_intensity_max": "FX-Intensität Max. (dB)",
      "effects_threshold": "FX-Schwelle",
      "none_fxchain": "-- Keine --",
      "none_touch_effect": "Kein",
      "restart_audio_engine_button": "Audio Neustart",
      "reload_app_button_title": "App Neu Laden",
      "reloading_app_message": "App wird neu geladen...",
      "master_output_title": "Master-Ausgang",
      "master_volume_ceiling": "Lautstärke-Limit",
      "master_volume_ceiling_label": "Lautstärke-Limit",
      "y_axis_volume_min_output": "Min. Ausgabe",
      "y_axis_volume_max_output": "Max. Ausgabe",
      "y_axis_volume_y_threshold": "Y-Schwelle",
      "y_axis_curve_type": "Kurventyp",
      "y_axis_curve_factor": "Kurvenfaktor",
      "y_axis_effects_min_output": "Min. Ausgabe (dB)",
      "y_axis_effects_max_output": "Max. Ausgabe (dB)",
      "y_axis_effects_y_threshold": "Y-Schwelle",
      "logarithmic": "Logarithmisch",
      "s_curve": "S-Kurve",
      "select_option": "Option Auswählen",
      "no_options_found": "Keine Optionen gefunden",
      "error_loading_options": "Fehler beim Laden der Optionen.",
      "pad_modes_button": "Modi",
      "pad_modes_button_title": "Pad-Modi",
      "pad_modes_panel_title": "Pad-Modi",
      "pad_mode_label": "Pad-Modus",
      "pad_mode_select_title": "Pad-Modus Auswählen",
      "pad_mode_classic": "Klassisch",
      "pad_mode_reactive": "Reaktiv",
      "reactive_mode_show_suggestions": "Harm. Hinweise Anzeigen",
      "reactive_mode_suggestion_count": "Anz. Hinweise",
      "no_specific_settings_classic": "Keine spezifischen Einstellungen für Klassisch-Modus.",
      "no_specific_settings_reactive": "Hinweise für Reaktiv-Modus konfigurieren.",
      "pad_mode_rocket": "Rakete",
      "rocket_highlight_active": "Aktive Noten Hervorheben",
      "rocket_show_markers": "Direktionale Marker Anzeigen",
      "rocket_marker_style": "Marker-Stil",
      "rocket_valid_chords_only": "Marker Nur für Valide Akkorde",
      "rocket_animate_fade": "Marker-Ausblendung Animieren",
      "rocket_show_chord_name": "Erkannten Akkordnamen Anzeigen",
      "style_GlowFromNote": "Glühen von Note",
      "style_WaveToNote": "Welle zu Note",
      "style_PulseRing": "Pulsierender Ring",
      "style_SparkTrail": "Funkenpfad",
      "style_ShadowDrop": "Schatten unter Note",
      "rocket_mode_panel_title": "Raketenmodus",
      "rocket_mode_enable": "Raketenmodus Aktivieren",
      "rocket_mode_settings_placeholder": "Einstellungen für den Raketenmodus erscheinen hier.",
      "error_loading_mode_settings": "Fehler beim Laden der Modus-Einstellungen.",
      "no_specific_settings_rocket": "Spezifische Einstellungen für den Raketenmodus konfigurieren.",
      "reset_settings_button": "Alle Einstellungen Zurücksetzen",
      "reload_app_button": "App Vollständig Neu Laden",
      "restart_audio_button": "Audio-Engine Neu Starten",
      "rocket_section_general": "Allgemein",
      "rocket_section_phases": "Phasen",
      "rocket_section_harmonic_logic": "Harmonische Logik",
      "rocket_section_interactive_behavior": "Interaktives Verhalten",
      "rocket_intensity": "Intensität",
      "rocket_visual_theme": "Visuelles Thema",
      "rocket_auto_phases": "Auto-Phasen",
      "rocket_harmonic_key": "Harmonischer Schlüssel",
      "rocket_marker_logic": "Marker-Logik",
      "marker_logic_tonal": "Tonale Bindung",
      "marker_logic_adaptive": "Adaptive Analyse",
      "marker_logic_semi_free": "Halbfrei",
      "marker_logic_random": "Zufällig Gerichtet",
      "rocket_phase_ignition": "Zündung",
      "rocket_phase_lift_off": "Start",
      "rocket_phase_burst": "Ausbruch",
      "rocket_phase_transition": "Phasenübergang",
      "phase_mode_activity": "Nach Aktivität",
      "phase_mode_time": "Nach Zeit",
      "phase_mode_manual": "Manuell",
      "status_chord": "Akkord",
      "status_key": "Tonart",
      "status_next": "Nächstes",
      "status_energy": "Energie",
      "status_phase": "Phase",
      "status_na": "N/A",
      "rocket_presets_title": "Modus-Presets",
      "rocket_select_preset": "Preset Auswählen",
      "rocket_select_preset_title": "Raketenmodus-Preset Auswählen",
      "rocket_preset_current": "Aktuelle Einstellungen",
      "none_selected": "Keine",
      "preset_rocket_melodic_drift": "Melodischer Drift",
      "desc_rocket_melodic_drift": "Sanfte, schwebende, halbfreie harmonische Logik.",
      "preset_rocket_jazz_climb": "Jazz-Aufstieg",
      "desc_rocket_jazz_climb": "Aktive, adaptive, jazz-inspirierte Logik.",
      "rocket_marker_labels": "Marker-Beschriftungen",
      "labels_none": "Keine",
      "labels_function": "Funktion (T/S/D)",
      "labels_chord_name": "Akkordname",
      "rocket_marker_retention": "Marker-Beibehaltung",
      "desc_rocket_marker_retention": "Relevante Marker bei neuen Berührungen sichtbar halten.",
      "desc_rocket_animate_fade": "Nicht relevante Marker sanft ausblenden.",
      "rocket_fade_delay": "Ausblendverzögerung",
      "desc_rocket_fade_delay": "Verzögerung, bevor Marker auszublenden beginnt.",
      "rocket_fade_duration": "Ausblenddauer",
      "desc_rocket_fade_duration": "Dauer der Marker-Ausblendanimation.",
      "rocket_max_markers_zone": "Max Marker/Zone",
      "desc_rocket_max_markers_zone": "Max. Vorschläge pro Zone.",
      "rocket_phase_styles": "Phasen-Stile",
      "desc_rocket_phase_styles": "Aktueller Phase erlauben, Marker-Stil zu überschreiben.",
      "rocket_tb_in_key": "Ton. Bind.: Nur in Tonart",
      "desc_rocket_tb_in_key": "Nur Noten/Akkorde der aktuellen Tonart vorschlagen.",
      "rocket_aa_autokey": "Adap. An.: Auto Tonartwechsel",
      "desc_rocket_aa_autokey": "Adaptiven Tonartwechsel basierend auf Eingabe erlauben.",
      "rocket_sf_basekey": "Halbfrei: Grundtonart",
      "desc_rocket_sf_basekey": "Grundtonart für halbfreien Modus.",
      "rocket_sf_deviations": "Halbfrei: Modale Abweichungen",
      "desc_rocket_sf_deviations": "Temporäre Abweichungen von Grundtonart erlauben.",
      "rocket_sf_return": "Halbfrei: Rückkehr hervorheben",
      "desc_rocket_sf_return": "Vorschläge hervorheben, die zur Grundtonart zurückkehren.",
      "rocket_rd_randomlevel": "Zufallsniveau",
      "desc_rocket_rd_randomlevel": "Niveau der Zufälligkeit in Vorschlägen.",
      "select_chord": "Akkord Auswählen",
      "select_key": "Tonart Auswählen",
      "select_phase": "Phase Auswählen",
      "no_language_found": "Keine Sprachen gefunden",
      "no_theme_found": "Keine Themen gefunden",
      "no_visualizer_found": "Keine Visualisierer gefunden",
      "no_touchEffect_found": "Keine Touch-Effekte gefunden",
      "no_scale_found": "Keine Tonleitern gefunden",
      "no_fxChain_found": "Keine FX-Ketten gefunden",
      "error_audio_fatal_restart": "Kritischer Audiofehler. Bitte starten Sie die App neu.",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_preset": "Neuen Sound Speichern",
      "delete_preset": "Sound Löschen",
      "synth_controls": "Synth-Steuerung",
      "synth_type": "Synth-Typ",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "Oszillator-Typ",
      "sine": "Sinus",
      "square": "Rechteck",
      "sawtooth": "Sägezahn",
      "triangle": "Dreieck",
      "fat_sine": "Fat Sinus",
      "fat_square": "Fat Rechteck",
      "fat_sawtooth": "Fat Sägezahn",
      "fat_triangle": "Fat Dreieck",
      "fm_sine": "FM Sinus",
      "fm_square": "FM Rechteck",
      "fm_sawtooth": "FM Sägezahn",
      "fm_triangle": "FM Dreieck",
      "am_sine": "AM Sinus",
      "am_square": "AM Rechteck",
      "am_sawtooth": "AM Sägezahn",
      "am_triangle": "AM Dreieck",
      "pwm": "PWM",
      "pulse": "Puls",
      "noise_white": "Weißes Rauschen",
      "noise_pink": "Rosa Rauschen",
      "noise_brown": "Braunes Rauschen",
      "oscillator_params": "Oszillator-Parameter",
      "phase": "Phase",
      "count": "Anzahl",
      "spread": "Streuung",
      "width": "Breite",
      "mod_freq_short": "Mod.-Frequenz",
      "harmonicity": "Harmonizität",
      "mod_index": "Mod.-Index",
      "mod_type": "Mod.-Typ",
      "noise_type": "Rauschtyp",
      "envelope": "Hüllkurve",
      "attack": "Attack",
      "sustain": "Sustain",
      "release": "Release",
      "envelope_curves": "Hüllkurvenformen",
      "attack_curve": "Attack",
      "decay_curve": "Decay",
      "release_curve": "Release",
      "filter_advanced": "Erw. Filter",
      "filter_rolloff": "Flankensteilheit",
      "filter_gain": "Gain (dB)",
      "filter_envelope": "Filterhüllkurve",
      "base_frequency": "Grundfrequenz",
      "exponent": "Exponent",
      "modulation": "Modulation",
      "modulation_envelope": "Modulationshüllkurve",
      "special_parameters": "Spezialparameter",
      "pitch_decay": "Tonhöhenabfall",
      "attack_noise": "Attack-Rauschen",
      "dampening": "Dämpfung",
      "resonance": "Resonanz",
      "lfo": "LFO",
      "lfo_type": "Typ",
      "lfo_target": "Ziel",
      "lfo_min": "Min.",
      "lfo_max": "Max.",
      "save_preset_title": "Sound-Preset Speichern",
      "preset_name_label": "Preset-Name:",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_fx_chain_title": "Effektkette Speichern",
      "fx_chain_name_label": "Name der Kette:",
      "fx_chain_name_placeholder": "Meine Effektkette",
      "cancel": "Abbrechen",
      "save": "Speichern",
      "major": "Dur",
      "minor": "Moll",
      "pentatonic": "Pentatonisch",
      "blues": "Blues",
      "chromatic": "Chromatisch",
      "dorian": "Dorisch",
      "phrygian": "Phrygisch",
      "lydian": "Lydisch",
      "mixolydian": "Mixolydisch",
      "locrian": "Lokrisch",
      "day": "Tag",
      "night": "Nacht",
      "neon": "Neon",
      "retro": "Retro",
      "pastel": "Pastell",
      "aurora": "Aurora",
      "ocean": "Ozean",
      "cyberpunk": "Cyberpunk",
      "fire": "Feuer",
      "matrix": "Matrix",
      "hologram": "Hologramm",
      "crystal": "Kristall",
      "galaxy": "Galaxie",
      "waves": "Wellen",
      "spectrum": "Spektrum",
      "particles": "Fischschwarm",
      "nebula": "Nebel",
      "reactive_ripples": "Reaktive Wellen",
      "touch_trails": "Touch-Spuren",
      "loading": "Laden...",
      "initializing": "Initialisiere...",
      "loading_bridge": "Verbinde...",
      "loading_settings": "Lade Einstellungen...",
      "loading_modules": "Lade Module...",
      "loading_ui": "Initialisiere UI...",
      "loading_presets": "Wende Einstellungen an...",
      "loading_audio": "Lade Sounds...",
      "tap_to_start": "Tippen, um Audio zu starten",
      "starting_audio": "Starte Audio...",
      "audio_suspended": "Audio pausiert. Tippen zum Fortsetzen.",
      "loading_preset": "Lade Preset...",
      "loading_fxchain": "Lade FX-Kette...",
      "saving_preset_progress": "Speichere Preset...",
      "saving_fxchain_progress": "Speichere FX-Kette...",
      "deleting_preset_progress": "Lösche Preset...",
      "deleting_fxchain_progress": "Lösche FX-Kette...",
      "hit_play_vibe": "Drück Play, Fühl den Vibe",
      "error_bridge_failed": "Fehler: Bridge-Verbindung fehlgeschlagen.",
      "error_init_failed": "Initialisierungsfehler. Konsole prüfen.",
      "error_init_failed_details": "Initialisierungsfehler: ${error}. Konsole prüfen.",
      "error_fatal_init": "Kritischer Initialisierungsfehler. Bitte neu starten.",
      "error_audio_failed_retry": "Fehler beim Starten von Audio. Bitte erneut tippen.",
      "error_audio_resume": "Audio konnte nicht fortgesetzt werden.",
      "error_apply_preset": "Fehler beim Anwenden des Presets.",
      "error_apply_fxchain": "Fehler beim Anwenden der FX-Kette.",
      "error_loading_presets": "Fehler beim Laden der Presets.",
      "error_loading_fxchains": "Fehler beim Laden der Ketten",
      "error_loading_effects_ui": "Fehler beim Laden der Effekt-UI.",
      "no_presets_found": "Keine Presets gefunden.",
      "no_fxchains_found": "Keine FX-Ketten gefunden",
      "no_effects_available": "Keine Effekte verfügbar.",
      "enter_preset_name": "Bitte gib einen Preset-Namen ein.",
      "enter_fxchain_name": "Bitte gib einen FX-Ketten-Namen ein.",
      "preset_saved_success": "Preset \"${name}\" erfolgreich gespeichert!",
      "fxchain_saved_success": "FX-Kette \"${name}\" erfolgreich gespeichert!",
      "error_saving_preset": "Fehler beim Speichern des Presets: ${error}",
      "error_saving_fxchain": "Fehler beim Speichern der FX-Kette: ${error}",
      "exception_saving_preset": "Ausnahme beim Speichern des Presets: ${error}",
      "exception_saving_fxchain": "Ausnahme beim Speichern der FX-Kette: ${error}",
      "confirm_delete_preset": "Preset \"${name}\" wirklich löschen?",
      "confirm_delete_fxchain": "FX-Kette \"${name}\" wirklich löschen?",
      "cannot_delete_default_preset": "Standard-Presets können nicht gelöscht werden.",
      "cannot_delete_default_fxchain": "Standard-FX-Ketten können nicht gelöscht werden.",
      "preset_deleted_success": "Preset gelöscht.",
      "fxchain_deleted_success": "FX-Kette gelöscht.",
      "preset_delete_failed": "Preset konnte nicht gelöscht werden.",
      "fxchain_delete_failed": "FX-Kette konnte nicht gelöscht werden.",
      "exception_deleting_preset": "Ausnahme beim Löschen des Presets: ${error}",
      "exception_deleting_fxchain": "Ausnahme beim Löschen der FX-Kette: ${error}",
      "audio_not_ready_record": "Audio nicht bereit. Aufnahme kann nicht gestartet werden.",
      "pitch_envelope": "Tonhöhen-Hüllkurve",
      "pitch_amount_cents": "Betrag (Cents)",
      "macro_controls_title": "Makro-Regler",
      "macro_space": "Raum",
      "macro_time": "Zeit",
      "macro_motion": "Bewegung",
      "macro_tone": "Klangfarbe",
      "macro_drive": "Drive",
      "effects_intensity_min": "FX-Intensität Min. (dB)",
      "effects_intensity_max": "FX-Intensität Max. (dB)",
      "effects_threshold": "FX-Schwelle",
      "none_fxchain": "-- Keine --",
      "none_touch_effect": "Kein",
      "restart_audio_engine_button": "Audio Neustart",
      "reload_app_button_title": "App Neu Laden",
      "reloading_app_message": "App wird neu geladen...",
      "master_output_title": "Master-Ausgang",
      "master_volume_ceiling": "Lautstärke-Limit",
      "master_volume_ceiling_label": "Lautstärke-Limit",
      "y_axis_volume_min_output": "Min. Ausgabe",
      "y_axis_volume_max_output": "Max. Ausgabe",
      "y_axis_volume_y_threshold": "Y-Schwelle",
      "y_axis_curve_type": "Kurventyp",
      "y_axis_curve_factor": "Kurvenfaktor",
      "y_axis_effects_min_output": "Min. Ausgabe (dB)",
      "y_axis_effects_max_output": "Max. Ausgabe (dB)",
      "y_axis_effects_y_threshold": "Y-Schwelle",
      "logarithmic": "Logarithmisch",
      "s_curve": "S-Kurve",
      "select_option": "Option Auswählen",
      "no_options_found": "Keine Optionen gefunden",
      "error_loading_options": "Fehler beim Laden der Optionen.",
      "pad_modes_button": "Modi",
      "pad_modes_button_title": "Pad-Modi",
      "pad_modes_panel_title": "Pad-Modi",
      "pad_mode_label": "Pad-Modus",
      "pad_mode_select_title": "Pad-Modus Auswählen",
      "pad_mode_classic": "Klassisch",
      "pad_mode_reactive": "Reaktiv",
      "reactive_mode_show_suggestions": "Harm. Hinweise Anzeigen",
      "reactive_mode_suggestion_count": "Anz. Hinweise",
      "no_specific_settings_classic": "Keine spezifischen Einstellungen für Klassisch-Modus.",
      "no_specific_settings_reactive": "Hinweise für Reaktiv-Modus konfigurieren.",
      "pad_mode_rocket": "Rakete",
      "rocket_highlight_active": "Aktive Noten Hervorheben",
      "rocket_show_markers": "Direktionale Marker Anzeigen",
      "rocket_marker_style": "Marker-Stil",
      "rocket_valid_chords_only": "Marker Nur für Valide Akkorde",
      "rocket_animate_fade": "Marker-Ausblendung Animieren",
      "rocket_show_chord_name": "Erkannten Akkordnamen Anzeigen",
      "style_GlowFromNote": "Glühen von Note",
      "style_WaveToNote": "Welle zu Note",
      "style_PulseRing": "Pulsierender Ring",
      "style_SparkTrail": "Funkenpfad",
      "style_ShadowDrop": "Schatten unter Note",
      "rocket_mode_panel_title": "Raketenmodus",
      "rocket_mode_enable": "Raketenmodus Aktivieren",
      "rocket_mode_settings_placeholder": "Einstellungen für den Raketenmodus erscheinen hier.",
      "error_loading_mode_settings": "Fehler beim Laden der Modus-Einstellungen.",
      "no_specific_settings_rocket": "Spezifische Einstellungen für den Raketenmodus konfigurieren.",
      "reset_settings_button": "Alle Einstellungen Zurücksetzen",
      "reload_app_button": "App Vollständig Neu Laden",
      "restart_audio_button": "Audio-Engine Neu Starten",
      "rocket_section_general": "Allgemein",
      "rocket_section_phases": "Phasen",
      "rocket_section_harmonic_logic": "Harmonische Logik",
      "rocket_section_interactive_behavior": "Interaktives Verhalten",
      "rocket_intensity": "Intensität",
      "rocket_visual_theme": "Visuelles Thema",
      "rocket_auto_phases": "Auto-Phasen",
      "rocket_harmonic_key": "Harmonischer Schlüssel",
      "rocket_marker_logic": "Marker-Logik",
      "marker_logic_tonal": "Tonale Bindung",
      "marker_logic_adaptive": "Adaptive Analyse",
      "marker_logic_semi_free": "Halbfrei",
      "marker_logic_random": "Zufällig Gerichtet",
      "rocket_phase_ignition": "Zündung",
      "rocket_phase_lift_off": "Start",
      "rocket_phase_burst": "Ausbruch",
      "rocket_phase_transition": "Phasenübergang",
      "phase_mode_activity": "Nach Aktivität",
      "phase_mode_time": "Nach Zeit",
      "phase_mode_manual": "Manuell",
      "status_chord": "Akkord",
      "status_key": "Tonart",
      "status_next": "Nächstes",
      "status_energy": "Energie",
      "status_phase": "Phase",
      "status_na": "N/A",
      "rocket_presets_title": "Modus-Presets",
      "rocket_select_preset": "Preset Auswählen",
      "rocket_select_preset_title": "Raketenmodus-Preset Auswählen",
      "rocket_preset_current": "Aktuelle Einstellungen",
      "none_selected": "Keine",
      "preset_rocket_melodic_drift": "Melodischer Drift",
      "desc_rocket_melodic_drift": "Sanfte, schwebende, halbfreie harmonische Logik.",
      "preset_rocket_jazz_climb": "Jazz-Aufstieg",
      "desc_rocket_jazz_climb": "Aktive, adaptive, jazz-inspirierte Logik.",
      "rocket_marker_labels": "Marker-Beschriftungen",
      "labels_none": "Keine",
      "labels_function": "Funktion (T/S/D)",
      "labels_chord_name": "Akkordname",
      "rocket_marker_retention": "Marker-Beibehaltung",
      "desc_rocket_marker_retention": "Relevante Marker bei neuen Berührungen sichtbar halten.",
      "desc_rocket_animate_fade": "Nicht relevante Marker sanft ausblenden.",
      "rocket_fade_delay": "Ausblendverzögerung",
      "desc_rocket_fade_delay": "Verzögerung, bevor Marker auszublenden beginnt.",
      "rocket_fade_duration": "Ausblenddauer",
      "desc_rocket_fade_duration": "Dauer der Marker-Ausblendanimation.",
      "rocket_max_markers_zone": "Max Marker/Zone",
      "desc_rocket_max_markers_zone": "Max. Vorschläge pro Zone.",
      "rocket_phase_styles": "Phasen-Stile",
      "desc_rocket_phase_styles": "Aktueller Phase erlauben, Marker-Stil zu überschreiben.",
      "rocket_tb_in_key": "Ton. Bind.: Nur in Tonart",
      "desc_rocket_tb_in_key": "Nur Noten/Akkorde der aktuellen Tonart vorschlagen.",
      "rocket_aa_autokey": "Adap. An.: Auto Tonartwechsel",
      "desc_rocket_aa_autokey": "Adaptiven Tonartwechsel basierend auf Eingabe erlauben.",
      "rocket_sf_basekey": "Halbfrei: Grundtonart",
      "desc_rocket_sf_basekey": "Grundtonart für halbfreien Modus.",
      "rocket_sf_deviations": "Halbfrei: Modale Abweichungen",
      "desc_rocket_sf_deviations": "Temporäre Abweichungen von Grundtonart erlauben.",
      "rocket_sf_return": "Halbfrei: Rückkehr hervorheben",
      "desc_rocket_sf_return": "Vorschläge hervorheben, die zur Grundtonart zurückkehren.",
      "rocket_rd_randomlevel": "Zufallsniveau",
      "desc_rocket_rd_randomlevel": "Niveau der Zufälligkeit in Vorschlägen.",
      "select_chord": "Akkord Auswählen",
      "select_key": "Tonart Auswählen",
      "select_phase": "Phase Auswählen",
      "no_language_found": "Keine Sprachen gefunden",
      "no_theme_found": "Keine Themen gefunden",
      "no_visualizer_found": "Keine Visualisierer gefunden",
      "no_touchEffect_found": "Keine Touch-Effekte gefunden",
      "no_scale_found": "Keine Tonleitern gefunden",
      "no_fxChain_found": "Keine FX-Ketten gefunden",
      "error_audio_fatal_restart": "Kritischer Audiofehler. Bitte starten Sie die App neu.",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_preset": "Neuen Sound Speichern",
      "delete_preset": "Sound Löschen",
      "synth_controls": "Synth-Steuerung",
      "synth_type": "Synth-Typ",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "Oszillator-Typ",
      "sine": "Sinus",
      "square": "Rechteck",
      "sawtooth": "Sägezahn",
      "triangle": "Dreieck",
      "fat_sine": "Fat Sinus",
      "fat_square": "Fat Rechteck",
      "fat_sawtooth": "Fat Sägezahn",
      "fat_triangle": "Fat Dreieck",
      "fm_sine": "FM Sinus",
      "fm_square": "FM Rechteck",
      "fm_sawtooth": "FM Sägezahn",
      "fm_triangle": "FM Dreieck",
      "am_sine": "AM Sinus",
      "am_square": "AM Rechteck",
      "am_sawtooth": "AM Sägezahn",
      "am_triangle": "AM Dreieck",
      "pwm": "PWM",
      "pulse": "Puls",
      "noise_white": "Weißes Rauschen",
      "noise_pink": "Rosa Rauschen",
      "noise_brown": "Braunes Rauschen",
      "oscillator_params": "Oszillator-Parameter",
      "phase": "Phase",
      "count": "Anzahl",
      "spread": "Streuung",
      "width": "Breite",
      "mod_freq_short": "Mod.-Frequenz",
      "harmonicity": "Harmonizität",
      "mod_index": "Mod.-Index",
      "mod_type": "Mod.-Typ",
      "noise_type": "Rauschtyp",
      "envelope": "Hüllkurve",
      "attack": "Attack",
      "sustain": "Sustain",
      "release": "Release",
      "envelope_curves": "Hüllkurvenformen",
      "attack_curve": "Attack",
      "decay_curve": "Decay",
      "release_curve": "Release",
      "filter_advanced": "Erw. Filter",
      "filter_rolloff": "Flankensteilheit",
      "filter_gain": "Gain (dB)",
      "filter_envelope": "Filterhüllkurve",
      "base_frequency": "Grundfrequenz",
      "exponent": "Exponent",
      "modulation": "Modulation",
      "modulation_envelope": "Modulationshüllkurve",
      "special_parameters": "Spezialparameter",
      "pitch_decay": "Tonhöhenabfall",
      "attack_noise": "Attack-Rauschen",
      "dampening": "Dämpfung",
      "resonance": "Resonanz",
      "lfo": "LFO",
      "lfo_type": "Typ",
      "lfo_target": "Ziel",
      "lfo_min": "Min.",
      "lfo_max": "Max.",
      "save_preset_title": "Sound-Preset Speichern",
      "preset_name_label": "Preset-Name:",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_fx_chain_title": "Effektkette Speichern",
      "fx_chain_name_label": "Name der Kette:",
      "fx_chain_name_placeholder": "Meine Effektkette",
      "cancel": "Abbrechen",
      "save": "Speichern",
      "major": "Dur",
      "minor": "Moll",
      "pentatonic": "Pentatonisch",
      "blues": "Blues",
      "chromatic": "Chromatisch",
      "dorian": "Dorisch",
      "phrygian": "Phrygisch",
      "lydian": "Lydisch",
      "mixolydian": "Mixolydisch",
      "locrian": "Lokrisch",
      "day": "Tag",
      "night": "Nacht",
      "neon": "Neon",
      "retro": "Retro",
      "pastel": "Pastell",
      "aurora": "Aurora",
      "ocean": "Ozean",
      "cyberpunk": "Cyberpunk",
      "fire": "Feuer",
      "matrix": "Matrix",
      "hologram": "Hologramm",
      "crystal": "Kristall",
      "galaxy": "Galaxie",
      "waves": "Wellen",
      "spectrum": "Spektrum",
      "particles": "Fischschwarm",
      "nebula": "Nebel",
      "reactive_ripples": "Reaktive Wellen",
      "touch_trails": "Touch-Spuren",
      "loading": "Laden...",
      "initializing": "Initialisiere...",
      "loading_bridge": "Verbinde...",
      "loading_settings": "Lade Einstellungen...",
      "loading_modules": "Lade Module...",
      "loading_ui": "Initialisiere UI...",
      "loading_presets": "Wende Einstellungen an...",
      "loading_audio": "Lade Sounds...",
      "tap_to_start": "Tippen, um Audio zu starten",
      "starting_audio": "Starte Audio...",
      "audio_suspended": "Audio pausiert. Tippen zum Fortsetzen.",
      "loading_preset": "Lade Preset...",
      "loading_fxchain": "Lade FX-Kette...",
      "saving_preset_progress": "Speichere Preset...",
      "saving_fxchain_progress": "Speichere FX-Kette...",
      "deleting_preset_progress": "Lösche Preset...",
      "deleting_fxchain_progress": "Lösche FX-Kette...",
      "hit_play_vibe": "Drück Play, Fühl den Vibe",
      "error_bridge_failed": "Fehler: Bridge-Verbindung fehlgeschlagen.",
      "error_init_failed": "Initialisierungsfehler. Konsole prüfen.",
      "error_init_failed_details": "Initialisierungsfehler: ${error}. Konsole prüfen.",
      "error_fatal_init": "Kritischer Initialisierungsfehler. Bitte neu starten.",
      "error_audio_failed_retry": "Fehler beim Starten von Audio. Bitte erneut tippen.",
      "error_audio_resume": "Audio konnte nicht fortgesetzt werden.",
      "error_apply_preset": "Fehler beim Anwenden des Presets.",
      "error_apply_fxchain": "Fehler beim Anwenden der FX-Kette.",
      "error_loading_presets": "Fehler beim Laden der Presets.",
      "error_loading_fxchains": "Fehler beim Laden der Ketten",
      "error_loading_effects_ui": "Fehler beim Laden der Effekt-UI.",
      "no_presets_found": "Keine Presets gefunden.",
      "no_fxchains_found": "Keine FX-Ketten gefunden",
      "no_effects_available": "Keine Effekte verfügbar.",
      "enter_preset_name": "Bitte gib einen Preset-Namen ein.",
      "enter_fxchain_name": "Bitte gib einen FX-Ketten-Namen ein.",
      "preset_saved_success": "Preset \"${name}\" erfolgreich gespeichert!",
      "fxchain_saved_success": "FX-Kette \"${name}\" erfolgreich gespeichert!",
      "error_saving_preset": "Fehler beim Speichern des Presets: ${error}",
      "error_saving_fxchain": "Fehler beim Speichern der FX-Kette: ${error}",
      "exception_saving_preset": "Ausnahme beim Speichern des Presets: ${error}",
      "exception_saving_fxchain": "Ausnahme beim Speichern der FX-Kette: ${error}",
      "confirm_delete_preset": "Preset \"${name}\" wirklich löschen?",
      "confirm_delete_fxchain": "FX-Kette \"${name}\" wirklich löschen?",
      "cannot_delete_default_preset": "Standard-Presets können nicht gelöscht werden.",
      "cannot_delete_default_fxchain": "Standard-FX-Ketten können nicht gelöscht werden.",
      "preset_deleted_success": "Preset gelöscht.",
      "fxchain_deleted_success": "FX-Kette gelöscht.",
      "preset_delete_failed": "Preset konnte nicht gelöscht werden.",
      "fxchain_delete_failed": "FX-Kette konnte nicht gelöscht werden.",
      "exception_deleting_preset": "Ausnahme beim Löschen des Presets: ${error}",
      "exception_deleting_fxchain": "Ausnahme beim Löschen der FX-Kette: ${error}",
      "audio_not_ready_record": "Audio nicht bereit. Aufnahme kann nicht gestartet werden.",
      "pitch_envelope": "Tonhöhen-Hüllkurve",
      "pitch_amount_cents": "Betrag (Cents)",
      "macro_controls_title": "Makro-Regler",
      "macro_space": "Raum",
      "macro_time": "Zeit",
      "macro_motion": "Bewegung",
      "macro_tone": "Klangfarbe",
      "macro_drive": "Drive",
      "effects_intensity_min": "FX-Intensität Min. (dB)",
      "effects_intensity_max": "FX-Intensität Max. (dB)",
      "effects_threshold": "FX-Schwelle",
      "none_fxchain": "-- Keine --",
      "none_touch_effect": "Kein",
      "restart_audio_engine_button": "Audio Neustart",
      "reload_app_button_title": "App Neu Laden",
      "reloading_app_message": "App wird neu geladen...",
      "master_output_title": "Master-Ausgang",
      "master_volume_ceiling": "Lautstärke-Limit",
      "master_volume_ceiling_label": "Lautstärke-Limit",
      "y_axis_volume_min_output": "Min. Ausgabe",
      "y_axis_volume_max_output": "Max. Ausgabe",
      "y_axis_volume_y_threshold": "Y-Schwelle",
      "y_axis_curve_type": "Kurventyp",
      "y_axis_curve_factor": "Kurvenfaktor",
      "y_axis_effects_min_output": "Min. Ausgabe (dB)",
      "y_axis_effects_max_output": "Max. Ausgabe (dB)",
      "y_axis_effects_y_threshold": "Y-Schwelle",
      "logarithmic": "Logarithmisch",
      "s_curve": "S-Kurve",
      "select_option": "Option Auswählen",
      "no_options_found": "Keine Optionen gefunden",
      "error_loading_options": "Fehler beim Laden der Optionen.",
      "pad_modes_button": "Modi",
      "pad_modes_button_title": "Pad-Modi",
      "pad_modes_panel_title": "Pad-Modi",
      "pad_mode_label": "Pad-Modus",
      "pad_mode_select_title": "Pad-Modus Auswählen",
      "pad_mode_classic": "Klassisch",
      "pad_mode_reactive": "Reaktiv",
      "reactive_mode_show_suggestions": "Harm. Hinweise Anzeigen",
      "reactive_mode_suggestion_count": "Anz. Hinweise",
      "no_specific_settings_classic": "Keine spezifischen Einstellungen für Klassisch-Modus.",
      "no_specific_settings_reactive": "Hinweise für Reaktiv-Modus konfigurieren.",
      "pad_mode_rocket": "Rakete",
      "rocket_highlight_active": "Aktive Noten Hervorheben",
      "rocket_show_markers": "Direktionale Marker Anzeigen",
      "rocket_marker_style": "Marker-Stil",
      "rocket_valid_chords_only": "Marker Nur für Valide Akkorde",
      "rocket_animate_fade": "Marker-Ausblendung Animieren",
      "rocket_show_chord_name": "Erkannten Akkordnamen Anzeigen",
      "style_GlowFromNote": "Glühen von Note",
      "style_WaveToNote": "Welle zu Note",
      "style_PulseRing": "Pulsierender Ring",
      "style_SparkTrail": "Funkenpfad",
      "style_ShadowDrop": "Schatten unter Note",
      "rocket_mode_panel_title": "Raketenmodus",
      "rocket_mode_enable": "Raketenmodus Aktivieren",
      "rocket_mode_settings_placeholder": "Einstellungen für den Raketenmodus erscheinen hier.",
      "error_loading_mode_settings": "Fehler beim Laden der Modus-Einstellungen.",
      "no_specific_settings_rocket": "Spezifische Einstellungen für den Raketenmodus konfigurieren.",
      "reset_settings_button": "Alle Einstellungen Zurücksetzen",
      "reload_app_button": "App Vollständig Neu Laden",
      "restart_audio_button": "Audio-Engine Neu Starten",
      "rocket_section_general": "Allgemein",
      "rocket_section_phases": "Phasen",
      "rocket_section_harmonic_logic": "Harmonische Logik",
      "rocket_section_interactive_behavior": "Interaktives Verhalten",
      "rocket_intensity": "Intensität",
      "rocket_visual_theme": "Visuelles Thema",
      "rocket_auto_phases": "Auto-Phasen",
      "rocket_harmonic_key": "Harmonischer Schlüssel",
      "rocket_marker_logic": "Marker-Logik",
      "marker_logic_tonal": "Tonale Bindung",
      "marker_logic_adaptive": "Adaptive Analyse",
      "marker_logic_semi_free": "Halbfrei",
      "marker_logic_random": "Zufällig Gerichtet",
      "rocket_phase_ignition": "Zündung",
      "rocket_phase_lift_off": "Start",
      "rocket_phase_burst": "Ausbruch",
      "rocket_phase_transition": "Phasenübergang",
      "phase_mode_activity": "Nach Aktivität",
      "phase_mode_time": "Nach Zeit",
      "phase_mode_manual": "Manuell",
      "status_chord": "Akkord",
      "status_key": "Tonart",
      "status_next": "Nächstes",
      "status_energy": "Energie",
      "status_phase": "Phase",
      "status_na": "N/A",
      "rocket_presets_title": "Modus-Presets",
      "rocket_select_preset": "Preset Auswählen",
      "rocket_select_preset_title": "Raketenmodus-Preset Auswählen",
      "rocket_preset_current": "Aktuelle Einstellungen",
      "none_selected": "Keine",
      "preset_rocket_melodic_drift": "Melodischer Drift",
      "desc_rocket_melodic_drift": "Sanfte, schwebende, halbfreie harmonische Logik.",
      "preset_rocket_jazz_climb": "Jazz-Aufstieg",
      "desc_rocket_jazz_climb": "Aktive, adaptive, jazz-inspirierte Logik.",
      "rocket_marker_labels": "Marker-Beschriftungen",
      "labels_none": "Keine",
      "labels_function": "Funktion (T/S/D)",
      "labels_chord_name": "Akkordname",
      "rocket_marker_retention": "Marker-Beibehaltung",
      "desc_rocket_marker_retention": "Relevante Marker bei neuen Berührungen sichtbar halten.",
      "desc_rocket_animate_fade": "Nicht relevante Marker sanft ausblenden.",
      "rocket_fade_delay": "Ausblendverzögerung",
      "desc_rocket_fade_delay": "Verzögerung, bevor Marker auszublenden beginnt.",
      "rocket_fade_duration": "Ausblenddauer",
      "desc_rocket_fade_duration": "Dauer der Marker-Ausblendanimation.",
      "rocket_max_markers_zone": "Max Marker/Zone",
      "desc_rocket_max_markers_zone": "Max. Vorschläge pro Zone.",
      "rocket_phase_styles": "Phasen-Stile",
      "desc_rocket_phase_styles": "Aktueller Phase erlauben, Marker-Stil zu überschreiben.",
      "rocket_tb_in_key": "Ton. Bind.: Nur in Tonart",
      "desc_rocket_tb_in_key": "Nur Noten/Akkorde der aktuellen Tonart vorschlagen.",
      "rocket_aa_autokey": "Adap. An.: Auto Tonartwechsel",
      "desc_rocket_aa_autokey": "Adaptiven Tonartwechsel basierend auf Eingabe erlauben.",
      "rocket_sf_basekey": "Halbfrei: Grundtonart",
      "desc_rocket_sf_basekey": "Grundtonart für halbfreien Modus.",
      "rocket_sf_deviations": "Halbfrei: Modale Abweichungen",
      "desc_rocket_sf_deviations": "Temporäre Abweichungen von Grundtonart erlauben.",
      "rocket_sf_return": "Halbfrei: Rückkehr hervorheben",
      "desc_rocket_sf_return": "Vorschläge hervorheben, die zur Grundtonart zurückkehren.",
      "rocket_rd_randomlevel": "Zufallsniveau",
      "desc_rocket_rd_randomlevel": "Niveau der Zufälligkeit in Vorschlägen.",
      "select_chord": "Akkord Auswählen",
      "select_key": "Tonart Auswählen",
      "select_phase": "Phase Auswählen",
      "no_language_found": "Keine Sprachen gefunden",
      "no_theme_found": "Keine Themen gefunden",
      "no_visualizer_found": "Keine Visualisierer gefunden",
      "no_touchEffect_found": "Keine Touch-Effekte gefunden",
      "no_scale_found": "Keine Tonleitern gefunden",
      "no_fxChain_found": "Keine FX-Ketten gefunden",
      "error_audio_fatal_restart": "Kritischer Audiofehler. Bitte starten Sie die App neu.",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_preset": "Neuen Sound Speichern",
      "delete_preset": "Sound Löschen",
      "synth_controls": "Synth-Steuerung",
      "synth_type": "Synth-Typ",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "Oszillator-Typ",
      "sine": "Sinus",
      "square": "Rechteck",
      "sawtooth": "Sägezahn",
      "triangle": "Dreieck",
      "fat_sine": "Fat Sinus",
      "fat_square": "Fat Rechteck",
      "fat_sawtooth": "Fat Sägezahn",
      "fat_triangle": "Fat Dreieck",
      "fm_sine": "FM Sinus",
      "fm_square": "FM Rechteck",
      "fm_sawtooth": "FM Sägezahn",
      "fm_triangle": "FM Dreieck",
      "am_sine": "AM Sinus",
      "am_square": "AM Rechteck",
      "am_sawtooth": "AM Sägezahn",
      "am_triangle": "AM Dreieck",
      "pwm": "PWM",
      "pulse": "Puls",
      "noise_white": "Weißes Rauschen",
      "noise_pink": "Rosa Rauschen",
      "noise_brown": "Braunes Rauschen",
      "oscillator_params": "Oszillator-Parameter",
      "phase": "Phase",
      "count": "Anzahl",
      "spread": "Streuung",
      "width": "Breite",
      "mod_freq_short": "Mod.-Frequenz",
      "harmonicity": "Harmonizität",
      "mod_index": "Mod.-Index",
      "mod_type": "Mod.-Typ",
      "noise_type": "Rauschtyp",
      "envelope": "Hüllkurve",
      "attack": "Attack",
      "sustain": "Sustain",
      "release": "Release",
      "envelope_curves": "Hüllkurvenformen",
      "attack_curve": "Attack",
      "decay_curve": "Decay",
      "release_curve": "Release",
      "filter_advanced": "Erw. Filter",
      "filter_rolloff": "Flankensteilheit",
      "filter_gain": "Gain (dB)",
      "filter_envelope": "Filterhüllkurve",
      "base_frequency": "Grundfrequenz",
      "exponent": "Exponent",
      "modulation": "Modulation",
      "modulation_envelope": "Modulationshüllkurve",
      "special_parameters": "Spezialparameter",
      "pitch_decay": "Tonhöhenabfall",
      "attack_noise": "Attack-Rauschen",
      "dampening": "Dämpfung",
      "resonance": "Resonanz",
      "lfo": "LFO",
      "lfo_type": "Typ",
      "lfo_target": "Ziel",
      "lfo_min": "Min.",
      "lfo_max": "Max.",
      "save_preset_title": "Sound-Preset Speichern",
      "preset_name_label": "Preset-Name:",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_fx_chain_title": "Effektkette Speichern",
      "fx_chain_name_label": "Name der Kette:",
      "fx_chain_name_placeholder": "Meine Effektkette",
      "cancel": "Abbrechen",
      "save": "Speichern",
      "major": "Dur",
      "minor": "Moll",
      "pentatonic": "Pentatonisch",
      "blues": "Blues",
      "chromatic": "Chromatisch",
      "dorian": "Dorisch",
      "phrygian": "Phrygisch",
      "lydian": "Lydisch",
      "mixolydian": "Mixolydisch",
      "locrian": "Lokrisch",
      "day": "Tag",
      "night": "Nacht",
      "neon": "Neon",
      "retro": "Retro",
      "pastel": "Pastell",
      "aurora": "Aurora",
      "ocean": "Ozean",
      "cyberpunk": "Cyberpunk",
      "fire": "Feuer",
      "matrix": "Matrix",
      "hologram": "Hologramm",
      "crystal": "Kristall",
      "galaxy": "Galaxie",
      "waves": "Wellen",
      "spectrum": "Spektrum",
      "particles": "Fischschwarm",
      "nebula": "Nebel",
      "reactive_ripples": "Reaktive Wellen",
      "touch_trails": "Touch-Spuren",
      "loading": "Laden...",
      "initializing": "Initialisiere...",
      "loading_bridge": "Verbinde...",
      "loading_settings": "Lade Einstellungen...",
      "loading_modules": "Lade Module...",
      "loading_ui": "Initialisiere UI...",
      "loading_presets": "Wende Einstellungen an...",
      "loading_audio": "Lade Sounds...",
      "tap_to_start": "Tippen, um Audio zu starten",
      "starting_audio": "Starte Audio...",
      "audio_suspended": "Audio pausiert. Tippen zum Fortsetzen.",
      "loading_preset": "Lade Preset...",
      "loading_fxchain": "Lade FX-Kette...",
      "saving_preset_progress": "Speichere Preset...",
      "saving_fxchain_progress": "Speichere FX-Kette...",
      "deleting_preset_progress": "Lösche Preset...",
      "deleting_fxchain_progress": "Lösche FX-Kette...",
      "hit_play_vibe": "Drück Play, Fühl den Vibe",
      "error_bridge_failed": "Fehler: Bridge-Verbindung fehlgeschlagen.",
      "error_init_failed": "Initialisierungsfehler. Konsole prüfen.",
      "error_init_failed_details": "Initialisierungsfehler: ${error}. Konsole prüfen.",
      "error_fatal_init": "Kritischer Initialisierungsfehler. Bitte neu starten.",
      "error_audio_failed_retry": "Fehler beim Starten von Audio. Bitte erneut tippen.",
      "error_audio_resume": "Audio konnte nicht fortgesetzt werden.",
      "error_apply_preset": "Fehler beim Anwenden des Presets.",
      "error_apply_fxchain": "Fehler beim Anwenden der FX-Kette.",
      "error_loading_presets": "Fehler beim Laden der Presets.",
      "error_loading_fxchains": "Fehler beim Laden der Ketten",
      "error_loading_effects_ui": "Fehler beim Laden der Effekt-UI.",
      "no_presets_found": "Keine Presets gefunden.",
      "no_fxchains_found": "Keine FX-Ketten gefunden",
      "no_effects_available": "Keine Effekte verfügbar.",
      "enter_preset_name": "Bitte gib einen Preset-Namen ein.",
      "enter_fxchain_name": "Bitte gib einen FX-Ketten-Namen ein.",
      "preset_saved_success": "Preset \"${name}\" erfolgreich gespeichert!",
      "fxchain_saved_success": "FX-Kette \"${name}\" erfolgreich gespeichert!",
      "error_saving_preset": "Fehler beim Speichern des Presets: ${error}",
      "error_saving_fxchain": "Fehler beim Speichern der FX-Kette: ${error}",
      "exception_saving_preset": "Ausnahme beim Speichern des Presets: ${error}",
      "exception_saving_fxchain": "Ausnahme beim Speichern der FX-Kette: ${error}",
      "confirm_delete_preset": "Preset \"${name}\" wirklich löschen?",
      "confirm_delete_fxchain": "FX-Kette \"${name}\" wirklich löschen?",
      "cannot_delete_default_preset": "Standard-Presets können nicht gelöscht werden.",
      "cannot_delete_default_fxchain": "Standard-FX-Ketten können nicht gelöscht werden.",
      "preset_deleted_success": "Preset gelöscht.",
      "fxchain_deleted_success": "FX-Kette gelöscht.",
      "preset_delete_failed": "Preset konnte nicht gelöscht werden.",
      "fxchain_delete_failed": "FX-Kette konnte nicht gelöscht werden.",
      "exception_deleting_preset": "Ausnahme beim Löschen des Presets: ${error}",
      "exception_deleting_fxchain": "Ausnahme beim Löschen der FX-Kette: ${error}",
      "audio_not_ready_record": "Audio nicht bereit. Aufnahme kann nicht gestartet werden.",
      "pitch_envelope": "Tonhöhen-Hüllkurve",
      "pitch_amount_cents": "Betrag (Cents)",
      "macro_controls_title": "Makro-Regler",
      "macro_space": "Raum",
      "macro_time": "Zeit",
      "macro_motion": "Bewegung",
      "macro_tone": "Klangfarbe",
      "macro_drive": "Drive",
      "effects_intensity_min": "FX-Intensität Min. (dB)",
      "effects_intensity_max": "FX-Intensität Max. (dB)",
      "effects_threshold": "FX-Schwelle",
      "none_fxchain": "-- Keine --",
      "none_touch_effect": "Kein",
      "restart_audio_engine_button": "Audio Neustart",
      "reload_app_button_title": "App Neu Laden",
      "reloading_app_message": "App wird neu geladen...",
      "master_output_title": "Master-Ausgang",
      "master_volume_ceiling": "Lautstärke-Limit",
      "master_volume_ceiling_label": "Lautstärke-Limit",
      "y_axis_volume_min_output": "Min. Ausgabe",
      "y_axis_volume_max_output": "Max. Ausgabe",
      "y_axis_volume_y_threshold": "Y-Schwelle",
      "y_axis_curve_type": "Kurventyp",
      "y_axis_curve_factor": "Kurvenfaktor",
      "y_axis_effects_min_output": "Min. Ausgabe (dB)",
      "y_axis_effects_max_output": "Max. Ausgabe (dB)",
      "y_axis_effects_y_threshold": "Y-Schwelle",
      "logarithmic": "Logarithmisch",
      "s_curve": "S-Kurve",
      "select_option": "Option Auswählen",
      "no_options_found": "Keine Optionen gefunden",
      "error_loading_options": "Fehler beim Laden der Optionen.",
      "pad_modes_button": "Modi",
      "pad_modes_button_title": "Pad-Modi",
      "pad_modes_panel_title": "Pad-Modi",
      "pad_mode_label": "Pad-Modus",
      "pad_mode_select_title": "Pad-Modus Auswählen",
      "pad_mode_classic": "Klassisch",
      "pad_mode_reactive": "Reaktiv",
      "reactive_mode_show_suggestions": "Harm. Hinweise Anzeigen",
      "reactive_mode_suggestion_count": "Anz. Hinweise",
      "no_specific_settings_classic": "Keine spezifischen Einstellungen für Klassisch-Modus.",
      "no_specific_settings_reactive": "Hinweise für Reaktiv-Modus konfigurieren.",
      "pad_mode_rocket": "Rakete",
      "rocket_highlight_active": "Aktive Noten Hervorheben",
      "rocket_show_markers": "Direktionale Marker Anzeigen",
      "rocket_marker_style": "Marker-Stil",
      "rocket_valid_chords_only": "Marker Nur für Valide Akkorde",
      "rocket_animate_fade": "Marker-Ausblendung Animieren",
      "rocket_show_chord_name": "Erkannten Akkordnamen Anzeigen",
      "style_GlowFromNote": "Glühen von Note",
      "style_WaveToNote": "Welle zu Note",
      "style_PulseRing": "Pulsierender Ring",
      "style_SparkTrail": "Funkenpfad",
      "style_ShadowDrop": "Schatten unter Note",
      "rocket_mode_panel_title": "Raketenmodus",
      "rocket_mode_enable": "Raketenmodus Aktivieren",
      "rocket_mode_settings_placeholder": "Einstellungen für den Raketenmodus erscheinen hier.",
      "error_loading_mode_settings": "Fehler beim Laden der Modus-Einstellungen.",
      "no_specific_settings_rocket": "Spezifische Einstellungen für den Raketenmodus konfigurieren.",
      "reset_settings_button": "Alle Einstellungen Zurücksetzen",
      "reload_app_button": "App Vollständig Neu Laden",
      "restart_audio_button": "Audio-Engine Neu Starten",
      "rocket_section_general": "Allgemein",
      "rocket_section_phases": "Phasen",
      "rocket_section_harmonic_logic": "Harmonische Logik",
      "rocket_section_interactive_behavior": "Interaktives Verhalten",
      "rocket_intensity": "Intensität",
      "rocket_visual_theme": "Visuelles Thema",
      "rocket_auto_phases": "Auto-Phasen",
      "rocket_harmonic_key": "Harmonischer Schlüssel",
      "rocket_marker_logic": "Marker-Logik",
      "marker_logic_tonal": "Tonale Bindung",
      "marker_logic_adaptive": "Adaptive Analyse",
      "marker_logic_semi_free": "Halbfrei",
      "marker_logic_random": "Zufällig Gerichtet",
      "rocket_phase_ignition": "Zündung",
      "rocket_phase_lift_off": "Start",
      "rocket_phase_burst": "Ausbruch",
      "rocket_phase_transition": "Phasenübergang",
      "phase_mode_activity": "Nach Aktivität",
      "phase_mode_time": "Nach Zeit",
      "phase_mode_manual": "Manuell",
      "status_chord": "Akkord",
      "status_key": "Tonart",
      "status_next": "Nächstes",
      "status_energy": "Energie",
      "status_phase": "Phase",
      "status_na": "N/A",
      "rocket_presets_title": "Modus-Presets",
      "rocket_select_preset": "Preset Auswählen",
      "rocket_select_preset_title": "Raketenmodus-Preset Auswählen",
      "rocket_preset_current": "Aktuelle Einstellungen",
      "none_selected": "Keine",
      "preset_rocket_melodic_drift": "Melodischer Drift",
      "desc_rocket_melodic_drift": "Sanfte, schwebende, halbfreie harmonische Logik.",
      "preset_rocket_jazz_climb": "Jazz-Aufstieg",
      "desc_rocket_jazz_climb": "Aktive, adaptive, jazz-inspirierte Logik.",
      "rocket_marker_labels": "Marker-Beschriftungen",
      "labels_none": "Keine",
      "labels_function": "Funktion (T/S/D)",
      "labels_chord_name": "Akkordname",
      "rocket_marker_retention": "Marker-Beibehaltung",
      "desc_rocket_marker_retention": "Relevante Marker bei neuen Berührungen sichtbar halten.",
      "desc_rocket_animate_fade": "Nicht relevante Marker sanft ausblenden.",
      "rocket_fade_delay": "Ausblendverzögerung",
      "desc_rocket_fade_delay": "Verzögerung, bevor Marker auszublenden beginnt.",
      "rocket_fade_duration": "Ausblenddauer",
      "desc_rocket_fade_duration": "Dauer der Marker-Ausblendanimation.",
      "rocket_max_markers_zone": "Max Marker/Zone",
      "desc_rocket_max_markers_zone": "Max. Vorschläge pro Zone.",
      "rocket_phase_styles": "Phasen-Stile",
      "desc_rocket_phase_styles": "Aktueller Phase erlauben, Marker-Stil zu überschreiben.",
      "rocket_tb_in_key": "Ton. Bind.: Nur in Tonart",
      "desc_rocket_tb_in_key": "Nur Noten/Akkorde der aktuellen Tonart vorschlagen.",
      "rocket_aa_autokey": "Adap. An.: Auto Tonartwechsel",
      "desc_rocket_aa_autokey": "Adaptiven Tonartwechsel basierend auf Eingabe erlauben.",
      "rocket_sf_basekey": "Halbfrei: Grundtonart",
      "desc_rocket_sf_basekey": "Grundtonart für halbfreien Modus.",
      "rocket_sf_deviations": "Halbfrei: Modale Abweichungen",
      "desc_rocket_sf_deviations": "Temporäre Abweichungen von Grundtonart erlauben.",
      "rocket_sf_return": "Halbfrei: Rückkehr hervorheben",
      "desc_rocket_sf_return": "Vorschläge hervorheben, die zur Grundtonart zurückkehren.",
      "rocket_rd_randomlevel": "Zufallsniveau",
      "desc_rocket_rd_randomlevel": "Niveau der Zufälligkeit in Vorschlägen.",
      "select_chord": "Akkord Auswählen",
      "select_key": "Tonart Auswählen",
      "select_phase": "Phase Auswählen",
      "no_language_found": "Keine Sprachen gefunden",
      "no_theme_found": "Keine Themen gefunden",
      "no_visualizer_found": "Keine Visualisierer gefunden",
      "no_touchEffect_found": "Keine Touch-Effekte gefunden",
      "no_scale_found": "Keine Tonleitern gefunden",
      "no_fxChain_found": "Keine FX-Ketten gefunden",
      "error_audio_fatal_restart": "Kritischer Audiofehler. Bitte starten Sie die App neu.",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_preset": "Neuen Sound Speichern",
      "delete_preset": "Sound Löschen",
      "synth_controls": "Synth-Steuerung",
      "synth_type": "Synth-Typ",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "Oszillator-Typ",
      "sine": "Sinus",
      "square": "Rechteck",
      "sawtooth": "Sägezahn",
      "triangle": "Dreieck",
      "fat_sine": "Fat Sinus",
      "fat_square": "Fat Rechteck",
      "fat_sawtooth": "Fat Sägezahn",
      "fat_triangle": "Fat Dreieck",
      "fm_sine": "FM Sinus",
      "fm_square": "FM Rechteck",
      "fm_sawtooth": "FM Sägezahn",
      "fm_triangle": "FM Dreieck",
      "am_sine": "AM Sinus",
      "am_square": "AM Rechteck",
      "am_sawtooth": "AM Sägezahn",
      "am_triangle": "AM Dreieck",
      "pwm": "PWM",
      "pulse": "Puls",
      "noise_white": "Weißes Rauschen",
      "noise_pink": "Rosa Rauschen",
      "noise_brown": "Braunes Rauschen",
      "oscillator_params": "Oszillator-Parameter",
      "phase": "Phase",
      "count": "Anzahl",
      "spread": "Streuung",
      "width": "Breite",
      "mod_freq_short": "Mod.-Frequenz",
      "harmonicity": "Harmonizität",
      "mod_index": "Mod.-Index",
      "mod_type": "Mod.-Typ",
      "noise_type": "Rauschtyp",
      "envelope": "Hüllkurve",
      "attack": "Attack",
      "sustain": "Sustain",
      "release": "Release",
      "envelope_curves": "Hüllkurvenformen",
      "attack_curve": "Attack",
      "decay_curve": "Decay",
      "release_curve": "Release",
      "filter_advanced": "Erw. Filter",
      "filter_rolloff": "Flankensteilheit",
      "filter_gain": "Gain (dB)",
      "filter_envelope": "Filterhüllkurve",
      "base_frequency": "Grundfrequenz",
      "exponent": "Exponent",
      "modulation": "Modulation",
      "modulation_envelope": "Modulationshüllkurve",
      "special_parameters": "Spezialparameter",
      "pitch_decay": "Tonhöhenabfall",
      "attack_noise": "Attack-Rauschen",
      "dampening": "Dämpfung",
      "resonance": "Resonanz",
      "lfo": "LFO",
      "lfo_type": "Typ",
      "lfo_target": "Ziel",
      "lfo_min": "Min.",
      "lfo_max": "Max.",
      "save_preset_title": "Sound-Preset Speichern",
      "preset_name_label": "Preset-Name:",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_fx_chain_title": "Effektkette Speichern",
      "fx_chain_name_label": "Name der Kette:",
      "fx_chain_name_placeholder": "Meine Effektkette",
      "cancel": "Abbrechen",
      "save": "Speichern",
      "major": "Dur",
      "minor": "Moll",
      "pentatonic": "Pentatonisch",
      "blues": "Blues",
      "chromatic": "Chromatisch",
      "dorian": "Dorisch",
      "phrygian": "Phrygisch",
      "lydian": "Lydisch",
      "mixolydian": "Mixolydisch",
      "locrian": "Lokrisch",
      "day": "Tag",
      "night": "Nacht",
      "neon": "Neon",
      "retro": "Retro",
      "pastel": "Pastell",
      "aurora": "Aurora",
      "ocean": "Ozean",
      "cyberpunk": "Cyberpunk",
      "fire": "Feuer",
      "matrix": "Matrix",
      "hologram": "Hologramm",
      "crystal": "Kristall",
      "galaxy": "Galaxie",
      "waves": "Wellen",
      "spectrum": "Spektrum",
      "particles": "Fischschwarm",
      "nebula": "Nebel",
      "reactive_ripples": "Reaktive Wellen",
      "touch_trails": "Touch-Spuren",
      "loading": "Laden...",
      "initializing": "Initialisiere...",
      "loading_bridge": "Verbinde...",
      "loading_settings": "Lade Einstellungen...",
      "loading_modules": "Lade Module...",
      "loading_ui": "Initialisiere UI...",
      "loading_presets": "Wende Einstellungen an...",
      "loading_audio": "Lade Sounds...",
      "tap_to_start": "Tippen, um Audio zu starten",
      "starting_audio": "Starte Audio...",
      "audio_suspended": "Audio pausiert. Tippen zum Fortsetzen.",
      "loading_preset": "Lade Preset...",
      "loading_fxchain": "Lade FX-Kette...",
      "saving_preset_progress": "Speichere Preset...",
      "saving_fxchain_progress": "Speichere FX-Kette...",
      "deleting_preset_progress": "Lösche Preset...",
      "deleting_fxchain_progress": "Lösche FX-Kette...",
      "hit_play_vibe": "Drück Play, Fühl den Vibe",
      "error_bridge_failed": "Fehler: Bridge-Verbindung fehlgeschlagen.",
      "error_init_failed": "Initialisierungsfehler. Konsole prüfen.",
      "error_init_failed_details": "Initialisierungsfehler: ${error}. Konsole prüfen.",
      "error_fatal_init": "Kritischer Initialisierungsfehler. Bitte neu starten.",
      "error_audio_failed_retry": "Fehler beim Starten von Audio. Bitte erneut tippen.",
      "error_audio_resume": "Audio konnte nicht fortgesetzt werden.",
      "error_apply_preset": "Fehler beim Anwenden des Presets.",
      "error_apply_fxchain": "Fehler beim Anwenden der FX-Kette.",
      "error_loading_presets": "Fehler beim Laden der Presets.",
      "error_loading_fxchains": "Fehler beim Laden der Ketten",
      "error_loading_effects_ui": "Fehler beim Laden der Effekt-UI.",
      "no_presets_found": "Keine Presets gefunden.",
      "no_fxchains_found": "Keine FX-Ketten gefunden",
      "no_effects_available": "Keine Effekte verfügbar.",
      "enter_preset_name": "Bitte gib einen Preset-Namen ein.",
      "enter_fxchain_name": "Bitte gib einen FX-Ketten-Namen ein.",
      "preset_saved_success": "Preset \"${name}\" erfolgreich gespeichert!",
      "fxchain_saved_success": "FX-Kette \"${name}\" erfolgreich gespeichert!",
      "error_saving_preset": "Fehler beim Speichern des Presets: ${error}",
      "error_saving_fxchain": "Fehler beim Speichern der FX-Kette: ${error}",
      "exception_saving_preset": "Ausnahme beim Speichern des Presets: ${error}",
      "exception_saving_fxchain": "Ausnahme beim Speichern der FX-Kette: ${error}",
      "confirm_delete_preset": "Preset \"${name}\" wirklich löschen?",
      "confirm_delete_fxchain": "FX-Kette \"${name}\" wirklich löschen?",
      "cannot_delete_default_preset": "Standard-Presets können nicht gelöscht werden.",
      "cannot_delete_default_fxchain": "Standard-FX-Ketten können nicht gelöscht werden.",
      "preset_deleted_success": "Preset gelöscht.",
      "fxchain_deleted_success": "FX-Kette gelöscht.",
      "preset_delete_failed": "Preset konnte nicht gelöscht werden.",
      "fxchain_delete_failed": "FX-Kette konnte nicht gelöscht werden.",
      "exception_deleting_preset": "Ausnahme beim Löschen des Presets: ${error}",
      "exception_deleting_fxchain": "Ausnahme beim Löschen der FX-Kette: ${error}",
      "audio_not_ready_record": "Audio nicht bereit. Aufnahme kann nicht gestartet werden.",
      "pitch_envelope": "Tonhöhen-Hüllkurve",
      "pitch_amount_cents": "Betrag (Cents)",
      "macro_controls_title": "Makro-Regler",
      "macro_space": "Raum",
      "macro_time": "Zeit",
      "macro_motion": "Bewegung",
      "macro_tone": "Klangfarbe",
      "macro_drive": "Drive",
      "effects_intensity_min": "FX-Intensität Min. (dB)",
      "effects_intensity_max": "FX-Intensität Max. (dB)",
      "effects_threshold": "FX-Schwelle",
      "none_fxchain": "-- Keine --",
      "none_touch_effect": "Kein",
      "restart_audio_engine_button": "Audio Neustart",
      "reload_app_button_title": "App Neu Laden",
      "reloading_app_message": "App wird neu geladen...",
      "master_output_title": "Master-Ausgang",
      "master_volume_ceiling": "Lautstärke-Limit",
      "master_volume_ceiling_label": "Lautstärke-Limit",
      "y_axis_volume_min_output": "Min. Ausgabe",
      "y_axis_volume_max_output": "Max. Ausgabe",
      "y_axis_volume_y_threshold": "Y-Schwelle",
      "y_axis_curve_type": "Kurventyp",
      "y_axis_curve_factor": "Kurvenfaktor",
      "y_axis_effects_min_output": "Min. Ausgabe (dB)",
      "y_axis_effects_max_output": "Max. Ausgabe (dB)",
      "y_axis_effects_y_threshold": "Y-Schwelle",
      "logarithmic": "Logarithmisch",
      "s_curve": "S-Kurve",
      "select_option": "Option Auswählen",
      "no_options_found": "Keine Optionen gefunden",
      "error_loading_options": "Fehler beim Laden der Optionen.",
      "pad_modes_button": "Modi",
      "pad_modes_button_title": "Pad-Modi",
      "pad_modes_panel_title": "Pad-Modi",
      "pad_mode_label": "Pad-Modus",
      "pad_mode_select_title": "Pad-Modus Auswählen",
      "pad_mode_classic": "Klassisch",
      "pad_mode_reactive": "Reaktiv",
      "reactive_mode_show_suggestions": "Harm. Hinweise Anzeigen",
      "reactive_mode_suggestion_count": "Anz. Hinweise",
      "no_specific_settings_classic": "Keine spezifischen Einstellungen für Klassisch-Modus.",
      "no_specific_settings_reactive": "Hinweise für Reaktiv-Modus konfigurieren.",
      "pad_mode_rocket": "Rakete",
      "rocket_highlight_active": "Aktive Noten Hervorheben",
      "rocket_show_markers": "Direktionale Marker Anzeigen",
      "rocket_marker_style": "Marker-Stil",
      "rocket_valid_chords_only": "Marker Nur für Valide Akkorde",
      "rocket_animate_fade": "Marker-Ausblendung Animieren",
      "rocket_show_chord_name": "Erkannten Akkordnamen Anzeigen",
      "style_GlowFromNote": "Glühen von Note",
      "style_WaveToNote": "Welle zu Note",
      "style_PulseRing": "Pulsierender Ring",
      "style_SparkTrail": "Funkenpfad",
      "style_ShadowDrop": "Schatten unter Note",
      "rocket_mode_panel_title": "Raketenmodus",
      "rocket_mode_enable": "Raketenmodus Aktivieren",
      "rocket_mode_settings_placeholder": "Einstellungen für den Raketenmodus erscheinen hier.",
      "error_loading_mode_settings": "Fehler beim Laden der Modus-Einstellungen.",
      "no_specific_settings_rocket": "Spezifische Einstellungen für den Raketenmodus konfigurieren.",
      "reset_settings_button": "Alle Einstellungen Zurücksetzen",
      "reload_app_button": "App Vollständig Neu Laden",
      "restart_audio_button": "Audio-Engine Neu Starten",
      "rocket_section_general": "Allgemein",
      "rocket_section_phases": "Phasen",
      "rocket_section_harmonic_logic": "Harmonische Logik",
      "rocket_section_interactive_behavior": "Interaktives Verhalten",
      "rocket_intensity": "Intensität",
      "rocket_visual_theme": "Visuelles Thema",
      "rocket_auto_phases": "Auto-Phasen",
      "rocket_harmonic_key": "Harmonischer Schlüssel",
      "rocket_marker_logic": "Marker-Logik",
      "marker_logic_tonal": "Tonale Bindung",
      "marker_logic_adaptive": "Adaptive Analyse",
      "marker_logic_semi_free": "Halbfrei",
      "marker_logic_random": "Zufällig Gerichtet",
      "rocket_phase_ignition": "Zündung",
      "rocket_phase_lift_off": "Start",
      "rocket_phase_burst": "Ausbruch",
      "rocket_phase_transition": "Phasenübergang",
      "phase_mode_activity": "Nach Aktivität",
      "phase_mode_time": "Nach Zeit",
      "phase_mode_manual": "Manuell",
      "status_chord": "Akkord",
      "status_key": "Tonart",
      "status_next": "Nächstes",
      "status_energy": "Energie",
      "status_phase": "Phase",
      "status_na": "N/A",
      "rocket_presets_title": "Modus-Presets",
      "rocket_select_preset": "Preset Auswählen",
      "rocket_select_preset_title": "Raketenmodus-Preset Auswählen",
      "rocket_preset_current": "Aktuelle Einstellungen",
      "none_selected": "Keine",
      "preset_rocket_melodic_drift": "Melodischer Drift",
      "desc_rocket_melodic_drift": "Sanfte, schwebende, halbfreie harmonische Logik.",
      "preset_rocket_jazz_climb": "Jazz-Aufstieg",
      "desc_rocket_jazz_climb": "Aktive, adaptive, jazz-inspirierte Logik.",
      "rocket_marker_labels": "Marker-Beschriftungen",
      "labels_none": "Keine",
      "labels_function": "Funktion (T/S/D)",
      "labels_chord_name": "Akkordname",
      "rocket_marker_retention": "Marker-Beibehaltung",
      "desc_rocket_marker_retention": "Relevante Marker bei neuen Berührungen sichtbar halten.",
      "desc_rocket_animate_fade": "Nicht relevante Marker sanft ausblenden.",
      "rocket_fade_delay": "Ausblendverzögerung",
      "desc_rocket_fade_delay": "Verzögerung, bevor Marker auszublenden beginnt.",
      "rocket_fade_duration": "Ausblenddauer",
      "desc_rocket_fade_duration": "Dauer der Marker-Ausblendanimation.",
      "rocket_max_markers_zone": "Max Marker/Zone",
      "desc_rocket_max_markers_zone": "Max. Vorschläge pro Zone.",
      "rocket_phase_styles": "Phasen-Stile",
      "desc_rocket_phase_styles": "Aktueller Phase erlauben, Marker-Stil zu überschreiben.",
      "rocket_tb_in_key": "Ton. Bind.: Nur in Tonart",
      "desc_rocket_tb_in_key": "Nur Noten/Akkorde der aktuellen Tonart vorschlagen.",
      "rocket_aa_autokey": "Adap. An.: Auto Tonartwechsel",
      "desc_rocket_aa_autokey": "Adaptiven Tonartwechsel basierend auf Eingabe erlauben.",
      "rocket_sf_basekey": "Halbfrei: Grundtonart",
      "desc_rocket_sf_basekey": "Grundtonart für halbfreien Modus.",
      "rocket_sf_deviations": "Halbfrei: Modale Abweichungen",
      "desc_rocket_sf_deviations": "Temporäre Abweichungen von Grundtonart erlauben.",
      "rocket_sf_return": "Halbfrei: Rückkehr hervorheben",
      "desc_rocket_sf_return": "Vorschläge hervorheben, die zur Grundtonart zurückkehren.",
      "rocket_rd_randomlevel": "Zufallsniveau",
      "desc_rocket_rd_randomlevel": "Niveau der Zufälligkeit in Vorschlägen.",
      "select_chord": "Akkord Auswählen",
      "select_key": "Tonart Auswählen",
      "select_phase": "Phase Auswählen",
      "no_language_found": "Keine Sprachen gefunden",
      "no_theme_found": "Keine Themen gefunden",
      "no_visualizer_found": "Keine Visualisierer gefunden",
      "no_touchEffect_found": "Keine Touch-Effekte gefunden",
      "no_scale_found": "Keine Tonleitern gefunden",
      "no_fxChain_found": "Keine FX-Ketten gefunden",
      "error_audio_fatal_restart": "Kritischer Audiofehler. Bitte starten Sie die App neu.",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_preset": "Neuen Sound Speichern",
      "delete_preset": "Sound Löschen",
      "synth_controls": "Synth-Steuerung",
      "synth_type": "Synth-Typ",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "Oszillator-Typ",
      "sine": "Sinus",
      "square": "Rechteck",
      "sawtooth": "Sägezahn",
      "triangle": "Dreieck",
      "fat_sine": "Fat Sinus",
      "fat_square": "Fat Rechteck",
      "fat_sawtooth": "Fat Sägezahn",
      "fat_triangle": "Fat Dreieck",
      "fm_sine": "FM Sinus",
      "fm_square": "FM Rechteck",
      "fm_sawtooth": "FM Sägezahn",
      "fm_triangle": "FM Dreieck",
      "am_sine": "AM Sinus",
      "am_square": "AM Rechteck",
      "am_sawtooth": "AM Sägezahn",
      "am_triangle": "AM Dreieck",
      "pwm": "PWM",
      "pulse": "Puls",
      "noise_white": "Weißes Rauschen",
      "noise_pink": "Rosa Rauschen",
      "noise_brown": "Braunes Rauschen",
      "oscillator_params": "Oszillator-Parameter",
      "phase": "Phase",
      "count": "Anzahl",
      "spread": "Streuung",
      "width": "Breite",
      "mod_freq_short": "Mod.-Frequenz",
      "harmonicity": "Harmonizität",
      "mod_index": "Mod.-Index",
      "mod_type": "Mod.-Typ",
      "noise_type": "Rauschtyp",
      "envelope": "Hüllkurve",
      "attack": "Attack",
      "sustain": "Sustain",
      "release": "Release",
      "envelope_curves": "Hüllkurvenformen",
      "attack_curve": "Attack",
      "decay_curve": "Decay",
      "release_curve": "Release",
      "filter_advanced": "Erw. Filter",
      "filter_rolloff": "Flankensteilheit",
      "filter_gain": "Gain (dB)",
      "filter_envelope": "Filterhüllkurve",
      "base_frequency": "Grundfrequenz",
      "exponent": "Exponent",
      "modulation": "Modulation",
      "modulation_envelope": "Modulationshüllkurve",
      "special_parameters": "Spezialparameter",
      "pitch_decay": "Tonhöhenabfall",
      "attack_noise": "Attack-Rauschen",
      "dampening": "Dämpfung",
      "resonance": "Resonanz",
      "lfo": "LFO",
      "lfo_type": "Typ",
      "lfo_target": "Ziel",
      "lfo_min": "Min.",
      "lfo_max": "Max.",
      "save_preset_title": "Sound-Preset Speichern",
      "preset_name_label": "Preset-Name:",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_fx_chain_title": "Effektkette Speichern",
      "fx_chain_name_label": "Name der Kette:",
      "fx_chain_name_placeholder": "Meine Effektkette",
      "cancel": "Abbrechen",
      "save": "Speichern",
      "major": "Dur",
      "minor": "Moll",
      "pentatonic": "Pentatonisch",
      "blues": "Blues",
      "chromatic": "Chromatisch",
      "dorian": "Dorisch",
      "phrygian": "Phrygisch",
      "lydian": "Lydisch",
      "mixolydian": "Mixolydisch",
      "locrian": "Lokrisch",
      "day": "Tag",
      "night": "Nacht",
      "neon": "Neon",
      "retro": "Retro",
      "pastel": "Pastell",
      "aurora": "Aurora",
      "ocean": "Ozean",
      "cyberpunk": "Cyberpunk",
      "fire": "Feuer",
      "matrix": "Matrix",
      "hologram": "Hologramm",
      "crystal": "Kristall",
      "galaxy": "Galaxie",
      "waves": "Wellen",
      "spectrum": "Spektrum",
      "particles": "Fischschwarm",
      "nebula": "Nebel",
      "reactive_ripples": "Reaktive Wellen",
      "touch_trails": "Touch-Spuren",
      "loading": "Laden...",
      "initializing": "Initialisiere...",
      "loading_bridge": "Verbinde...",
      "loading_settings": "Lade Einstellungen...",
      "loading_modules": "Lade Module...",
      "loading_ui": "Initialisiere UI...",
      "loading_presets": "Wende Einstellungen an...",
      "loading_audio": "Lade Sounds...",
      "tap_to_start": "Tippen, um Audio zu starten",
      "starting_audio": "Starte Audio...",
      "audio_suspended": "Audio pausiert. Tippen zum Fortsetzen.",
      "loading_preset": "Lade Preset...",
      "loading_fxchain": "Lade FX-Kette...",
      "saving_preset_progress": "Speichere Preset...",
      "saving_fxchain_progress": "Speichere FX-Kette...",
      "deleting_preset_progress": "Lösche Preset...",
      "deleting_fxchain_progress": "Lösche FX-Kette...",
      "hit_play_vibe": "Drück Play, Fühl den Vibe",
      "error_bridge_failed": "Fehler: Bridge-Verbindung fehlgeschlagen.",
      "error_init_failed": "Initialisierungsfehler. Konsole prüfen.",
      "error_init_failed_details": "Initialisierungsfehler: ${error}. Konsole prüfen.",
      "error_fatal_init": "Kritischer Initialisierungsfehler. Bitte neu starten.",
      "error_audio_failed_retry": "Fehler beim Starten von Audio. Bitte erneut tippen.",
      "error_audio_resume": "Audio konnte nicht fortgesetzt werden.",
      "error_apply_preset": "Fehler beim Anwenden des Presets.",
      "error_apply_fxchain": "Fehler beim Anwenden der FX-Kette.",
      "error_loading_presets": "Fehler beim Laden der Presets.",
      "error_loading_fxchains": "Fehler beim Laden der Ketten",
      "error_loading_effects_ui": "Fehler beim Laden der Effekt-UI.",
      "no_presets_found": "Keine Presets gefunden.",
      "no_fxchains_found": "Keine FX-Ketten gefunden",
      "no_effects_available": "Keine Effekte verfügbar.",
      "enter_preset_name": "Bitte gib einen Preset-Namen ein.",
      "enter_fxchain_name": "Bitte gib einen FX-Ketten-Namen ein.",
      "preset_saved_success": "Preset \"${name}\" erfolgreich gespeichert!",
      "fxchain_saved_success": "FX-Kette \"${name}\" erfolgreich gespeichert!",
      "error_saving_preset": "Fehler beim Speichern des Presets: ${error}",
      "error_saving_fxchain": "Fehler beim Speichern der FX-Kette: ${error}",
      "exception_saving_preset": "Ausnahme beim Speichern des Presets: ${error}",
      "exception_saving_fxchain": "Ausnahme beim Speichern der FX-Kette: ${error}",
      "confirm_delete_preset": "Preset \"${name}\" wirklich löschen?",
      "confirm_delete_fxchain": "FX-Kette \"${name}\" wirklich löschen?",
      "cannot_delete_default_preset": "Standard-Presets können nicht gelöscht werden.",
      "cannot_delete_default_fxchain": "Standard-FX-Ketten können nicht gelöscht werden.",
      "preset_deleted_success": "Preset gelöscht.",
      "fxchain_deleted_success": "FX-Kette gelöscht.",
      "preset_delete_failed": "Preset konnte nicht gelöscht werden.",
      "fxchain_delete_failed": "FX-Kette konnte nicht gelöscht werden.",
      "exception_deleting_preset": "Ausnahme beim Löschen des Presets: ${error}",
      "exception_deleting_fxchain": "Ausnahme beim Löschen der FX-Kette: ${error}",
      "audio_not_ready_record": "Audio nicht bereit. Aufnahme kann nicht gestartet werden.",
      "pitch_envelope": "Tonhöhen-Hüllkurve",
      "pitch_amount_cents": "Betrag (Cents)",
      "macro_controls_title": "Makro-Regler",
      "macro_space": "Raum",
      "macro_time": "Zeit",
      "macro_motion": "Bewegung",
      "macro_tone": "Klangfarbe",
      "macro_drive": "Drive",
      "effects_intensity_min": "FX-Intensität Min. (dB)",
      "effects_intensity_max": "FX-Intensität Max. (dB)",
      "effects_threshold": "FX-Schwelle",
      "none_fxchain": "-- Keine --",
      "none_touch_effect": "Kein",
      "restart_audio_engine_button": "Audio Neustart",
      "reload_app_button_title": "App Neu Laden",
      "reloading_app_message": "App wird neu geladen...",
      "master_output_title": "Master-Ausgang",
      "master_volume_ceiling": "Lautstärke-Limit",
      "master_volume_ceiling_label": "Lautstärke-Limit",
      "y_axis_volume_min_output": "Min. Ausgabe",
      "y_axis_volume_max_output": "Max. Ausgabe",
      "y_axis_volume_y_threshold": "Y-Schwelle",
      "y_axis_curve_type": "Kurventyp",
      "y_axis_curve_factor": "Kurvenfaktor",
      "y_axis_effects_min_output": "Min. Ausgabe (dB)",
      "y_axis_effects_max_output": "Max. Ausgabe (dB)",
      "y_axis_effects_y_threshold": "Y-Schwelle",
      "logarithmic": "Logarithmisch",
      "s_curve": "S-Kurve",
      "select_option": "Option Auswählen",
      "no_options_found": "Keine Optionen gefunden",
      "error_loading_options": "Fehler beim Laden der Optionen.",
      "pad_modes_button": "Modi",
      "pad_modes_button_title": "Pad-Modi",
      "pad_modes_panel_title": "Pad-Modi",
      "pad_mode_label": "Pad-Modus",
      "pad_mode_select_title": "Pad-Modus Auswählen",
      "pad_mode_classic": "Klassisch",
      "pad_mode_reactive": "Reaktiv",
      "reactive_mode_show_suggestions": "Harm. Hinweise Anzeigen",
      "reactive_mode_suggestion_count": "Anz. Hinweise",
      "no_specific_settings_classic": "Keine spezifischen Einstellungen für Klassisch-Modus.",
      "no_specific_settings_reactive": "Hinweise für Reaktiv-Modus konfigurieren.",
      "pad_mode_rocket": "Rakete",
      "rocket_highlight_active": "Aktive Noten Hervorheben",
      "rocket_show_markers": "Direktionale Marker Anzeigen",
      "rocket_marker_style": "Marker-Stil",
      "rocket_valid_chords_only": "Marker Nur für Valide Akkorde",
      "rocket_animate_fade": "Marker-Ausblendung Animieren",
      "rocket_show_chord_name": "Erkannten Akkordnamen Anzeigen",
      "style_GlowFromNote": "Glühen von Note",
      "style_WaveToNote": "Welle zu Note",
      "style_PulseRing": "Pulsierender Ring",
      "style_SparkTrail": "Funkenpfad",
      "style_ShadowDrop": "Schatten unter Note",
      "rocket_mode_panel_title": "Raketenmodus",
      "rocket_mode_enable": "Raketenmodus Aktivieren",
      "rocket_mode_settings_placeholder": "Einstellungen für den Raketenmodus erscheinen hier.",
      "error_loading_mode_settings": "Fehler beim Laden der Modus-Einstellungen.",
      "no_specific_settings_rocket": "Spezifische Einstellungen für den Raketenmodus konfigurieren.",
      "reset_settings_button": "Alle Einstellungen Zurücksetzen",
      "reload_app_button": "App Vollständig Neu Laden",
      "restart_audio_button": "Audio-Engine Neu Starten",
      "rocket_section_general": "Allgemein",
      "rocket_section_phases": "Phasen",
      "rocket_section_harmonic_logic": "Harmonische Logik",
      "rocket_section_interactive_behavior": "Interaktives Verhalten",
      "rocket_intensity": "Intensität",
      "rocket_visual_theme": "Visuelles Thema",
      "rocket_auto_phases": "Auto-Phasen",
      "rocket_harmonic_key": "Harmonischer Schlüssel",
      "rocket_marker_logic": "Marker-Logik",
      "marker_logic_tonal": "Tonale Bindung",
      "marker_logic_adaptive": "Adaptive Analyse",
      "marker_logic_semi_free": "Halbfrei",
      "marker_logic_random": "Zufällig Gerichtet",
      "rocket_phase_ignition": "Zündung",
      "rocket_phase_lift_off": "Start",
      "rocket_phase_burst": "Ausbruch",
      "rocket_phase_transition": "Phasenübergang",
      "phase_mode_activity": "Nach Aktivität",
      "phase_mode_time": "Nach Zeit",
      "phase_mode_manual": "Manuell",
      "status_chord": "Akkord",
      "status_key": "Tonart",
      "status_next": "Nächstes",
      "status_energy": "Energie",
      "status_phase": "Phase",
      "status_na": "N/A",
      "rocket_presets_title": "Modus-Presets",
      "rocket_select_preset": "Preset Auswählen",
      "rocket_select_preset_title": "Raketenmodus-Preset Auswählen",
      "rocket_preset_current": "Aktuelle Einstellungen",
      "none_selected": "Keine",
      "preset_rocket_melodic_drift": "Melodischer Drift",
      "desc_rocket_melodic_drift": "Sanfte, schwebende, halbfreie harmonische Logik.",
      "preset_rocket_jazz_climb": "Jazz-Aufstieg",
      "desc_rocket_jazz_climb": "Aktive, adaptive, jazz-inspirierte Logik.",
      "rocket_marker_labels": "Marker-Beschriftungen",
      "labels_none": "Keine",
      "labels_function": "Funktion (T/S/D)",
      "labels_chord_name": "Akkordname",
      "rocket_marker_retention": "Marker-Beibehaltung",
      "desc_rocket_marker_retention": "Relevante Marker bei neuen Berührungen sichtbar halten.",
      "desc_rocket_animate_fade": "Nicht relevante Marker sanft ausblenden.",
      "rocket_fade_delay": "Ausblendverzögerung",
      "desc_rocket_fade_delay": "Verzögerung, bevor Marker auszublenden beginnt.",
      "rocket_fade_duration": "Ausblenddauer",
      "desc_rocket_fade_duration": "Dauer der Marker-Ausblendanimation.",
      "rocket_max_markers_zone": "Max Marker/Zone",
      "desc_rocket_max_markers_zone": "Max. Vorschläge pro Zone.",
      "rocket_phase_styles": "Phasen-Stile",
      "desc_rocket_phase_styles": "Aktueller Phase erlauben, Marker-Stil zu überschreiben.",
      "rocket_tb_in_key": "Ton. Bind.: Nur in Tonart",
      "desc_rocket_tb_in_key": "Nur Noten/Akkorde der aktuellen Tonart vorschlagen.",
      "rocket_aa_autokey": "Adap. An.: Auto Tonartwechsel",
      "desc_rocket_aa_autokey": "Adaptiven Tonartwechsel basierend auf Eingabe erlauben.",
      "rocket_sf_basekey": "Halbfrei: Grundtonart",
      "desc_rocket_sf_basekey": "Grundtonart für halbfreien Modus.",
      "rocket_sf_deviations": "Halbfrei: Modale Abweichungen",
      "desc_rocket_sf_deviations": "Temporäre Abweichungen von Grundtonart erlauben.",
      "rocket_sf_return": "Halbfrei: Rückkehr hervorheben",
      "desc_rocket_sf_return": "Vorschläge hervorheben, die zur Grundtonart zurückkehren.",
      "rocket_rd_randomlevel": "Zufallsniveau",
      "desc_rocket_rd_randomlevel": "Niveau der Zufälligkeit in Vorschlägen.",
      "select_chord": "Akkord Auswählen",
      "select_key": "Tonart Auswählen",
      "select_phase": "Phase Auswählen",
      "no_language_found": "Keine Sprachen gefunden",
      "no_theme_found": "Keine Themen gefunden",
      "no_visualizer_found": "Keine Visualisierer gefunden",
      "no_touchEffect_found": "Keine Touch-Effekte gefunden",
      "no_scale_found": "Keine Tonleitern gefunden",
      "no_fxChain_found": "Keine FX-Ketten gefunden",
      "error_audio_fatal_restart": "Kritischer Audiofehler. Bitte starten Sie die App neu.",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_preset": "Neuen Sound Speichern",
      "delete_preset": "Sound Löschen",
      "synth_controls": "Synth-Steuerung",
      "synth_type": "Synth-Typ",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "Oszillator-Typ",
      "sine": "Sinus",
      "square": "Rechteck",
      "sawtooth": "Sägezahn",
      "triangle": "Dreieck",
      "fat_sine": "Fat Sinus",
      "fat_square": "Fat Rechteck",
      "fat_sawtooth": "Fat Sägezahn",
      "fat_triangle": "Fat Dreieck",
      "fm_sine": "FM Sinus",
      "fm_square": "FM Rechteck",
      "fm_sawtooth": "FM Sägezahn",
      "fm_triangle": "FM Dreieck",
      "am_sine": "AM Sinus",
      "am_square": "AM Rechteck",
      "am_sawtooth": "AM Sägezahn",
      "am_triangle": "AM Dreieck",
      "pwm": "PWM",
      "pulse": "Puls",
      "noise_white": "Weißes Rauschen",
      "noise_pink": "Rosa Rauschen",
      "noise_brown": "Braunes Rauschen",
      "oscillator_params": "Oszillator-Parameter",
      "phase": "Phase",
      "count": "Anzahl",
      "spread": "Streuung",
      "width": "Breite",
      "mod_freq_short": "Mod.-Frequenz",
      "harmonicity": "Harmonizität",
      "mod_index": "Mod.-Index",
      "mod_type": "Mod.-Typ",
      "noise_type": "Rauschtyp",
      "envelope": "Hüllkurve",
      "attack": "Attack",
      "sustain": "Sustain",
      "release": "Release",
      "envelope_curves": "Hüllkurvenformen",
      "attack_curve": "Attack",
      "decay_curve": "Decay",
      "release_curve": "Release",
      "filter_advanced": "Erw. Filter",
      "filter_rolloff": "Flankensteilheit",
      "filter_gain": "Gain (dB)",
      "filter_envelope": "Filterhüllkurve",
      "base_frequency": "Grundfrequenz",
      "exponent": "Exponent",
      "modulation": "Modulation",
      "modulation_envelope": "Modulationshüllkurve",
      "special_parameters": "Spezialparameter",
      "pitch_decay": "Tonhöhenabfall",
      "attack_noise": "Attack-Rauschen",
      "dampening": "Dämpfung",
      "resonance": "Resonanz",
      "lfo": "LFO",
      "lfo_type": "Typ",
      "lfo_target": "Ziel",
      "lfo_min": "Min.",
      "lfo_max": "Max.",
      "save_preset_title": "Sound-Preset Speichern",
      "preset_name_label": "Preset-Name:",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_fx_chain_title": "Effektkette Speichern",
      "fx_chain_name_label": "Name der Kette:",
      "fx_chain_name_placeholder": "Meine Effektkette",
      "cancel": "Abbrechen",
      "save": "Speichern",
      "major": "Dur",
      "minor": "Moll",
      "pentatonic": "Pentatonisch",
      "blues": "Blues",
      "chromatic": "Chromatisch",
      "dorian": "Dorisch",
      "phrygian": "Phrygisch",
      "lydian": "Lydisch",
      "mixolydian": "Mixolydisch",
      "locrian": "Lokrisch",
      "day": "Tag",
      "night": "Nacht",
      "neon": "Neon",
      "retro": "Retro",
      "pastel": "Pastell",
      "aurora": "Aurora",
      "ocean": "Ozean",
      "cyberpunk": "Cyberpunk",
      "fire": "Feuer",
      "matrix": "Matrix",
      "hologram": "Hologramm",
      "crystal": "Kristall",
      "galaxy": "Galaxie",
      "waves": "Wellen",
      "spectrum": "Spektrum",
      "particles": "Fischschwarm",
      "nebula": "Nebel",
      "reactive_ripples": "Reaktive Wellen",
      "touch_trails": "Touch-Spuren",
      "loading": "Laden...",
      "initializing": "Initialisiere...",
      "loading_bridge": "Verbinde...",
      "loading_settings": "Lade Einstellungen...",
      "loading_modules": "Lade Module...",
      "loading_ui": "Initialisiere UI...",
      "loading_presets": "Wende Einstellungen an...",
      "loading_audio": "Lade Sounds...",
      "tap_to_start": "Tippen, um Audio zu starten",
      "starting_audio": "Starte Audio...",
      "audio_suspended": "Audio pausiert. Tippen zum Fortsetzen.",
      "loading_preset": "Lade Preset...",
      "loading_fxchain": "Lade FX-Kette...",
      "saving_preset_progress": "Speichere Preset...",
      "saving_fxchain_progress": "Speichere FX-Kette...",
      "deleting_preset_progress": "Lösche Preset...",
      "deleting_fxchain_progress": "Lösche FX-Kette...",
      "hit_play_vibe": "Drück Play, Fühl den Vibe",
      "error_bridge_failed": "Fehler: Bridge-Verbindung fehlgeschlagen.",
      "error_init_failed": "Initialisierungsfehler. Konsole prüfen.",
      "error_init_failed_details": "Initialisierungsfehler: ${error}. Konsole prüfen.",
      "error_fatal_init": "Kritischer Initialisierungsfehler. Bitte neu starten.",
      "error_audio_failed_retry": "Fehler beim Starten von Audio. Bitte erneut tippen.",
      "error_audio_resume": "Audio konnte nicht fortgesetzt werden.",
      "error_apply_preset": "Fehler beim Anwenden des Presets.",
      "error_apply_fxchain": "Fehler beim Anwenden der FX-Kette.",
      "error_loading_presets": "Fehler beim Laden der Presets.",
      "error_loading_fxchains": "Fehler beim Laden der Ketten",
      "error_loading_effects_ui": "Fehler beim Laden der Effekt-UI.",
      "no_presets_found": "Keine Presets gefunden.",
      "no_fxchains_found": "Keine FX-Ketten gefunden",
      "no_effects_available": "Keine Effekte verfügbar.",
      "enter_preset_name": "Bitte gib einen Preset-Namen ein.",
      "enter_fxchain_name": "Bitte gib einen FX-Ketten-Namen ein.",
      "preset_saved_success": "Preset \"${name}\" erfolgreich gespeichert!",
      "fxchain_saved_success": "FX-Kette \"${name}\" erfolgreich gespeichert!",
      "error_saving_preset": "Fehler beim Speichern des Presets: ${error}",
      "error_saving_fxchain": "Fehler beim Speichern der FX-Kette: ${error}",
      "exception_saving_preset": "Ausnahme beim Speichern des Presets: ${error}",
      "exception_saving_fxchain": "Ausnahme beim Speichern der FX-Kette: ${error}",
      "confirm_delete_preset": "Preset \"${name}\" wirklich löschen?",
      "confirm_delete_fxchain": "FX-Kette \"${name}\" wirklich löschen?",
      "cannot_delete_default_preset": "Standard-Presets können nicht gelöscht werden.",
      "cannot_delete_default_fxchain": "Standard-FX-Ketten können nicht gelöscht werden.",
      "preset_deleted_success": "Preset gelöscht.",
      "fxchain_deleted_success": "FX-Kette gelöscht.",
      "preset_delete_failed": "Preset konnte nicht gelöscht werden.",
      "fxchain_delete_failed": "FX-Kette konnte nicht gelöscht werden.",
      "exception_deleting_preset": "Ausnahme beim Löschen des Presets: ${error}",
      "exception_deleting_fxchain": "Ausnahme beim Löschen der FX-Kette: ${error}",
      "audio_not_ready_record": "Audio nicht bereit. Aufnahme kann nicht gestartet werden.",
      "pitch_envelope": "Tonhöhen-Hüllkurve",
      "pitch_amount_cents": "Betrag (Cents)",
      "macro_controls_title": "Makro-Regler",
      "macro_space": "Raum",
      "macro_time": "Zeit",
      "macro_motion": "Bewegung",
      "macro_tone": "Klangfarbe",
      "macro_drive": "Drive",
      "effects_intensity_min": "FX-Intensität Min. (dB)",
      "effects_intensity_max": "FX-Intensität Max. (dB)",
      "effects_threshold": "FX-Schwelle",
      "none_fxchain": "-- Keine --",
      "none_touch_effect": "Kein",
      "restart_audio_engine_button": "Audio Neustart",
      "reload_app_button_title": "App Neu Laden",
      "reloading_app_message": "App wird neu geladen...",
      "master_output_title": "Master-Ausgang",
      "master_volume_ceiling": "Lautstärke-Limit",
      "master_volume_ceiling_label": "Lautstärke-Limit",
      "y_axis_volume_min_output": "Min. Ausgabe",
      "y_axis_volume_max_output": "Max. Ausgabe",
      "y_axis_volume_y_threshold": "Y-Schwelle",
      "y_axis_curve_type": "Kurventyp",
      "y_axis_curve_factor": "Kurvenfaktor",
      "y_axis_effects_min_output": "Min. Ausgabe (dB)",
      "y_axis_effects_max_output": "Max. Ausgabe (dB)",
      "y_axis_effects_y_threshold": "Y-Schwelle",
      "logarithmic": "Logarithmisch",
      "s_curve": "S-Kurve",
      "select_option": "Option Auswählen",
      "no_options_found": "Keine Optionen gefunden",
      "error_loading_options": "Fehler beim Laden der Optionen.",
      "pad_modes_button": "Modi",
      "pad_modes_button_title": "Pad-Modi",
      "pad_modes_panel_title": "Pad-Modi",
      "pad_mode_label": "Pad-Modus",
      "pad_mode_select_title": "Pad-Modus Auswählen",
      "pad_mode_classic": "Klassisch",
      "pad_mode_reactive": "Reaktiv",
      "reactive_mode_show_suggestions": "Harm. Hinweise Anzeigen",
      "reactive_mode_suggestion_count": "Anz. Hinweise",
      "no_specific_settings_classic": "Keine spezifischen Einstellungen für Klassisch-Modus.",
      "no_specific_settings_reactive": "Hinweise für Reaktiv-Modus konfigurieren.",
      "pad_mode_rocket": "Rakete",
      "rocket_highlight_active": "Aktive Noten Hervorheben",
      "rocket_show_markers": "Direktionale Marker Anzeigen",
      "rocket_marker_style": "Marker-Stil",
      "rocket_valid_chords_only": "Marker Nur für Valide Akkorde",
      "rocket_animate_fade": "Marker-Ausblendung Animieren",
      "rocket_show_chord_name": "Erkannten Akkordnamen Anzeigen",
      "style_GlowFromNote": "Glühen von Note",
      "style_WaveToNote": "Welle zu Note",
      "style_PulseRing": "Pulsierender Ring",
      "style_SparkTrail": "Funkenpfad",
      "style_ShadowDrop": "Schatten unter Note",
      "rocket_mode_panel_title": "Raketenmodus",
      "rocket_mode_enable": "Raketenmodus Aktivieren",
      "rocket_mode_settings_placeholder": "Einstellungen für den Raketenmodus erscheinen hier.",
      "error_loading_mode_settings": "Fehler beim Laden der Modus-Einstellungen.",
      "no_specific_settings_rocket": "Spezifische Einstellungen für den Raketenmodus konfigurieren.",
      "reset_settings_button": "Alle Einstellungen Zurücksetzen",
      "reload_app_button": "App Vollständig Neu Laden",
      "restart_audio_button": "Audio-Engine Neu Starten",
      "rocket_section_general": "Allgemein",
      "rocket_section_phases": "Phasen",
      "rocket_section_harmonic_logic": "Harmonische Logik",
      "rocket_section_interactive_behavior": "Interaktives Verhalten",
      "rocket_intensity": "Intensität",
      "rocket_visual_theme": "Visuelles Thema",
      "rocket_auto_phases": "Auto-Phasen",
      "rocket_harmonic_key": "Harmonischer Schlüssel",
      "rocket_marker_logic": "Marker-Logik",
      "marker_logic_tonal": "Tonale Bindung",
      "marker_logic_adaptive": "Adaptive Analyse",
      "marker_logic_semi_free": "Halbfrei",
      "marker_logic_random": "Zufällig Gerichtet",
      "rocket_phase_ignition": "Zündung",
      "rocket_phase_lift_off": "Start",
      "rocket_phase_burst": "Ausbruch",
      "rocket_phase_transition": "Phasenübergang",
      "phase_mode_activity": "Nach Aktivität",
      "phase_mode_time": "Nach Zeit",
      "phase_mode_manual": "Manuell",
      "status_chord": "Akkord",
      "status_key": "Tonart",
      "status_next": "Nächstes",
      "status_energy": "Energie",
      "status_phase": "Phase",
      "status_na": "N/A",
      "rocket_presets_title": "Modus-Presets",
      "rocket_select_preset": "Preset Auswählen",
      "rocket_select_preset_title": "Raketenmodus-Preset Auswählen",
      "rocket_preset_current": "Aktuelle Einstellungen",
      "none_selected": "Keine",
      "preset_rocket_melodic_drift": "Melodischer Drift",
      "desc_rocket_melodic_drift": "Sanfte, schwebende, halbfreie harmonische Logik.",
      "preset_rocket_jazz_climb": "Jazz-Aufstieg",
      "desc_rocket_jazz_climb": "Aktive, adaptive, jazz-inspirierte Logik.",
      "rocket_marker_labels": "Marker-Beschriftungen",
      "labels_none": "Keine",
      "labels_function": "Funktion (T/S/D)",
      "labels_chord_name": "Akkordname",
      "rocket_marker_retention": "Marker-Beibehaltung",
      "desc_rocket_marker_retention": "Relevante Marker bei neuen Berührungen sichtbar halten.",
      "desc_rocket_animate_fade": "Nicht relevante Marker sanft ausblenden.",
      "rocket_fade_delay": "Ausblendverzögerung",
      "desc_rocket_fade_delay": "Verzögerung, bevor Marker auszublenden beginnt.",
      "rocket_fade_duration": "Ausblenddauer",
      "desc_rocket_fade_duration": "Dauer der Marker-Ausblendanimation.",
      "rocket_max_markers_zone": "Max Marker/Zone",
      "desc_rocket_max_markers_zone": "Max. Vorschläge pro Zone.",
      "rocket_phase_styles": "Phasen-Stile",
      "desc_rocket_phase_styles": "Aktueller Phase erlauben, Marker-Stil zu überschreiben.",
      "rocket_tb_in_key": "Ton. Bind.: Nur in Tonart",
      "desc_rocket_tb_in_key": "Nur Noten/Akkorde der aktuellen Tonart vorschlagen.",
      "rocket_aa_autokey": "Adap. An.: Auto Tonartwechsel",
      "desc_rocket_aa_autokey": "Adaptiven Tonartwechsel basierend auf Eingabe erlauben.",
      "rocket_sf_basekey": "Halbfrei: Grundtonart",
      "desc_rocket_sf_basekey": "Grundtonart für halbfreien Modus.",
      "rocket_sf_deviations": "Halbfrei: Modale Abweichungen",
      "desc_rocket_sf_deviations": "Temporäre Abweichungen von Grundtonart erlauben.",
      "rocket_sf_return": "Halbfrei: Rückkehr hervorheben",
      "desc_rocket_sf_return": "Vorschläge hervorheben, die zur Grundtonart zurückkehren.",
      "rocket_rd_randomlevel": "Zufallsniveau",
      "desc_rocket_rd_randomlevel": "Niveau der Zufälligkeit in Vorschlägen.",
      "select_chord": "Akkord Auswählen",
      "select_key": "Tonart Auswählen",
      "select_phase": "Phase Auswählen",
      "no_language_found": "Keine Sprachen gefunden",
      "no_theme_found": "Keine Themen gefunden",
      "no_visualizer_found": "Keine Visualisierer gefunden",
      "no_touchEffect_found": "Keine Touch-Effekte gefunden",
      "no_scale_found": "Keine Tonleitern gefunden",
      "no_fxChain_found": "Keine FX-Ketten gefunden",
      "error_audio_fatal_restart": "Kritischer Audiofehler. Bitte starten Sie die App neu.",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_preset": "Neuen Sound Speichern",
      "delete_preset": "Sound Löschen",
      "synth_controls": "Synth-Steuerung",
      "synth_type": "Synth-Typ",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "Oszillator-Typ",
      "sine": "Sinus",
      "square": "Rechteck",
      "sawtooth": "Sägezahn",
      "triangle": "Dreieck",
      "fat_sine": "Fat Sinus",
      "fat_square": "Fat Rechteck",
      "fat_sawtooth": "Fat Sägezahn",
      "fat_triangle": "Fat Dreieck",
      "fm_sine": "FM Sinus",
      "fm_square": "FM Rechteck",
      "fm_sawtooth": "FM Sägezahn",
      "fm_triangle": "FM Dreieck",
      "am_sine": "AM Sinus",
      "am_square": "AM Rechteck",
      "am_sawtooth": "AM Sägezahn",
      "am_triangle": "AM Dreieck",
      "pwm": "PWM",
      "pulse": "Puls",
      "noise_white": "Weißes Rauschen",
      "noise_pink": "Rosa Rauschen",
      "noise_brown": "Braunes Rauschen",
      "oscillator_params": "Oszillator-Parameter",
      "phase": "Phase",
      "count": "Anzahl",
      "spread": "Streuung",
      "width": "Breite",
      "mod_freq_short": "Mod.-Frequenz",
      "harmonicity": "Harmonizität",
      "mod_index": "Mod.-Index",
      "mod_type": "Mod.-Typ",
      "noise_type": "Rauschtyp",
      "envelope": "Hüllkurve",
      "attack": "Attack",
      "sustain": "Sustain",
      "release": "Release",
      "envelope_curves": "Hüllkurvenformen",
      "attack_curve": "Attack",
      "decay_curve": "Decay",
      "release_curve": "Release",
      "filter_advanced": "Erw. Filter",
      "filter_rolloff": "Flankensteilheit",
      "filter_gain": "Gain (dB)",
      "filter_envelope": "Filterhüllkurve",
      "base_frequency": "Grundfrequenz",
      "exponent": "Exponent",
      "modulation": "Modulation",
      "modulation_envelope": "Modulationshüllkurve",
      "special_parameters": "Spezialparameter",
      "pitch_decay": "Tonhöhenabfall",
      "attack_noise": "Attack-Rauschen",
      "dampening": "Dämpfung",
      "resonance": "Resonanz",
      "lfo": "LFO",
      "lfo_type": "Typ",
      "lfo_target": "Ziel",
      "lfo_min": "Min.",
      "lfo_max": "Max.",
      "save_preset_title": "Sound-Preset Speichern",
      "preset_name_label": "Preset-Name:",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_fx_chain_title": "Effektkette Speichern",
      "fx_chain_name_label": "Name der Kette:",
      "fx_chain_name_placeholder": "Meine Effektkette",
      "cancel": "Abbrechen",
      "save": "Speichern",
      "major": "Dur",
      "minor": "Moll",
      "pentatonic": "Pentatonisch",
      "blues": "Blues",
      "chromatic": "Chromatisch",
      "dorian": "Dorisch",
      "phrygian": "Phrygisch",
      "lydian": "Lydisch",
      "mixolydian": "Mixolydisch",
      "locrian": "Lokrisch",
      "day": "Tag",
      "night": "Nacht",
      "neon": "Neon",
      "retro": "Retro",
      "pastel": "Pastell",
      "aurora": "Aurora",
      "ocean": "Ozean",
      "cyberpunk": "Cyberpunk",
      "fire": "Feuer",
      "matrix": "Matrix",
      "hologram": "Hologramm",
      "crystal": "Kristall",
      "galaxy": "Galaxie",
      "waves": "Wellen",
      "spectrum": "Spektrum",
      "particles": "Fischschwarm",
      "nebula": "Nebel",
      "reactive_ripples": "Reaktive Wellen",
      "touch_trails": "Touch-Spuren",
      "loading": "Laden...",
      "initializing": "Initialisiere...",
      "loading_bridge": "Verbinde...",
      "loading_settings": "Lade Einstellungen...",
      "loading_modules": "Lade Module...",
      "loading_ui": "Initialisiere UI...",
      "loading_presets": "Wende Einstellungen an...",
      "loading_audio": "Lade Sounds...",
      "tap_to_start": "Tippen, um Audio zu starten",
      "starting_audio": "Starte Audio...",
      "audio_suspended": "Audio pausiert. Tippen zum Fortsetzen.",
      "loading_preset": "Lade Preset...",
      "loading_fxchain": "Lade FX-Kette...",
      "saving_preset_progress": "Speichere Preset...",
      "saving_fxchain_progress": "Speichere FX-Kette...",
      "deleting_preset_progress": "Lösche Preset...",
      "deleting_fxchain_progress": "Lösche FX-Kette...",
      "hit_play_vibe": "Drück Play, Fühl den Vibe",
      "error_bridge_failed": "Fehler: Bridge-Verbindung fehlgeschlagen.",
      "error_init_failed": "Initialisierungsfehler. Konsole prüfen.",
      "error_init_failed_details": "Initialisierungsfehler: ${error}. Konsole prüfen.",
      "error_fatal_init": "Kritischer Initialisierungsfehler. Bitte neu starten.",
      "error_audio_failed_retry": "Fehler beim Starten von Audio. Bitte erneut tippen.",
      "error_audio_resume": "Audio konnte nicht fortgesetzt werden.",
      "error_apply_preset": "Fehler beim Anwenden des Presets.",
      "error_apply_fxchain": "Fehler beim Anwenden der FX-Kette.",
      "error_loading_presets": "Fehler beim Laden der Presets.",
      "error_loading_fxchains": "Fehler beim Laden der Ketten",
      "error_loading_effects_ui": "Fehler beim Laden der Effekt-UI.",
      "no_presets_found": "Keine Presets gefunden.",
      "no_fxchains_found": "Keine FX-Ketten gefunden",
      "no_effects_available": "Keine Effekte verfügbar.",
      "enter_preset_name": "Bitte gib einen Preset-Namen ein.",
      "enter_fxchain_name": "Bitte gib einen FX-Ketten-Namen ein.",
      "preset_saved_success": "Preset \"${name}\" erfolgreich gespeichert!",
      "fxchain_saved_success": "FX-Kette \"${name}\" erfolgreich gespeichert!",
      "error_saving_preset": "Fehler beim Speichern des Presets: ${error}",
      "error_saving_fxchain": "Fehler beim Speichern der FX-Kette: ${error}",
      "exception_saving_preset": "Ausnahme beim Speichern des Presets: ${error}",
      "exception_saving_fxchain": "Ausnahme beim Speichern der FX-Kette: ${error}",
      "confirm_delete_preset": "Preset \"${name}\" wirklich löschen?",
      "confirm_delete_fxchain": "FX-Kette \"${name}\" wirklich löschen?",
      "cannot_delete_default_preset": "Standard-Presets können nicht gelöscht werden.",
      "cannot_delete_default_fxchain": "Standard-FX-Ketten können nicht gelöscht werden.",
      "preset_deleted_success": "Preset gelöscht.",
      "fxchain_deleted_success": "FX-Kette gelöscht.",
      "preset_delete_failed": "Preset konnte nicht gelöscht werden.",
      "fxchain_delete_failed": "FX-Kette konnte nicht gelöscht werden.",
      "exception_deleting_preset": "Ausnahme beim Löschen des Presets: ${error}",
      "exception_deleting_fxchain": "Ausnahme beim Löschen der FX-Kette: ${error}",
      "audio_not_ready_record": "Audio nicht bereit. Aufnahme kann nicht gestartet werden.",
      "pitch_envelope": "Tonhöhen-Hüllkurve",
      "pitch_amount_cents": "Betrag (Cents)",
      "macro_controls_title": "Makro-Regler",
      "macro_space": "Raum",
      "macro_time": "Zeit",
      "macro_motion": "Bewegung",
      "macro_tone": "Klangfarbe",
      "macro_drive": "Drive",
      "effects_intensity_min": "FX-Intensität Min. (dB)",
      "effects_intensity_max": "FX-Intensität Max. (dB)",
      "effects_threshold": "FX-Schwelle",
      "none_fxchain": "-- Keine --",
      "none_touch_effect": "Kein",
      "restart_audio_engine_button": "Audio Neustart",
      "reload_app_button_title": "App Neu Laden",
      "reloading_app_message": "App wird neu geladen...",
      "master_output_title": "Master-Ausgang",
      "master_volume_ceiling": "Lautstärke-Limit",
      "master_volume_ceiling_label": "Lautstärke-Limit",
      "y_axis_volume_min_output": "Min. Ausgabe",
      "y_axis_volume_max_output": "Max. Ausgabe",
      "y_axis_volume_y_threshold": "Y-Schwelle",
      "y_axis_curve_type": "Kurventyp",
      "y_axis_curve_factor": "Kurvenfaktor",
      "y_axis_effects_min_output": "Min. Ausgabe (dB)",
      "y_axis_effects_max_output": "Max. Ausgabe (dB)",
      "y_axis_effects_y_threshold": "Y-Schwelle",
      "logarithmic": "Logarithmisch",
      "s_curve": "S-Kurve",
      "select_option": "Option Auswählen",
      "no_options_found": "Keine Optionen gefunden",
      "error_loading_options": "Fehler beim Laden der Optionen.",
      "pad_modes_button": "Modi",
      "pad_modes_button_title": "Pad-Modi",
      "pad_modes_panel_title": "Pad-Modi",
      "pad_mode_label": "Pad-Modus",
      "pad_mode_select_title": "Pad-Modus Auswählen",
      "pad_mode_classic": "Klassisch",
      "pad_mode_reactive": "Reaktiv",
      "reactive_mode_show_suggestions": "Harm. Hinweise Anzeigen",
      "reactive_mode_suggestion_count": "Anz. Hinweise",
      "no_specific_settings_classic": "Keine spezifischen Einstellungen für Klassisch-Modus.",
      "no_specific_settings_reactive": "Hinweise für Reaktiv-Modus konfigurieren.",
      "pad_mode_rocket": "Rakete",
      "rocket_highlight_active": "Aktive Noten Hervorheben",
      "rocket_show_markers": "Direktionale Marker Anzeigen",
      "rocket_marker_style": "Marker-Stil",
      "rocket_valid_chords_only": "Marker Nur für Valide Akkorde",
      "rocket_animate_fade": "Marker-Ausblendung Animieren",
      "rocket_show_chord_name": "Erkannten Akkordnamen Anzeigen",
      "style_GlowFromNote": "Glühen von Note",
      "style_WaveToNote": "Welle zu Note",
      "style_PulseRing": "Pulsierender Ring",
      "style_SparkTrail": "Funkenpfad",
      "style_ShadowDrop": "Schatten unter Note",
      "rocket_mode_panel_title": "Raketenmodus",
      "rocket_mode_enable": "Raketenmodus Aktivieren",
      "rocket_mode_settings_placeholder": "Einstellungen für den Raketenmodus erscheinen hier.",
      "error_loading_mode_settings": "Fehler beim Laden der Modus-Einstellungen.",
      "no_specific_settings_rocket": "Spezifische Einstellungen für den Raketenmodus konfigurieren.",
      "reset_settings_button": "Alle Einstellungen Zurücksetzen",
      "reload_app_button": "App Vollständig Neu Laden",
      "restart_audio_button": "Audio-Engine Neu Starten",
      "rocket_section_general": "Allgemein",
      "rocket_section_phases": "Phasen",
      "rocket_section_harmonic_logic": "Harmonische Logik",
      "rocket_section_interactive_behavior": "Interaktives Verhalten",
      "rocket_intensity": "Intensität",
      "rocket_visual_theme": "Visuelles Thema",
      "rocket_auto_phases": "Auto-Phasen",
      "rocket_harmonic_key": "Harmonischer Schlüssel",
      "rocket_marker_logic": "Marker-Logik",
      "marker_logic_tonal": "Tonale Bindung",
      "marker_logic_adaptive": "Adaptive Analyse",
      "marker_logic_semi_free": "Halbfrei",
      "marker_logic_random": "Zufällig Gerichtet",
      "rocket_phase_ignition": "Zündung",
      "rocket_phase_lift_off": "Start",
      "rocket_phase_burst": "Ausbruch",
      "rocket_phase_transition": "Phasenübergang",
      "phase_mode_activity": "Nach Aktivität",
      "phase_mode_time": "Nach Zeit",
      "phase_mode_manual": "Manuell",
      "status_chord": "Akkord",
      "status_key": "Tonart",
      "status_next": "Nächstes",
      "status_energy": "Energie",
      "status_phase": "Phase",
      "status_na": "N/A",
      "rocket_presets_title": "Modus-Presets",
      "rocket_select_preset": "Preset Auswählen",
      "rocket_select_preset_title": "Raketenmodus-Preset Auswählen",
      "rocket_preset_current": "Aktuelle Einstellungen",
      "none_selected": "Keine",
      "preset_rocket_melodic_drift": "Melodischer Drift",
      "desc_rocket_melodic_drift": "Sanfte, schwebende, halbfreie harmonische Logik.",
      "preset_rocket_jazz_climb": "Jazz-Aufstieg",
      "desc_rocket_jazz_climb": "Aktive, adaptive, jazz-inspirierte Logik.",
      "rocket_marker_labels": "Marker-Beschriftungen",
      "labels_none": "Keine",
      "labels_function": "Funktion (T/S/D)",
      "labels_chord_name": "Akkordname",
      "rocket_marker_retention": "Marker-Beibehaltung",
      "desc_rocket_marker_retention": "Relevante Marker bei neuen Berührungen sichtbar halten.",
      "desc_rocket_animate_fade": "Nicht relevante Marker sanft ausblenden.",
      "rocket_fade_delay": "Ausblendverzögerung",
      "desc_rocket_fade_delay": "Verzögerung, bevor Marker auszublenden beginnt.",
      "rocket_fade_duration": "Ausblenddauer",
      "desc_rocket_fade_duration": "Dauer der Marker-Ausblendanimation.",
      "rocket_max_markers_zone": "Max Marker/Zone",
      "desc_rocket_max_markers_zone": "Max. Vorschläge pro Zone.",
      "rocket_phase_styles": "Phasen-Stile",
      "desc_rocket_phase_styles": "Aktueller Phase erlauben, Marker-Stil zu überschreiben.",
      "rocket_tb_in_key": "Ton. Bind.: Nur in Tonart",
      "desc_rocket_tb_in_key": "Nur Noten/Akkorde der aktuellen Tonart vorschlagen.",
      "rocket_aa_autokey": "Adap. An.: Auto Tonartwechsel",
      "desc_rocket_aa_autokey": "Adaptiven Tonartwechsel basierend auf Eingabe erlauben.",
      "rocket_sf_basekey": "Halbfrei: Grundtonart",
      "desc_rocket_sf_basekey": "Grundtonart für halbfreien Modus.",
      "rocket_sf_deviations": "Halbfrei: Modale Abweichungen",
      "desc_rocket_sf_deviations": "Temporäre Abweichungen von Grundtonart erlauben.",
      "rocket_sf_return": "Halbfrei: Rückkehr hervorheben",
      "desc_rocket_sf_return": "Vorschläge hervorheben, die zur Grundtonart zurückkehren.",
      "rocket_rd_randomlevel": "Zufallsniveau",
      "desc_rocket_rd_randomlevel": "Niveau der Zufälligkeit in Vorschlägen.",
      "select_chord": "Akkord Auswählen",
      "select_key": "Tonart Auswählen",
      "select_phase": "Phase Auswählen",
      "no_language_found": "Keine Sprachen gefunden",
      "no_theme_found": "Keine Themen gefunden",
      "no_visualizer_found": "Keine Visualisierer gefunden",
      "no_touchEffect_found": "Keine Touch-Effekte gefunden",
      "no_scale_found": "Keine Tonleitern gefunden",
      "no_fxChain_found": "Keine FX-Ketten gefunden",
      "error_audio_fatal_restart": "Kritischer Audiofehler. Bitte starten Sie die App neu.",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_preset": "Neuen Sound Speichern",
      "delete_preset": "Sound Löschen",
      "synth_controls": "Synth-Steuerung",
      "synth_type": "Synth-Typ",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "Oszillator-Typ",
      "sine": "Sinus",
      "square": "Rechteck",
      "sawtooth": "Sägezahn",
      "triangle": "Dreieck",
      "fat_sine": "Fat Sinus",
      "fat_square": "Fat Rechteck",
      "fat_sawtooth": "Fat Sägezahn",
      "fat_triangle": "Fat Dreieck",
      "fm_sine": "FM Sinus",
      "fm_square": "FM Rechteck",
      "fm_sawtooth": "FM Sägezahn",
      "fm_triangle": "FM Dreieck",
      "am_sine": "AM Sinus",
      "am_square": "AM Rechteck",
      "am_sawtooth": "AM Sägezahn",
      "am_triangle": "AM Dreieck",
      "pwm": "PWM",
      "pulse": "Puls",
      "noise_white": "Weißes Rauschen",
      "noise_pink": "Rosa Rauschen",
      "noise_brown": "Braunes Rauschen",
      "oscillator_params": "Oszillator-Parameter",
      "phase": "Phase",
      "count": "Anzahl",
      "spread": "Streuung",
      "width": "Breite",
      "mod_freq_short": "Mod.-Frequenz",
      "harmonicity": "Harmonizität",
      "mod_index": "Mod.-Index",
      "mod_type": "Mod.-Typ",
      "noise_type": "Rauschtyp",
      "envelope": "Hüllkurve",
      "attack": "Attack",
      "sustain": "Sustain",
      "release": "Release",
      "envelope_curves": "Hüllkurvenformen",
      "attack_curve": "Attack",
      "decay_curve": "Decay",
      "release_curve": "Release",
      "filter_advanced": "Erw. Filter",
      "filter_rolloff": "Flankensteilheit",
      "filter_gain": "Gain (dB)",
      "filter_envelope": "Filterhüllkurve",
      "base_frequency": "Grundfrequenz",
      "exponent": "Exponent",
      "modulation": "Modulation",
      "modulation_envelope": "Modulationshüllkurve",
      "special_parameters": "Spezialparameter",
      "pitch_decay": "Tonhöhenabfall",
      "attack_noise": "Attack-Rauschen",
      "dampening": "Dämpfung",
      "resonance": "Resonanz",
      "lfo": "LFO",
      "lfo_type": "Typ",
      "lfo_target": "Ziel",
      "lfo_min": "Min.",
      "lfo_max": "Max.",
      "save_preset_title": "Sound-Preset Speichern",
      "preset_name_label": "Preset-Name:",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_fx_chain_title": "Effektkette Speichern",
      "fx_chain_name_label": "Name der Kette:",
      "fx_chain_name_placeholder": "Meine Effektkette",
      "cancel": "Abbrechen",
      "save": "Speichern",
      "major": "Dur",
      "minor": "Moll",
      "pentatonic": "Pentatonisch",
      "blues": "Blues",
      "chromatic": "Chromatisch",
      "dorian": "Dorisch",
      "phrygian": "Phrygisch",
      "lydian": "Lydisch",
      "mixolydian": "Mixolydisch",
      "locrian": "Lokrisch",
      "day": "Tag",
      "night": "Nacht",
      "neon": "Neon",
      "retro": "Retro",
      "pastel": "Pastell",
      "aurora": "Aurora",
      "ocean": "Ozean",
      "cyberpunk": "Cyberpunk",
      "fire": "Feuer",
      "matrix": "Matrix",
      "hologram": "Hologramm",
      "crystal": "Kristall",
      "galaxy": "Galaxie",
      "waves": "Wellen",
      "spectrum": "Spektrum",
      "particles": "Fischschwarm",
      "nebula": "Nebel",
      "reactive_ripples": "Reaktive Wellen",
      "touch_trails": "Touch-Spuren",
      "loading": "Laden...",
      "initializing": "Initialisiere...",
      "loading_bridge": "Verbinde...",
      "loading_settings": "Lade Einstellungen...",
      "loading_modules": "Lade Module...",
      "loading_ui": "Initialisiere UI...",
      "loading_presets": "Wende Einstellungen an...",
      "loading_audio": "Lade Sounds...",
      "tap_to_start": "Tippen, um Audio zu starten",
      "starting_audio": "Starte Audio...",
      "audio_suspended": "Audio pausiert. Tippen zum Fortsetzen.",
      "loading_preset": "Lade Preset...",
      "loading_fxchain": "Lade FX-Kette...",
      "saving_preset_progress": "Speichere Preset...",
      "saving_fxchain_progress": "Speichere FX-Kette...",
      "deleting_preset_progress": "Lösche Preset...",
      "deleting_fxchain_progress": "Lösche FX-Kette...",
      "hit_play_vibe": "Drück Play, Fühl den Vibe",
      "error_bridge_failed": "Fehler: Bridge-Verbindung fehlgeschlagen.",
      "error_init_failed": "Initialisierungsfehler. Konsole prüfen.",
      "error_init_failed_details": "Initialisierungsfehler: ${error}. Konsole prüfen.",
      "error_fatal_init": "Kritischer Initialisierungsfehler. Bitte neu starten.",
      "error_audio_failed_retry": "Fehler beim Starten von Audio. Bitte erneut tippen.",
      "error_audio_resume": "Audio konnte nicht fortgesetzt werden.",
      "error_apply_preset": "Fehler beim Anwenden des Presets.",
      "error_apply_fxchain": "Fehler beim Anwenden der FX-Kette.",
      "error_loading_presets": "Fehler beim Laden der Presets.",
      "error_loading_fxchains": "Fehler beim Laden der Ketten",
      "error_loading_effects_ui": "Fehler beim Laden der Effekt-UI.",
      "no_presets_found": "Keine Presets gefunden.",
      "no_fxchains_found": "Keine FX-Ketten gefunden",
      "no_effects_available": "Keine Effekte verfügbar.",
      "enter_preset_name": "Bitte gib einen Preset-Namen ein.",
      "enter_fxchain_name": "Bitte gib einen FX-Ketten-Namen ein.",
      "preset_saved_success": "Preset \"${name}\" erfolgreich gespeichert!",
      "fxchain_saved_success": "FX-Kette \"${name}\" erfolgreich gespeichert!",
      "error_saving_preset": "Fehler beim Speichern des Presets: ${error}",
      "error_saving_fxchain": "Fehler beim Speichern der FX-Kette: ${error}",
      "exception_saving_preset": "Ausnahme beim Speichern des Presets: ${error}",
      "exception_saving_fxchain": "Ausnahme beim Speichern der FX-Kette: ${error}",
      "confirm_delete_preset": "Preset \"${name}\" wirklich löschen?",
      "confirm_delete_fxchain": "FX-Kette \"${name}\" wirklich löschen?",
      "cannot_delete_default_preset": "Standard-Presets können nicht gelöscht werden.",
      "cannot_delete_default_fxchain": "Standard-FX-Ketten können nicht gelöscht werden.",
      "preset_deleted_success": "Preset gelöscht.",
      "fxchain_deleted_success": "FX-Kette gelöscht.",
      "preset_delete_failed": "Preset konnte nicht gelöscht werden.",
      "fxchain_delete_failed": "FX-Kette konnte nicht gelöscht werden.",
      "exception_deleting_preset": "Ausnahme beim Löschen des Presets: ${error}",
      "exception_deleting_fxchain": "Ausnahme beim Löschen der FX-Kette: ${error}",
      "audio_not_ready_record": "Audio nicht bereit. Aufnahme kann nicht gestartet werden.",
      "pitch_envelope": "Tonhöhen-Hüllkurve",
      "pitch_amount_cents": "Betrag (Cents)",
      "macro_controls_title": "Makro-Regler",
      "macro_space": "Raum",
      "macro_time": "Zeit",
      "macro_motion": "Bewegung",
      "macro_tone": "Klangfarbe",
      "macro_drive": "Drive",
      "effects_intensity_min": "FX-Intensität Min. (dB)",
      "effects_intensity_max": "FX-Intensität Max. (dB)",
      "effects_threshold": "FX-Schwelle",
      "none_fxchain": "-- Keine --",
      "none_touch_effect": "Kein",
      "restart_audio_engine_button": "Audio Neustart",
      "reload_app_button_title": "App Neu Laden",
      "reloading_app_message": "App wird neu geladen...",
      "master_output_title": "Master-Ausgang",
      "master_volume_ceiling": "Lautstärke-Limit",
      "master_volume_ceiling_label": "Lautstärke-Limit",
      "y_axis_volume_min_output": "Min. Ausgabe",
      "y_axis_volume_max_output": "Max. Ausgabe",
      "y_axis_volume_y_threshold": "Y-Schwelle",
      "y_axis_curve_type": "Kurventyp",
      "y_axis_curve_factor": "Kurvenfaktor",
      "y_axis_effects_min_output": "Min. Ausgabe (dB)",
      "y_axis_effects_max_output": "Max. Ausgabe (dB)",
      "y_axis_effects_y_threshold": "Y-Schwelle",
      "logarithmic": "Logarithmisch",
      "s_curve": "S-Kurve",
      "select_option": "Option Auswählen",
      "no_options_found": "Keine Optionen gefunden",
      "error_loading_options": "Fehler beim Laden der Optionen.",
      "pad_modes_button": "Modi",
      "pad_modes_button_title": "Pad-Modi",
      "pad_modes_panel_title": "Pad-Modi",
      "pad_mode_label": "Pad-Modus",
      "pad_mode_select_title": "Pad-Modus Auswählen",
      "pad_mode_classic": "Klassisch",
      "pad_mode_reactive": "Reaktiv",
      "reactive_mode_show_suggestions": "Harm. Hinweise Anzeigen",
      "reactive_mode_suggestion_count": "Anz. Hinweise",
      "no_specific_settings_classic": "Keine spezifischen Einstellungen für Klassisch-Modus.",
      "no_specific_settings_reactive": "Hinweise für Reaktiv-Modus konfigurieren.",
      "pad_mode_rocket": "Rakete",
      "rocket_highlight_active": "Aktive Noten Hervorheben",
      "rocket_show_markers": "Direktionale Marker Anzeigen",
      "rocket_marker_style": "Marker-Stil",
      "rocket_valid_chords_only": "Marker Nur für Valide Akkorde",
      "rocket_animate_fade": "Marker-Ausblendung Animieren",
      "rocket_show_chord_name": "Erkannten Akkordnamen Anzeigen",
      "style_GlowFromNote": "Glühen von Note",
      "style_WaveToNote": "Welle zu Note",
      "style_PulseRing": "Pulsierender Ring",
      "style_SparkTrail": "Funkenpfad",
      "style_ShadowDrop": "Schatten unter Note",
      "rocket_mode_panel_title": "Raketenmodus",
      "rocket_mode_enable": "Raketenmodus Aktivieren",
      "rocket_mode_settings_placeholder": "Einstellungen für den Raketenmodus erscheinen hier.",
      "error_loading_mode_settings": "Fehler beim Laden der Modus-Einstellungen.",
      "no_specific_settings_rocket": "Spezifische Einstellungen für den Raketenmodus konfigurieren.",
      "reset_settings_button": "Alle Einstellungen Zurücksetzen",
      "reload_app_button": "App Vollständig Neu Laden",
      "restart_audio_button": "Audio-Engine Neu Starten",
      "rocket_section_general": "Allgemein",
      "rocket_section_phases": "Phasen",
      "rocket_section_harmonic_logic": "Harmonische Logik",
      "rocket_section_interactive_behavior": "Interaktives Verhalten",
      "rocket_intensity": "Intensität",
      "rocket_visual_theme": "Visuelles Thema",
      "rocket_auto_phases": "Auto-Phasen",
      "rocket_harmonic_key": "Harmonischer Schlüssel",
      "rocket_marker_logic": "Marker-Logik",
      "marker_logic_tonal": "Tonale Bindung",
      "marker_logic_adaptive": "Adaptive Analyse",
      "marker_logic_semi_free": "Halbfrei",
      "marker_logic_random": "Zufällig Gerichtet",
      "rocket_phase_ignition": "Zündung",
      "rocket_phase_lift_off": "Start",
      "rocket_phase_burst": "Ausbruch",
      "rocket_phase_transition": "Phasenübergang",
      "phase_mode_activity": "Nach Aktivität",
      "phase_mode_time": "Nach Zeit",
      "phase_mode_manual": "Manuell",
      "status_chord": "Akkord",
      "status_key": "Tonart",
      "status_next": "Nächstes",
      "status_energy": "Energie",
      "status_phase": "Phase",
      "status_na": "N/A",
      "rocket_presets_title": "Modus-Presets",
      "rocket_select_preset": "Preset Auswählen",
      "rocket_select_preset_title": "Raketenmodus-Preset Auswählen",
      "rocket_preset_current": "Aktuelle Einstellungen",
      "none_selected": "Keine",
      "preset_rocket_melodic_drift": "Melodischer Drift",
      "desc_rocket_melodic_drift": "Sanfte, schwebende, halbfreie harmonische Logik.",
      "preset_rocket_jazz_climb": "Jazz-Aufstieg",
      "desc_rocket_jazz_climb": "Aktive, adaptive, jazz-inspirierte Logik.",
      "rocket_marker_labels": "Marker-Beschriftungen",
      "labels_none": "Keine",
      "labels_function": "Funktion (T/S/D)",
      "labels_chord_name": "Akkordname",
      "rocket_marker_retention": "Marker-Beibehaltung",
      "desc_rocket_marker_retention": "Relevante Marker bei neuen Berührungen sichtbar halten.",
      "desc_rocket_animate_fade": "Nicht relevante Marker sanft ausblenden.",
      "rocket_fade_delay": "Ausblendverzögerung",
      "desc_rocket_fade_delay": "Verzögerung, bevor Marker auszublenden beginnt.",
      "rocket_fade_duration": "Ausblenddauer",
      "desc_rocket_fade_duration": "Dauer der Marker-Ausblendanimation.",
      "rocket_max_markers_zone": "Max Marker/Zone",
      "desc_rocket_max_markers_zone": "Max. Vorschläge pro Zone.",
      "rocket_phase_styles": "Phasen-Stile",
      "desc_rocket_phase_styles": "Aktueller Phase erlauben, Marker-Stil zu überschreiben.",
      "rocket_tb_in_key": "Ton. Bind.: Nur in Tonart",
      "desc_rocket_tb_in_key": "Nur Noten/Akkorde der aktuellen Tonart vorschlagen.",
      "rocket_aa_autokey": "Adap. An.: Auto Tonartwechsel",
      "desc_rocket_aa_autokey": "Adaptiven Tonartwechsel basierend auf Eingabe erlauben.",
      "rocket_sf_basekey": "Halbfrei: Grundtonart",
      "desc_rocket_sf_basekey": "Grundtonart für halbfreien Modus.",
      "rocket_sf_deviations": "Halbfrei: Modale Abweichungen",
      "desc_rocket_sf_deviations": "Temporäre Abweichungen von Grundtonart erlauben.",
      "rocket_sf_return": "Halbfrei: Rückkehr hervorheben",
      "desc_rocket_sf_return": "Vorschläge hervorheben, die zur Grundtonart zurückkehren.",
      "rocket_rd_randomlevel": "Zufallsniveau",
      "desc_rocket_rd_randomlevel": "Niveau der Zufälligkeit in Vorschlägen.",
      "select_chord": "Akkord Auswählen",
      "select_key": "Tonart Auswählen",
      "select_phase": "Phase Auswählen",
      "no_language_found": "Keine Sprachen gefunden",
      "no_theme_found": "Keine Themen gefunden",
      "no_visualizer_found": "Keine Visualisierer gefunden",
      "no_touchEffect_found": "Keine Touch-Effekte gefunden",
      "no_scale_found": "Keine Tonleitern gefunden",
      "no_fxChain_found": "Keine FX-Ketten gefunden",
      "error_audio_fatal_restart": "Kritischer Audiofehler. Bitte starten Sie die App neu.",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_preset": "Neuen Sound Speichern",
      "delete_preset": "Sound Löschen",
      "synth_controls": "Synth-Steuerung",
      "synth_type": "Synth-Typ",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "Oszillator-Typ",
      "sine": "Sinus",
      "square": "Rechteck",
      "sawtooth": "Sägezahn",
      "triangle": "Dreieck",
      "fat_sine": "Fat Sinus",
      "fat_square": "Fat Rechteck",
      "fat_sawtooth": "Fat Sägezahn",
      "fat_triangle": "Fat Dreieck",
      "fm_sine": "FM Sinus",
      "fm_square": "FM Rechteck",
      "fm_sawtooth": "FM Sägezahn",
      "fm_triangle": "FM Dreieck",
      "am_sine": "AM Sinus",
      "am_square": "AM Rechteck",
      "am_sawtooth": "AM Sägezahn",
      "am_triangle": "AM Dreieck",
      "pwm": "PWM",
      "pulse": "Puls",
      "noise_white": "Weißes Rauschen",
      "noise_pink": "Rosa Rauschen",
      "noise_brown": "Braunes Rauschen",
      "oscillator_params": "Oszillator-Parameter",
      "phase": "Phase",
      "count": "Anzahl",
      "spread": "Streuung",
      "width": "Breite",
      "mod_freq_short": "Mod.-Frequenz",
      "harmonicity": "Harmonizität",
      "mod_index": "Mod.-Index",
      "mod_type": "Mod.-Typ",
      "noise_type": "Rauschtyp",
      "envelope": "Hüllkurve",
      "attack": "Attack",
      "sustain": "Sustain",
      "release": "Release",
      "envelope_curves": "Hüllkurvenformen",
      "attack_curve": "Attack",
      "decay_curve": "Decay",
      "release_curve": "Release",
      "filter_advanced": "Erw. Filter",
      "filter_rolloff": "Flankensteilheit",
      "filter_gain": "Gain (dB)",
      "filter_envelope": "Filterhüllkurve",
      "base_frequency": "Grundfrequenz",
      "exponent": "Exponent",
      "modulation": "Modulation",
      "modulation_envelope": "Modulationshüllkurve",
      "special_parameters": "Spezialparameter",
      "pitch_decay": "Tonhöhenabfall",
      "attack_noise": "Attack-Rauschen",
      "dampening": "Dämpfung",
      "resonance": "Resonanz",
      "lfo": "LFO",
      "lfo_type": "Typ",
      "lfo_target": "Ziel",
      "lfo_min": "Min.",
      "lfo_max": "Max.",
      "save_preset_title": "Sound-Preset Speichern",
      "preset_name_label": "Preset-Name:",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_fx_chain_title": "Effektkette Speichern",
      "fx_chain_name_label": "Name der Kette:",
      "fx_chain_name_placeholder": "Meine Effektkette",
      "cancel": "Abbrechen",
      "save": "Speichern",
      "major": "Dur",
      "minor": "Moll",
      "pentatonic": "Pentatonisch",
      "blues": "Blues",
      "chromatic": "Chromatisch",
      "dorian": "Dorisch",
      "phrygian": "Phrygisch",
      "lydian": "Lydisch",
      "mixolydian": "Mixolydisch",
      "locrian": "Lokrisch",
      "day": "Tag",
      "night": "Nacht",
      "neon": "Neon",
      "retro": "Retro",
      "pastel": "Pastell",
      "aurora": "Aurora",
      "ocean": "Ozean",
      "cyberpunk": "Cyberpunk",
      "fire": "Feuer",
      "matrix": "Matrix",
      "hologram": "Hologramm",
      "crystal": "Kristall",
      "galaxy": "Galaxie",
      "waves": "Wellen",
      "spectrum": "Spektrum",
      "particles": "Fischschwarm",
      "nebula": "Nebel",
      "reactive_ripples": "Reaktive Wellen",
      "touch_trails": "Touch-Spuren",
      "loading": "Laden...",
      "initializing": "Initialisiere...",
      "loading_bridge": "Verbinde...",
      "loading_settings": "Lade Einstellungen...",
      "loading_modules": "Lade Module...",
      "loading_ui": "Initialisiere UI...",
      "loading_presets": "Wende Einstellungen an...",
      "loading_audio": "Lade Sounds...",
      "tap_to_start": "Tippen, um Audio zu starten",
      "starting_audio": "Starte Audio...",
      "audio_suspended": "Audio pausiert. Tippen zum Fortsetzen.",
      "loading_preset": "Lade Preset...",
      "loading_fxchain": "Lade FX-Kette...",
      "saving_preset_progress": "Speichere Preset...",
      "saving_fxchain_progress": "Speichere FX-Kette...",
      "deleting_preset_progress": "Lösche Preset...",
      "deleting_fxchain_progress": "Lösche FX-Kette...",
      "hit_play_vibe": "Drück Play, Fühl den Vibe",
      "error_bridge_failed": "Fehler: Bridge-Verbindung fehlgeschlagen.",
      "error_init_failed": "Initialisierungsfehler. Konsole prüfen.",
      "error_init_failed_details": "Initialisierungsfehler: ${error}. Konsole prüfen.",
      "error_fatal_init": "Kritischer Initialisierungsfehler. Bitte neu starten.",
      "error_audio_failed_retry": "Fehler beim Starten von Audio. Bitte erneut tippen.",
      "error_audio_resume": "Audio konnte nicht fortgesetzt werden.",
      "error_apply_preset": "Fehler beim Anwenden des Presets.",
      "error_apply_fxchain": "Fehler beim Anwenden der FX-Kette.",
      "error_loading_presets": "Fehler beim Laden der Presets.",
      "error_loading_fxchains": "Fehler beim Laden der Ketten",
      "error_loading_effects_ui": "Fehler beim Laden der Effekt-UI.",
      "no_presets_found": "Keine Presets gefunden.",
      "no_fxchains_found": "Keine FX-Ketten gefunden",
      "no_effects_available": "Keine Effekte verfügbar.",
      "enter_preset_name": "Bitte gib einen Preset-Namen ein.",
      "enter_fxchain_name": "Bitte gib einen FX-Ketten-Namen ein.",
      "preset_saved_success": "Preset \"${name}\" erfolgreich gespeichert!",
      "fxchain_saved_success": "FX-Kette \"${name}\" erfolgreich gespeichert!",
      "error_saving_preset": "Fehler beim Speichern des Presets: ${error}",
      "error_saving_fxchain": "Fehler beim Speichern der FX-Kette: ${error}",
      "exception_saving_preset": "Ausnahme beim Speichern des Presets: ${error}",
      "exception_saving_fxchain": "Ausnahme beim Speichern der FX-Kette: ${error}",
      "confirm_delete_preset": "Preset \"${name}\" wirklich löschen?",
      "confirm_delete_fxchain": "FX-Kette \"${name}\" wirklich löschen?",
      "cannot_delete_default_preset": "Standard-Presets können nicht gelöscht werden.",
      "cannot_delete_default_fxchain": "Standard-FX-Ketten können nicht gelöscht werden.",
      "preset_deleted_success": "Preset gelöscht.",
      "fxchain_deleted_success": "FX-Kette gelöscht.",
      "preset_delete_failed": "Preset konnte nicht gelöscht werden.",
      "fxchain_delete_failed": "FX-Kette konnte nicht gelöscht werden.",
      "exception_deleting_preset": "Ausnahme beim Löschen des Presets: ${error}",
      "exception_deleting_fxchain": "Ausnahme beim Löschen der FX-Kette: ${error}",
      "audio_not_ready_record": "Audio nicht bereit. Aufnahme kann nicht gestartet werden.",
      "pitch_envelope": "Tonhöhen-Hüllkurve",
      "pitch_amount_cents": "Betrag (Cents)",
      "macro_controls_title": "Makro-Regler",
      "macro_space": "Raum",
      "macro_time": "Zeit",
      "macro_motion": "Bewegung",
      "macro_tone": "Klangfarbe",
      "macro_drive": "Drive",
      "effects_intensity_min": "FX-Intensität Min. (dB)",
      "effects_intensity_max": "FX-Intensität Max. (dB)",
      "effects_threshold": "FX-Schwelle",
      "none_fxchain": "-- Keine --",
      "none_touch_effect": "Kein",
      "restart_audio_engine_button": "Audio Neustart",
      "reload_app_button_title": "App Neu Laden",
      "reloading_app_message": "App wird neu geladen...",
      "master_output_title": "Master-Ausgang",
      "master_volume_ceiling": "Lautstärke-Limit",
      "master_volume_ceiling_label": "Lautstärke-Limit",
      "y_axis_volume_min_output": "Min. Ausgabe",
      "y_axis_volume_max_output": "Max. Ausgabe",
      "y_axis_volume_y_threshold": "Y-Schwelle",
      "y_axis_curve_type": "Kurventyp",
      "y_axis_curve_factor": "Kurvenfaktor",
      "y_axis_effects_min_output": "Min. Ausgabe (dB)",
      "y_axis_effects_max_output": "Max. Ausgabe (dB)",
      "y_axis_effects_y_threshold": "Y-Schwelle",
      "logarithmic": "Logarithmisch",
      "s_curve": "S-Kurve",
      "select_option": "Option Auswählen",
      "no_options_found": "Keine Optionen gefunden",
      "error_loading_options": "Fehler beim Laden der Optionen.",
      "pad_modes_button": "Modi",
      "pad_modes_button_title": "Pad-Modi",
      "pad_modes_panel_title": "Pad-Modi",
      "pad_mode_label": "Pad-Modus",
      "pad_mode_select_title": "Pad-Modus Auswählen",
      "pad_mode_classic": "Klassisch",
      "pad_mode_reactive": "Reaktiv",
      "reactive_mode_show_suggestions": "Harm. Hinweise Anzeigen",
      "reactive_mode_suggestion_count": "Anz. Hinweise",
      "no_specific_settings_classic": "Keine spezifischen Einstellungen für Klassisch-Modus.",
      "no_specific_settings_reactive": "Hinweise für Reaktiv-Modus konfigurieren.",
      "pad_mode_rocket": "Rakete",
      "rocket_highlight_active": "Aktive Noten Hervorheben",
      "rocket_show_markers": "Direktionale Marker Anzeigen",
      "rocket_marker_style": "Marker-Stil",
      "rocket_valid_chords_only": "Marker Nur für Valide Akkorde",
      "rocket_animate_fade": "Marker-Ausblendung Animieren",
      "rocket_show_chord_name": "Erkannten Akkordnamen Anzeigen",
      "style_GlowFromNote": "Glühen von Note",
      "style_WaveToNote": "Welle zu Note",
      "style_PulseRing": "Pulsierender Ring",
      "style_SparkTrail": "Funkenpfad",
      "style_ShadowDrop": "Schatten unter Note",
      "rocket_mode_panel_title": "Raketenmodus",
      "rocket_mode_enable": "Raketenmodus Aktivieren",
      "rocket_mode_settings_placeholder": "Einstellungen für den Raketenmodus erscheinen hier.",
      "error_loading_mode_settings": "Fehler beim Laden der Modus-Einstellungen.",
      "no_specific_settings_rocket": "Spezifische Einstellungen für den Raketenmodus konfigurieren.",
      "reset_settings_button": "Alle Einstellungen Zurücksetzen",
      "reload_app_button": "App Vollständig Neu Laden",
      "restart_audio_button": "Audio-Engine Neu Starten",
      "rocket_section_general": "Allgemein",
      "rocket_section_phases": "Phasen",
      "rocket_section_harmonic_logic": "Harmonische Logik",
      "rocket_section_interactive_behavior": "Interaktives Verhalten",
      "rocket_intensity": "Intensität",
      "rocket_visual_theme": "Visuelles Thema",
      "rocket_auto_phases": "Auto-Phasen",
      "rocket_harmonic_key": "Harmonischer Schlüssel",
      "rocket_marker_logic": "Marker-Logik",
      "marker_logic_tonal": "Tonale Bindung",
      "marker_logic_adaptive": "Adaptive Analyse",
      "marker_logic_semi_free": "Halbfrei",
      "marker_logic_random": "Zufällig Gerichtet",
      "rocket_phase_ignition": "Zündung",
      "rocket_phase_lift_off": "Start",
      "rocket_phase_burst": "Ausbruch",
      "rocket_phase_transition": "Phasenübergang",
      "phase_mode_activity": "Nach Aktivität",
      "phase_mode_time": "Nach Zeit",
      "phase_mode_manual": "Manuell",
      "status_chord": "Akkord",
      "status_key": "Tonart",
      "status_next": "Nächstes",
      "status_energy": "Energie",
      "status_phase": "Phase",
      "status_na": "N/A",
      "rocket_presets_title": "Modus-Presets",
      "rocket_select_preset": "Preset Auswählen",
      "rocket_select_preset_title": "Raketenmodus-Preset Auswählen",
      "rocket_preset_current": "Aktuelle Einstellungen",
      "none_selected": "Keine",
      "preset_rocket_melodic_drift": "Melodischer Drift",
      "desc_rocket_melodic_drift": "Sanfte, schwebende, halbfreie harmonische Logik.",
      "preset_rocket_jazz_climb": "Jazz-Aufstieg",
      "desc_rocket_jazz_climb": "Aktive, adaptive, jazz-inspirierte Logik.",
      "rocket_marker_labels": "Marker-Beschriftungen",
      "labels_none": "Keine",
      "labels_function": "Funktion (T/S/D)",
      "labels_chord_name": "Akkordname",
      "rocket_marker_retention": "Marker-Beibehaltung",
      "desc_rocket_marker_retention": "Relevante Marker bei neuen Berührungen sichtbar halten.",
      "desc_rocket_animate_fade": "Nicht relevante Marker sanft ausblenden.",
      "rocket_fade_delay": "Ausblendverzögerung",
      "desc_rocket_fade_delay": "Verzögerung, bevor Marker auszublenden beginnt.",
      "rocket_fade_duration": "Ausblenddauer",
      "desc_rocket_fade_duration": "Dauer der Marker-Ausblendanimation.",
      "rocket_max_markers_zone": "Max Marker/Zone",
      "desc_rocket_max_markers_zone": "Max. Vorschläge pro Zone.",
      "rocket_phase_styles": "Phasen-Stile",
      "desc_rocket_phase_styles": "Aktueller Phase erlauben, Marker-Stil zu überschreiben.",
      "rocket_tb_in_key": "Ton. Bind.: Nur in Tonart",
      "desc_rocket_tb_in_key": "Nur Noten/Akkorde der aktuellen Tonart vorschlagen.",
      "rocket_aa_autokey": "Adap. An.: Auto Tonartwechsel",
      "desc_rocket_aa_autokey": "Adaptiven Tonartwechsel basierend auf Eingabe erlauben.",
      "rocket_sf_basekey": "Halbfrei: Grundtonart",
      "desc_rocket_sf_basekey": "Grundtonart für halbfreien Modus.",
      "rocket_sf_deviations": "Halbfrei: Modale Abweichungen",
      "desc_rocket_sf_deviations": "Temporäre Abweichungen von Grundtonart erlauben.",
      "rocket_sf_return": "Halbfrei: Rückkehr hervorheben",
      "desc_rocket_sf_return": "Vorschläge hervorheben, die zur Grundtonart zurückkehren.",
      "rocket_rd_randomlevel": "Zufallsniveau",
      "desc_rocket_rd_randomlevel": "Niveau der Zufälligkeit in Vorschlägen.",
      "select_chord": "Akkord Auswählen",
      "select_key": "Tonart Auswählen",
      "select_phase": "Phase Auswählen",
      "no_language_found": "Keine Sprachen gefunden",
      "no_theme_found": "Keine Themen gefunden",
      "no_visualizer_found": "Keine Visualisierer gefunden",
      "no_touchEffect_found": "Keine Touch-Effekte gefunden",
      "no_scale_found": "Keine Tonleitern gefunden",
      "no_fxChain_found": "Keine FX-Ketten gefunden",
      "error_audio_fatal_restart": "Kritischer Audiofehler. Bitte starten Sie die App neu.",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_preset": "Neuen Sound Speichern",
      "delete_preset": "Sound Löschen",
      "synth_controls": "Synth-Steuerung",
      "synth_type": "Synth-Typ",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "Oszillator-Typ",
      "sine": "Sinus",
      "square": "Rechteck",
      "sawtooth": "Sägezahn",
      "triangle": "Dreieck",
      "fat_sine": "Fat Sinus",
      "fat_square": "Fat Rechteck",
      "fat_sawtooth": "Fat Sägezahn",
      "fat_triangle": "Fat Dreieck",
      "fm_sine": "FM Sinus",
      "fm_square": "FM Rechteck",
      "fm_sawtooth": "FM Sägezahn",
      "fm_triangle": "FM Dreieck",
      "am_sine": "AM Sinus",
      "am_square": "AM Rechteck",
      "am_sawtooth": "AM Sägezahn",
      "am_triangle": "AM Dreieck",
      "pwm": "PWM",
      "pulse": "Puls",
      "noise_white": "Weißes Rauschen",
      "noise_pink": "Rosa Rauschen",
      "noise_brown": "Braunes Rauschen",
      "oscillator_params": "Oszillator-Parameter",
      "phase": "Phase",
      "count": "Anzahl",
      "spread": "Streuung",
      "width": "Breite",
      "mod_freq_short": "Mod.-Frequenz",
      "harmonicity": "Harmonizität",
      "mod_index": "Mod.-Index",
      "mod_type": "Mod.-Typ",
      "noise_type": "Rauschtyp",
      "envelope": "Hüllkurve",
      "attack": "Attack",
      "sustain": "Sustain",
      "release": "Release",
      "envelope_curves": "Hüllkurvenformen",
      "attack_curve": "Attack",
      "decay_curve": "Decay",
      "release_curve": "Release",
      "filter_advanced": "Erw. Filter",
      "filter_rolloff": "Flankensteilheit",
      "filter_gain": "Gain (dB)",
      "filter_envelope": "Filterhüllkurve",
      "base_frequency": "Grundfrequenz",
      "exponent": "Exponent",
      "modulation": "Modulation",
      "modulation_envelope": "Modulationshüllkurve",
      "special_parameters": "Spezialparameter",
      "pitch_decay": "Tonhöhenabfall",
      "attack_noise": "Attack-Rauschen",
      "dampening": "Dämpfung",
      "resonance": "Resonanz",
      "lfo": "LFO",
      "lfo_type": "Typ",
      "lfo_target": "Ziel",
      "lfo_min": "Min.",
      "lfo_max": "Max.",
      "save_preset_title": "Sound-Preset Speichern",
      "preset_name_label": "Preset-Name:",
      "preset_name_placeholder": "Mein Sound-Preset",
      "save_fx_chain_title": "Effektkette Speichern",
      "fx_chain_name_label": "Name der Kette:",
      "fx_chain_name_placeholder": "Meine Effektkette",
      "cancel": "Abbrechen",
      "save": "Speichern",
      "major": "Dur",
      "minor": "Moll",
      "pentatonic": "Pentatonisch",
      "blues": "Blues",
      "chromatic": "Chromatisch",
      "dorian": "Dorisch",
      "phrygian": "Phrygisch",
      "lydian": "Lydisch",
      "mixolydian": "Mixolydisch",
      "locrian": "Lokrisch",
      "day": "Tag",
      "night": "Nacht",
      "neon": "Neon",
      "retro": "Retro",
      "pastel": "Pastell",
      "aurora": "Aurora",
      "ocean": "Ozean",
      "cyberpunk": "Cyberpunk",
      "fire": "Feuer",
      "matrix": "Matrix",
      "hologram": "Hologramm",
      "crystal": "Kristall",
      "galaxy": "Galaxie",
      "waves": "Wellen",
      "spectrum": "Spektrum",
      "particles": "Fischschwarm",
      "nebula": "Nebel",
      "reactive_ripples": "Reaktive Wellen",
      "touch_trails": "Touch-Spuren",
      "loading": "Laden...",
      "initializing": "Initialisiere...",
      "loading_bridge": "Verbinde...",
      "loading_settings": "Lade Einstellungen...",
      "loading_modules": "Lade Module...",
      "loading_ui": "Initialisiere UI...",
      "loading_presets": "Wende Einstellungen an...",
      "loading_audio": "Lade Sounds...",
      "tap_to_start": "Tippen, um Audio zu starten",
      "starting_audio": "Starte Audio...",
      "audio_suspended": "Audio pausiert. Tippen zum Fortsetzen.",
      "loading_preset": "Lade Preset...",
      "loading_fxchain": "Lade FX-Kette...",
      "saving_preset_progress": "Speichere Preset...",
      "saving_fxchain_progress": "Speichere FX-Kette...",
      "deleting_preset_progress": "Lösche Preset...",
      "deleting_fxchain_progress": "Lösche FX-Kette...",
      "hit_play_vibe": "Drück Play, Fühl den Vibe",
      "error_bridge_failed": "Fehler: Bridge-Verbindung fehlgeschlagen.",
      "error_init_failed": "Initialisierungsfehler. Konsole prüfen.",
      "error_init_failed_details": "Initialisierungsfehler: ${error}. Konsole prüfen.",
      "error_fatal_init": "Kritischer Initialisierungsfehler. Bitte neu starten.",
      "error_audio_failed_retry": "Fehler beim Starten von Audio. Bitte erneut tippen.",
      "error_audio_resume": "Audio konnte nicht fortgesetzt werden.",
      "error_apply_preset": "Fehler beim Anwenden des Presets.",
      "error_apply_fxchain": "Fehler beim Anwenden der FX-Kette.",
      "error_loading_presets": "Fehler beim Laden der Presets.",
      "error_loading_fxchains": "Fehler beim Laden der Ketten",
      "error_loading_effects_ui": "Fehler beim Laden der Effekt-UI.",
      "no_presets_found": "Keine Presets gefunden.",
      "no_fxchains_found": "Keine FX-Ketten gefunden",
      "no_effects_available": "Keine Effekte verfügbar.",
      "enter_preset_name": "Bitte gib einen Preset-Namen ein.",
      "enter_fxchain_name": "Bitte gib einen FX-Ketten-Namen ein.",
      "preset_saved_success": "Preset \"${name}\" erfolgreich gespeichert!",
      "fxchain_saved_success": "FX-Kette \"${name}\" erfolgreich gespeichert!",
      "error_saving_preset": "Fehler beim Speichern des Presets: ${error}",
      "error_saving_fxchain": "Fehler beim Speichern der FX-Kette: ${error}",
      "exception_saving_preset": "Ausnahme beim Speichern des Presets: ${error}",
      "exception_saving_fxchain": "Ausnahme beim Speichern der FX-Kette: ${error}",
      "confirm_delete_preset": "Preset \"${name}\" wirklich löschen?",
      "confirm_delete_fxchain": "FX-Kette \"${name}\" wirklich löschen?",
      "cannot_delete_default_preset": "Standard-Presets können nicht gelöscht werden.",
      "cannot_delete_default_fxchain": "Standard-FX-Ketten können nicht gelöscht werden.",
      "preset_deleted_success": "Preset gelöscht.",
      "fxchain_deleted_success": "FX-Kette gelöscht.",
      "preset_delete_failed": "Preset konnte nicht gelöscht werden.",
      "fxchain_delete_failed": "FX-Kette konnte nicht gelöscht werden.",
      "exception_deleting_preset": "Ausnahme beim Löschen des Presets: ${error}",
      "exception_deleting_fxchain": "Ausnahme beim Löschen der FX-Kette: ${error}",
      "audio_not_ready_record": "Audio nicht bereit. Aufnahme kann nicht gestartet werden.",
      "pitch_envelope": "Tonhöhen-Hüllkurve",
      "pitch_amount_cents": "Betrag (Cents)",
      "macro_controls_title": "Makro-Regler",
      "macro_space": "Raum",
      "macro_time": "Zeit",
      "macro_motion": "Bewegung",
      "macro_tone": "Klangfarbe",
      "macro_drive": "Drive",
      "effects_intensity_min": "FX-Intensität Min. (dB)",
      "effects_intensity_max": "FX-Intensität Max. (dB)",
      "effects_threshold": "FX-Schwelle",
      "none_fxchain": "-- Keine --",
      "none_touch_effect": "Kein",
      "restart_audio_engine_button": "Audio Neustart",
      "reload_app_button_title": "App Neu Laden",
      "reloading_app_message": "App wird neu geladen...",
      "master_output_title": "Master-Ausgang",
      "master_volume_ceiling": "Lautstärke-Limit",
      "master_volume_ceiling_label": "Lautstärke-Limit",
      "y_axis_volume_min_output": "Min. Ausgabe",
      "y_axis_volume_max_output": "Max. Ausgabe",
      "y_axis_volume_y_threshold": "Y-Schwelle",
      "y_axis_curve_type": "Kurventyp",
      "y_axis_curve_factor": "Kurvenfaktor",
      "y_axis_effects_min_output": "Min. Ausgabe (dB)",
      "y_axis_effects_max_output": "Max. Ausgabe (dB)",
      "y_axis_effects_y_threshold": "Y-Schwelle",
      "logarithmic": "Logarithmisch",
      "s_curve": "S-Kurve",
      "select_option": "Option Auswählen",
      "no_options_found": "Keine Optionen gefunden",
      "error_loading_options": "Fehler beim Laden der Optionen.",
      "pad_modes_button": "Modi",
      "pad_modes_button_title": "Pad-Modi",
      "pad_modes_panel_title": "Pad-Modi",
      "pad_mode_label": "Pad-Modus",
      "pad_mode_select_title": "Pad-Modus Auswählen",
      "pad_mode_classic": "Klassisch",
      "pad_mode_reactive": "
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\language\en.json
{
  "id": "en",
  "type": "language",
  "name": "English",
  "version": "1.0.5",
  "description": "English language pack (Updated 25.05.2025)",
  "active": true,
  "data": {
    "strings": {
      "presets_panel_title": "Presets",
      "app_title": "Prismtone",
      "menu_button": "Menu",
      "sound_library_button": "Sound Library",
      "tonality_button": "Tonality",
      "effects_button": "Effects",
      "record_button": "Record",
      "stop_recording_button": "Stop Recording",
      "settings_title": "Settings",
      "language_label": "Language",
      "theme_label": "Theme",
      "visualizer_label": "Visualizer",
      "touch_effect_label": "Touch Effect",
      "display_options_header": "Display & Behavior",
      "show_note_names": "Show Note Names",
      "show_lines": "Show Grid Lines",
      "multi_touch": "Multi-touch",
      "enable_polyphony_scaling": "Polyphony Volume Scaling",
      "haptic_feedback": "Haptic Feedback",
      "enable_vibration": "Enable Vibration",
      "highlight_sharps_flats": "Highlight Accidentals",
      "tonality_title": "Tonality",
      "octave_label": "Octave",
      "scale_label": "Scale",
      "size_label": "Size",
      "effects_title": "Effects",
      "fx_chain_label": "FX Chain",
      "save_chain": "Save Chain",
      "delete_chain": "Delete Chain",
      "reset_fx": "Reset FX",
      "y_axis_controls": "Y-Axis Controls",
      "volume_min": "Volume Min",
      "volume_max": "Volume Max",
      "volume_curve": "Curve",
      "effects_min": "FX Send Min (dB)",
      "effects_max": "FX Send Max (dB)",
      "effects_curve": "Curve",
      "linear": "Linear",
      "exponential": "Exponential",
      "delay": "Delay",
      "reverb": "Reverb",
      "chorus": "Chorus",
      "distortion": "Distortion",
      "filter": "Filter",
      "phaser": "Phaser",
      "pitchShift": "Pitch Shift",
      "wet": "Wet",
      "time": "Time",
      "delayTime": "Time",
      "feedback": "Feedback",
      "decay": "Decay",
      "preDelay": "PreDelay",
      "frequency": "Frequency",
      "depth": "Depth",
      "Q": "Q",
      "type": "Type",
      "gain": "Gain",
      "rolloff": "Rolloff",
      "pitch": "Pitch",
      "octaves": "Octaves",
      "baseFrequency": "Base Freq",
      "sound_library_title": "Sound Library",
      "presets_title": "Presets",
      "save_preset": "Save New Sound",
      "delete_preset": "Delete Sound",
      "synth_controls": "Synth Controls",
      "synth_type": "Synth Type",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "Oscillator Type",
      "sine": "Sine",
      "square": "Square",
      "sawtooth": "Sawtooth",
      "triangle": "Triangle",
      "fat_sine": "Fat Sine",
      "fat_square": "Fat Square",
      "fat_sawtooth": "Fat Saw",
      "fat_triangle": "Fat Triangle",
      "fm_sine": "FM Sine",
      "fm_square": "FM Square",
      "fm_sawtooth": "FM Saw",
      "fm_triangle": "FM Triangle",
      "am_sine": "AM Sine",
      "am_square": "AM Square",
      "am_sawtooth": "AM Saw",
      "am_triangle": "AM Triangle",
      "pwm": "PWM",
      "pulse": "Pulse",
      "noise_white": "White Noise",
      "noise_pink": "Pink Noise",
      "noise_brown": "Brown Noise",
      "oscillator_params": "Oscillator Parameters",
      "phase": "Phase",
      "count": "Count",
      "spread": "Spread",
      "width": "Width",
      "mod_freq_short": "Mod Freq",
      "harmonicity": "Harmonicity",
      "mod_index": "Mod Index",
      "mod_type": "Mod Type",
      "noise_type": "Noise Type",
      "envelope": "Envelope",
      "attack": "Attack",
      "sustain": "Sustain",
      "release": "Release",
      "envelope_curves": "Envelope Curves",
      "attack_curve": "Attack",
      "decay_curve": "Decay",
      "release_curve": "Release",
      "filter_advanced": "Advanced Filter",
      "filter_rolloff": "Rolloff",
      "filter_gain": "Gain (dB)",
      "filter_envelope": "Filter Envelope",
      "base_frequency": "Base Freq",
      "exponent": "Exponent",
      "modulation": "Modulation",
      "modulation_envelope": "Modulation Envelope",
      "special_parameters": "Special Parameters",
      "pitch_decay": "Pitch Decay",
      "attack_noise": "Attack Noise",
      "dampening": "Dampening",
      "resonance": "Resonance",
      "lfo": "LFO",
      "lfo_type": "Type",
      "lfo_target": "Target",
      "lfo_min": "Min",
      "lfo_max": "Max",
      "save_preset_title": "Save Sound Preset",
      "preset_name_label": "Preset Name:",
      "preset_name_placeholder": "My Sound Preset",
      "save_fx_chain_title": "Save FX Chain",
      "fx_chain_name_label": "FX Chain Name:",
      "fx_chain_name_placeholder": "My FX Chain",
      "cancel": "Cancel",
      "save": "Save",
      "major": "Major",
      "minor": "Minor",
      "pentatonic": "Pentatonic",
      "blues": "Blues",
      "chromatic": "Chromatic",
      "dorian": "Dorian",
      "phrygian": "Phrygian",
      "lydian": "Lydian",
      "mixolydian": "Mixolydian",
      "locrian": "Locrian",
      "day": "Day",
      "night": "Night",
      "neon": "Neon",
      "retro": "Retro",
      "pastel": "Pastel",
      "aurora": "Aurora",
      "ocean": "Ocean",
      "cyberpunk": "Cyberpunk",
      "fire": "Fire",
      "matrix": "Matrix",
      "hologram": "Hologram",
      "crystal": "Crystal",
      "galaxy": "Galaxy",
      "waves": "Waves",
      "spectrum": "Spectrum",
      "particles": "School of Fish",
      "nebula": "Nebula",
      "reactive_ripples": "Reactive Ripples",
      "touch_trails": "Touch Trails",
      "loading": "Loading...",
      "initializing": "Initializing...",
      "loading_bridge": "Connecting...",
      "loading_settings": "Loading settings...",
      "loading_modules": "Loading modules...",
      "loading_ui": "Initializing UI...",
      "loading_presets": "Applying settings...",
      "loading_audio": "Loading sounds...",
      "tap_to_start": "Tap to start audio",
      "starting_audio": "Starting audio...",
      "audio_suspended": "Audio suspended. Tap to resume.",
      "loading_preset": "Loading Preset...",
      "loading_fxchain": "Loading FX Chain...",
      "saving_preset_progress": "Saving preset...",
      "saving_fxchain_progress": "Saving FX chain...",
      "deleting_preset_progress": "Deleting preset...",
      "deleting_fxchain_progress": "Deleting FX chain...",
      "hit_play_vibe": "Hit Play, Feel the Vibe",
      "error_bridge_failed": "Error: Bridge connection failed.",
      "error_init_failed": "Initialization Error. Check console.",
      "error_init_failed_details": "Initialization Error: ${error}. Check console.",
      "error_fatal_init": "Fatal Initialization Error. Please restart.",
      "error_audio_failed_retry": "Error starting audio. Please tap again.",
      "error_audio_resume": "Failed to resume audio.",
      "error_apply_preset": "Error applying preset.",
      "error_apply_fxchain": "Error applying FX chain.",
      "error_loading_presets": "Error loading presets.",
      "error_loading_fxchains": "Error loading chains",
      "error_loading_effects_ui": "Error loading effects UI.",
      "no_presets_found": "No presets found.",
      "no_fxchains_found": "No FX chains found",
      "no_effects_available": "No effects available.",
      "enter_preset_name": "Please enter a preset name.",
      "enter_fxchain_name": "Please enter an FX chain name.",
      "preset_saved_success": "Preset \"${name}\" saved successfully!",
      "fxchain_saved_success": "FX Chain \"${name}\" saved successfully!",
      "error_saving_preset": "Error saving preset: ${error}",
      "error_saving_fxchain": "Error saving FX chain: ${error}",
      "exception_saving_preset": "Exception saving preset: ${error}",
      "exception_saving_fxchain": "Exception saving FX chain: ${error}",
      "confirm_delete_preset": "Are you sure you want to delete preset \"${name}\"?",
      "confirm_delete_fxchain": "Are you sure you want to delete FX chain \"${name}\"?",
      "cannot_delete_default_preset": "Cannot delete default presets.",
      "cannot_delete_default_fxchain": "Cannot delete default FX chains.",
      "preset_deleted_success": "Preset deleted.",
      "fxchain_deleted_success": "FX Chain deleted.",
      "preset_delete_failed": "Failed to delete preset.",
      "fxchain_delete_failed": "Failed to delete FX chain.",
      "exception_deleting_preset": "Exception deleting preset: ${error}",
      "exception_deleting_fxchain": "Exception deleting FX chain: ${error}",
      "audio_not_ready_record": "Audio is not ready. Cannot start recording.",
      "pitch_envelope": "Pitch Envelope",
      "pitch_amount_cents": "Amount (Cents)",
      "macro_controls_title": "Macro Controls",
      "macro_space": "Space",
      "macro_time": "Time",
      "macro_motion": "Motion",
      "macro_tone": "Tone",
      "macro_drive": "Drive",
      "effects_intensity_min": "FX Intensity Min (dB)",
      "effects_intensity_max": "FX Intensity Max (dB)",
      "effects_threshold": "FX Threshold",
      "none_fxchain": "-- None --",
      "none_touch_effect": "None",
      "restart_audio_engine_button": "Restart Audio",
      "reload_app_button_title": "Reload App",
      "reloading_app_message": "Reloading application...",
      "master_output_title": "Master Output",
      "master_volume_ceiling": "Volume Ceiling",
      "master_volume_ceiling_label": "Master Volume Ceiling",
      "y_axis_volume_min_output": "Min Output",
      "y_axis_volume_max_output": "Max Output",
      "y_axis_volume_y_threshold": "Y Threshold",
      "y_axis_curve_type": "Curve Type",
      "y_axis_curve_factor": "Curve Factor",
      "y_axis_effects_min_output": "Min Output (dB)",
      "y_axis_effects_max_output": "Max Output (dB)",
      "y_axis_effects_y_threshold": "Y Threshold",
      "logarithmic": "Logarithmic",
      "s_curve": "S-Curve",
      "select_option": "Select Option",
      "no_options_found": "No options found",
      "error_loading_options": "Error loading options.",
      "pad_modes_button": "Modes",
      "pad_modes_panel_title": "Pad Modes",
      "pad_mode_label": "Pad Mode",
      "pad_mode_select_title": "Select Pad Mode",
      "pad_mode_classic": "Classic",
      "pad_mode_reactive": "Reactive",
      "reactive_mode_show_suggestions": "Show Harmonic Hints",
      "reactive_mode_suggestion_count": "Hint Count",
      "no_specific_settings_classic": "No specific settings for Classic mode.",
      "no_specific_settings_reactive": "Configure Reactive mode hints.",
      "pad_mode_rocket": "Rocket",
      "rocket_highlight_active": "Highlight Active Notes",
      "rocket_show_markers": "Show Directional Markers",
      "rocket_marker_style": "Marker Style",
      "rocket_valid_chords_only": "Show Markers Only for Valid Chords",
      "rocket_animate_fade": "Animate Marker Fade-Out",
      "rocket_show_chord_name": "Show Recognized Chord Name",
      "style_GlowFromNote": "Glow From Note",
      "style_WaveToNote": "Wave To Note",
      "style_PulseRing": "Pulse Ring",
      "style_SparkTrail": "Spark Trail",
      "style_ShadowDrop": "Shadow Drop",
      "rocket_mode_panel_title": "Rocket Mode",
      "rocket_mode_enable": "Enable Rocket Mode",
      "rocket_mode_settings_placeholder": "Rocket Mode settings will appear here.",
      "error_loading_mode_settings": "Error loading mode settings.",
      "no_specific_settings_rocket": "Configure Rocket mode specific settings.",
      "reset_settings_button": "Reset All Settings",
      "reload_app_button": "Full App Reload",
      "restart_audio_button": "Restart Audio Engine",
      "rocket_section_general": "General",
      "rocket_section_phases": "Phases",
      "rocket_section_harmonic_logic": "Harmonic Logic",
      "rocket_section_interactive_behavior": "Interactive Behavior",
      "rocket_intensity": "Intensity",
      "rocket_visual_theme": "Visual Theme",
      "rocket_auto_phases": "Auto Phases",
      "rocket_harmonic_key": "Harmonic Key",
      "rocket_marker_logic": "Marker Logic",
      "marker_logic_tonal": "Tonal Binding",
      "marker_logic_adaptive": "Adaptive Analysis",
      "marker_logic_semi_free": "Semi-Free",
      "marker_logic_random": "Random Directed",
      "rocket_phase_ignition": "Ignition",
      "rocket_phase_lift_off": "Lift-off",
      "rocket_phase_burst": "Burst",
      "rocket_phase_transition": "Phase Transition",
      "phase_mode_activity": "By Activity",
      "phase_mode_time": "By Time",
      "phase_mode_manual": "Manual",
      "status_chord": "Chord",
      "status_key": "Key",
      "status_next": "Next",
      "status_energy": "Energy",
      "status_phase": "Phase",
      "status_na": "N/A",
      "rocket_presets_title": "Mode Presets",
      "rocket_select_preset": "Select Preset",
      "rocket_select_preset_title": "Select Rocket Mode Preset",
      "rocket_preset_current": "Current Settings",
      "none_selected": "None",
      "preset_rocket_melodic_drift": "Melodic Drift",
      "desc_rocket_melodic_drift": "Gentle, floating, semi-free harmonic logic.",
      "preset_rocket_jazz_climb": "Jazz Climb",
      "desc_rocket_jazz_climb": "Active, adaptive, jazz-inspired logic.",
      "rocket_marker_labels": "Marker Labels",
      "labels_none": "None",
      "labels_function": "Function (T/S/D)",
      "labels_chord_name": "Chord Name",
      "rocket_marker_retention": "Marker Retention",
      "desc_rocket_marker_retention": "Keep relevant markers visible during new touches.",
      "desc_rocket_animate_fade": "Smoothly fade out non-relevant markers.",
      "rocket_fade_delay": "Fade-Out Delay",
      "desc_rocket_fade_delay": "Delay before marker starts fading out.",
      "rocket_fade_duration": "Fade-Out Duration",
      "desc_rocket_fade_duration": "Duration of the marker fade-out animation.",
      "rocket_max_markers_zone": "Max Markers/Zone",
      "desc_rocket_max_markers_zone": "Maximum suggestions shown per zone.",
      "rocket_phase_styles": "Phase Styles",
      "desc_rocket_phase_styles": "Allow current phase to override marker style.",
      "rocket_tb_in_key": "Tonal Binding In-Key Only",
      "desc_rocket_tb_in_key": "Only suggest notes/chords within the current key.",
      "rocket_aa_autokey": "Adaptive Auto Key Change",
      "desc_rocket_aa_autokey": "Allow adaptive key changes based on input.",
      "rocket_sf_basekey": "Semi-Free Base Key",
      "desc_rocket_sf_basekey": "Base key for semi-free mode.",
      "rocket_sf_deviations": "Semi-Free Modal Deviations",
      "desc_rocket_sf_deviations": "Allow temporary deviations from base key.",
      "rocket_sf_return": "Semi-Free Highlight Return",
      "desc_rocket_sf_return": "Highlight suggestions returning to base key.",
      "rocket_rd_randomlevel": "Randomization Level",
      "desc_rocket_rd_randomlevel": "Level of randomness in suggestions.",
      "select_chord": "Select Chord",
      "select_key": "Select Key",
      "select_phase": "Select Phase",
      "no_language_found": "No languages found",
      "no_theme_found": "No themes found",
      "no_visualizer_found": "No visualizers found",
      "no_touchEffect_found": "No touch effects found",
      "no_scale_found": "No scales found",
      "no_fxChain_found": "No FX chains found",
      "error_audio_fatal_restart": "Fatal audio error. Please restart the app."
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\language\es.json
{
  "id": "es",
  "type": "language",
  "name": "Español",
  "version": "1.0.5",
  "description": "Spanish language pack (Updated 25.05.2025)",
  "active": false,
  "data": {
    "strings": {
      "presets_panel_title": "Presets",
      "app_title": "Prismtone",
      "menu_button": "Menú",
      "sound_library_button": "Biblioteca de Sonidos",
      "tonality_button": "Tonalidad",
      "effects_button": "Efectos",
      "record_button": "Grabar",
      "stop_recording_button": "Detener Grabación",
      "settings_title": "Ajustes",
      "language_label": "Idioma",
      "theme_label": "Tema",
      "visualizer_label": "Visualizador",
      "touch_effect_label": "Efecto Táctil",
      "display_options_header": "Visualización y Comportamiento",
      "show_note_names": "Mostrar Nombres de Notas",
      "show_lines": "Mostrar Líneas de Cuadrícula",
      "multi_touch": "Multitáctil",
      "enable_polyphony_scaling": "Escala de Vol. Polifonía",
      "haptic_feedback": "Respuesta Háptica",
      "enable_vibration": "Activar Vibración",
      "highlight_sharps_flats": "Resaltar Sostenidos/Bemoles",
      "tonality_title": "Tonalidad",
      "octave_label": "Octava",
      "scale_label": "Escala",
      "size_label": "Tamaño",
      "effects_title": "Efectos",
      "fx_chain_label": "Cadena de Efectos",
      "save_chain": "Guardar Cadena",
      "delete_chain": "Eliminar Cadena",
      "reset_fx": "Reiniciar Efectos",
      "y_axis_controls": "Controles Eje Y",
      "volume_min": "Volumen Mín.",
      "volume_max": "Volumen Máx.",
      "volume_curve": "Curva",
      "effects_min": "Envío FX Mín. (dB)",
      "effects_max": "Envío FX Máx. (dB)",
      "effects_curve": "Curva",
      "linear": "Lineal",
      "exponential": "Exponencial",
      "delay": "Retardo",
      "reverb": "Reverberación",
      "chorus": "Chorus",
      "distortion": "Distorsión",
      "filter": "Filtro",
      "phaser": "Phaser",
      "pitchShift": "Cambio de Tono",
      "wet": "Mezcla",
      "time": "Tiempo",
      "delayTime": "Tiempo",
      "feedback": "Retroalimentación",
      "decay": "Decaimiento",
      "preDelay": "Pre-Retardo",
      "frequency": "Frecuencia",
      "depth": "Profundidad",
      "Q": "Q",
      "type": "Tipo",
      "gain": "Ganancia",
      "rolloff": "Atenuación",
      "pitch": "Tono",
      "octaves": "Octavas",
      "baseFrequency": "Frec. Base",
      "sound_library_title": "Biblioteca de Sonidos",
      "presets_title": "Presets",
      "save_preset": "Guardar Nuevo Sonido",
      "delete_preset": "Eliminar Sonido",
      "synth_controls": "Controles del Sintetizador",
      "synth_type": "Tipo de Sintetizador",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "Tipo de Oscilador",
      "sine": "Sinusoidal",
      "square": "Cuadrada",
      "sawtooth": "Diente de Sierra",
      "triangle": "Triangular",
      "fat_sine": "Fat Sinusoidal",
      "fat_square": "Fat Cuadrada",
      "fat_sawtooth": "Fat Diente de Sierra",
      "fat_triangle": "Fat Triangular",
      "fm_sine": "FM Sinusoidal",
      "fm_square": "FM Cuadrada",
      "fm_sawtooth": "FM Diente de Sierra",
      "fm_triangle": "FM Triangular",
      "am_sine": "AM Sinusoidal",
      "am_square": "AM Cuadrada",
      "am_sawtooth": "AM Diente de Sierra",
      "am_triangle": "AM Triangular",
      "pwm": "PWM",
      "pulse": "Pulso",
      "noise_white": "Ruido Blanco",
      "noise_pink": "Ruido Rosa",
      "noise_brown": "Ruido Marrón",
      "oscillator_params": "Parámetros del Oscilador",
      "phase": "Fase",
      "count": "Cantidad",
      "spread": "Dispersión",
      "width": "Ancho",
      "mod_freq_short": "Frec. Mod.",
      "harmonicity": "Armonicidad",
      "mod_index": "Índice Mod.",
      "mod_type": "Tipo Mod.",
      "noise_type": "Tipo de Ruido",
      "envelope": "Envolvente",
      "attack": "Ataque",
      "sustain": "Sostenido",
      "release": "Relajación",
      "envelope_curves": "Curvas de Envolvente",
      "attack_curve": "Ataque",
      "decay_curve": "Decaimiento",
      "release_curve": "Relajación",
      "filter_advanced": "Filtro Avanzado",
      "filter_rolloff": "Atenuación",
      "filter_gain": "Ganancia (dB)",
      "filter_envelope": "Envolvente de Filtro",
      "base_frequency": "Frec. Base",
      "exponent": "Exponente",
      "modulation": "Modulación",
      "modulation_envelope": "Envolvente de Modulación",
      "special_parameters": "Parámetros Especiales",
      "pitch_decay": "Decaimiento de Tono",
      "attack_noise": "Ruido de Ataque",
      "dampening": "Amortiguación",
      "resonance": "Resonancia",
      "lfo": "LFO",
      "lfo_type": "Tipo",
      "lfo_target": "Objetivo",
      "lfo_min": "Mín.",
      "lfo_max": "Máx.",
      "save_preset_title": "Guardar Preset de Sonido",
      "preset_name_label": "Nombre del Preset:",
      "preset_name_placeholder": "Mi Preset de Sonido",
      "save_fx_chain_title": "Guardar Cadena de Efectos",
      "fx_chain_name_label": "Nombre de la Cadena:",
      "fx_chain_name_placeholder": "Mi Cadena de Efectos",
      "cancel": "Cancelar",
      "save": "Guardar",
      "major": "Mayor",
      "minor": "Menor",
      "pentatonic": "Pentatónica",
      "blues": "Blues",
      "chromatic": "Cromática",
      "dorian": "Dórica",
      "phrygian": "Frigia",
      "lydian": "Lidia",
      "mixolydian": "Mixolidia",
      "locrian": "Locria",
      "day": "Día",
      "night": "Noche",
      "neon": "Neón",
      "retro": "Retro",
      "pastel": "Pastel",
      "aurora": "Aurora",
      "ocean": "Océano",
      "cyberpunk": "Cyberpunk",
      "fire": "Fuego",
      "matrix": "Matrix",
      "hologram": "Holograma",
      "crystal": "Cristal",
      "galaxy": "Galaxia",
      "waves": "Ondas",
      "spectrum": "Espectro",
      "particles": "Banco de Peces",
      "nebula": "Nebulosa",
      "reactive_ripples": "Ondas Reactivas",
      "touch_trails": "Estelas Táctiles",
      "loading": "Cargando...",
      "initializing": "Inicializando...",
      "loading_bridge": "Conectando...",
      "loading_settings": "Cargando ajustes...",
      "loading_modules": "Cargando módulos...",
      "loading_ui": "Inicializando UI...",
      "loading_presets": "Aplicando ajustes...",
      "loading_audio": "Cargando sonidos...",
      "tap_to_start": "Toca para iniciar audio",
      "starting_audio": "Iniciando audio...",
      "audio_suspended": "Audio suspendido. Toca para reanudar.",
      "loading_preset": "Cargando Preset...",
      "loading_fxchain": "Cargando Cadena FX...",
      "saving_preset_progress": "Guardando preset...",
      "saving_fxchain_progress": "Guardando cadena FX...",
      "deleting_preset_progress": "Eliminando preset...",
      "deleting_fxchain_progress": "Eliminando cadena FX...",
      "hit_play_vibe": "Toca Play, Siente la Vibra",
      "error_bridge_failed": "Error: Falló la conexión del puente.",
      "error_init_failed": "Error de Inicialización. Revisa la consola.",
      "error_init_failed_details": "Error de Inicialización: ${error}. Revisa la consola.",
      "error_fatal_init": "Error Crítico de Inicialización. Por favor, reinicia.",
      "error_audio_failed_retry": "Error al iniciar audio. Por favor, toca de nuevo.",
      "error_audio_resume": "No se pudo reanudar el audio.",
      "error_apply_preset": "Error al aplicar preset.",
      "error_apply_fxchain": "Error al aplicar cadena FX.",
      "error_loading_presets": "Error al cargar presets.",
      "error_loading_fxchains": "Error al cargar cadenas",
      "error_loading_effects_ui": "Error al cargar UI de efectos.",
      "no_presets_found": "No se encontraron presets.",
      "no_fxchains_found": "No se encontraron cadenas FX",
      "no_effects_available": "No hay efectos disponibles.",
      "enter_preset_name": "Por favor, introduce un nombre para el preset.",
      "enter_fxchain_name": "Por favor, introduce un nombre para la cadena FX.",
      "preset_saved_success": "¡Preset \"${name}\" guardado con éxito!",
      "fxchain_saved_success": "¡Cadena FX \"${name}\" guardada con éxito!",
      "error_saving_preset": "Error al guardar preset: ${error}",
      "error_saving_fxchain": "Error al guardar cadena FX: ${error}",
      "exception_saving_preset": "Excepción al guardar preset: ${error}",
      "exception_saving_fxchain": "Excepción al guardar cadena FX: ${error}",
      "confirm_delete_preset": "¿Seguro que quieres eliminar el preset \"${name}\"?",
      "confirm_delete_fxchain": "¿Seguro que quieres eliminar la cadena FX \"${name}\"?",
      "cannot_delete_default_preset": "No se pueden eliminar presets predeterminados.",
      "cannot_delete_default_fxchain": "No se pueden eliminar cadenas FX predeterminadas.",
      "preset_deleted_success": "Preset eliminado.",
      "fxchain_deleted_success": "Cadena FX eliminada.",
      "preset_delete_failed": "No se pudo eliminar el preset.",
      "fxchain_delete_failed": "No se pudo eliminar la cadena FX.",
      "exception_deleting_preset": "Excepción al eliminar preset: ${error}",
      "exception_deleting_fxchain": "Excepción al eliminar cadena FX: ${error}",
      "audio_not_ready_record": "El audio no está listo. No se puede iniciar la grabación.",
      "pitch_envelope": "Envolvente de Tono",
      "pitch_amount_cents": "Cantidad (Cents)",
      "macro_controls_title": "Controles Macro",
      "macro_space": "Espacio",
      "macro_time": "Tiempo",
      "macro_motion": "Movimiento",
      "macro_tone": "Tono",
      "macro_drive": "Drive",
      "effects_intensity_min": "Intensidad FX Mín. (dB)",
      "effects_intensity_max": "Intensidad FX Máx. (dB)",
      "effects_threshold": "Umbral FX",
      "none_fxchain": "-- Ninguno --",
      "none_touch_effect": "Ninguno",
      "restart_audio_engine_button": "Reiniciar Audio",
      "reload_app_button_title": "Recargar App",
      "reloading_app_message": "Recargando aplicación...",
      "master_output_title": "Salida Maestra",
      "master_volume_ceiling": "Techo de Volumen",
      "master_volume_ceiling_label": "Techo de Volumen",
      "y_axis_volume_min_output": "Salida Mín.",
      "y_axis_volume_max_output": "Salida Máx.",
      "y_axis_volume_y_threshold": "Umbral Y",
      "y_axis_curve_type": "Tipo de Curva",
      "y_axis_curve_factor": "Factor Curva",
      "y_axis_effects_min_output": "Salida Mín. (dB)",
      "y_axis_effects_max_output": "Salida Máx. (dB)",
      "y_axis_effects_y_threshold": "Umbral Y",
      "logarithmic": "Logarítmica",
      "s_curve": "Curva-S",
      "select_option": "Seleccionar Opción",
      "no_options_found": "No se encontraron opciones",
      "error_loading_options": "Error al cargar opciones.",
      "pad_modes_button": "Modos",
      "pad_modes_button_title": "Modos del Pad",
      "pad_modes_panel_title": "Modos del Pad",
      "pad_mode_label": "Modo del Pad",
      "pad_mode_select_title": "Seleccionar Modo del Pad",
      "pad_mode_classic": "Clásico",
      "pad_mode_reactive": "Reactivo",
      "reactive_mode_show_suggestions": "Mostrar Pistas Armónicas",
      "reactive_mode_suggestion_count": "Nº de Pistas",
      "no_specific_settings_classic": "Sin ajustes específicos para el modo Clásico.",
      "no_specific_settings_reactive": "Configurar pistas del modo Reactivo.",
      "pad_mode_rocket": "Cohete",
      "rocket_highlight_active": "Resaltar Notas Activas",
      "rocket_show_markers": "Mostrar Marcadores Direccionales",
      "rocket_marker_style": "Estilo de Marcador",
      "rocket_valid_chords_only": "Marcadores Solo para Acordes Válidos",
      "rocket_animate_fade": "Animar Desvanecimiento de Marcadores",
      "rocket_show_chord_name": "Mostrar Nombre de Acorde Reconocido",
      "style_GlowFromNote": "Brillo desde Nota",
      "style_WaveToNote": "Onda hacia Nota",
      "style_PulseRing": "Anillo Pulsante",
      "style_SparkTrail": "Estela de Chispas",
      "style_ShadowDrop": "Sombra bajo Nota",
      "rocket_mode_panel_title": "Modo Cohete",
      "rocket_mode_enable": "Activar Modo Cohete",
      "rocket_mode_settings_placeholder": "Ajustes del Modo Cohete aparecerán aquí.",
      "error_loading_mode_settings": "Error al cargar ajustes del modo.",
      "no_specific_settings_rocket": "Configurar ajustes específicos del modo Cohete.",
      "reset_settings_button": "Reiniciar Todos los Ajustes",
      "reload_app_button": "Recarga Completa de App",
      "restart_audio_button": "Reiniciar Motor de Audio",
      "rocket_section_general": "General",
      "rocket_section_phases": "Fases",
      "rocket_section_harmonic_logic": "Lógica Armónica",
      "rocket_section_interactive_behavior": "Comportamiento Interactivo",
      "rocket_intensity": "Intensidad",
      "rocket_visual_theme": "Tema Visual",
      "rocket_auto_phases": "Fases Automáticas",
      "rocket_harmonic_key": "Clave Armónica",
      "rocket_marker_logic": "Lógica de Marcadores",
      "marker_logic_tonal": "Vinculación Tonal",
      "marker_logic_adaptive": "Análisis Adaptativo",
      "marker_logic_semi_free": "Semi-Libre",
      "marker_logic_random": "Aleatorio Dirigido",
      "rocket_phase_ignition": "Ignición",
      "rocket_phase_lift_off": "Despegue",
      "rocket_phase_burst": "Explosión",
      "rocket_phase_transition": "Transición de Fase",
      "phase_mode_activity": "Por Actividad",
      "phase_mode_time": "Por Tiempo",
      "phase_mode_manual": "Manual",
      "status_chord": "Acorde",
      "status_key": "Tonalidad",
      "status_next": "Siguiente",
      "status_energy": "Energía",
      "status_phase": "Fase",
      "status_na": "N/A",
      "rocket_presets_title": "Presets del Modo",
      "rocket_select_preset": "Seleccionar Preset",
      "rocket_select_preset_title": "Seleccionar Preset Modo Cohete",
      "rocket_preset_current": "Ajustes Actuales",
      "none_selected": "Ninguno",
      "preset_rocket_melodic_drift": "Deriva Melódica",
      "desc_rocket_melodic_drift": "Lógica armónica suave, flotante, semi-libre.",
      "preset_rocket_jazz_climb": "Ascenso Jazzístico",
      "desc_rocket_jazz_climb": "Lógica activa, adaptativa, de inspiración jazz.",
      "rocket_marker_labels": "Etiquetas de Marcador",
      "labels_none": "Ninguna",
      "labels_function": "Función (T/S/D)",
      "labels_chord_name": "Nombre de Acorde",
      "rocket_marker_retention": "Retención de Marcadores",
      "desc_rocket_marker_retention": "Mantener marcadores relevantes visibles durante nuevos toques.",
      "desc_rocket_animate_fade": "Desvanecer suavemente marcadores no relevantes.",
      "rocket_fade_delay": "Retardo Desvanecimiento",
      "desc_rocket_fade_delay": "Retardo antes de que el marcador comience a desvanecerse.",
      "rocket_fade_duration": "Duración Desvanecimiento",
      "desc_rocket_fade_duration": "Duración de la animación de desvanecimiento del marcador.",
      "rocket_max_markers_zone": "Máx Marcadores/Zona",
      "desc_rocket_max_markers_zone": "Máximo de sugerencias mostradas por zona.",
      "rocket_phase_styles": "Estilos de Fase",
      "desc_rocket_phase_styles": "Permitir que la fase actual anule el estilo del marcador.",
      "rocket_tb_in_key": "Vinc. Tonal: Solo en Tonalidad",
      "desc_rocket_tb_in_key": "Sugerir solo notas/acordes dentro de la tonalidad actual.",
      "rocket_aa_autokey": "Anál. Adapt.: Auto Cambio Tonalidad",
      "desc_rocket_aa_autokey": "Permitir cambios adaptativos de tonalidad basados en la entrada.",
      "rocket_sf_basekey": "Semi-Libre: Tonalidad Base",
      "desc_rocket_sf_basekey": "Tonalidad base para el modo semi-libre.",
      "rocket_sf_deviations": "Semi-Libre: Desviaciones Modales",
      "desc_rocket_sf_deviations": "Permitir desviaciones temporales de la tonalidad base.",
      "rocket_sf_return": "Semi-Libre: Resaltar Retorno",
      "desc_rocket_sf_return": "Resaltar sugerencias que retornan a la tonalidad base.",
      "rocket_rd_randomlevel": "Nivel de Aleatoriedad",
      "desc_rocket_rd_randomlevel": "Nivel de aleatoriedad en las sugerencias.",
      "select_chord": "Seleccionar Acorde",
      "select_key": "Seleccionar Tonalidad",
      "select_phase": "Seleccionar Fase",
      "no_language_found": "No se encontraron idiomas",
      "no_theme_found": "No se encontraron temas",
      "no_visualizer_found": "No se encontraron visualizadores",
      "no_touchEffect_found": "No se encontraron efectos táctiles",
      "no_scale_found": "No se encontraron escalas",
      "no_fxChain_found": "No se encontraron cadenas de FX",
      "error_audio_fatal_restart": "Error crítico de audio. Por favor, reinicie la aplicación.",
      "presets_panel_title": "Presets"
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\language\fr.json
{
  "id": "fr",
  "type": "language",
  "name": "Français",
  "version": "1.0.5",
  "description": "French language pack (Updated 25.05.2025)",
  "active": false,
  "data": {
    "strings": {
      "presets_panel_title": "Presets",
      "app_title": "Prismtone",
      "menu_button": "Menu",
      "sound_library_button": "Bibliothèque de Sons",
      "tonality_button": "Tonalité",
      "effects_button": "Effets",
      "record_button": "Enregistrer",
      "stop_recording_button": "Arrêter l'Enregistrement",
      "settings_title": "Paramètres",
      "language_label": "Langue",
      "theme_label": "Thème",
      "visualizer_label": "Visualiseur",
      "touch_effect_label": "Effet Tactile",
      "display_options_header": "Affichage et Comportement",
      "show_note_names": "Afficher Noms des Notes",
      "show_lines": "Afficher Lignes de Grille",
      "multi_touch": "Multitouch",
      "enable_polyphony_scaling": "Échelle Vol. Polyphonie",
      "haptic_feedback": "Retour Haptique",
      "enable_vibration": "Activer Vibration",
      "highlight_sharps_flats": "Surligner Dièses/Bémols",
      "tonality_title": "Tonalité",
      "octave_label": "Octave",
      "scale_label": "Gamme",
      "size_label": "Taille",
      "effects_title": "Effets",
      "fx_chain_label": "Chaîne d'Effets",
      "save_chain": "Sauvegarder Chaîne",
      "delete_chain": "Supprimer Chaîne",
      "reset_fx": "Réinitialiser Effets",
      "y_axis_controls": "Contrôles Axe Y",
      "volume_min": "Volume Min.",
      "volume_max": "Volume Max.",
      "volume_curve": "Courbe",
      "effects_min": "Envoi FX Min. (dB)",
      "effects_max": "Envoi FX Max. (dB)",
      "effects_curve": "Courbe",
      "linear": "Linéaire",
      "exponential": "Exponentielle",
      "delay": "Délai",
      "reverb": "Réverbération",
      "chorus": "Chorus",
      "distortion": "Distorsion",
      "filter": "Filtre",
      "phaser": "Phaser",
      "pitchShift": "Décalage de Hauteur",
      "wet": "Mélange",
      "time": "Temps",
      "delayTime": "Temps",
      "feedback": "Rétroaction",
      "decay": "Déclin",
      "preDelay": "Pré-Délai",
      "frequency": "Fréquence",
      "depth": "Profondeur",
      "Q": "Q",
      "type": "Type",
      "gain": "Gain",
      "rolloff": "Atténuation",
      "pitch": "Hauteur",
      "octaves": "Octaves",
      "baseFrequency": "Fréq. Base",
      "sound_library_title": "Bibliothèque de Sons",
      "presets_title": "Presets",
      "save_preset": "Sauvegarder Nouveau Son",
      "delete_preset": "Supprimer Son",
      "synth_controls": "Contrôles du Synthé",
      "synth_type": "Type de Synthé",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "Type d'Oscillateur",
      "sine": "Sinusoïdale",
      "square": "Carrée",
      "sawtooth": "Dent de Scie",
      "triangle": "Triangulaire",
      "fat_sine": "Fat Sinusoïdale",
      "fat_square": "Fat Carrée",
      "fat_sawtooth": "Fat Dent de Scie",
      "fat_triangle": "Fat Triangulaire",
      "fm_sine": "FM Sinusoïdale",
      "fm_square": "FM Carrée",
      "fm_sawtooth": "FM Dent de Scie",
      "fm_triangle": "FM Triangulaire",
      "am_sine": "AM Sinusoïdale",
      "am_square": "AM Carrée",
      "am_sawtooth": "AM Dent de Scie",
      "am_triangle": "AM Triangulaire",
      "pwm": "PWM",
      "pulse": "Impulsion",
      "noise_white": "Bruit Blanc",
      "noise_pink": "Bruit Rose",
      "noise_brown": "Bruit Brun",
      "oscillator_params": "Paramètres de l'Oscillateur",
      "phase": "Phase",
      "count": "Nombre",
      "spread": "Dispersion",
      "width": "Largeur",
      "mod_freq_short": "Fréq. Mod.",
      "harmonicity": "Harmonicité",
      "mod_index": "Indice Mod.",
      "mod_type": "Type Mod.",
      "noise_type": "Type de Bruit",
      "envelope": "Enveloppe",
      "attack": "Attaque",
      "sustain": "Sustain",
      "release": "Relâchement",
      "envelope_curves": "Courbes d'Enveloppe",
      "attack_curve": "Attaque",
      "decay_curve": "Déclin",
      "release_curve": "Relâchement",
      "filter_advanced": "Filtre Avancé",
      "filter_rolloff": "Atténuation",
      "filter_gain": "Gain (dB)",
      "filter_envelope": "Enveloppe de Filtre",
      "base_frequency": "Fréq. Base",
      "exponent": "Exposant",
      "modulation": "Modulation",
      "modulation_envelope": "Enveloppe de Modulation",
      "special_parameters": "Paramètres Spéciaux",
      "pitch_decay": "Déclin de Hauteur",
      "attack_noise": "Bruit d'Attaque",
      "dampening": "Amortissement",
      "resonance": "Résonance",
      "lfo": "LFO",
      "lfo_type": "Type",
      "lfo_target": "Cible",
      "lfo_min": "Min.",
      "lfo_max": "Max.",
      "save_preset_title": "Sauvegarder Preset de Son",
      "preset_name_label": "Nom du Preset :",
      "preset_name_placeholder": "Mon Preset de Son",
      "save_fx_chain_title": "Sauvegarder Chaîne d'Effets",
      "fx_chain_name_label": "Nom de la Chaîne :",
      "fx_chain_name_placeholder": "Ma Chaîne d'Effets",
      "cancel": "Annuler",
      "save": "Sauvegarder",
      "major": "Majeure",
      "minor": "Mineure",
      "pentatonic": "Pentatonique",
      "blues": "Blues",
      "chromatic": "Chromatique",
      "dorian": "Dorien",
      "phrygian": "Phrygien",
      "lydian": "Lydien",
      "mixolydian": "Mixolydien",
      "locrian": "Locrien",
      "day": "Jour",
      "night": "Nuit",
      "neon": "Néon",
      "retro": "Rétro",
      "pastel": "Pastel",
      "aurora": "Aurore",
      "ocean": "Océan",
      "cyberpunk": "Cyberpunk",
      "fire": "Feu",
      "matrix": "Matrice",
      "hologram": "Hologramme",
      "crystal": "Cristal",
      "galaxy": "Galaxie",
      "waves": "Ondes",
      "spectrum": "Spectre",
      "particles": "Banc de Poissons",
      "nebula": "Nébuleuse",
      "reactive_ripples": "Ondulations Réactives",
      "touch_trails": "Traînées Tactiles",
      "loading": "Chargement...",
      "initializing": "Initialisation...",
      "loading_bridge": "Connexion...",
      "loading_settings": "Chargement des paramètres...",
      "loading_modules": "Chargement des modules...",
      "loading_ui": "Initialisation UI...",
      "loading_presets": "Application des paramètres...",
      "loading_audio": "Chargement des sons...",
      "tap_to_start": "Touchez pour démarrer l'audio",
      "starting_audio": "Démarrage audio...",
      "audio_suspended": "Audio suspendu. Touchez pour reprendre.",
      "loading_preset": "Chargement du Preset...",
      "loading_fxchain": "Chargement de la Chaîne FX...",
      "saving_preset_progress": "Sauvegarde du preset...",
      "saving_fxchain_progress": "Sauvegarde de la chaîne FX...",
      "deleting_preset_progress": "Suppression du preset...",
      "deleting_fxchain_progress": "Suppression de la chaîne FX...",
      "hit_play_vibe": "Touchez Play, Sentez la Vibe",
      "error_bridge_failed": "Erreur : Échec de connexion du pont.",
      "error_init_failed": "Erreur d'Initialisation. Vérifiez la console.",
      "error_init_failed_details": "Erreur d'Initialisation : ${error}. Vérifiez la console.",
      "error_fatal_init": "Erreur Critique d'Initialisation. Veuillez redémarrer.",
      "error_audio_failed_retry": "Erreur au démarrage de l'audio. Veuillez toucher à nouveau.",
      "error_audio_resume": "Échec de la reprise audio.",
      "error_apply_preset": "Erreur d'application du preset.",
      "error_apply_fxchain": "Erreur d'application de la chaîne FX.",
      "error_loading_presets": "Erreur de chargement des presets.",
      "error_loading_fxchains": "Erreur de chargement des chaînes",
      "error_loading_effects_ui": "Erreur de chargement UI des effets.",
      "no_presets_found": "Aucun preset trouvé.",
      "no_fxchains_found": "Aucune chaîne FX trouvée",
      "no_effects_available": "Aucun effet disponible.",
      "enter_preset_name": "Veuillez entrer un nom pour le preset.",
      "enter_fxchain_name": "Veuillez entrer un nom pour la chaîne FX.",
      "preset_saved_success": "Preset \"${name}\" sauvegardé avec succès !",
      "fxchain_saved_success": "Chaîne FX \"${name}\" sauvegardée avec succès !",
      "error_saving_preset": "Erreur de sauvegarde du preset : ${error}",
      "error_saving_fxchain": "Erreur de sauvegarde de la chaîne FX : ${error}",
      "exception_saving_preset": "Exception lors de la sauvegarde du preset : ${error}",
      "exception_saving_fxchain": "Exception lors de la sauvegarde de la chaîne FX : ${error}",
      "confirm_delete_preset": "Voulez-vous vraiment supprimer le preset \"${name}\" ?",
      "confirm_delete_fxchain": "Voulez-vous vraiment supprimer la chaîne FX \"${name}\" ?",
      "cannot_delete_default_preset": "Impossible de supprimer les presets par défaut.",
      "cannot_delete_default_fxchain": "Impossible de supprimer les chaînes FX par défaut.",
      "preset_deleted_success": "Preset supprimé.",
      "fxchain_deleted_success": "Chaîne FX supprimée.",
      "preset_delete_failed": "Échec de la suppression du preset.",
      "fxchain_delete_failed": "Échec de la suppression de la chaîne FX.",
      "exception_deleting_preset": "Exception lors de la suppression du preset : ${error}",
      "exception_deleting_fxchain": "Exception lors de la suppression de la chaîne FX : ${error}",
      "audio_not_ready_record": "L'audio n'est pas prêt. Impossible de démarrer l'enregistrement.",
      "pitch_envelope": "Enveloppe de Hauteur",
      "pitch_amount_cents": "Quantité (Cents)",
      "macro_controls_title": "Contrôles Macro",
      "macro_space": "Espace",
      "macro_time": "Temps",
      "macro_motion": "Mouvement",
      "macro_tone": "Timbre",
      "macro_drive": "Drive",
      "effects_intensity_min": "Intensité FX Min. (dB)",
      "effects_intensity_max": "Intensité FX Max. (dB)",
      "effects_threshold": "Seuil FX",
      "none_fxchain": "-- Aucun --",
      "none_touch_effect": "Aucun",
      "restart_audio_engine_button": "Redémarrer Audio",
      "reload_app_button_title": "Recharger App",
      "reloading_app_message": "Rechargement de l'application...",
      "master_output_title": "Sortie Maître",
      "master_volume_ceiling": "Plafond Volume",
      "master_volume_ceiling_label": "Plafond Volume",
      "y_axis_volume_min_output": "Sortie Min.",
      "y_axis_volume_max_output": "Sortie Max.",
      "y_axis_volume_y_threshold": "Seuil Y",
      "y_axis_curve_type": "Type de Courbe",
      "y_axis_curve_factor": "Facteur Courbe",
      "y_axis_effects_min_output": "Sortie Min. (dB)",
      "y_axis_effects_max_output": "Sortie Max. (dB)",
      "y_axis_effects_y_threshold": "Seuil Y",
      "logarithmic": "Logarithmique",
      "s_curve": "Courbe-S",
      "select_option": "Sélectionner Option",
      "no_options_found": "Aucune option trouvée",
      "error_loading_options": "Erreur de chargement des options.",
      "pad_modes_button": "Modes",
      "pad_modes_button_title": "Modes du Pad",
      "pad_modes_panel_title": "Modes du Pad",
      "pad_mode_label": "Mode du Pad",
      "pad_mode_select_title": "Sélectionner Mode du Pad",
      "pad_mode_classic": "Classique",
      "pad_mode_reactive": "Réactif",
      "reactive_mode_show_suggestions": "Afficher Indices Harmoniques",
      "reactive_mode_suggestion_count": "Nb d'Indices",
      "no_specific_settings_classic": "Aucun paramètre spécifique pour le mode Classique.",
      "no_specific_settings_reactive": "Configurer les indices du mode Réactif.",
      "pad_mode_rocket": "Fusée",
      "rocket_highlight_active": "Surligner Notes Actives",
      "rocket_show_markers": "Afficher Marqueurs Directionnels",
      "rocket_marker_style": "Style de Marqueur",
      "rocket_valid_chords_only": "Marqueurs Uniquement pour Accords Valides",
      "rocket_animate_fade": "Animer Fondu des Marqueurs",
      "rocket_show_chord_name": "Afficher Nom d'Accord Reconnu",
      "style_GlowFromNote": "Lueur depuis Note",
      "style_WaveToNote": "Onde vers Note",
      "style_PulseRing": "Anneau Pulsant",
      "style_SparkTrail": "Traînée d'Étincelles",
      "style_ShadowDrop": "Ombre sous Note",
      "rocket_mode_panel_title": "Mode Fusée",
      "rocket_mode_enable": "Activer Mode Fusée",
      "rocket_mode_settings_placeholder": "Les paramètres du Mode Fusée apparaîtront ici.",
      "error_loading_mode_settings": "Erreur de chargement des paramètres du mode.",
      "no_specific_settings_rocket": "Configurer les paramètres spécifiques du mode Fusée.",
      "reset_settings_button": "Réinitialiser Tous les Paramètres",
      "reload_app_button": "Rechargement Complet",
      "restart_audio_button": "Redémarrer Moteur Audio",
      "rocket_section_general": "Général",
      "rocket_section_phases": "Phases",
      "rocket_section_harmonic_logic": "Logique Harmonique",
      "rocket_section_interactive_behavior": "Comportement Interactif",
      "rocket_intensity": "Intensité",
      "rocket_visual_theme": "Thème Visuel",
      "rocket_auto_phases": "Phases Auto",
      "rocket_harmonic_key": "Clé Harmonique",
      "rocket_marker_logic": "Logique des Marqueurs",
      "marker_logic_tonal": "Liaison Tonale",
      "marker_logic_adaptive": "Analyse Adaptative",
      "marker_logic_semi_free": "Semi-Libre",
      "marker_logic_random": "Aléatoire Dirigé",
      "rocket_phase_ignition": "Allumage",
      "rocket_phase_lift_off": "Décollage",
      "rocket_phase_burst": "Explosion",
      "rocket_phase_transition": "Transition de Phase",
      "phase_mode_activity": "Par Activité",
      "phase_mode_time": "Par Temps",
      "phase_mode_manual": "Manuel",
      "status_chord": "Accord",
      "status_key": "Tonalité",
      "status_next": "Suivant",
      "status_energy": "Énergie",
      "status_phase": "Phase",
      "status_na": "N/A",
      "rocket_presets_title": "Presets du Mode",
      "rocket_select_preset": "Sélectionner Preset",
      "rocket_select_preset_title": "Sélectionner Preset Mode Fusée",
      "rocket_preset_current": "Paramètres Actuels",
      "none_selected": "Aucun",
      "preset_rocket_melodic_drift": "Dérive Mélodique",
      "desc_rocket_melodic_drift": "Logique harmonique douce, flottante, semi-libre.",
      "preset_rocket_jazz_climb": "Montée Jazz",
      "desc_rocket_jazz_climb": "Logique active, adaptative, d'inspiration jazz.",
      "rocket_marker_labels": "Étiquettes de Marqueur",
      "labels_none": "Aucune",
      "labels_function": "Fonction (T/S/D)",
      "labels_chord_name": "Nom d'Accord",
      "rocket_marker_retention": "Rétention des Marqueurs",
      "desc_rocket_marker_retention": "Garder les marqueurs pertinents visibles lors de nouveaux touchers.",
      "desc_rocket_animate_fade": "Faire disparaître en fondu les marqueurs non pertinents.",
      "rocket_fade_delay": "Délai de Fondu",
      "desc_rocket_fade_delay": "Délai avant que le marqueur ne commence à disparaître.",
      "rocket_fade_duration": "Durée du Fondu",
      "desc_rocket_fade_duration": "Durée de l'animation de disparition du marqueur.",
      "rocket_max_markers_zone": "Max Marqueurs/Zone",
      "desc_rocket_max_markers_zone": "Maximum de suggestions affichées par zone.",
      "rocket_phase_styles": "Styles de Phase",
      "desc_rocket_phase_styles": "Permettre à la phase actuelle de remplacer le style du marqueur.",
      "rocket_tb_in_key": "Liais. Tonale : Uniquement en Tonalité",
      "desc_rocket_tb_in_key": "Suggérer uniquement les notes/accords de la tonalité actuelle.",
      "rocket_aa_autokey": "An. Adapt. : Changement Tonalité Auto",
      "desc_rocket_aa_autokey": "Permettre des changements de tonalité adaptatifs basés sur l'entrée.",
      "rocket_sf_basekey": "Semi-Libre : Tonalité de Base",
      "desc_rocket_sf_basekey": "Tonalité de base pour le mode semi-libre.",
      "rocket_sf_deviations": "Semi-Libre : Déviations Modales",
      "desc_rocket_sf_deviations": "Permettre des déviations temporaires de la tonalité de base.",
      "rocket_sf_return": "Semi-Libre : Surligner Retour",
      "desc_rocket_sf_return": "Surligner les suggestions retournant à la tonalité de base.",
      "rocket_rd_randomlevel": "Niveau d'Aléatoire",
      "desc_rocket_rd_randomlevel": "Niveau d'aléatoire dans les suggestions.",
      "select_chord": "Sélectionner Accord",
      "select_key": "Sélectionner Tonalité",
      "select_phase": "Sélectionner Phase",
      "no_language_found": "Aucune langue trouvée",
      "no_theme_found": "Aucun thème trouvé",
      "no_visualizer_found": "Aucun visualiseur trouvé",
      "no_touchEffect_found": "Aucun effet tactile trouvé",
      "no_scale_found": "Aucune gamme trouvée",
      "no_fxChain_found": "Aucune chaîne FX trouvée",
      "error_audio_fatal_restart": "Erreur audio critique. Veuillez redémarrer l'application."
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\language\ja.json
{
  "id": "ja",
  "type": "language",
  "name": "日本語",
  "version": "1.0.5",
  "description": "Japanese language pack (Updated 25.05.2025)",
  "active": false,
  "data": {
    "strings": {
      "presets_panel_title": "プリセット一覧",
      "app_title": "Prismtone",
      "menu_button": "メニュー",
      "sound_library_button": "サウンドライブラリ",
      "tonality_button": "調性",
      "effects_button": "エフェクト",
      "record_button": "録音",
      "stop_recording_button": "録音停止",
      "settings_title": "設定",
      "language_label": "言語",
      "theme_label": "テーマ",
      "visualizer_label": "ビジュアライザ",
      "touch_effect_label": "タッチエフェクト",
      "display_options_header": "表示と動作",
      "show_note_names": "ノート名を表示",
      "show_lines": "グリッド線を表示",
      "multi_touch": "マルチタッチ",
      "enable_polyphony_scaling": "ポリフォニー音量スケール",
      "haptic_feedback": "触覚フィードバック",
      "enable_vibration": "振動を有効にする",
      "highlight_sharps_flats": "シャープ/フラットを強調",
      "tonality_title": "調性",
      "octave_label": "オクターブ",
      "scale_label": "音階",
      "size_label": "サイズ",
      "effects_title": "エフェクト",
      "fx_chain_label": "エフェクトチェーン",
      "save_chain": "チェーンを保存",
      "delete_chain": "チェーンを削除",
      "reset_fx": "エフェクトをリセット",
      "y_axis_controls": "Y軸コントロール",
      "volume_min": "最小音量",
      "volume_max": "最大音量",
      "volume_curve": "カーブ",
      "effects_min": "FXセンド最小 (dB)",
      "effects_max": "FXセンド最大 (dB)",
      "effects_curve": "カーブ",
      "linear": "リニア",
      "exponential": "指数関数",
      "delay": "ディレイ",
      "reverb": "リバーブ",
      "chorus": "コーラス",
      "distortion": "ディストーション",
      "filter": "フィルター",
      "phaser": "フェイザー",
      "pitchShift": "ピッチシフト",
      "wet": "ウェット",
      "time": "時間",
      "delayTime": "時間",
      "feedback": "フィードバック",
      "decay": "ディケイ",
      "preDelay": "プリディレイ",
      "frequency": "周波数",
      "depth": "深さ",
      "Q": "Q値",
      "type": "タイプ",
      "gain": "ゲイン",
      "rolloff": "ロールオフ",
      "pitch": "ピッチ",
      "octaves": "オクターブ",
      "baseFrequency": "基本周波数",
      "sound_library_title": "サウンドライブラリ",
      "presets_title": "プリセット",
      "save_preset": "新規サウンドを保存",
      "delete_preset": "サウンドを削除",
      "synth_controls": "シンセコントロール",
      "synth_type": "シンセタイプ",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "オシレータータイプ",
      "sine": "サイン波",
      "square": "矩形波",
      "sawtooth": "ノコギリ波",
      "triangle": "三角波",
      "fat_sine": "Fat サイン波",
      "fat_square": "Fat 矩形波",
      "fat_sawtooth": "Fat ノコギリ波",
      "fat_triangle": "Fat 三角波",
      "fm_sine": "FM サイン波",
      "fm_square": "FM 矩形波",
      "fm_sawtooth": "FM ノコギリ波",
      "fm_triangle": "FM 三角波",
      "am_sine": "AM サイン波",
      "am_square": "AM 矩形波",
      "am_sawtooth": "AM ノコギリ波",
      "am_triangle": "AM 三角波",
      "pwm": "PWM",
      "pulse": "パルス波",
      "noise_white": "ホワイトノイズ",
      "noise_pink": "ピンクノイズ",
      "noise_brown": "ブラウンノイズ",
      "oscillator_params": "オシレーターパラメータ",
      "phase": "位相",
      "count": "数",
      "spread": "広がり",
      "width": "幅",
      "mod_freq_short": "変調周波数",
      "harmonicity": "倍音度",
      "mod_index": "変調指数",
      "mod_type": "変調タイプ",
      "noise_type": "ノイズタイプ",
      "envelope": "エンベロープ",
      "attack": "アタック",
      "sustain": "サスティン",
      "release": "リリース",
      "envelope_curves": "エンベロープカーブ",
      "attack_curve": "アタック",
      "decay_curve": "ディケイ",
      "release_curve": "リリース",
      "filter_advanced": "高度なフィルター",
      "filter_rolloff": "ロールオフ",
      "filter_gain": "ゲイン (dB)",
      "filter_envelope": "フィルターエンベロープ",
      "base_frequency": "基本周波数",
      "exponent": "指数",
      "modulation": "モジュレーション",
      "modulation_envelope": "モジュレーションエンベロープ",
      "special_parameters": "特殊パラメータ",
      "pitch_decay": "ピッチディケイ",
      "attack_noise": "アタックノイズ",
      "dampening": "ダンピング",
      "resonance": "レゾナンス",
      "lfo": "LFO",
      "lfo_type": "タイプ",
      "lfo_target": "ターゲット",
      "lfo_min": "最小",
      "lfo_max": "最大",
      "save_preset_title": "サウンドプリセットを保存",
      "preset_name_label": "プリセット名:",
      "preset_name_placeholder": "マイサウンドプリセット",
      "save_fx_chain_title": "エフェクトチェーンを保存",
      "fx_chain_name_label": "チェーン名:",
      "fx_chain_name_placeholder": "マイエフェクトチェーン",
      "cancel": "キャンセル",
      "save": "保存",
      "major": "メジャー",
      "minor": "マイナー",
      "pentatonic": "ペンタトニック",
      "blues": "ブルース",
      "chromatic": "クロマチック",
      "dorian": "ドリアン",
      "phrygian": "フリジアン",
      "lydian": "リディアン",
      "mixolydian": "ミクソリディアン",
      "locrian": "ロクリアン",
      "day": "昼",
      "night": "夜",
      "neon": "ネオン",
      "retro": "レトロ",
      "pastel": "パステル",
      "aurora": "オーロラ",
      "ocean": "オーシャン",
      "cyberpunk": "サイバーパンク",
      "fire": "ファイア",
      "matrix": "マトリックス",
      "hologram": "ホログラム",
      "crystal": "クリスタル",
      "galaxy": "ギャラクシー",
      "waves": "波形",
      "spectrum": "スペクトラム",
      "particles": "魚群",
      "nebula": "星雲",
      "reactive_ripples": "リアクティブリップル",
      "touch_trails": "タッチトレイル",
      "loading": "ロード中...",
      "initializing": "初期化中...",
      "loading_bridge": "接続中...",
      "loading_settings": "設定をロード中...",
      "loading_modules": "モジュールをロード中...",
      "loading_ui": "UIを初期化中...",
      "loading_presets": "設定を適用中...",
      "loading_audio": "サウンドをロード中...",
      "tap_to_start": "タップしてオーディオを開始",
      "starting_audio": "オーディオを開始中...",
      "audio_suspended": "オーディオ一時停止中。タップして再開。",
      "loading_preset": "プリセットをロード中...",
      "loading_fxchain": "FXチェーンをロード中...",
      "saving_preset_progress": "プリセットを保存中...",
      "saving_fxchain_progress": "FXチェーンを保存中...",
      "deleting_preset_progress": "プリセットを削除中...",
      "deleting_fxchain_progress": "FXチェーンを削除中...",
      "hit_play_vibe": "再生してバイブを感じよう",
      "error_bridge_failed": "エラー：ブリッジ接続に失敗しました。",
      "error_init_failed": "初期化エラー。コンソールを確認してください。",
      "error_init_failed_details": "初期化エラー: ${error}。コンソールを確認してください。",
      "error_fatal_init": "致命的な初期化エラー。再起動してください。",
      "error_audio_failed_retry": "オーディオ開始エラー。もう一度タップしてください。",
      "error_audio_resume": "オーディオを再開できませんでした。",
      "error_apply_preset": "プリセット適用エラー。",
      "error_apply_fxchain": "FXチェーン適用エラー。",
      "error_loading_presets": "プリセット読み込みエラー。",
      "error_loading_fxchains": "チェーン読み込みエラー",
      "error_loading_effects_ui": "エフェクトUI読み込みエラー。",
      "no_presets_found": "プリセットが見つかりません。",
      "no_fxchains_found": "FXチェーンが見つかりません",
      "no_effects_available": "利用可能なエフェクトはありません。",
      "enter_preset_name": "プリセット名を入力してください。",
      "enter_fxchain_name": "FXチェーン名を入力してください。",
      "preset_saved_success": "プリセット「${name}」を保存しました！",
      "fxchain_saved_success": "FXチェーン「${name}」を保存しました！",
      "error_saving_preset": "プリセット保存エラー: ${error}",
      "error_saving_fxchain": "FXチェーン保存エラー: ${error}",
      "exception_saving_preset": "プリセット保存例外: ${error}",
      "exception_saving_fxchain": "FXチェーン保存例外: ${error}",
      "confirm_delete_preset": "プリセット「${name}」を削除しますか？",
      "confirm_delete_fxchain": "FXチェーン「${name}」を削除しますか？",
      "cannot_delete_default_preset": "デフォルトプリセットは削除できません。",
      "cannot_delete_default_fxchain": "デフォルトFXチェーンは削除できません。",
      "preset_deleted_success": "プリセットを削除しました。",
      "fxchain_deleted_success": "FXチェーンを削除しました。",
      "preset_delete_failed": "プリセットの削除に失敗しました。",
      "fxchain_delete_failed": "FXチェーンの削除に失敗しました。",
      "exception_deleting_preset": "プリセット削除例外: ${error}",
      "exception_deleting_fxchain": "FXチェーン削除例外: ${error}",
      "audio_not_ready_record": "オーディオの準備ができていません。録音を開始できません。",
      "pitch_envelope": "ピッチエンベロープ",
      "pitch_amount_cents": "量 (セント)",
      "macro_controls_title": "マクロコントロール",
      "macro_space": "空間",
      "macro_time": "時間",
      "macro_motion": "動き",
      "macro_tone": "音色",
      "macro_drive": "ドライブ",
      "effects_intensity_min": "FX強度 最小 (dB)",
      "effects_intensity_max": "FX強度 最大 (dB)",
      "effects_threshold": "FXしきい値",
      "none_fxchain": "-- なし --",
      "none_touch_effect": "なし",
      "restart_audio_engine_button": "オーディオ再起動",
      "reload_app_button_title": "アプリ再読込",
      "reloading_app_message": "アプリケーションを再読み込み中...",
      "master_output_title": "マスター出力",
      "master_volume_ceiling": "音量上限",
      "master_volume_ceiling_label": "音量上限",
      "y_axis_volume_min_output": "最小出力",
      "y_axis_volume_max_output": "最大出力",
      "y_axis_volume_y_threshold": "Y軸しきい値",
      "y_axis_curve_type": "カーブタイプ",
      "y_axis_curve_factor": "カーブ係数",
      "y_axis_effects_min_output": "最小出力 (dB)",
      "y_axis_effects_max_output": "最大出力 (dB)",
      "y_axis_effects_y_threshold": "Y軸しきい値",
      "logarithmic": "対数",
      "s_curve": "Sカーブ",
      "select_option": "オプションを選択",
      "no_options_found": "オプションが見つかりません",
      "error_loading_options": "オプションの読み込みエラー。",
      "pad_modes_button": "モード",
      "pad_modes_button_title": "パッドモード",
      "pad_modes_panel_title": "パッドモード",
      "pad_mode_label": "パッドモード",
      "pad_mode_select_title": "パッドモードを選択",
      "pad_mode_classic": "クラシック",
      "pad_mode_reactive": "リアクティブ",
      "reactive_mode_show_suggestions": "ハーモニックヒントを表示",
      "reactive_mode_suggestion_count": "ヒント数",
      "no_specific_settings_classic": "クラシックモードの特定設定なし。",
      "no_specific_settings_reactive": "リアクティブモードのヒントを設定。",
      "pad_mode_rocket": "ロケット",
      "rocket_highlight_active": "アクティブノートを強調表示",
      "rocket_show_markers": "方向マーカーを表示",
      "rocket_marker_style": "マーカースタイル",
      "rocket_valid_chords_only": "有効なコードのみマーカー表示",
      "rocket_animate_fade": "マーカーフェードアウトをアニメート",
      "rocket_show_chord_name": "認識されたコード名を表示",
      "style_GlowFromNote": "ノートからのグロー",
      "style_WaveToNote": "ノートへの波",
      "style_PulseRing": "パルスリング",
      "style_SparkTrail": "スパークトレイル",
      "style_ShadowDrop": "ノート下の影",
      "rocket_mode_panel_title": "ロケットモード",
      "rocket_mode_enable": "ロケットモードを有効化",
      "rocket_mode_settings_placeholder": "ロケットモードの設定はここに表示されます。",
      "error_loading_mode_settings": "モード設定の読み込みエラー。",
      "no_specific_settings_rocket": "ロケットモード固有の設定を構成します。",
      "reset_settings_button": "全設定をリセット",
      "reload_app_button": "アプリ完全再読込",
      "restart_audio_button": "オーディオエンジン再起動",
      "rocket_section_general": "一般",
      "rocket_section_phases": "フェーズ",
      "rocket_section_harmonic_logic": "ハーモニックロジック",
      "rocket_section_interactive_behavior": "インタラクティブ動作",
      "rocket_intensity": "強度",
      "rocket_visual_theme": "ビジュアルテーマ",
      "rocket_auto_phases": "自動フェーズ",
      "rocket_harmonic_key": "ハーモニックキー",
      "rocket_marker_logic": "マーカーロジック",
      "marker_logic_tonal": "トーナルバインディング",
      "marker_logic_adaptive": "アダプティブ分析",
      "marker_logic_semi_free": "セミフリー",
      "marker_logic_random": "ランダム指向",
      "rocket_phase_ignition": "点火",
      "rocket_phase_lift_off": "離陸",
      "rocket_phase_burst": "バースト",
      "rocket_phase_transition": "フェーズ移行",
      "phase_mode_activity": "アクティビティ別",
      "phase_mode_time": "時間別",
      "phase_mode_manual": "手動",
      "status_chord": "コード",
      "status_key": "キー",
      "status_next": "次",
      "status_energy": "エネルギー",
      "status_phase": "フェーズ",
      "status_na": "N/A",
      "rocket_presets_title": "モードプリセット",
      "rocket_select_preset": "プリセットを選択",
      "rocket_select_preset_title": "ロケットモードプリセットを選択",
      "rocket_preset_current": "現在の設定",
      "none_selected": "なし",
      "preset_rocket_melodic_drift": "メロディックドリフト",
      "desc_rocket_melodic_drift": "穏やかで浮遊感のある、セミフリーのハーモニックロジック。",
      "preset_rocket_jazz_climb": "ジャズクライム",
      "desc_rocket_jazz_climb": "アクティブでアダпティブな、ジャズ風のロジック。",
      "rocket_marker_labels": "マーカーラベル",
      "labels_none": "なし",
      "labels_function": "機能 (T/S/D)",
      "labels_chord_name": "コード名",
      "rocket_marker_retention": "マーカー保持",
      "desc_rocket_marker_retention": "新しいタッチ中も関連マーカーを表示し続ける。",
      "desc_rocket_animate_fade": "関連性のないマーカーを滑らかにフェードアウトさせる。",
      "rocket_fade_delay": "フェードアウト遅延",
      "desc_rocket_fade_delay": "マーカーがフェードアウトし始めるまでの遅延。",
      "rocket_fade_duration": "フェードアウト時間",
      "desc_rocket_fade_duration": "マーカーフェードアウトアニメーションの時間。"
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\language\ko.json
{
  "id": "ko",
  "type": "language",
  "name": "한국어",
  "version": "1.0.5",
  "description": "Korean language pack (Updated 25.05.2025)",
  "active": false,
  "data": {
    "strings": {
      "presets_panel_title": "프리셋 목록",
      "app_title": "Prismtone",
      "menu_button": "메뉴",
      "sound_library_button": "사운드 라이브러리",
      "tonality_button": "조성",
      "effects_button": "효과",
      "record_button": "녹음",
      "stop_recording_button": "녹음 중지",
      "settings_title": "설정",
      "language_label": "언어",
      "theme_label": "테마",
      "visualizer_label": "비주얼라이저",
      "touch_effect_label": "터치 효과",
      "display_options_header": "표시 및 동작",
      "show_note_names": "음표 이름 표시",
      "show_lines": "격자선 표시",
      "multi_touch": "멀티터치",
      "enable_polyphony_scaling": "폴리포니 볼륨 스케일링",
      "haptic_feedback": "햅틱 피드백",
      "enable_vibration": "진동 활성화",
      "highlight_sharps_flats": "샵/플랫 강조",
      "tonality_title": "조성",
      "octave_label": "옥타브",
      "scale_label": "음계",
      "size_label": "크기",
      "effects_title": "효과",
      "fx_chain_label": "효과 체인",
      "save_chain": "체인 저장",
      "delete_chain": "체인 삭제",
      "reset_fx": "효과 초기화",
      "y_axis_controls": "Y축 컨트롤",
      "volume_min": "최소 볼륨",
      "volume_max": "최대 볼륨",
      "volume_curve": "곡선",
      "effects_min": "FX 센드 최소 (dB)",
      "effects_max": "FX 센드 최대 (dB)",
      "effects_curve": "곡선",
      "linear": "선형",
      "exponential": "지수",
      "delay": "딜레이",
      "reverb": "리버브",
      "chorus": "코러스",
      "distortion": "디스토션",
      "filter": "필터",
      "phaser": "페이저",
      "pitchShift": "피치 시프트",
      "wet": "Wet",
      "time": "시간",
      "delayTime": "시간",
      "feedback": "피드백",
      "decay": "디케이",
      "preDelay": "프리딜레이",
      "frequency": "주파수",
      "depth": "깊이",
      "Q": "Q값",
      "type": "타입",
      "gain": "게인",
      "rolloff": "롤오프",
      "pitch": "피치",
      "octaves": "옥타브",
      "baseFrequency": "기본 주파수",
      "sound_library_title": "사운드 라이브러리",
      "presets_title": "프리셋",
      "save_preset": "새 사운드 저장",
      "delete_preset": "사운드 삭제",
      "synth_controls": "신스 컨트롤",
      "synth_type": "신스 타입",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "오실레이터 타입",
      "sine": "사인파",
      "square": "사각파",
      "sawtooth": "톱니파",
      "triangle": "삼각파",
      "fat_sine": "Fat 사인파",
      "fat_square": "Fat 사각파",
      "fat_sawtooth": "Fat 톱니파",
      "fat_triangle": "Fat 삼각파",
      "fm_sine": "FM 사인파",
      "fm_square": "FM 사각파",
      "fm_sawtooth": "FM 톱니파",
      "fm_triangle": "FM 삼각파",
      "am_sine": "AM 사인파",
      "am_square": "AM 사각파",
      "am_sawtooth": "AM 톱니파",
      "am_triangle": "AM 삼각파",
      "pwm": "PWM",
      "pulse": "펄스파",
      "noise_white": "백색 소음",
      "noise_pink": "분홍 소음",
      "noise_brown": "갈색 소음",
      "oscillator_params": "오실레이터 파라미터",
      "phase": "위상",
      "count": "개수",
      "spread": "확산",
      "width": "너비",
      "mod_freq_short": "변조 주파수",
      "harmonicity": "배음성",
      "mod_index": "변조 지수",
      "mod_type": "변조 타입",
      "noise_type": "소음 타입",
      "envelope": "엔벨로프",
      "attack": "어택",
      "sustain": "서스테인",
      "release": "릴리즈",
      "envelope_curves": "엔벨로프 곡선",
      "attack_curve": "어택",
      "decay_curve": "디케이",
      "release_curve": "릴리즈",
      "filter_advanced": "고급 필터",
      "filter_rolloff": "롤오프",
      "filter_gain": "게인 (dB)",
      "filter_envelope": "필터 엔벨로프",
      "base_frequency": "기본 주파수",
      "exponent": "지수",
      "modulation": "모듈레이션",
      "modulation_envelope": "모듈레이션 엔벨로프",
      "special_parameters": "특수 파라미터",
      "pitch_decay": "피치 디케이",
      "attack_noise": "어택 노이즈",
      "dampening": "댐핑",
      "resonance": "레조넌스",
      "lfo": "LFO",
      "lfo_type": "타입",
      "lfo_target": "타겟",
      "lfo_min": "최소",
      "lfo_max": "최대",
      "save_preset_title": "사운드 프리셋 저장",
      "preset_name_label": "프리셋 이름:",
      "preset_name_placeholder": "내 사운드 프리셋",
      "save_fx_chain_title": "효과 체인 저장",
      "fx_chain_name_label": "체인 이름:",
      "fx_chain_name_placeholder": "내 효과 체인",
      "cancel": "취소",
      "save": "저장",
      "major": "장조",
      "minor": "단조",
      "pentatonic": "펜타토닉",
      "blues": "블루스",
      "chromatic": "반음계",
      "dorian": "도리안",
      "phrygian": "프리지안",
      "lydian": "리디안",
      "mixolydian": "믹솔리디안",
      "locrian": "로크리안",
      "day": "주간",
      "night": "야간",
      "neon": "네온",
      "retro": "레트로",
      "pastel": "파스텔",
      "aurora": "오로라",
      "ocean": "오션",
      "cyberpunk": "사이버펑크",
      "fire": "불꽃",
      "matrix": "매트릭스",
      "hologram": "홀로그램",
      "crystal": "크리스탈",
      "galaxy": "갤럭시",
      "waves": "파형",
      "spectrum": "스펙트럼",
      "particles": "물고기 떼",
      "nebula": "성운",
      "reactive_ripples": "반응형 잔물결",
      "touch_trails": "터치 궤적",
      "loading": "로드 중...",
      "initializing": "초기화 중...",
      "loading_bridge": "연결 중...",
      "loading_settings": "설정 로드 중...",
      "loading_modules": "모듈 로드 중...",
      "loading_ui": "UI 초기화 중...",
      "loading_presets": "설정 적용 중...",
      "loading_audio": "사운드 로드 중...",
      "tap_to_start": "탭하여 오디오 시작",
      "starting_audio": "오디오 시작 중...",
      "audio_suspended": "오디오 일시 중지됨. 탭하여 재개.",
      "loading_preset": "프리셋 로드 중...",
      "loading_fxchain": "FX 체인 로드 중...",
      "saving_preset_progress": "프리셋 저장 중...",
      "saving_fxchain_progress": "FX 체인 저장 중...",
      "deleting_preset_progress": "프리셋 삭제 중...",
      "deleting_fxchain_progress": "FX 체인 삭제 중...",
      "hit_play_vibe": "재생하고 바이브를 느껴보세요",
      "error_bridge_failed": "오류: 브리지 연결 실패.",
      "error_init_failed": "초기화 오류. 콘솔을 확인하세요.",
      "error_init_failed_details": "초기화 오류: ${error}. 콘솔을 확인하세요.",
      "error_fatal_init": "치명적인 초기화 오류. 재시작하세요.",
      "error_audio_failed_retry": "오디오 시작 오류. 다시 탭하세요.",
      "error_audio_resume": "오디오를 재개하지 못했습니다.",
      "error_apply_preset": "프리셋 적용 오류.",
      "error_apply_fxchain": "FX 체인 적용 오류.",
      "error_loading_presets": "프리셋 로드 오류.",
      "error_loading_fxchains": "체인 로드 오류",
      "error_loading_effects_ui": "효과 UI 로드 오류.",
      "no_presets_found": "프리셋을 찾을 수 없습니다.",
      "no_fxchains_found": "FX 체인을 찾을 수 없습니다",
      "no_effects_available": "사용 가능한 효과가 없습니다.",
      "enter_preset_name": "프리셋 이름을 입력하세요.",
      "enter_fxchain_name": "FX 체인 이름을 입력하세요.",
      "preset_saved_success": "프리셋 \"${name}\" 저장 완료!",
      "fxchain_saved_success": "FX 체인 \"${name}\" 저장 완료!",
      "error_saving_preset": "프리셋 저장 오류: ${error}",
      "error_saving_fxchain": "FX 체인 저장 오류: ${error}",
      "exception_saving_preset": "프리셋 저장 예외: ${error}",
      "exception_saving_fxchain": "FX 체인 저장 예외: ${error}",
      "confirm_delete_preset": "프리셋 \"${name}\"을(를) 삭제하시겠습니까?",
      "confirm_delete_fxchain": "FX 체인 \"${name}\"을(를) 삭제하시겠습니까?",
      "cannot_delete_default_preset": "기본 프리셋은 삭제할 수 없습니다.",
      "cannot_delete_default_fxchain": "기본 FX 체인은 삭제할 수 없습니다.",
      "preset_deleted_success": "프리셋이 삭제되었습니다.",
      "fxchain_deleted_success": "FX 체인이 삭제되었습니다.",
      "preset_delete_failed": "프리셋 삭제 실패.",
      "fxchain_delete_failed": "FX 체인 삭제 실패.",
      "exception_deleting_preset": "프리셋 삭제 예외: ${error}",
      "exception_deleting_fxchain": "FX 체인 삭제 예외: ${error}",
      "audio_not_ready_record": "오디오가 준비되지 않았습니다. 녹음을 시작할 수 없습니다.",
      "pitch_envelope": "피치 엔벨로프",
      "pitch_amount_cents": "양 (센트)",
      "macro_controls_title": "매크로 컨트롤",
      "macro_space": "공간",
      "macro_time": "시간",
      "macro_motion": "움직임",
      "macro_tone": "음색",
      "macro_drive": "드라이브",
      "effects_intensity_min": "FX 강도 최소 (dB)",
      "effects_intensity_max": "FX 강도 최대 (dB)",
      "effects_threshold": "FX 임계값",
      "none_fxchain": "-- 없음 --",
      "none_touch_effect": "없음",
      "restart_audio_engine_button": "오디오 재시작",
      "reload_app_button_title": "앱 새로고침",
      "reloading_app_message": "애플리케이션 다시 로드 중...",
      "master_output_title": "마스터 출력",
      "master_volume_ceiling": "볼륨 상한",
      "master_volume_ceiling_label": "볼륨 상한",
      "y_axis_volume_min_output": "최소 출력",
      "y_axis_volume_max_output": "최대 출력",
      "y_axis_volume_y_threshold": "Y축 임계값",
      "y_axis_curve_type": "곡선 유형",
      "y_axis_curve_factor": "곡선 계수",
      "y_axis_effects_min_output": "최소 출력 (dB)",
      "y_axis_effects_max_output": "최대 출력 (dB)",
      "y_axis_effects_y_threshold": "Y축 임계값",
      "logarithmic": "로그",
      "s_curve": "S-커브",
      "select_option": "옵션 선택",
      "no_options_found": "옵션을 찾을 수 없음",
      "error_loading_options": "옵션 로드 오류.",
      "pad_modes_button": "모드",
      "pad_modes_button_title": "패드 모드",
      "pad_modes_panel_title": "패드 모드",
      "pad_mode_label": "패드 모드",
      "pad_mode_select_title": "패드 모드 선택",
      "pad_mode_classic": "클래식",
      "pad_mode_reactive": "리액티브",
      "reactive_mode_show_suggestions": "화성 힌트 표시",
      "reactive_mode_suggestion_count": "힌트 수",
      "no_specific_settings_classic": "클래식 모드 특정 설정 없음.",
      "no_specific_settings_reactive": "리액티브 모드 힌트 구성.",
      "pad_mode_rocket": "로켓",
      "rocket_highlight_active": "활성 음표 강조",
      "rocket_show_markers": "방향 마커 표시",
      "rocket_marker_style": "마커 스타일",
      "rocket_valid_chords_only": "유효한 코드에만 마커 표시",
      "rocket_animate_fade": "마커 페이드 아웃 애니메이션",
      "rocket_show_chord_name": "인식된 코드 이름 표시",
      "style_GlowFromNote": "음표에서 빛",
      "style_WaveToNote": "음표로 파동",
      "style_PulseRing": "펄스 링",
      "style_SparkTrail": "스파크 트레일",
      "style_ShadowDrop": "음표 아래 그림자",
      "rocket_mode_panel_title": "로켓 모드",
      "rocket_mode_enable": "로켓 모드 활성화",
      "rocket_mode_settings_placeholder": "로켓 모드 설정이 여기에 표시됩니다.",
      "error_loading_mode_settings": "모드 설정 로드 오류.",
      "no_specific_settings_rocket": "로켓 모드 특정 설정을 구성합니다.",
      "reset_settings_button": "모든 설정 초기화",
      "reload_app_button": "앱 전체 새로고침",
      "restart_audio_button": "오디오 엔진 재시작",
      "rocket_section_general": "일반",
      "rocket_section_phases": "단계",
      "rocket_section_harmonic_logic": "화성 논리",
      "rocket_section_interactive_behavior": "상호작용 행동",
      "rocket_intensity": "강도",
      "rocket_visual_theme": "시각 테마",
      "rocket_auto_phases": "자동 단계",
      "rocket_harmonic_key": "화성 키",
      "rocket_marker_logic": "마커 논리",
      "marker_logic_tonal": "조성 결합",
      "marker_logic_adaptive": "적응형 분석",
      "marker_logic_semi_free": "반자유형",
      "marker_logic_random": "무작위 지향",
      "rocket_phase_ignition": "점화",
      "rocket_phase_lift_off": "이륙",
      "rocket_phase_burst": "폭발",
      "rocket_phase_transition": "단계 전환",
      "phase_mode_activity": "활동별",
      "phase_mode_time": "시간별",
      "phase_mode_manual": "수동",
      "status_chord": "코드",
      "status_key": "조성",
      "status_next": "다음",
      "status_energy": "에너지",
      "status_phase": "단계",
      "status_na": "N/A",
      "rocket_presets_title": "모드 프리셋",
      "rocket_select_preset": "프리셋 선택",
      "rocket_select_preset_title": "로켓 모드 프리셋 선택",
      "rocket_preset_current": "현재 설정",
      "none_selected": "없음",
      "preset_rocket_melodic_drift": "선율 표류",
      "desc_rocket_melodic_drift": "부드럽고 떠다니는 반자유형 화성 논리.",
      "preset_rocket_jazz_climb": "재즈 상승",
      "desc_rocket_jazz_climb": "활동적이고 적응형인 재즈풍 논리.",
      "rocket_marker_labels": "마커 라벨",
      "labels_none": "없음",
      "labels_function": "기능 (T/S/D)",
      "labels_chord_name": "코드 이름",
      "rocket_marker_retention": "마커 유지",
      "desc_rocket_marker_retention": "새로운 터치 중에도 관련 마커를 계속 표시합니다.",
      "desc_rocket_animate_fade": "관련 없는 마커를 부드럽게 페이드 아웃합니다.",
      "rocket_fade_delay": "페이드 아웃 지연",
      "desc_rocket_fade_delay": "마커가 페이드 아웃되기 시작하기 전의 지연 시간.",
      "rocket_fade_duration": "페이드 아웃 지속 시간",
      "desc_rocket_fade_duration": "마커 페이드 아웃 애니메이션의 지속 시간.",
      "rocket_max_markers_zone": "최대 마커/구역",
      "desc_rocket_max_markers_zone": "구역당 표시되는 최대 제안 수.",
      "rocket_phase_styles": "단계 스타일",
      "desc_rocket_phase_styles": "현재 단계가 마커 스타일을 덮어쓰도록 허용합니다.",
      "rocket_tb_in_key": "조성 결합: 조성 내에서만",
      "desc_rocket_tb_in_key": "현재 조성 내의 음표/코드만 제안합니다.",
      "rocket_aa_autokey": "적응형 분석: 자동 조성 변경",
      "desc_rocket_aa_autokey": "입력에 따라 적응형 조성 변경을 허용합니다.",
      "rocket_sf_basekey": "반자유형: 기본 조성",
      "desc_rocket_sf_basekey": "반자유형 모드의 기본 조성.",
      "rocket_sf_deviations": "반자유형: 모달 편차",
      "desc_rocket_sf_deviations": "기본 조성으로부터의 일시적인 편차를 허용합니다.",
      "rocket_sf_return": "반자유형: 복귀 강조",
      "desc_rocket_sf_return": "기본 조성으로 돌아가는 제안을 강조 표시합니다.",
      "rocket_rd_randomlevel": "무작위 수준",
      "desc_rocket_rd_randomlevel": "제안의 무작위성 수준.",
      "select_chord": "코드 선택",
      "select_key": "조성 선택",
      "select_phase": "단계 선택",
      "no_language_found": "언어를 찾을 수 없습니다",
      "no_theme_found": "테마를 찾을 수 없습니다",
      "no_visualizer_found": "비주얼라이저를 찾을 수 없습니다",
      "no_touchEffect_found": "터치 효과를 찾을 수 없습니다",
      "no_scale_found": "음계를 찾을 수 없습니다",
      "no_fxChain_found": "FX 체인을 찾을 수 없습니다",
      "error_audio_fatal_restart": "심각한 오디오 오류. 앱을 다시 시작하십시오.",
      "preset_name_label": "프리셋 이름:",
      "preset_name_placeholder": "내 사운드 프리셋"
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\language\ru.json
{
  "id": "ru",
  "type": "language",
  "name": "Русский",
  "version": "1.0.5",
  "description": "Russian language pack (Updated 25.05.2025)",
  "active": true,
  "data": {
    "strings": {
      "presets_panel_title": "Список пресетов",
      "app_title": "Prismtone",
      "menu_button": "Меню",
      "sound_library_button": "Библиотека звуков",
      "tonality_button": "Тональность",
      "effects_button": "Эффекты",
      "record_button": "Запись",
      "stop_recording_button": "Остановить запись",
      "settings_title": "Настройки",
      "language_label": "Язык",
      "theme_label": "Тема",
      "visualizer_label": "Визуализация",
      "touch_effect_label": "Эффект касания",
      "display_options_header": "Отображение и Поведение",
      "show_note_names": "Показывать названия нот",
      "show_lines": "Показывать линии сетки",
      "multi_touch": "Мультитач",
      "enable_polyphony_scaling": "Масштаб. громк. полифонии",
      "haptic_feedback": "Виброотклик",
      "enable_vibration": "Включить вибрацию",
      "highlight_sharps_flats": "Выделять диезы/бемоли",
      "tonality_title": "Тональность",
      "octave_label": "Октава",
      "scale_label": "Лад",
      "size_label": "Размер",
      "effects_title": "Эффекты",
      "fx_chain_label": "Цепочка эффектов",
      "save_chain": "Сохранить цепочку",
      "delete_chain": "Удалить цепочку",
      "reset_fx": "Сбросить эффекты",
      "y_axis_controls": "Управление по оси Y",
      "volume_min": "Мин. громкость",
      "volume_max": "Макс. громкость",
      "volume_curve": "Кривая",
      "effects_min": "Мин. посыл FX (дБ)",
      "effects_max": "Макс. посыл FX (дБ)",
      "effects_curve": "Кривая",
      "linear": "Линейная",
      "exponential": "Экспонента",
      "delay": "Задержка",
      "reverb": "Реверберация",
      "chorus": "Хорус",
      "distortion": "Искажение",
      "filter": "Фильтр",
      "phaser": "Фейзер",
      "pitchShift": "Сдвиг высоты",
      "wet": "Микс",
      "time": "Время",
      "delayTime": "Время",
      "feedback": "Обратная связь",
      "decay": "Затухание",
      "preDelay": "Предзадержка",
      "frequency": "Частота",
      "depth": "Глубина",
      "Q": "Q",
      "type": "Тип",
      "gain": "Усиление",
      "rolloff": "Спад",
      "pitch": "Высота",
      "octaves": "Октавы",
      "baseFrequency": "Баз. частота",
      "sound_library_title": "Библиотека звуков",
      "presets_title": "Пресеты",
      "save_preset": "Сохранить новый звук",
      "delete_preset": "Удалить звук",
      "synth_controls": "Управление синтезатором",
      "synth_type": "Тип синтезатора",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "Тип осциллятора",
      "sine": "Синус",
      "square": "Квадрат",
      "sawtooth": "Пила",
      "triangle": "Треугольник",
      "fat_sine": "Fat Синус",
      "fat_square": "Fat Квадрат",
      "fat_sawtooth": "Fat Пила",
      "fat_triangle": "Fat Треугольник",
      "fm_sine": "FM Синус",
      "fm_square": "FM Квадрат",
      "fm_sawtooth": "FM Пила",
      "fm_triangle": "FM Треугольник",
      "am_sine": "AM Синус",
      "am_square": "AM Квадрат",
      "am_sawtooth": "AM Пила",
      "am_triangle": "AM Треугольник",
      "pwm": "ШИМ",
      "pulse": "Пульс",
      "noise_white": "Белый шум",
      "noise_pink": "Розовый шум",
      "noise_brown": "Коричневый шум",
      "oscillator_params": "Параметры осциллятора",
      "phase": "Фаза",
      "count": "Кол-во",
      "spread": "Разброс",
      "width": "Ширина",
      "mod_freq_short": "Част. мод.",
      "harmonicity": "Гармоничность",
      "mod_index": "Индекс мод.",
      "mod_type": "Тип мод.",
      "noise_type": "Тип шума",
      "envelope": "Огибающая",
      "attack": "Атака",
      "sustain": "Поддержка",
      "release": "Затухание",
      "envelope_curves": "Кривые огибающей",
      "attack_curve": "Атака",
      "decay_curve": "Спад",
      "release_curve": "Затухание",
      "filter_advanced": "Расш. фильтр",
      "filter_rolloff": "Спад",
      "filter_gain": "Усиление (дБ)",
      "filter_envelope": "Огибающая фильтра",
      "base_frequency": "Баз. частота",
      "exponent": "Экспонента",
      "modulation": "Модуляция",
      "modulation_envelope": "Огибающая модуляции",
      "special_parameters": "Спец. параметры",
      "pitch_decay": "Спад высоты",
      "attack_noise": "Шум атаки",
      "dampening": "Демпфирование",
      "resonance": "Резонанс",
      "lfo": "LFO",
      "lfo_type": "Тип",
      "lfo_target": "Цель",
      "lfo_min": "Мин.",
      "lfo_max": "Макс.",
      "save_preset_title": "Сохранить звуковой пресет",
      "preset_name_label": "Название пресета:",
      "preset_name_placeholder": "Мой звуковой пресет",
      "save_fx_chain_title": "Сохранить цепочку эффектов",
      "fx_chain_name_label": "Название цепочки:",
      "fx_chain_name_placeholder": "Моя цепочка эффектов",
      "cancel": "Отмена",
      "save": "Сохранить",
      "major": "Мажор",
      "minor": "Минор",
      "pentatonic": "Пентатоника",
      "blues": "Блюз",
      "chromatic": "Хроматическая",
      "dorian": "Дорийский",
      "phrygian": "Фригийский",
      "lydian": "Лидийский",
      "mixolydian": "Миксолидийский",
      "locrian": "Локрийский",
      "day": "День",
      "night": "Ночь",
      "neon": "Неон",
      "retro": "Ретро",
      "pastel": "Пастель",
      "aurora": "Аврора",
      "ocean": "Океан",
      "cyberpunk": "Киберпанк",
      "fire": "Огонь",
      "matrix": "Матрица",
      "hologram": "Голограмма",
      "crystal": "Кристалл",
      "galaxy": "Галактика",
      "waves": "Волны",
      "spectrum": "Спектр",
      "particles": "Косяк рыб",
      "nebula": "Туманность",
      "reactive_ripples": "Реактивная рябь",
      "touch_trails": "Следы касаний",
      "loading": "Загрузка...",
      "initializing": "Инициализация...",
      "loading_bridge": "Соединение...",
      "loading_settings": "Загрузка настроек...",
      "loading_modules": "Загрузка модулей...",
      "loading_ui": "Инициализация UI...",
      "loading_presets": "Применение настроек...",
      "loading_audio": "Загрузка звуков...",
      "tap_to_start": "Нажмите для запуска аудио",
      "starting_audio": "Запуск аудио...",
      "audio_suspended": "Аудио приостановлено. Нажмите для возобновления.",
      "loading_preset": "Загрузка пресета...",
      "loading_fxchain": "Загрузка цепочки FX...",
      "saving_preset_progress": "Сохранение пресета...",
      "saving_fxchain_progress": "Сохранение цепочки FX...",
      "deleting_preset_progress": "Удаление пресета...",
      "deleting_fxchain_progress": "Удаление цепочки FX...",
      "hit_play_vibe": "Нажми Play, Почувствуй Вайб",
      "error_bridge_failed": "Ошибка: Сбой подключения моста.",
      "error_init_failed": "Ошибка инициализации. См. консоль.",
      "error_init_failed_details": "Ошибка инициализации: ${error}. См. консоль.",
      "error_fatal_init": "Критическая ошибка инициализации. Перезапустите.",
      "error_audio_failed_retry": "Ошибка запуска аудио. Нажмите еще раз.",
      "error_audio_resume": "Не удалось возобновить аудио.",
      "error_apply_preset": "Ошибка применения пресета.",
      "error_apply_fxchain": "Ошибка применения цепочки FX.",
      "error_loading_presets": "Ошибка загрузки пресетов.",
      "error_loading_fxchains": "Ошибка загрузки цепочек",
      "error_loading_effects_ui": "Ошибка загрузки UI эффектов.",
      "no_presets_found": "Пресеты не найдены.",
      "no_fxchains_found": "Цепочки FX не найдены",
      "no_effects_available": "Эффекты недоступны.",
      "enter_preset_name": "Введите имя пресета.",
      "enter_fxchain_name": "Введите имя цепочки FX.",
      "preset_saved_success": "Пресет \"${name}\" успешно сохранен!",
      "fxchain_saved_success": "Цепочка FX \"${name}\" успешно сохранена!",
      "error_saving_preset": "Ошибка сохранения пресета: ${error}",
      "error_saving_fxchain": "Ошибка сохранения цепочки FX: ${error}",
      "exception_saving_preset": "Исключение при сохранении пресета: ${error}",
      "exception_saving_fxchain": "Исключение при сохранении цепочки FX: ${error}",
      "confirm_delete_preset": "Удалить пресет \"${name}\"? ",
      "confirm_delete_fxchain": "Удалить цепочку FX \"${name}\"?",
      "cannot_delete_default_preset": "Нельзя удалить стандартные пресеты.",
      "cannot_delete_default_fxchain": "Нельзя удалить стандартные цепочки FX.",
      "preset_deleted_success": "Пресет удален.",
      "fxchain_deleted_success": "Цепочка FX удалена.",
      "preset_delete_failed": "Не удалось удалить пресет.",
      "fxchain_delete_failed": "Не удалось удалить цепочку FX.",
      "exception_deleting_preset": "Исключение при удалении пресета: ${error}",
      "exception_deleting_fxchain": "Исключение при удалении цепочки FX: ${error}",
      "audio_not_ready_record": "Аудио не готово. Невозможно начать запись.",
      "pitch_envelope": "Огибающая питча",
      "pitch_amount_cents": "Величина (центы)",
      "macro_controls_title": "Макро контроллеры",
      "macro_space": "Пространство",
      "macro_time": "Время",
      "macro_motion": "Движение",
      "macro_tone": "Тембр",
      "macro_drive": "Драйв",
      "effects_intensity_min": "Мин. интенсивность FX (дБ)",
      "effects_intensity_max": "Макс. интенсивность FX (дБ)",
      "effects_threshold": "Порог FX",
      "none_fxchain": "-- Нет --",
      "none_touch_effect": "Нет",
      "restart_audio_engine_button": "Перезапуск аудио",
      "reload_app_button_title": "Перезагрузить",
      "reloading_app_message": "Перезагрузка приложения...",
      "master_output_title": "Мастер выход",
      "master_volume_ceiling": "Потолок громкости",
      "master_volume_ceiling_label": "Потолок громкости",
      "y_axis_volume_min_output": "Мин. выход",
      "y_axis_volume_max_output": "Макс. выход",
      "y_axis_volume_y_threshold": "Y порог",
      "y_axis_curve_type": "Тип кривой",
      "y_axis_curve_factor": "Фактор кривой",
      "y_axis_effects_min_output": "Мин. выход (дБ)",
      "y_axis_effects_max_output": "Макс. выход (дБ)",
      "y_axis_effects_y_threshold": "Y порог",
      "logarithmic": "Логарифм.",
      "s_curve": "S-кривая",
      "select_option": "Выбор опции",
      "no_options_found": "Опции не найдены",
      "error_loading_options": "Ошибка загрузки опций.",
      "pad_modes_button": "Режимы",
      "pad_modes_button_title": "Режимы пэда",
      "pad_modes_panel_title": "Режимы пэда",
      "pad_mode_label": "Режим пэда",
      "pad_mode_select_title": "Выбор режима пэда",
      "pad_mode_classic": "Классический",
      "pad_mode_reactive": "Реактивный",
      "reactive_mode_show_suggestions": "Показывать гарм. подсказки",
      "reactive_mode_suggestion_count": "Кол-во подсказок",
      "no_specific_settings_classic": "Нет настроек для Классического режима.",
      "no_specific_settings_reactive": "Настройте подсказки Реактивного режима.",
      "pad_mode_rocket": "Ракета",
      "rocket_highlight_active": "Подсвечивать активные ноты",
      "rocket_show_markers": "Показывать гармонические маркеры",
      "rocket_marker_style": "Стиль маркера",
      "rocket_valid_chords_only": "Маркеры только для аккордов",
      "rocket_animate_fade": "Анимация исчезновения маркеров",
      "rocket_show_chord_name": "Показывать имя аккорда",
      "style_GlowFromNote": "Сияние от ноты",
      "style_WaveToNote": "Волна к ноте",
      "style_PulseRing": "Пульсирующее кольцо",
      "style_SparkTrail": "Искристый след",
      "style_ShadowDrop": "Тень под нотой",
      "rocket_mode_panel_title": "Режим \"Ракета\"",
      "rocket_mode_enable": "Включить режим \"Ракета\"",
      "rocket_mode_settings_placeholder": "Настройки режима \"Ракета\" появятся здесь.",
      "error_loading_mode_settings": "Ошибка загрузки настроек режима.",
      "no_specific_settings_rocket": "Настройте специфичные параметры режима \"Ракета\".",
      "reset_settings_button": "Сбросить все настройки",
      "reload_app_button": "Полная перезагрузка",
      "restart_audio_button": "Перезапуск аудио движка",
      "rocket_section_general": "Общее",
      "rocket_section_phases": "Фазы",
      "rocket_section_harmonic_logic": "Гармоническая логика",
      "rocket_section_interactive_behavior": "Интерактивное поведение",
      "rocket_intensity": "Интенсивность",
      "rocket_visual_theme": "Визуальная тема",
      "rocket_auto_phases": "Автофазы",
      "rocket_harmonic_key": "Гармонический ключ",
      "rocket_marker_logic": "Логика маркеров",
      "marker_logic_tonal": "Тональная привязка",
      "marker_logic_adaptive": "Адаптивный анализ",
      "marker_logic_semi_free": "Полусвободный",
      "marker_logic_random": "Случайно-направленный",
      "rocket_phase_ignition": "Зажигание",
      "rocket_phase_lift_off": "Старт",
      "rocket_phase_burst": "Взрыв",
      "rocket_phase_transition": "Переход фаз",
      "phase_mode_activity": "По активности",
      "phase_mode_time": "По времени",
      "phase_mode_manual": "Вручную",
      "status_chord": "Аккорд",
      "status_key": "Тональность",
      "status_next": "Далее",
      "status_energy": "Энергия",
      "status_phase": "Фаза",
      "status_na": "Н/Д",
      "rocket_presets_title": "Пресеты режима",
      "rocket_select_preset": "Выбрать пресет",
      "rocket_select_preset_title": "Выбор пресета Режима \"Ракета\"",
      "rocket_preset_current": "Текущие настройки",
      "none_selected": "Нет",
      "preset_rocket_melodic_drift": "Мелодический дрейф",
      "desc_rocket_melodic_drift": "Мягкая, парящая, полу-свободная гармония.",
      "preset_rocket_jazz_climb": "Джазовый подъем",
      "desc_rocket_jazz_climb": "Активная, адаптивная, джазовая логика.",
      "rocket_marker_labels": "Метки маркеров",
      "labels_none": "Нет",
      "labels_function": "Функция (T/S/D)",
      "labels_chord_name": "Имя аккорда",
      "rocket_marker_retention": "Удержание маркеров",
      "desc_rocket_marker_retention": "Сохранять маркеры видимыми при новых касаниях.",
      "desc_rocket_animate_fade": "Плавное исчезновение ненужных маркеров.",
      "rocket_fade_delay": "Задержка исчезновения",
      "desc_rocket_fade_delay": "Задержка перед началом исчезновения маркера.",
      "rocket_fade_duration": "Длительность исчезновения",
      "desc_rocket_fade_duration": "Время анимации исчезновения маркера.",
      "rocket_max_markers_zone": "Макс. маркеров/зона",
      "desc_rocket_max_markers_zone": "Макс. подсказок на зону.",
      "rocket_phase_styles": "Стили фаз",
      "desc_rocket_phase_styles": "Разрешить фазе переопределять стиль маркера.",
      "rocket_tb_in_key": "Тон. привязка: только в тональности",
      "desc_rocket_tb_in_key": "Предлагать только ноты/аккорды текущей тональности.",
      "rocket_aa_autokey": "Адапт. анализ: авто-смена тональности",
      "desc_rocket_aa_autokey": "Разрешить адаптивную смену тональности по вводу.",
      "rocket_sf_basekey": "Полусвоб.: базовая тональность",
      "desc_rocket_sf_basekey": "Базовая тональность для полусвободного режима.",
      "rocket_sf_deviations": "Полусвоб.: модальные отклонения",
      "desc_rocket_sf_deviations": "Разрешить временные отклонения от базовой тональности.",
      "rocket_sf_return": "Полусвоб.: подсветка возврата",
      "desc_rocket_sf_return": "Подсвечивать предложения, возвращающие в баз. тональность.",
      "rocket_rd_randomlevel": "Уровень случайности",
      "desc_rocket_rd_randomlevel": "Уровень случайности в предложениях.",
      "select_chord": "Выбрать аккорд",
      "select_key": "Выбрать тональность",
      "select_phase": "Выбрать фазу",
      "no_language_found": "Языки не найдены",
      "no_theme_found": "Темы не найдены",
      "no_visualizer_found": "Визуализации не найдены",
      "no_touchEffect_found": "Эффекты касания не найдены",
      "no_scale_found": "Лады не найдены",
      "no_fxChain_found": "Цепочки FX не найдены",
      "error_audio_fatal_restart": "Критическая ошибка аудио. Перезапустите приложение.",
      "preset_name_label": "Название пресета:",
      "preset_name_placeholder": "Мой звуковой пресет",
      "save_fx_chain_title": "Сохранить цепочку эффектов",
      "fx_chain_name_label": "Название цепочки:",
      "fx_chain_name_placeholder": "Моя цепочка эффектов",
      "cancel": "Отмена",
      "save": "Сохранить",
      "major": "Мажор",
      "minor": "Минор",
      "pentatonic": "Пентатоника",
      "blues": "Блюз",
      "chromatic": "Хроматическая",
      "dorian": "Дорийский",
      "phrygian": "Фригийский",
      "lydian": "Лидийский",
      "mixolydian": "Миксолидийский",
      "locrian": "Локрийский",
      "day": "День",
      "night": "Ночь",
      "neon": "Неон",
      "retro": "Ретро",
      "pastel": "Пастель",
      "aurora": "Аврора",
      "ocean": "Океан",
      "cyberpunk": "Киберпанк",
      "fire": "Огонь",
      "matrix": "Матрица",
      "hologram": "Голограмма",
      "crystal": "Кристалл",
      "galaxy": "Галактика",
      "waves": "Волны",
      "spectrum": "Спектр",
      "particles": "Косяк рыб",
      "nebula": "Туманность",
      "reactive_ripples": "Реактивная рябь",
      "touch_trails": "Следы касаний",
      "loading": "Загрузка...",
      "initializing": "Инициализация...",
      "loading_bridge": "Соединение...",
      "loading_settings": "Загрузка настроек...",
      "loading_modules": "Загрузка модулей...",
      "loading_ui": "Инициализация UI...",
      "loading_presets": "Применение настроек...",
      "loading_audio": "Загрузка звуков...",
      "tap_to_start": "Нажмите для запуска аудио",
      "starting_audio": "Запуск аудио...",
      "audio_suspended": "Аудио приостановлено. Нажмите для возобновления.",
      "loading_preset": "Загрузка пресета...",
      "loading_fxchain": "Загрузка цепочки FX...",
      "saving_preset_progress": "Сохранение пресета...",
      "saving_fxchain_progress": "Сохранение цепочки FX...",
      "deleting_preset_progress": "Удаление пресета...",
      "deleting_fxchain_progress": "Удаление цепочки FX...",
      "hit_play_vibe": "Нажми Play, Почувствуй Вайб",
      "error_bridge_failed": "Ошибка: Сбой подключения моста.",
      "error_init_failed": "Ошибка инициализации. См. консоль.",
      "error_init_failed_details": "Ошибка инициализации: ${error}. См. консоль.",
      "error_fatal_init": "Критическая ошибка инициализации. Перезапустите.",
      "error_audio_failed_retry": "Ошибка запуска аудио. Нажмите еще раз.",
      "error_audio_resume": "Не удалось возобновить аудио.",
      "error_apply_preset": "Ошибка применения пресета.",
      "error_apply_fxchain": "Ошибка применения цепочки FX.",
      "error_loading_presets": "Ошибка загрузки пресетов.",
      "error_loading_fxchains": "Ошибка загрузки цепочек",
      "error_loading_effects_ui": "Ошибка загрузки UI эффектов.",
      "no_presets_found": "Пресеты не найдены.",
      "no_fxchains_found": "Цепочки FX не найдены",
      "no_effects_available": "Эффекты недоступны.",
      "enter_preset_name": "Введите имя пресета.",
      "enter_fxchain_name": "Введите имя цепочки FX.",
      "preset_saved_success": "Пресет \"${name}\" успешно сохранен!",
      "fxchain_saved_success": "Цепочка FX \"${name}\" успешно сохранена!",
      "error_saving_preset": "Ошибка сохранения пресета: ${error}",
      "error_saving_fxchain": "Ошибка сохранения цепочки FX: ${error}",
      "exception_saving_preset": "Исключение при сохранении пресета: ${error}",
      "exception_saving_fxchain": "Исключение при сохранении цепочки FX: ${error}",
      "confirm_delete_preset": "Удалить пресет \"${name}\"? ",
      "confirm_delete_fxchain": "Удалить цепочку FX \"${name}\"?",
      "cannot_delete_default_preset": "Нельзя удалить стандартные пресеты.",
      "cannot_delete_default_fxchain": "Нельзя удалить стандартные цепочки FX.",
      "preset_deleted_success": "Пресет удален.",
      "fxchain_deleted_success": "Цепочка FX удалена.",
      "preset_delete_failed": "Не удалось удалить пресет.",
      "fxchain_delete_failed": "Не удалось удалить цепочку FX.",
      "exception_deleting_preset": "Исключение при удалении пресета: ${error}",
      "exception_deleting_fxchain": "Исключение при удалении цепочки FX: ${error}",
      "audio_not_ready_record": "Аудио не готово. Невозможно начать запись.",
      "pitch_envelope": "Огибающая питча",
      "pitch_amount_cents": "Величина (центы)",
      "macro_controls_title": "Макро контроллеры",
      "macro_space": "Пространство",
      "macro_time": "Время",
      "macro_motion": "Движение",
      "macro_tone": "Тембр",
      "macro_drive": "Драйв",
      "effects_intensity_min": "Мин. интенсивность FX (дБ)",
      "effects_intensity_max": "Макс. интенсивность FX (дБ)",
      "effects_threshold": "Порог FX",
      "none_fxchain": "-- Нет --",
      "none_touch_effect": "Нет",
      "restart_audio_engine_button": "Перезапуск аудио",
      "reload_app_button_title": "Перезагрузить",
      "reloading_app_message": "Перезагрузка приложения...",
      "master_output_title": "Мастер выход",
      "master_volume_ceiling": "Потолок громкости",
      "master_volume_ceiling_label": "Потолок громкости",
      "y_axis_volume_min_output": "Мин. выход",
      "y_axis_volume_max_output": "Макс. выход",
      "y_axis_volume_y_threshold": "Y порог",
      "y_axis_curve_type": "Тип кривой",
      "y_axis_curve_factor": "Фактор кривой",
      "y_axis_effects_min_output": "Мин. выход (дБ)",
      "y_axis_effects_max_output": "Макс. выход (дБ)",
      "y_axis_effects_y_threshold": "Y порог",
      "logarithmic": "Логарифм.",
      "s_curve": "S-кривая",
      "select_option": "Выбор опции",
      "no_options_found": "Опции не найдены",
      "error_loading_options": "Ошибка загрузки опций.",
      "pad_modes_button": "Режимы",
      "pad_modes_button_title": "Режимы пэда",
      "pad_modes_panel_title": "Режимы пэда",
      "pad_mode_label": "Режим пэда",
      "pad_mode_select_title": "Выбор режима пэда",
      "pad_mode_classic": "Классический",
      "pad_mode_reactive": "Реактивный",
      "reactive_mode_show_suggestions": "Показывать гарм. подсказки",
      "reactive_mode_suggestion_count": "Кол-во подсказок",
      "no_specific_settings_classic": "Нет настроек для Классического режима.",
      "no_specific_settings_reactive": "Настройте подсказки Реактивного режима.",
      "pad_mode_rocket": "Ракета",
      "rocket_highlight_active": "Подсвечивать активные ноты",
      "rocket_show_markers": "Показывать гармонические маркеры",
      "rocket_marker_style": "Стиль маркера",
      "rocket_valid_chords_only": "Маркеры только для аккордов",
      "rocket_animate_fade": "Анимация исчезновения маркеров",
      "rocket_show_chord_name": "Показывать имя аккорда",
      "style_GlowFromNote": "Сияние от ноты",
      "style_WaveToNote": "Волна к ноте",
      "style_PulseRing": "Пульсирующее кольцо",
      "style_SparkTrail": "Искристый след",
      "style_ShadowDrop": "Тень под нотой",
      "rocket_mode_panel_title": "Режим \"Ракета\"",
      "rocket_mode_enable": "Включить режим \"Ракета\"",
      "rocket_mode_settings_placeholder": "Настройки режима \"Ракета\" появятся здесь.",
      "error_loading_mode_settings": "Ошибка загрузки настроек режима.",
      "no_specific_settings_rocket": "Настройте специфичные параметры режима \"Ракета\".",
      "reset_settings_button": "Сбросить все настройки",
      "reload_app_button": "Полная перезагрузка",
      "restart_audio_button": "Перезапуск аудио движка",
      "rocket_section_general": "Общее",
      "rocket_section_phases": "Фазы",
      "rocket_section_harmonic_logic": "Гармоническая логика",
      "rocket_section_interactive_behavior": "Интерактивное поведение",
      "rocket_intensity": "Интенсивность",
      "rocket_visual_theme": "Визуальная тема",
      "rocket_auto_phases": "Автофазы",
      "rocket_harmonic_key": "Гармонический ключ",
      "rocket_marker_logic": "Логика маркеров",
      "marker_logic_tonal": "Тональная привязка",
      "marker_logic_adaptive": "Адаптивный анализ",
      "marker_logic_semi_free": "Полусвободный",
      "marker_logic_random": "Случайно-направленный",
      "rocket_phase_ignition": "Зажигание",
      "rocket_phase_lift_off": "Старт",
      "rocket_phase_burst": "Взрыв",
      "rocket_phase_transition": "Переход фаз",
      "phase_mode_activity": "По активности",
      "phase_mode_time": "По времени",
      "phase_mode_manual": "Вручную",
      "status_chord": "Аккорд",
      "status_key": "Тональность",
      "status_next": "Далее",
      "status_energy": "Энергия",
      "status_phase": "Фаза",
      "status_na": "Н/Д",
      "rocket_presets_title": "Пресеты режима",
      "rocket_select_preset": "Выбрать пресет",
      "rocket_select_preset_title": "Выбор пресета Режима \"Ракета\"",
      "rocket_preset_current": "Текущие настройки",
      "none_selected": "Нет",
      "preset_rocket_melodic_drift": "Мелодический дрейф",
      "desc_rocket_melodic_drift": "Мягкая, парящая, полу-свободная гармония.",
      "preset_rocket_jazz_climb": "Джазовый подъем",
      "desc_rocket_jazz_climb": "Активная, адаптивная, джазовая логика.",
      "rocket_marker_labels": "Метки маркеров",
      "labels_none": "Нет",
      "labels_function": "Функция (T/S/D)",
      "labels_chord_name": "Имя аккорда",
      "rocket_marker_retention": "Удержание маркеров",
      "desc_rocket_marker_retention": "Сохранять маркеры видимыми при новых касаниях.",
      "desc_rocket_animate_fade": "Плавное исчезновение ненужных маркеров.",
      "rocket_fade_delay": "Задержка исчезновения",
      "desc_rocket_fade_delay": "Задержка перед началом исчезновения маркера.",
      "rocket_fade_duration": "Длительность исчезновения",
      "desc_rocket_fade_duration": "Время анимации исчезновения маркера.",
      "rocket_max_markers_zone": "Макс. маркеров/зона",
      "desc_rocket_max_markers_zone": "Макс. подсказок на зону.",
      "rocket_phase_styles": "Стили фаз",
      "desc_rocket_phase_styles": "Разрешить фазе переопределять стиль маркера.",
      "rocket_tb_in_key": "Тон. привязка: только в тональности",
      "desc_rocket_tb_in_key": "Предлагать только ноты/аккорды текущей тональности.",
      "rocket_aa_autokey": "Адапт. анализ: авто-смена тональности",
      "desc_rocket_aa_autokey": "Разрешить адаптивную смену тональности по вводу.",
      "rocket_sf_basekey": "Полусвоб.: базовая тональность",
      "desc_rocket_sf_basekey": "Базовая тональность для полусвободного режима.",
      "rocket_sf_deviations": "Полусвоб.: модальные отклонения",
      "desc_rocket_sf_deviations": "Разрешить временные отклонения от базовой тональности.",
      "rocket_sf_return": "Полусвоб.: подсветка возврата",
      "desc_rocket_sf_return": "Подсвечивать предложения, возвращающие в баз. тональность.",
      "rocket_rd_randomlevel": "Уровень случайности",
      "desc_rocket_rd_randomlevel": "Уровень случайности в предложениях.",
      "select_chord": "Выбрать аккорд",
      "select_key": "Выбрать тональность",
      "select_phase": "Выбрать фазу",
      "no_language_found": "Языки не найдены",
      "no_theme_found": "Темы не найдены",
      "no_visualizer_found": "Визуализации не найдены",
      "no_touchEffect_found": "Эффекты касания не найдены",
      "no_scale_found": "Лады не найдены",
      "no_fxChain_found": "Цепочки FX не найдены",
      "error_audio_fatal_restart": "Критическая ошибка аудио. Перезапустите приложение."
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\language\zh-CN.json
{
  "id": "zh-CN",
  "type": "language",
  "name": "简体中文",
  "version": "1.0.5",
  "description": "Simplified Chinese language pack (Updated 25.05.2025)",
  "active": false,
  "data": {
    "strings": {
      "presets_panel_title": "预设列表",
      "app_title": "Prismtone",
      "menu_button": "菜单",
      "sound_library_button": "音色库",
      "tonality_button": "调性",
      "effects_button": "效果",
      "record_button": "录音",
      "stop_recording_button": "停止录音",
      "settings_title": "设置",
      "language_label": "语言",
      "theme_label": "主题",
      "visualizer_label": "可视化",
      "touch_effect_label": "触摸效果",
      "display_options_header": "显示与行为",
      "show_note_names": "显示音名",
      "show_lines": "显示网格线",
      "multi_touch": "多点触控",
      "enable_polyphony_scaling": "复音音量缩放",
      "haptic_feedback": "触觉反馈",
      "enable_vibration": "启用振动",
      "highlight_sharps_flats": "高亮升/降号",
      "tonality_title": "调性",
      "octave_label": "八度",
      "scale_label": "音阶",
      "size_label": "大小",
      "effects_title": "效果",
      "fx_chain_label": "效果链",
      "save_chain": "保存效果链",
      "delete_chain": "删除效果链",
      "reset_fx": "重置效果",
      "y_axis_controls": "Y轴控制",
      "volume_min": "最小音量",
      "volume_max": "最大音量",
      "volume_curve": "曲线",
      "effects_min": "FX发送最小 (dB)",
      "effects_max": "FX发送最大 (dB)",
      "effects_curve": "曲线",
      "linear": "线性",
      "exponential": "指数",
      "delay": "延迟",
      "reverb": "混响",
      "chorus": "合唱",
      "distortion": "失真",
      "filter": "滤波器",
      "phaser": "移相器",
      "pitchShift": "变调",
      "wet": "干湿比",
      "time": "时间",
      "delayTime": "时间",
      "feedback": "反馈",
      "decay": "衰减",
      "preDelay": "预延迟",
      "frequency": "频率",
      "depth": "深度",
      "Q": "Q值",
      "type": "类型",
      "gain": "增益",
      "rolloff": "滚降",
      "pitch": "音高",
      "octaves": "八度",
      "baseFrequency": "基频",
      "sound_library_title": "音色库",
      "presets_title": "预设",
      "save_preset": "保存新音色",
      "delete_preset": "删除音色",
      "synth_controls": "合成器控制",
      "synth_type": "合成器类型",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "振荡器类型",
      "sine": "正弦波",
      "square": "方波",
      "sawtooth": "锯齿波",
      "triangle": "三角波",
      "fat_sine": "Fat 正弦波",
      "fat_square": "Fat 方波",
      "fat_sawtooth": "Fat 锯齿波",
      "fat_triangle": "Fat 三角波",
      "fm_sine": "FM 正弦波",
      "fm_square": "FM 方波",
      "fm_sawtooth": "FM 锯齿波",
      "fm_triangle": "FM 三角波",
      "am_sine": "AM 正弦波",
      "am_square": "AM 方波",
      "am_sawtooth": "AM 锯齿波",
      "am_triangle": "AM 三角波",
      "pwm": "PWM",
      "pulse": "脉冲波",
      "noise_white": "白噪音",
      "noise_pink": "粉红噪音",
      "noise_brown": "布朗噪音",
      "oscillator_params": "振荡器参数",
      "phase": "相位",
      "count": "数量",
      "spread": "扩展度",
      "width": "宽度",
      "mod_freq_short": "调制频率",
      "harmonicity": "谐波性",
      "mod_index": "调制指数",
      "mod_type": "调制类型",
      "noise_type": "噪音类型",
      "envelope": "包络",
      "attack": "起音",
      "sustain": "持续",
      "release": "释音",
      "envelope_curves": "包络曲线",
      "attack_curve": "起音",
      "decay_curve": "衰减",
      "release_curve": "释音",
      "filter_advanced": "高级滤波器",
      "filter_rolloff": "滚降",
      "filter_gain": "增益 (dB)",
      "filter_envelope": "滤波器包络",
      "base_frequency": "基频",
      "exponent": "指数",
      "modulation": "调制",
      "modulation_envelope": "调制包络",
      "special_parameters": "特殊参数",
      "pitch_decay": "音高衰减",
      "attack_noise": "起音噪音",
      "dampening": "阻尼",
      "resonance": "共振",
      "lfo": "LFO",
      "lfo_type": "类型",
      "lfo_target": "目标",
      "lfo_min": "最小",
      "lfo_max": "最大",
      "save_preset_title": "保存音色预设",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_fx_chain_title": "保存效果链",
      "fx_chain_name_label": "效果链名称:",
      "fx_chain_name_placeholder": "我的效果链",
      "cancel": "取消",
      "save": "保存",
      "major": "大调",
      "minor": "小调",
      "pentatonic": "五声音阶",
      "blues": "布鲁斯",
      "chromatic": "半音阶",
      "dorian": "多利亚",
      "phrygian": "弗里几亚",
      "lydian": "利底亚",
      "mixolydian": "混合利底亚",
      "locrian": "洛克里亚",
      "day": "日间",
      "night": "夜间",
      "neon": "霓虹",
      "retro": "复古",
      "pastel": "粉彩",
      "aurora": "极光",
      "ocean": "海洋",
      "cyberpunk": "赛博朋克",
      "fire": "火焰",
      "matrix": "矩阵",
      "hologram": "全息图",
      "crystal": "水晶",
      "galaxy": "银河",
      "waves": "波形",
      "spectrum": "频谱",
      "particles": "鱼群",
      "nebula": "星云",
      "reactive_ripples": "反应涟漪",
      "touch_trails": "触摸轨迹",
      "loading": "加载中...",
      "initializing": "初始化中...",
      "loading_bridge": "连接中...",
      "loading_settings": "加载设置...",
      "loading_modules": "加载模块...",
      "loading_ui": "初始化UI...",
      "loading_presets": "应用设置...",
      "loading_audio": "加载声音...",
      "tap_to_start": "点击以启动音频",
      "starting_audio": "启动音频中...",
      "audio_suspended": "音频已暂停。点击以恢复。",
      "loading_preset": "加载预设...",
      "loading_fxchain": "加载效果链...",
      "saving_preset_progress": "保存预设中...",
      "saving_fxchain_progress": "保存效果链中...",
      "deleting_preset_progress": "删除预设中...",
      "deleting_fxchain_progress": "删除效果链中...",
      "hit_play_vibe": "点击播放，感受律动",
      "error_bridge_failed": "错误：桥接连接失败。",
      "error_init_failed": "初始化错误。请检查控制台。",
      "error_init_failed_details": "初始化错误: ${error}。请检查控制台。",
      "error_fatal_init": "严重初始化错误。请重启。",
      "error_audio_failed_retry": "启动音频错误。请再次点击。",
      "error_audio_resume": "无法恢复音频。",
      "error_apply_preset": "应用预设错误。",
      "error_apply_fxchain": "应用效果链错误。",
      "error_loading_presets": "加载预设错误。",
      "error_loading_fxchains": "加载效果链错误",
      "error_loading_effects_ui": "加载效果UI错误。",
      "no_presets_found": "未找到预设。",
      "no_fxchains_found": "未找到效果链",
      "no_effects_available": "无可用效果。",
      "enter_preset_name": "请输入预设名称。",
      "enter_fxchain_name": "请输入效果链名称。",
      "preset_saved_success": "预设 \"${name}\" 保存成功！",
      "fxchain_saved_success": "效果链 \"${name}\" 保存成功！",
      "error_saving_preset": "保存预设错误: ${error}",
      "error_saving_fxchain": "保存效果链错误: ${error}",
      "exception_saving_preset": "保存预设异常: ${error}",
      "exception_saving_fxchain": "保存效果链异常: ${error}",
      "confirm_delete_preset": "确定删除预设 \"${name}\" 吗？",
      "confirm_delete_fxchain": "确定删除效果链 \"${name}\" 吗？",
      "cannot_delete_default_preset": "无法删除默认预设。",
      "cannot_delete_default_fxchain": "无法删除默认效果链。",
      "preset_deleted_success": "预设已删除。",
      "fxchain_deleted_success": "效果链已删除。",
      "preset_delete_failed": "删除预设失败。",
      "fxchain_delete_failed": "删除效果链失败。",
      "exception_deleting_preset": "删除预设异常: ${error}",
      "exception_deleting_fxchain": "删除效果链异常: ${error}",
      "audio_not_ready_record": "音频未准备好。无法开始录制。",
      "pitch_envelope": "音高包络",
      "pitch_amount_cents": "量 (音分)",
      "macro_controls_title": "宏控制",
      "macro_space": "空间",
      "macro_time": "时间",
      "macro_motion": "动态",
      "macro_tone": "音色",
      "macro_drive": "驱动",
      "effects_intensity_min": "FX强度最小 (dB)",
      "effects_intensity_max": "FX强度最大 (dB)",
      "effects_threshold": "FX阈值",
      "none_fxchain": "-- 无 --",
      "none_touch_effect": "无",
      "restart_audio_engine_button": "重启音频",
      "reload_app_button_title": "重载应用",
      "reloading_app_message": "重新加载应用程序...",
      "master_output_title": "主输出",
      "master_volume_ceiling": "音量上限",
      "master_volume_ceiling_label": "音量上限",
      "y_axis_volume_min_output": "最小输出",
      "y_axis_volume_max_output": "最大输出",
      "y_axis_volume_y_threshold": "Y轴阈值",
      "y_axis_curve_type": "曲线类型",
      "y_axis_curve_factor": "曲线因子",
      "y_axis_effects_min_output": "最小输出 (dB)",
      "y_axis_effects_max_output": "最大输出 (dB)",
      "y_axis_effects_y_threshold": "Y轴阈值",
      "logarithmic": "对数",
      "s_curve": "S形曲线",
      "select_option": "选择选项",
      "no_options_found": "未找到选项",
      "error_loading_options": "加载选项错误。",
      "pad_modes_button": "模式",
      "pad_modes_button_title": "打击垫模式",
      "pad_modes_panel_title": "打击垫模式",
      "pad_mode_label": "打击垫模式",
      "pad_mode_select_title": "选择打击垫模式",
      "pad_mode_classic": "经典",
      "pad_mode_reactive": "反应",
      "reactive_mode_show_suggestions": "显示和声提示",
      "reactive_mode_suggestion_count": "提示数量",
      "no_specific_settings_classic": "经典模式无特定设置。",
      "no_specific_settings_reactive": "配置反应模式提示。",
      "pad_mode_rocket": "火箭",
      "rocket_highlight_active": "高亮活动音符",
      "rocket_show_markers": "显示方向标记",
      "rocket_marker_style": "标记样式",
      "rocket_valid_chords_only": "仅对有效和弦显示标记",
      "rocket_animate_fade": "动画标记淡出",
      "rocket_show_chord_name": "显示识别的和弦名称",
      "style_GlowFromNote": "音符发光",
      "style_WaveToNote": "波形至音符",
      "style_PulseRing": "脉冲环",
      "style_SparkTrail": "火花轨迹",
      "style_ShadowDrop": "音符下阴影",
      "rocket_mode_panel_title": "火箭模式",
      "rocket_mode_enable": "启用火箭模式",
      "rocket_mode_settings_placeholder": "火箭模式设置将显示在此处。",
      "error_loading_mode_settings": "加载模式设置错误。",
      "no_specific_settings_rocket": "配置火箭模式特定设置。",
      "reset_settings_button": "重置所有设置",
      "reload_app_button": "完全重载应用",
      "restart_audio_button": "重启音频引擎",
      "rocket_section_general": "通用",
      "rocket_section_phases": "阶段",
      "rocket_section_harmonic_logic": "和声逻辑",
      "rocket_section_interactive_behavior": "交互行为",
      "rocket_intensity": "强度",
      "rocket_visual_theme": "视觉主题",
      "rocket_auto_phases": "自动阶段",
      "rocket_harmonic_key": "和声调",
      "rocket_marker_logic": "标记逻辑",
      "marker_logic_tonal": "调性绑定",
      "marker_logic_adaptive": "自适应分析",
      "marker_logic_semi_free": "半自由",
      "marker_logic_random": "随机定向",
      "rocket_phase_ignition": "点火",
      "rocket_phase_lift_off": "升空",
      "rocket_phase_burst": "爆发",
      "rocket_phase_transition": "阶段转换",
      "phase_mode_activity": "按活动",
      "phase_mode_time": "按时间",
      "phase_mode_manual": "手动",
      "status_chord": "和弦",
      "status_key": "调性",
      "status_next": "下一个",
      "status_energy": "能量",
      "status_phase": "阶段",
      "status_na": "无",
      "rocket_presets_title": "模式预设",
      "rocket_select_preset": "选择预设",
      "rocket_select_preset_title": "选择火箭模式预设",
      "rocket_preset_current": "当前设置",
      "none_selected": "无",
      "preset_rocket_melodic_drift": "旋律漂移",
      "desc_rocket_melodic_drift": "温柔、漂浮、半自由的和声逻辑。",
      "preset_rocket_jazz_climb": "爵士攀升",
      "desc_rocket_jazz_climb": "活跃、自适应、爵士风格的逻辑。",
      "rocket_marker_labels": "标记标签",
      "labels_none": "无",
      "labels_function": "功能 (T/S/D)",
      "labels_chord_name": "和弦名称",
      "rocket_marker_retention": "标记保留",
      "desc_rocket_marker_retention": "在新触摸期间保持相关标记可见。",
      "desc_rocket_animate_fade": "平滑淡出不相关的标记。",
      "rocket_fade_delay": "淡出延迟",
      "desc_rocket_fade_delay": "标记开始淡出前的延迟。",
      "rocket_fade_duration": "淡出时长",
      "desc_rocket_fade_duration": "标记淡出动画的持续时间。",
      "rocket_max_markers_zone": "最大标记/区域",
      "desc_rocket_max_markers_zone": "每个区域显示的最大建议数。",
      "rocket_phase_styles": "阶段样式",
      "desc_rocket_phase_styles": "允许当前阶段覆盖标记样式。",
      "rocket_tb_in_key": "调性绑定：仅在调内",
      "desc_rocket_tb_in_key": "仅建议当前调内的音符/和弦。",
      "rocket_aa_autokey": "自适应分析：自动换调",
      "desc_rocket_aa_autokey": "允许根据输入自适应更改调性。",
      "rocket_sf_basekey": "半自由：基础调性",
      "desc_rocket_sf_basekey": "半自由模式的基础调性。",
      "rocket_sf_deviations": "半自由：模态偏差",
      "desc_rocket_sf_deviations": "允许临时偏离基础调性。",
      "rocket_sf_return": "半自由：高亮返回",
      "desc_rocket_sf_return": "高亮显示返回基础调性的建议。",
      "rocket_rd_randomlevel": "随机级别",
      "desc_rocket_rd_randomlevel": "建议中的随机性级别。",
      "select_chord": "选择和弦",
      "select_key": "选择调性",
      "select_phase": "选择阶段",
      "no_language_found": "未找到语言",
      "no_theme_found": "未找到主题",
      "no_visualizer_found": "未找到可视化工具",
      "no_touchEffect_found": "未找到触摸效果",
      "no_scale_found": "未找到音阶",
      "no_fxChain_found": "未找到效果链",
      "error_audio_fatal_restart": "严重音频错误。请重启应用。",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_preset": "保存新音色",
      "delete_preset": "删除音色",
      "synth_controls": "合成器控制",
      "synth_type": "合成器类型",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "振荡器类型",
      "sine": "正弦波",
      "square": "方波",
      "sawtooth": "锯齿波",
      "triangle": "三角波",
      "fat_sine": "Fat 正弦波",
      "fat_square": "Fat 方波",
      "fat_sawtooth": "Fat 锯齿波",
      "fat_triangle": "Fat 三角波",
      "fm_sine": "FM 正弦波",
      "fm_square": "FM 方波",
      "fm_sawtooth": "FM 锯齿波",
      "fm_triangle": "FM 三角波",
      "am_sine": "AM 正弦波",
      "am_square": "AM 方波",
      "am_sawtooth": "AM 锯齿波",
      "am_triangle": "AM 三角波",
      "pwm": "PWM",
      "pulse": "脉冲波",
      "noise_white": "白噪音",
      "noise_pink": "粉红噪音",
      "noise_brown": "布朗噪音",
      "oscillator_params": "振荡器参数",
      "phase": "相位",
      "count": "数量",
      "spread": "扩展度",
      "width": "宽度",
      "mod_freq_short": "调制频率",
      "harmonicity": "谐波性",
      "mod_index": "调制指数",
      "mod_type": "调制类型",
      "noise_type": "噪音类型",
      "envelope": "包络",
      "attack": "起音",
      "sustain": "持续",
      "release": "释音",
      "envelope_curves": "包络曲线",
      "attack_curve": "起音",
      "decay_curve": "衰减",
      "release_curve": "释音",
      "filter_advanced": "高级滤波器",
      "filter_rolloff": "滚降",
      "filter_gain": "增益 (dB)",
      "filter_envelope": "滤波器包络",
      "base_frequency": "基频",
      "exponent": "指数",
      "modulation": "调制",
      "modulation_envelope": "调制包络",
      "special_parameters": "特殊参数",
      "pitch_decay": "音高衰减",
      "attack_noise": "起音噪音",
      "dampening": "阻尼",
      "resonance": "共振",
      "lfo": "LFO",
      "lfo_type": "类型",
      "lfo_target": "目标",
      "lfo_min": "最小",
      "lfo_max": "最大",
      "save_preset_title": "保存音色预设",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_fx_chain_title": "保存效果链",
      "fx_chain_name_label": "效果链名称:",
      "fx_chain_name_placeholder": "我的效果链",
      "cancel": "取消",
      "save": "保存",
      "major": "大调",
      "minor": "小调",
      "pentatonic": "五声音阶",
      "blues": "布鲁斯",
      "chromatic": "半音阶",
      "dorian": "多利亚",
      "phrygian": "弗里几亚",
      "lydian": "利底亚",
      "mixolydian": "混合利底亚",
      "locrian": "洛克里亚",
      "day": "日间",
      "night": "夜间",
      "neon": "霓虹",
      "retro": "复古",
      "pastel": "粉彩",
      "aurora": "极光",
      "ocean": "海洋",
      "cyberpunk": "赛博朋克",
      "fire": "火焰",
      "matrix": "矩阵",
      "hologram": "全息图",
      "crystal": "水晶",
      "galaxy": "银河",
      "waves": "波形",
      "spectrum": "频谱",
      "particles": "鱼群",
      "nebula": "星云",
      "reactive_ripples": "反应涟漪",
      "touch_trails": "触摸轨迹",
      "loading": "加载中...",
      "initializing": "初始化中...",
      "loading_bridge": "连接中...",
      "loading_settings": "加载设置...",
      "loading_modules": "加载模块...",
      "loading_ui": "初始化UI...",
      "loading_presets": "应用设置...",
      "loading_audio": "加载声音...",
      "tap_to_start": "点击以启动音频",
      "starting_audio": "启动音频中...",
      "audio_suspended": "音频已暂停。点击以恢复。",
      "loading_preset": "加载预设...",
      "loading_fxchain": "加载效果链...",
      "saving_preset_progress": "保存预设中...",
      "saving_fxchain_progress": "保存效果链中...",
      "deleting_preset_progress": "删除预设中...",
      "deleting_fxchain_progress": "删除效果链中...",
      "hit_play_vibe": "点击播放，感受律动",
      "error_bridge_failed": "错误：桥接连接失败。",
      "error_init_failed": "初始化错误。请检查控制台。",
      "error_init_failed_details": "初始化错误: ${error}。请检查控制台。",
      "error_fatal_init": "严重初始化错误。请重启。",
      "error_audio_failed_retry": "启动音频错误。请再次点击。",
      "error_audio_resume": "无法恢复音频。",
      "error_apply_preset": "应用预设错误。",
      "error_apply_fxchain": "应用效果链错误。",
      "error_loading_presets": "加载预设错误。",
      "error_loading_fxchains": "加载效果链错误",
      "error_loading_effects_ui": "加载效果UI错误。",
      "no_presets_found": "未找到预设。",
      "no_fxchains_found": "未找到效果链",
      "no_effects_available": "无可用效果。",
      "enter_preset_name": "请输入预设名称。",
      "enter_fxchain_name": "请输入效果链名称。",
      "preset_saved_success": "预设 \"${name}\" 保存成功！",
      "fxchain_saved_success": "效果链 \"${name}\" 保存成功！",
      "error_saving_preset": "保存预设错误: ${error}",
      "error_saving_fxchain": "保存效果链错误: ${error}",
      "exception_saving_preset": "保存预设异常: ${error}",
      "exception_saving_fxchain": "保存效果链异常: ${error}",
      "confirm_delete_preset": "确定删除预设 \"${name}\" 吗？",
      "confirm_delete_fxchain": "确定删除效果链 \"${name}\" 吗？",
      "cannot_delete_default_preset": "无法删除默认预设。",
      "cannot_delete_default_fxchain": "无法删除默认效果链。",
      "preset_deleted_success": "预设已删除。",
      "fxchain_deleted_success": "效果链已删除。",
      "preset_delete_failed": "删除预设失败。",
      "fxchain_delete_failed": "删除效果链失败。",
      "exception_deleting_preset": "删除预设异常: ${error}",
      "exception_deleting_fxchain": "删除效果链异常: ${error}",
      "audio_not_ready_record": "音频未准备好。无法开始录制。",
      "pitch_envelope": "音高包络",
      "pitch_amount_cents": "量 (音分)",
      "macro_controls_title": "宏控制",
      "macro_space": "空间",
      "macro_time": "时间",
      "macro_motion": "动态",
      "macro_tone": "音色",
      "macro_drive": "驱动",
      "effects_intensity_min": "FX强度最小 (dB)",
      "effects_intensity_max": "FX强度最大 (dB)",
      "effects_threshold": "FX阈值",
      "none_fxchain": "-- 无 --",
      "none_touch_effect": "无",
      "restart_audio_engine_button": "重启音频",
      "reload_app_button_title": "重载应用",
      "reloading_app_message": "重新加载应用程序...",
      "master_output_title": "主输出",
      "master_volume_ceiling": "音量上限",
      "master_volume_ceiling_label": "音量上限",
      "y_axis_volume_min_output": "最小输出",
      "y_axis_volume_max_output": "最大输出",
      "y_axis_volume_y_threshold": "Y轴阈值",
      "y_axis_curve_type": "曲线类型",
      "y_axis_curve_factor": "曲线因子",
      "y_axis_effects_min_output": "最小输出 (dB)",
      "y_axis_effects_max_output": "最大输出 (dB)",
      "y_axis_effects_y_threshold": "Y轴阈值",
      "logarithmic": "对数",
      "s_curve": "S形曲线",
      "select_option": "选择选项",
      "no_options_found": "未找到选项",
      "error_loading_options": "加载选项错误。",
      "pad_modes_button": "模式",
      "pad_modes_button_title": "打击垫模式",
      "pad_modes_panel_title": "打击垫模式",
      "pad_mode_label": "打击垫模式",
      "pad_mode_select_title": "选择打击垫模式",
      "pad_mode_classic": "经典",
      "pad_mode_reactive": "反应",
      "reactive_mode_show_suggestions": "显示和声提示",
      "reactive_mode_suggestion_count": "提示数量",
      "no_specific_settings_classic": "经典模式无特定设置。",
      "no_specific_settings_reactive": "配置反应模式提示。",
      "pad_mode_rocket": "火箭",
      "rocket_highlight_active": "高亮活动音符",
      "rocket_show_markers": "显示方向标记",
      "rocket_marker_style": "标记样式",
      "rocket_valid_chords_only": "仅对有效和弦显示标记",
      "rocket_animate_fade": "动画标记淡出",
      "rocket_show_chord_name": "显示识别的和弦名称",
      "style_GlowFromNote": "音符发光",
      "style_WaveToNote": "波形至音符",
      "style_PulseRing": "脉冲环",
      "style_SparkTrail": "火花轨迹",
      "style_ShadowDrop": "音符下阴影",
      "rocket_mode_panel_title": "火箭模式",
      "rocket_mode_enable": "启用火箭模式",
      "rocket_mode_settings_placeholder": "火箭模式设置将显示在此处。",
      "error_loading_mode_settings": "加载模式设置错误。",
      "no_specific_settings_rocket": "配置火箭模式特定设置。",
      "reset_settings_button": "重置所有设置",
      "reload_app_button": "完全重载应用",
      "restart_audio_button": "重启音频引擎",
      "rocket_section_general": "通用",
      "rocket_section_phases": "阶段",
      "rocket_section_harmonic_logic": "和声逻辑",
      "rocket_section_interactive_behavior": "交互行为",
      "rocket_intensity": "强度",
      "rocket_visual_theme": "视觉主题",
      "rocket_auto_phases": "自动阶段",
      "rocket_harmonic_key": "和声调",
      "rocket_marker_logic": "标记逻辑",
      "marker_logic_tonal": "调性绑定",
      "marker_logic_adaptive": "自适应分析",
      "marker_logic_semi_free": "半自由",
      "marker_logic_random": "随机定向",
      "rocket_phase_ignition": "点火",
      "rocket_phase_lift_off": "升空",
      "rocket_phase_burst": "爆发",
      "rocket_phase_transition": "阶段转换",
      "phase_mode_activity": "按活动",
      "phase_mode_time": "按时间",
      "phase_mode_manual": "手动",
      "status_chord": "和弦",
      "status_key": "调性",
      "status_next": "下一个",
      "status_energy": "能量",
      "status_phase": "阶段",
      "status_na": "无",
      "rocket_presets_title": "模式预设",
      "rocket_select_preset": "选择预设",
      "rocket_select_preset_title": "选择火箭模式预设",
      "rocket_preset_current": "当前设置",
      "none_selected": "无",
      "preset_rocket_melodic_drift": "旋律漂移",
      "desc_rocket_melodic_drift": "温柔、漂浮、半自由的和声逻辑。",
      "preset_rocket_jazz_climb": "爵士攀升",
      "desc_rocket_jazz_climb": "活跃、自适应、爵士风格的逻辑。",
      "rocket_marker_labels": "标记标签",
      "labels_none": "无",
      "labels_function": "功能 (T/S/D)",
      "labels_chord_name": "和弦名称",
      "rocket_marker_retention": "标记保留",
      "desc_rocket_marker_retention": "在新触摸期间保持相关标记可见。",
      "desc_rocket_animate_fade": "平滑淡出不相关的标记。",
      "rocket_fade_delay": "淡出延迟",
      "desc_rocket_fade_delay": "标记开始淡出前的延迟。",
      "rocket_fade_duration": "淡出时长",
      "desc_rocket_fade_duration": "标记淡出动画的持续时间。",
      "rocket_max_markers_zone": "最大标记/区域",
      "desc_rocket_max_markers_zone": "每个区域显示的最大建议数。",
      "rocket_phase_styles": "阶段样式",
      "desc_rocket_phase_styles": "允许当前阶段覆盖标记样式。",
      "rocket_tb_in_key": "调性绑定：仅在调内",
      "desc_rocket_tb_in_key": "仅建议当前调内的音符/和弦。",
      "rocket_aa_autokey": "自适应分析：自动换调",
      "desc_rocket_aa_autokey": "允许根据输入自适应更改调性。",
      "rocket_sf_basekey": "半自由：基础调性",
      "desc_rocket_sf_basekey": "半自由模式的基础调性。",
      "rocket_sf_deviations": "半自由：模态偏差",
      "desc_rocket_sf_deviations": "允许临时偏离基础调性。",
      "rocket_sf_return": "半自由：高亮返回",
      "desc_rocket_sf_return": "高亮显示返回基础调性的建议。",
      "rocket_rd_randomlevel": "随机级别",
      "desc_rocket_rd_randomlevel": "建议中的随机性级别。",
      "select_chord": "选择和弦",
      "select_key": "选择调性",
      "select_phase": "选择阶段",
      "no_language_found": "未找到语言",
      "no_theme_found": "未找到主题",
      "no_visualizer_found": "未找到可视化工具",
      "no_touchEffect_found": "未找到触摸效果",
      "no_scale_found": "未找到音阶",
      "no_fxChain_found": "未找到效果链",
      "error_audio_fatal_restart": "严重音频错误。请重启应用。",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_preset": "保存新音色",
      "delete_preset": "删除音色",
      "synth_controls": "合成器控制",
      "synth_type": "合成器类型",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "振荡器类型",
      "sine": "正弦波",
      "square": "方波",
      "sawtooth": "锯齿波",
      "triangle": "三角波",
      "fat_sine": "Fat 正弦波",
      "fat_square": "Fat 方波",
      "fat_sawtooth": "Fat 锯齿波",
      "fat_triangle": "Fat 三角波",
      "fm_sine": "FM 正弦波",
      "fm_square": "FM 方波",
      "fm_sawtooth": "FM 锯齿波",
      "fm_triangle": "FM 三角波",
      "am_sine": "AM 正弦波",
      "am_square": "AM 方波",
      "am_sawtooth": "AM 锯齿波",
      "am_triangle": "AM 三角波",
      "pwm": "PWM",
      "pulse": "脉冲波",
      "noise_white": "白噪音",
      "noise_pink": "粉红噪音",
      "noise_brown": "布朗噪音",
      "oscillator_params": "振荡器参数",
      "phase": "相位",
      "count": "数量",
      "spread": "扩展度",
      "width": "宽度",
      "mod_freq_short": "调制频率",
      "harmonicity": "谐波性",
      "mod_index": "调制指数",
      "mod_type": "调制类型",
      "noise_type": "噪音类型",
      "envelope": "包络",
      "attack": "起音",
      "sustain": "持续",
      "release": "释音",
      "envelope_curves": "包络曲线",
      "attack_curve": "起音",
      "decay_curve": "衰减",
      "release_curve": "释音",
      "filter_advanced": "高级滤波器",
      "filter_rolloff": "滚降",
      "filter_gain": "增益 (dB)",
      "filter_envelope": "滤波器包络",
      "base_frequency": "基频",
      "exponent": "指数",
      "modulation": "调制",
      "modulation_envelope": "调制包络",
      "special_parameters": "特殊参数",
      "pitch_decay": "音高衰减",
      "attack_noise": "起音噪音",
      "dampening": "阻尼",
      "resonance": "共振",
      "lfo": "LFO",
      "lfo_type": "类型",
      "lfo_target": "目标",
      "lfo_min": "最小",
      "lfo_max": "最大",
      "save_preset_title": "保存音色预设",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_fx_chain_title": "保存效果链",
      "fx_chain_name_label": "效果链名称:",
      "fx_chain_name_placeholder": "我的效果链",
      "cancel": "取消",
      "save": "保存",
      "major": "大调",
      "minor": "小调",
      "pentatonic": "五声音阶",
      "blues": "布鲁斯",
      "chromatic": "半音阶",
      "dorian": "多利亚",
      "phrygian": "弗里几亚",
      "lydian": "利底亚",
      "mixolydian": "混合利底亚",
      "locrian": "洛克里亚",
      "day": "日间",
      "night": "夜间",
      "neon": "霓虹",
      "retro": "复古",
      "pastel": "粉彩",
      "aurora": "极光",
      "ocean": "海洋",
      "cyberpunk": "赛博朋克",
      "fire": "火焰",
      "matrix": "矩阵",
      "hologram": "全息图",
      "crystal": "水晶",
      "galaxy": "银河",
      "waves": "波形",
      "spectrum": "频谱",
      "particles": "鱼群",
      "nebula": "星云",
      "reactive_ripples": "反应涟漪",
      "touch_trails": "触摸轨迹",
      "loading": "加载中...",
      "initializing": "初始化中...",
      "loading_bridge": "连接中...",
      "loading_settings": "加载设置...",
      "loading_modules": "加载模块...",
      "loading_ui": "初始化UI...",
      "loading_presets": "应用设置...",
      "loading_audio": "加载声音...",
      "tap_to_start": "点击以启动音频",
      "starting_audio": "启动音频中...",
      "audio_suspended": "音频已暂停。点击以恢复。",
      "loading_preset": "加载预设...",
      "loading_fxchain": "加载效果链...",
      "saving_preset_progress": "保存预设中...",
      "saving_fxchain_progress": "保存效果链中...",
      "deleting_preset_progress": "删除预设中...",
      "deleting_fxchain_progress": "删除效果链中...",
      "hit_play_vibe": "点击播放，感受律动",
      "error_bridge_failed": "错误：桥接连接失败。",
      "error_init_failed": "初始化错误。请检查控制台。",
      "error_init_failed_details": "初始化错误: ${error}。请检查控制台。",
      "error_fatal_init": "严重初始化错误。请重启。",
      "error_audio_failed_retry": "启动音频错误。请再次点击。",
      "error_audio_resume": "无法恢复音频。",
      "error_apply_preset": "应用预设错误。",
      "error_apply_fxchain": "应用效果链错误。",
      "error_loading_presets": "加载预设错误。",
      "error_loading_fxchains": "加载效果链错误",
      "error_loading_effects_ui": "加载效果UI错误。",
      "no_presets_found": "未找到预设。",
      "no_fxchains_found": "未找到效果链",
      "no_effects_available": "无可用效果。",
      "enter_preset_name": "请输入预设名称。",
      "enter_fxchain_name": "请输入效果链名称。",
      "preset_saved_success": "预设 \"${name}\" 保存成功！",
      "fxchain_saved_success": "效果链 \"${name}\" 保存成功！",
      "error_saving_preset": "保存预设错误: ${error}",
      "error_saving_fxchain": "保存效果链错误: ${error}",
      "exception_saving_preset": "保存预设异常: ${error}",
      "exception_saving_fxchain": "保存效果链异常: ${error}",
      "confirm_delete_preset": "确定删除预设 \"${name}\" 吗？",
      "confirm_delete_fxchain": "确定删除效果链 \"${name}\" 吗？",
      "cannot_delete_default_preset": "无法删除默认预设。",
      "cannot_delete_default_fxchain": "无法删除默认效果链。",
      "preset_deleted_success": "预设已删除。",
      "fxchain_deleted_success": "效果链已删除。",
      "preset_delete_failed": "删除预设失败。",
      "fxchain_delete_failed": "删除效果链失败。",
      "exception_deleting_preset": "删除预设异常: ${error}",
      "exception_deleting_fxchain": "删除效果链异常: ${error}",
      "audio_not_ready_record": "音频未准备好。无法开始录制。",
      "pitch_envelope": "音高包络",
      "pitch_amount_cents": "量 (音分)",
      "macro_controls_title": "宏控制",
      "macro_space": "空间",
      "macro_time": "时间",
      "macro_motion": "动态",
      "macro_tone": "音色",
      "macro_drive": "驱动",
      "effects_intensity_min": "FX强度最小 (dB)",
      "effects_intensity_max": "FX强度最大 (dB)",
      "effects_threshold": "FX阈值",
      "none_fxchain": "-- 无 --",
      "none_touch_effect": "无",
      "restart_audio_engine_button": "重启音频",
      "reload_app_button_title": "重载应用",
      "reloading_app_message": "重新加载应用程序...",
      "master_output_title": "主输出",
      "master_volume_ceiling": "音量上限",
      "master_volume_ceiling_label": "音量上限",
      "y_axis_volume_min_output": "最小输出",
      "y_axis_volume_max_output": "最大输出",
      "y_axis_volume_y_threshold": "Y轴阈值",
      "y_axis_curve_type": "曲线类型",
      "y_axis_curve_factor": "曲线因子",
      "y_axis_effects_min_output": "最小输出 (dB)",
      "y_axis_effects_max_output": "最大输出 (dB)",
      "y_axis_effects_y_threshold": "Y轴阈值",
      "logarithmic": "对数",
      "s_curve": "S形曲线",
      "select_option": "选择选项",
      "no_options_found": "未找到选项",
      "error_loading_options": "加载选项错误。",
      "pad_modes_button": "模式",
      "pad_modes_button_title": "打击垫模式",
      "pad_modes_panel_title": "打击垫模式",
      "pad_mode_label": "打击垫模式",
      "pad_mode_select_title": "选择打击垫模式",
      "pad_mode_classic": "经典",
      "pad_mode_reactive": "反应",
      "reactive_mode_show_suggestions": "显示和声提示",
      "reactive_mode_suggestion_count": "提示数量",
      "no_specific_settings_classic": "经典模式无特定设置。",
      "no_specific_settings_reactive": "配置反应模式提示。",
      "pad_mode_rocket": "火箭",
      "rocket_highlight_active": "高亮活动音符",
      "rocket_show_markers": "显示方向标记",
      "rocket_marker_style": "标记样式",
      "rocket_valid_chords_only": "仅对有效和弦显示标记",
      "rocket_animate_fade": "动画标记淡出",
      "rocket_show_chord_name": "显示识别的和弦名称",
      "style_GlowFromNote": "音符发光",
      "style_WaveToNote": "波形至音符",
      "style_PulseRing": "脉冲环",
      "style_SparkTrail": "火花轨迹",
      "style_ShadowDrop": "音符下阴影",
      "rocket_mode_panel_title": "火箭模式",
      "rocket_mode_enable": "启用火箭模式",
      "rocket_mode_settings_placeholder": "火箭模式设置将显示在此处。",
      "error_loading_mode_settings": "加载模式设置错误。",
      "no_specific_settings_rocket": "配置火箭模式特定设置。",
      "reset_settings_button": "重置所有设置",
      "reload_app_button": "完全重载应用",
      "restart_audio_button": "重启音频引擎",
      "rocket_section_general": "通用",
      "rocket_section_phases": "阶段",
      "rocket_section_harmonic_logic": "和声逻辑",
      "rocket_section_interactive_behavior": "交互行为",
      "rocket_intensity": "强度",
      "rocket_visual_theme": "视觉主题",
      "rocket_auto_phases": "自动阶段",
      "rocket_harmonic_key": "和声调",
      "rocket_marker_logic": "标记逻辑",
      "marker_logic_tonal": "调性绑定",
      "marker_logic_adaptive": "自适应分析",
      "marker_logic_semi_free": "半自由",
      "marker_logic_random": "随机定向",
      "rocket_phase_ignition": "点火",
      "rocket_phase_lift_off": "升空",
      "rocket_phase_burst": "爆发",
      "rocket_phase_transition": "阶段转换",
      "phase_mode_activity": "按活动",
      "phase_mode_time": "按时间",
      "phase_mode_manual": "手动",
      "status_chord": "和弦",
      "status_key": "调性",
      "status_next": "下一个",
      "status_energy": "能量",
      "status_phase": "阶段",
      "status_na": "无",
      "rocket_presets_title": "模式预设",
      "rocket_select_preset": "选择预设",
      "rocket_select_preset_title": "选择火箭模式预设",
      "rocket_preset_current": "当前设置",
      "none_selected": "无",
      "preset_rocket_melodic_drift": "旋律漂移",
      "desc_rocket_melodic_drift": "温柔、漂浮、半自由的和声逻辑。",
      "preset_rocket_jazz_climb": "爵士攀升",
      "desc_rocket_jazz_climb": "活跃、自适应、爵士风格的逻辑。",
      "rocket_marker_labels": "标记标签",
      "labels_none": "无",
      "labels_function": "功能 (T/S/D)",
      "labels_chord_name": "和弦名称",
      "rocket_marker_retention": "标记保留",
      "desc_rocket_marker_retention": "在新触摸期间保持相关标记可见。",
      "desc_rocket_animate_fade": "平滑淡出不相关的标记。",
      "rocket_fade_delay": "淡出延迟",
      "desc_rocket_fade_delay": "标记开始淡出前的延迟。",
      "rocket_fade_duration": "淡出时长",
      "desc_rocket_fade_duration": "标记淡出动画的持续时间。",
      "rocket_max_markers_zone": "最大标记/区域",
      "desc_rocket_max_markers_zone": "每个区域显示的最大建议数。",
      "rocket_phase_styles": "阶段样式",
      "desc_rocket_phase_styles": "允许当前阶段覆盖标记样式。",
      "rocket_tb_in_key": "调性绑定：仅在调内",
      "desc_rocket_tb_in_key": "仅建议当前调内的音符/和弦。",
      "rocket_aa_autokey": "自适应分析：自动换调",
      "desc_rocket_aa_autokey": "允许根据输入自适应更改调性。",
      "rocket_sf_basekey": "半自由：基础调性",
      "desc_rocket_sf_basekey": "半自由模式的基础调性。",
      "rocket_sf_deviations": "半自由：模态偏差",
      "desc_rocket_sf_deviations": "允许临时偏离基础调性。",
      "rocket_sf_return": "半自由：高亮返回",
      "desc_rocket_sf_return": "高亮显示返回基础调性的建议。",
      "rocket_rd_randomlevel": "随机级别",
      "desc_rocket_rd_randomlevel": "建议中的随机性级别。",
      "select_chord": "选择和弦",
      "select_key": "选择调性",
      "select_phase": "选择阶段",
      "no_language_found": "未找到语言",
      "no_theme_found": "未找到主题",
      "no_visualizer_found": "未找到可视化工具",
      "no_touchEffect_found": "未找到触摸效果",
      "no_scale_found": "未找到音阶",
      "no_fxChain_found": "未找到效果链",
      "error_audio_fatal_restart": "严重音频错误。请重启应用。",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_preset": "保存新音色",
      "delete_preset": "删除音色",
      "synth_controls": "合成器控制",
      "synth_type": "合成器类型",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "振荡器类型",
      "sine": "正弦波",
      "square": "方波",
      "sawtooth": "锯齿波",
      "triangle": "三角波",
      "fat_sine": "Fat 正弦波",
      "fat_square": "Fat 方波",
      "fat_sawtooth": "Fat 锯齿波",
      "fat_triangle": "Fat 三角波",
      "fm_sine": "FM 正弦波",
      "fm_square": "FM 方波",
      "fm_sawtooth": "FM 锯齿波",
      "fm_triangle": "FM 三角波",
      "am_sine": "AM 正弦波",
      "am_square": "AM 方波",
      "am_sawtooth": "AM 锯齿波",
      "am_triangle": "AM 三角波",
      "pwm": "PWM",
      "pulse": "脉冲波",
      "noise_white": "白噪音",
      "noise_pink": "粉红噪音",
      "noise_brown": "布朗噪音",
      "oscillator_params": "振荡器参数",
      "phase": "相位",
      "count": "数量",
      "spread": "扩展度",
      "width": "宽度",
      "mod_freq_short": "调制频率",
      "harmonicity": "谐波性",
      "mod_index": "调制指数",
      "mod_type": "调制类型",
      "noise_type": "噪音类型",
      "envelope": "包络",
      "attack": "起音",
      "sustain": "持续",
      "release": "释音",
      "envelope_curves": "包络曲线",
      "attack_curve": "起音",
      "decay_curve": "衰减",
      "release_curve": "释音",
      "filter_advanced": "高级滤波器",
      "filter_rolloff": "滚降",
      "filter_gain": "增益 (dB)",
      "filter_envelope": "滤波器包络",
      "base_frequency": "基频",
      "exponent": "指数",
      "modulation": "调制",
      "modulation_envelope": "调制包络",
      "special_parameters": "特殊参数",
      "pitch_decay": "音高衰减",
      "attack_noise": "起音噪音",
      "dampening": "阻尼",
      "resonance": "共振",
      "lfo": "LFO",
      "lfo_type": "类型",
      "lfo_target": "目标",
      "lfo_min": "最小",
      "lfo_max": "最大",
      "save_preset_title": "保存音色预设",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_fx_chain_title": "保存效果链",
      "fx_chain_name_label": "效果链名称:",
      "fx_chain_name_placeholder": "我的效果链",
      "cancel": "取消",
      "save": "保存",
      "major": "大调",
      "minor": "小调",
      "pentatonic": "五声音阶",
      "blues": "布鲁斯",
      "chromatic": "半音阶",
      "dorian": "多利亚",
      "phrygian": "弗里几亚",
      "lydian": "利底亚",
      "mixolydian": "混合利底亚",
      "locrian": "洛克里亚",
      "day": "日间",
      "night": "夜间",
      "neon": "霓虹",
      "retro": "复古",
      "pastel": "粉彩",
      "aurora": "极光",
      "ocean": "海洋",
      "cyberpunk": "赛博朋克",
      "fire": "火焰",
      "matrix": "矩阵",
      "hologram": "全息图",
      "crystal": "水晶",
      "galaxy": "银河",
      "waves": "波形",
      "spectrum": "频谱",
      "particles": "鱼群",
      "nebula": "星云",
      "reactive_ripples": "反应涟漪",
      "touch_trails": "触摸轨迹",
      "loading": "加载中...",
      "initializing": "初始化中...",
      "loading_bridge": "连接中...",
      "loading_settings": "加载设置...",
      "loading_modules": "加载模块...",
      "loading_ui": "初始化UI...",
      "loading_presets": "应用设置...",
      "loading_audio": "加载声音...",
      "tap_to_start": "点击以启动音频",
      "starting_audio": "启动音频中...",
      "audio_suspended": "音频已暂停。点击以恢复。",
      "loading_preset": "加载预设...",
      "loading_fxchain": "加载效果链...",
      "saving_preset_progress": "保存预设中...",
      "saving_fxchain_progress": "保存效果链中...",
      "deleting_preset_progress": "删除预设中...",
      "deleting_fxchain_progress": "删除效果链中...",
      "hit_play_vibe": "点击播放，感受律动",
      "error_bridge_failed": "错误：桥接连接失败。",
      "error_init_failed": "初始化错误。请检查控制台。",
      "error_init_failed_details": "初始化错误: ${error}。请检查控制台。",
      "error_fatal_init": "严重初始化错误。请重启。",
      "error_audio_failed_retry": "启动音频错误。请再次点击。",
      "error_audio_resume": "无法恢复音频。",
      "error_apply_preset": "应用预设错误。",
      "error_apply_fxchain": "应用效果链错误。",
      "error_loading_presets": "加载预设错误。",
      "error_loading_fxchains": "加载效果链错误",
      "error_loading_effects_ui": "加载效果UI错误。",
      "no_presets_found": "未找到预设。",
      "no_fxchains_found": "未找到效果链",
      "no_effects_available": "无可用效果。",
      "enter_preset_name": "请输入预设名称。",
      "enter_fxchain_name": "请输入效果链名称。",
      "preset_saved_success": "预设 \"${name}\" 保存成功！",
      "fxchain_saved_success": "效果链 \"${name}\" 保存成功！",
      "error_saving_preset": "保存预设错误: ${error}",
      "error_saving_fxchain": "保存效果链错误: ${error}",
      "exception_saving_preset": "保存预设异常: ${error}",
      "exception_saving_fxchain": "保存效果链异常: ${error}",
      "confirm_delete_preset": "确定删除预设 \"${name}\" 吗？",
      "confirm_delete_fxchain": "确定删除效果链 \"${name}\" 吗？",
      "cannot_delete_default_preset": "无法删除默认预设。",
      "cannot_delete_default_fxchain": "无法删除默认效果链。",
      "preset_deleted_success": "预设已删除。",
      "fxchain_deleted_success": "效果链已删除。",
      "preset_delete_failed": "删除预设失败。",
      "fxchain_delete_failed": "删除效果链失败。",
      "exception_deleting_preset": "删除预设异常: ${error}",
      "exception_deleting_fxchain": "删除效果链异常: ${error}",
      "audio_not_ready_record": "音频未准备好。无法开始录制。",
      "pitch_envelope": "音高包络",
      "pitch_amount_cents": "量 (音分)",
      "macro_controls_title": "宏控制",
      "macro_space": "空间",
      "macro_time": "时间",
      "macro_motion": "动态",
      "macro_tone": "音色",
      "macro_drive": "驱动",
      "effects_intensity_min": "FX强度最小 (dB)",
      "effects_intensity_max": "FX强度最大 (dB)",
      "effects_threshold": "FX阈值",
      "none_fxchain": "-- 无 --",
      "none_touch_effect": "无",
      "restart_audio_engine_button": "重启音频",
      "reload_app_button_title": "重载应用",
      "reloading_app_message": "重新加载应用程序...",
      "master_output_title": "主输出",
      "master_volume_ceiling": "音量上限",
      "master_volume_ceiling_label": "音量上限",
      "y_axis_volume_min_output": "最小输出",
      "y_axis_volume_max_output": "最大输出",
      "y_axis_volume_y_threshold": "Y轴阈值",
      "y_axis_curve_type": "曲线类型",
      "y_axis_curve_factor": "曲线因子",
      "y_axis_effects_min_output": "最小输出 (dB)",
      "y_axis_effects_max_output": "最大输出 (dB)",
      "y_axis_effects_y_threshold": "Y轴阈值",
      "logarithmic": "对数",
      "s_curve": "S形曲线",
      "select_option": "选择选项",
      "no_options_found": "未找到选项",
      "error_loading_options": "加载选项错误。",
      "pad_modes_button": "模式",
      "pad_modes_button_title": "打击垫模式",
      "pad_modes_panel_title": "打击垫模式",
      "pad_mode_label": "打击垫模式",
      "pad_mode_select_title": "选择打击垫模式",
      "pad_mode_classic": "经典",
      "pad_mode_reactive": "反应",
      "reactive_mode_show_suggestions": "显示和声提示",
      "reactive_mode_suggestion_count": "提示数量",
      "no_specific_settings_classic": "经典模式无特定设置。",
      "no_specific_settings_reactive": "配置反应模式提示。",
      "pad_mode_rocket": "火箭",
      "rocket_highlight_active": "高亮活动音符",
      "rocket_show_markers": "显示方向标记",
      "rocket_marker_style": "标记样式",
      "rocket_valid_chords_only": "仅对有效和弦显示标记",
      "rocket_animate_fade": "动画标记淡出",
      "rocket_show_chord_name": "显示识别的和弦名称",
      "style_GlowFromNote": "音符发光",
      "style_WaveToNote": "波形至音符",
      "style_PulseRing": "脉冲环",
      "style_SparkTrail": "火花轨迹",
      "style_ShadowDrop": "音符下阴影",
      "rocket_mode_panel_title": "火箭模式",
      "rocket_mode_enable": "启用火箭模式",
      "rocket_mode_settings_placeholder": "火箭模式设置将显示在此处。",
      "error_loading_mode_settings": "加载模式设置错误。",
      "no_specific_settings_rocket": "配置火箭模式特定设置。",
      "reset_settings_button": "重置所有设置",
      "reload_app_button": "完全重载应用",
      "restart_audio_button": "重启音频引擎",
      "rocket_section_general": "通用",
      "rocket_section_phases": "阶段",
      "rocket_section_harmonic_logic": "和声逻辑",
      "rocket_section_interactive_behavior": "交互行为",
      "rocket_intensity": "强度",
      "rocket_visual_theme": "视觉主题",
      "rocket_auto_phases": "自动阶段",
      "rocket_harmonic_key": "和声调",
      "rocket_marker_logic": "标记逻辑",
      "marker_logic_tonal": "调性绑定",
      "marker_logic_adaptive": "自适应分析",
      "marker_logic_semi_free": "半自由",
      "marker_logic_random": "随机定向",
      "rocket_phase_ignition": "点火",
      "rocket_phase_lift_off": "升空",
      "rocket_phase_burst": "爆发",
      "rocket_phase_transition": "阶段转换",
      "phase_mode_activity": "按活动",
      "phase_mode_time": "按时间",
      "phase_mode_manual": "手动",
      "status_chord": "和弦",
      "status_key": "调性",
      "status_next": "下一个",
      "status_energy": "能量",
      "status_phase": "阶段",
      "status_na": "无",
      "rocket_presets_title": "模式预设",
      "rocket_select_preset": "选择预设",
      "rocket_select_preset_title": "选择火箭模式预设",
      "rocket_preset_current": "当前设置",
      "none_selected": "无",
      "preset_rocket_melodic_drift": "旋律漂移",
      "desc_rocket_melodic_drift": "温柔、漂浮、半自由的和声逻辑。",
      "preset_rocket_jazz_climb": "爵士攀升",
      "desc_rocket_jazz_climb": "活跃、自适应、爵士风格的逻辑。",
      "rocket_marker_labels": "标记标签",
      "labels_none": "无",
      "labels_function": "功能 (T/S/D)",
      "labels_chord_name": "和弦名称",
      "rocket_marker_retention": "标记保留",
      "desc_rocket_marker_retention": "在新触摸期间保持相关标记可见。",
      "desc_rocket_animate_fade": "平滑淡出不相关的标记。",
      "rocket_fade_delay": "淡出延迟",
      "desc_rocket_fade_delay": "标记开始淡出前的延迟。",
      "rocket_fade_duration": "淡出时长",
      "desc_rocket_fade_duration": "标记淡出动画的持续时间。",
      "rocket_max_markers_zone": "最大标记/区域",
      "desc_rocket_max_markers_zone": "每个区域显示的最大建议数。",
      "rocket_phase_styles": "阶段样式",
      "desc_rocket_phase_styles": "允许当前阶段覆盖标记样式。",
      "rocket_tb_in_key": "调性绑定：仅在调内",
      "desc_rocket_tb_in_key": "仅建议当前调内的音符/和弦。",
      "rocket_aa_autokey": "自适应分析：自动换调",
      "desc_rocket_aa_autokey": "允许根据输入自适应更改调性。",
      "rocket_sf_basekey": "半自由：基础调性",
      "desc_rocket_sf_basekey": "半自由模式的基础调性。",
      "rocket_sf_deviations": "半自由：模态偏差",
      "desc_rocket_sf_deviations": "允许临时偏离基础调性。",
      "rocket_sf_return": "半自由：高亮返回",
      "desc_rocket_sf_return": "高亮显示返回基础调性的建议。",
      "rocket_rd_randomlevel": "随机级别",
      "desc_rocket_rd_randomlevel": "建议中的随机性级别。",
      "select_chord": "选择和弦",
      "select_key": "选择调性",
      "select_phase": "选择阶段",
      "no_language_found": "未找到语言",
      "no_theme_found": "未找到主题",
      "no_visualizer_found": "未找到可视化工具",
      "no_touchEffect_found": "未找到触摸效果",
      "no_scale_found": "未找到音阶",
      "no_fxChain_found": "未找到效果链",
      "error_audio_fatal_restart": "严重音频错误。请重启应用。",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_preset": "保存新音色",
      "delete_preset": "删除音色",
      "synth_controls": "合成器控制",
      "synth_type": "合成器类型",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "振荡器类型",
      "sine": "正弦波",
      "square": "方波",
      "sawtooth": "锯齿波",
      "triangle": "三角波",
      "fat_sine": "Fat 正弦波",
      "fat_square": "Fat 方波",
      "fat_sawtooth": "Fat 锯齿波",
      "fat_triangle": "Fat 三角波",
      "fm_sine": "FM 正弦波",
      "fm_square": "FM 方波",
      "fm_sawtooth": "FM 锯齿波",
      "fm_triangle": "FM 三角波",
      "am_sine": "AM 正弦波",
      "am_square": "AM 方波",
      "am_sawtooth": "AM 锯齿波",
      "am_triangle": "AM 三角波",
      "pwm": "PWM",
      "pulse": "脉冲波",
      "noise_white": "白噪音",
      "noise_pink": "粉红噪音",
      "noise_brown": "布朗噪音",
      "oscillator_params": "振荡器参数",
      "phase": "相位",
      "count": "数量",
      "spread": "扩展度",
      "width": "宽度",
      "mod_freq_short": "调制频率",
      "harmonicity": "谐波性",
      "mod_index": "调制指数",
      "mod_type": "调制类型",
      "noise_type": "噪音类型",
      "envelope": "包络",
      "attack": "起音",
      "sustain": "持续",
      "release": "释音",
      "envelope_curves": "包络曲线",
      "attack_curve": "起音",
      "decay_curve": "衰减",
      "release_curve": "释音",
      "filter_advanced": "高级滤波器",
      "filter_rolloff": "滚降",
      "filter_gain": "增益 (dB)",
      "filter_envelope": "滤波器包络",
      "base_frequency": "基频",
      "exponent": "指数",
      "modulation": "调制",
      "modulation_envelope": "调制包络",
      "special_parameters": "特殊参数",
      "pitch_decay": "音高衰减",
      "attack_noise": "起音噪音",
      "dampening": "阻尼",
      "resonance": "共振",
      "lfo": "LFO",
      "lfo_type": "类型",
      "lfo_target": "目标",
      "lfo_min": "最小",
      "lfo_max": "最大",
      "save_preset_title": "保存音色预设",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_fx_chain_title": "保存效果链",
      "fx_chain_name_label": "效果链名称:",
      "fx_chain_name_placeholder": "我的效果链",
      "cancel": "取消",
      "save": "保存",
      "major": "大调",
      "minor": "小调",
      "pentatonic": "五声音阶",
      "blues": "布鲁斯",
      "chromatic": "半音阶",
      "dorian": "多利亚",
      "phrygian": "弗里几亚",
      "lydian": "利底亚",
      "mixolydian": "混合利底亚",
      "locrian": "洛克里亚",
      "day": "日间",
      "night": "夜间",
      "neon": "霓虹",
      "retro": "复古",
      "pastel": "粉彩",
      "aurora": "极光",
      "ocean": "海洋",
      "cyberpunk": "赛博朋克",
      "fire": "火焰",
      "matrix": "矩阵",
      "hologram": "全息图",
      "crystal": "水晶",
      "galaxy": "银河",
      "waves": "波形",
      "spectrum": "频谱",
      "particles": "鱼群",
      "nebula": "星云",
      "reactive_ripples": "反应涟漪",
      "touch_trails": "触摸轨迹",
      "loading": "加载中...",
      "initializing": "初始化中...",
      "loading_bridge": "连接中...",
      "loading_settings": "加载设置...",
      "loading_modules": "加载模块...",
      "loading_ui": "初始化UI...",
      "loading_presets": "应用设置...",
      "loading_audio": "加载声音...",
      "tap_to_start": "点击以启动音频",
      "starting_audio": "启动音频中...",
      "audio_suspended": "音频已暂停。点击以恢复。",
      "loading_preset": "加载预设...",
      "loading_fxchain": "加载效果链...",
      "saving_preset_progress": "保存预设中...",
      "saving_fxchain_progress": "保存效果链中...",
      "deleting_preset_progress": "删除预设中...",
      "deleting_fxchain_progress": "删除效果链中...",
      "hit_play_vibe": "点击播放，感受律动",
      "error_bridge_failed": "错误：桥接连接失败。",
      "error_init_failed": "初始化错误。请检查控制台。",
      "error_init_failed_details": "初始化错误: ${error}。请检查控制台。",
      "error_fatal_init": "严重初始化错误。请重启。",
      "error_audio_failed_retry": "启动音频错误。请再次点击。",
      "error_audio_resume": "无法恢复音频。",
      "error_apply_preset": "应用预设错误。",
      "error_apply_fxchain": "应用效果链错误。",
      "error_loading_presets": "加载预设错误。",
      "error_loading_fxchains": "加载效果链错误",
      "error_loading_effects_ui": "加载效果UI错误。",
      "no_presets_found": "未找到预设。",
      "no_fxchains_found": "未找到效果链",
      "no_effects_available": "无可用效果。",
      "enter_preset_name": "请输入预设名称。",
      "enter_fxchain_name": "请输入效果链名称。",
      "preset_saved_success": "预设 \"${name}\" 保存成功！",
      "fxchain_saved_success": "效果链 \"${name}\" 保存成功！",
      "error_saving_preset": "保存预设错误: ${error}",
      "error_saving_fxchain": "保存效果链错误: ${error}",
      "exception_saving_preset": "保存预设异常: ${error}",
      "exception_saving_fxchain": "保存效果链异常: ${error}",
      "confirm_delete_preset": "确定删除预设 \"${name}\" 吗？",
      "confirm_delete_fxchain": "确定删除效果链 \"${name}\" 吗？",
      "cannot_delete_default_preset": "无法删除默认预设。",
      "cannot_delete_default_fxchain": "无法删除默认效果链。",
      "preset_deleted_success": "预设已删除。",
      "fxchain_deleted_success": "效果链已删除。",
      "preset_delete_failed": "删除预设失败。",
      "fxchain_delete_failed": "删除效果链失败。",
      "exception_deleting_preset": "删除预设异常: ${error}",
      "exception_deleting_fxchain": "删除效果链异常: ${error}",
      "audio_not_ready_record": "音频未准备好。无法开始录制。",
      "pitch_envelope": "音高包络",
      "pitch_amount_cents": "量 (音分)",
      "macro_controls_title": "宏控制",
      "macro_space": "空间",
      "macro_time": "时间",
      "macro_motion": "动态",
      "macro_tone": "音色",
      "macro_drive": "驱动",
      "effects_intensity_min": "FX强度最小 (dB)",
      "effects_intensity_max": "FX强度最大 (dB)",
      "effects_threshold": "FX阈值",
      "none_fxchain": "-- 无 --",
      "none_touch_effect": "无",
      "restart_audio_engine_button": "重启音频",
      "reload_app_button_title": "重载应用",
      "reloading_app_message": "重新加载应用程序...",
      "master_output_title": "主输出",
      "master_volume_ceiling": "音量上限",
      "master_volume_ceiling_label": "音量上限",
      "y_axis_volume_min_output": "最小输出",
      "y_axis_volume_max_output": "最大输出",
      "y_axis_volume_y_threshold": "Y轴阈值",
      "y_axis_curve_type": "曲线类型",
      "y_axis_curve_factor": "曲线因子",
      "y_axis_effects_min_output": "最小输出 (dB)",
      "y_axis_effects_max_output": "最大输出 (dB)",
      "y_axis_effects_y_threshold": "Y轴阈值",
      "logarithmic": "对数",
      "s_curve": "S形曲线",
      "select_option": "选择选项",
      "no_options_found": "未找到选项",
      "error_loading_options": "加载选项错误。",
      "pad_modes_button": "模式",
      "pad_modes_button_title": "打击垫模式",
      "pad_modes_panel_title": "打击垫模式",
      "pad_mode_label": "打击垫模式",
      "pad_mode_select_title": "选择打击垫模式",
      "pad_mode_classic": "经典",
      "pad_mode_reactive": "反应",
      "reactive_mode_show_suggestions": "显示和声提示",
      "reactive_mode_suggestion_count": "提示数量",
      "no_specific_settings_classic": "经典模式无特定设置。",
      "no_specific_settings_reactive": "配置反应模式提示。",
      "pad_mode_rocket": "火箭",
      "rocket_highlight_active": "高亮活动音符",
      "rocket_show_markers": "显示方向标记",
      "rocket_marker_style": "标记样式",
      "rocket_valid_chords_only": "仅对有效和弦显示标记",
      "rocket_animate_fade": "动画标记淡出",
      "rocket_show_chord_name": "显示识别的和弦名称",
      "style_GlowFromNote": "音符发光",
      "style_WaveToNote": "波形至音符",
      "style_PulseRing": "脉冲环",
      "style_SparkTrail": "火花轨迹",
      "style_ShadowDrop": "音符下阴影",
      "rocket_mode_panel_title": "火箭模式",
      "rocket_mode_enable": "启用火箭模式",
      "rocket_mode_settings_placeholder": "火箭模式设置将显示在此处。",
      "error_loading_mode_settings": "加载模式设置错误。",
      "no_specific_settings_rocket": "配置火箭模式特定设置。",
      "reset_settings_button": "重置所有设置",
      "reload_app_button": "完全重载应用",
      "restart_audio_button": "重启音频引擎",
      "rocket_section_general": "通用",
      "rocket_section_phases": "阶段",
      "rocket_section_harmonic_logic": "和声逻辑",
      "rocket_section_interactive_behavior": "交互行为",
      "rocket_intensity": "强度",
      "rocket_visual_theme": "视觉主题",
      "rocket_auto_phases": "自动阶段",
      "rocket_harmonic_key": "和声调",
      "rocket_marker_logic": "标记逻辑",
      "marker_logic_tonal": "调性绑定",
      "marker_logic_adaptive": "自适应分析",
      "marker_logic_semi_free": "半自由",
      "marker_logic_random": "随机定向",
      "rocket_phase_ignition": "点火",
      "rocket_phase_lift_off": "升空",
      "rocket_phase_burst": "爆发",
      "rocket_phase_transition": "阶段转换",
      "phase_mode_activity": "按活动",
      "phase_mode_time": "按时间",
      "phase_mode_manual": "手动",
      "status_chord": "和弦",
      "status_key": "调性",
      "status_next": "下一个",
      "status_energy": "能量",
      "status_phase": "阶段",
      "status_na": "无",
      "rocket_presets_title": "模式预设",
      "rocket_select_preset": "选择预设",
      "rocket_select_preset_title": "选择火箭模式预设",
      "rocket_preset_current": "当前设置",
      "none_selected": "无",
      "preset_rocket_melodic_drift": "旋律漂移",
      "desc_rocket_melodic_drift": "温柔、漂浮、半自由的和声逻辑。",
      "preset_rocket_jazz_climb": "爵士攀升",
      "desc_rocket_jazz_climb": "活跃、自适应、爵士风格的逻辑。",
      "rocket_marker_labels": "标记标签",
      "labels_none": "无",
      "labels_function": "功能 (T/S/D)",
      "labels_chord_name": "和弦名称",
      "rocket_marker_retention": "标记保留",
      "desc_rocket_marker_retention": "在新触摸期间保持相关标记可见。",
      "desc_rocket_animate_fade": "平滑淡出不相关的标记。",
      "rocket_fade_delay": "淡出延迟",
      "desc_rocket_fade_delay": "标记开始淡出前的延迟。",
      "rocket_fade_duration": "淡出时长",
      "desc_rocket_fade_duration": "标记淡出动画的持续时间。",
      "rocket_max_markers_zone": "最大标记/区域",
      "desc_rocket_max_markers_zone": "每个区域显示的最大建议数。",
      "rocket_phase_styles": "阶段样式",
      "desc_rocket_phase_styles": "允许当前阶段覆盖标记样式。",
      "rocket_tb_in_key": "调性绑定：仅在调内",
      "desc_rocket_tb_in_key": "仅建议当前调内的音符/和弦。",
      "rocket_aa_autokey": "自适应分析：自动换调",
      "desc_rocket_aa_autokey": "允许根据输入自适应更改调性。",
      "rocket_sf_basekey": "半自由：基础调性",
      "desc_rocket_sf_basekey": "半自由模式的基础调性。",
      "rocket_sf_deviations": "半自由：模态偏差",
      "desc_rocket_sf_deviations": "允许临时偏离基础调性。",
      "rocket_sf_return": "半自由：高亮返回",
      "desc_rocket_sf_return": "高亮显示返回基础调性的建议。",
      "rocket_rd_randomlevel": "随机级别",
      "desc_rocket_rd_randomlevel": "建议中的随机性级别。",
      "select_chord": "选择和弦",
      "select_key": "选择调性",
      "select_phase": "选择阶段",
      "no_language_found": "未找到语言",
      "no_theme_found": "未找到主题",
      "no_visualizer_found": "未找到可视化工具",
      "no_touchEffect_found": "未找到触摸效果",
      "no_scale_found": "未找到音阶",
      "no_fxChain_found": "未找到效果链",
      "error_audio_fatal_restart": "严重音频错误。请重启应用。",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_preset": "保存新音色",
      "delete_preset": "删除音色",
      "synth_controls": "合成器控制",
      "synth_type": "合成器类型",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "振荡器类型",
      "sine": "正弦波",
      "square": "方波",
      "sawtooth": "锯齿波",
      "triangle": "三角波",
      "fat_sine": "Fat 正弦波",
      "fat_square": "Fat 方波",
      "fat_sawtooth": "Fat 锯齿波",
      "fat_triangle": "Fat 三角波",
      "fm_sine": "FM 正弦波",
      "fm_square": "FM 方波",
      "fm_sawtooth": "FM 锯齿波",
      "fm_triangle": "FM 三角波",
      "am_sine": "AM 正弦波",
      "am_square": "AM 方波",
      "am_sawtooth": "AM 锯齿波",
      "am_triangle": "AM 三角波",
      "pwm": "PWM",
      "pulse": "脉冲波",
      "noise_white": "白噪音",
      "noise_pink": "粉红噪音",
      "noise_brown": "布朗噪音",
      "oscillator_params": "振荡器参数",
      "phase": "相位",
      "count": "数量",
      "spread": "扩展度",
      "width": "宽度",
      "mod_freq_short": "调制频率",
      "harmonicity": "谐波性",
      "mod_index": "调制指数",
      "mod_type": "调制类型",
      "noise_type": "噪音类型",
      "envelope": "包络",
      "attack": "起音",
      "sustain": "持续",
      "release": "释音",
      "envelope_curves": "包络曲线",
      "attack_curve": "起音",
      "decay_curve": "衰减",
      "release_curve": "释音",
      "filter_advanced": "高级滤波器",
      "filter_rolloff": "滚降",
      "filter_gain": "增益 (dB)",
      "filter_envelope": "滤波器包络",
      "base_frequency": "基频",
      "exponent": "指数",
      "modulation": "调制",
      "modulation_envelope": "调制包络",
      "special_parameters": "特殊参数",
      "pitch_decay": "音高衰减",
      "attack_noise": "起音噪音",
      "dampening": "阻尼",
      "resonance": "共振",
      "lfo": "LFO",
      "lfo_type": "类型",
      "lfo_target": "目标",
      "lfo_min": "最小",
      "lfo_max": "最大",
      "save_preset_title": "保存音色预设",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_fx_chain_title": "保存效果链",
      "fx_chain_name_label": "效果链名称:",
      "fx_chain_name_placeholder": "我的效果链",
      "cancel": "取消",
      "save": "保存",
      "major": "大调",
      "minor": "小调",
      "pentatonic": "五声音阶",
      "blues": "布鲁斯",
      "chromatic": "半音阶",
      "dorian": "多利亚",
      "phrygian": "弗里几亚",
      "lydian": "利底亚",
      "mixolydian": "混合利底亚",
      "locrian": "洛克里亚",
      "day": "日间",
      "night": "夜间",
      "neon": "霓虹",
      "retro": "复古",
      "pastel": "粉彩",
      "aurora": "极光",
      "ocean": "海洋",
      "cyberpunk": "赛博朋克",
      "fire": "火焰",
      "matrix": "矩阵",
      "hologram": "全息图",
      "crystal": "水晶",
      "galaxy": "银河",
      "waves": "波形",
      "spectrum": "频谱",
      "particles": "鱼群",
      "nebula": "星云",
      "reactive_ripples": "反应涟漪",
      "touch_trails": "触摸轨迹",
      "loading": "加载中...",
      "initializing": "初始化中...",
      "loading_bridge": "连接中...",
      "loading_settings": "加载设置...",
      "loading_modules": "加载模块...",
      "loading_ui": "初始化UI...",
      "loading_presets": "应用设置...",
      "loading_audio": "加载声音...",
      "tap_to_start": "点击以启动音频",
      "starting_audio": "启动音频中...",
      "audio_suspended": "音频已暂停。点击以恢复。",
      "loading_preset": "加载预设...",
      "loading_fxchain": "加载效果链...",
      "saving_preset_progress": "保存预设中...",
      "saving_fxchain_progress": "保存效果链中...",
      "deleting_preset_progress": "删除预设中...",
      "deleting_fxchain_progress": "删除效果链中...",
      "hit_play_vibe": "点击播放，感受律动",
      "error_bridge_failed": "错误：桥接连接失败。",
      "error_init_failed": "初始化错误。请检查控制台。",
      "error_init_failed_details": "初始化错误: ${error}。请检查控制台。",
      "error_fatal_init": "严重初始化错误。请重启。",
      "error_audio_failed_retry": "启动音频错误。请再次点击。",
      "error_audio_resume": "无法恢复音频。",
      "error_apply_preset": "应用预设错误。",
      "error_apply_fxchain": "应用效果链错误。",
      "error_loading_presets": "加载预设错误。",
      "error_loading_fxchains": "加载效果链错误",
      "error_loading_effects_ui": "加载效果UI错误。",
      "no_presets_found": "未找到预设。",
      "no_fxchains_found": "未找到效果链",
      "no_effects_available": "无可用效果。",
      "enter_preset_name": "请输入预设名称。",
      "enter_fxchain_name": "请输入效果链名称。",
      "preset_saved_success": "预设 \"${name}\" 保存成功！",
      "fxchain_saved_success": "效果链 \"${name}\" 保存成功！",
      "error_saving_preset": "保存预设错误: ${error}",
      "error_saving_fxchain": "保存效果链错误: ${error}",
      "exception_saving_preset": "保存预设异常: ${error}",
      "exception_saving_fxchain": "保存效果链异常: ${error}",
      "confirm_delete_preset": "确定删除预设 \"${name}\" 吗？",
      "confirm_delete_fxchain": "确定删除效果链 \"${name}\" 吗？",
      "cannot_delete_default_preset": "无法删除默认预设。",
      "cannot_delete_default_fxchain": "无法删除默认效果链。",
      "preset_deleted_success": "预设已删除。",
      "fxchain_deleted_success": "效果链已删除。",
      "preset_delete_failed": "删除预设失败。",
      "fxchain_delete_failed": "删除效果链失败。",
      "exception_deleting_preset": "删除预设异常: ${error}",
      "exception_deleting_fxchain": "删除效果链异常: ${error}",
      "audio_not_ready_record": "音频未准备好。无法开始录制。",
      "pitch_envelope": "音高包络",
      "pitch_amount_cents": "量 (音分)",
      "macro_controls_title": "宏控制",
      "macro_space": "空间",
      "macro_time": "时间",
      "macro_motion": "动态",
      "macro_tone": "音色",
      "macro_drive": "驱动",
      "effects_intensity_min": "FX强度最小 (dB)",
      "effects_intensity_max": "FX强度最大 (dB)",
      "effects_threshold": "FX阈值",
      "none_fxchain": "-- 无 --",
      "none_touch_effect": "无",
      "restart_audio_engine_button": "重启音频",
      "reload_app_button_title": "重载应用",
      "reloading_app_message": "重新加载应用程序...",
      "master_output_title": "主输出",
      "master_volume_ceiling": "音量上限",
      "master_volume_ceiling_label": "音量上限",
      "y_axis_volume_min_output": "最小输出",
      "y_axis_volume_max_output": "最大输出",
      "y_axis_volume_y_threshold": "Y轴阈值",
      "y_axis_curve_type": "曲线类型",
      "y_axis_curve_factor": "曲线因子",
      "y_axis_effects_min_output": "最小输出 (dB)",
      "y_axis_effects_max_output": "最大输出 (dB)",
      "y_axis_effects_y_threshold": "Y轴阈值",
      "logarithmic": "对数",
      "s_curve": "S形曲线",
      "select_option": "选择选项",
      "no_options_found": "未找到选项",
      "error_loading_options": "加载选项错误。",
      "pad_modes_button": "模式",
      "pad_modes_button_title": "打击垫模式",
      "pad_modes_panel_title": "打击垫模式",
      "pad_mode_label": "打击垫模式",
      "pad_mode_select_title": "选择打击垫模式",
      "pad_mode_classic": "经典",
      "pad_mode_reactive": "反应",
      "reactive_mode_show_suggestions": "显示和声提示",
      "reactive_mode_suggestion_count": "提示数量",
      "no_specific_settings_classic": "经典模式无特定设置。",
      "no_specific_settings_reactive": "配置反应模式提示。",
      "pad_mode_rocket": "火箭",
      "rocket_highlight_active": "高亮活动音符",
      "rocket_show_markers": "显示方向标记",
      "rocket_marker_style": "标记样式",
      "rocket_valid_chords_only": "仅对有效和弦显示标记",
      "rocket_animate_fade": "动画标记淡出",
      "rocket_show_chord_name": "显示识别的和弦名称",
      "style_GlowFromNote": "音符发光",
      "style_WaveToNote": "波形至音符",
      "style_PulseRing": "脉冲环",
      "style_SparkTrail": "火花轨迹",
      "style_ShadowDrop": "音符下阴影",
      "rocket_mode_panel_title": "火箭模式",
      "rocket_mode_enable": "启用火箭模式",
      "rocket_mode_settings_placeholder": "火箭模式设置将显示在此处。",
      "error_loading_mode_settings": "加载模式设置错误。",
      "no_specific_settings_rocket": "配置火箭模式特定设置。",
      "reset_settings_button": "重置所有设置",
      "reload_app_button": "完全重载应用",
      "restart_audio_button": "重启音频引擎",
      "rocket_section_general": "通用",
      "rocket_section_phases": "阶段",
      "rocket_section_harmonic_logic": "和声逻辑",
      "rocket_section_interactive_behavior": "交互行为",
      "rocket_intensity": "强度",
      "rocket_visual_theme": "视觉主题",
      "rocket_auto_phases": "自动阶段",
      "rocket_harmonic_key": "和声调",
      "rocket_marker_logic": "标记逻辑",
      "marker_logic_tonal": "调性绑定",
      "marker_logic_adaptive": "自适应分析",
      "marker_logic_semi_free": "半自由",
      "marker_logic_random": "随机定向",
      "rocket_phase_ignition": "点火",
      "rocket_phase_lift_off": "升空",
      "rocket_phase_burst": "爆发",
      "rocket_phase_transition": "阶段转换",
      "phase_mode_activity": "按活动",
      "phase_mode_time": "按时间",
      "phase_mode_manual": "手动",
      "status_chord": "和弦",
      "status_key": "调性",
      "status_next": "下一个",
      "status_energy": "能量",
      "status_phase": "阶段",
      "status_na": "无",
      "rocket_presets_title": "模式预设",
      "rocket_select_preset": "选择预设",
      "rocket_select_preset_title": "选择火箭模式预设",
      "rocket_preset_current": "当前设置",
      "none_selected": "无",
      "preset_rocket_melodic_drift": "旋律漂移",
      "desc_rocket_melodic_drift": "温柔、漂浮、半自由的和声逻辑。",
      "preset_rocket_jazz_climb": "爵士攀升",
      "desc_rocket_jazz_climb": "活跃、自适应、爵士风格的逻辑。",
      "rocket_marker_labels": "标记标签",
      "labels_none": "无",
      "labels_function": "功能 (T/S/D)",
      "labels_chord_name": "和弦名称",
      "rocket_marker_retention": "标记保留",
      "desc_rocket_marker_retention": "在新触摸期间保持相关标记可见。",
      "desc_rocket_animate_fade": "平滑淡出不相关的标记。",
      "rocket_fade_delay": "淡出延迟",
      "desc_rocket_fade_delay": "标记开始淡出前的延迟。",
      "rocket_fade_duration": "淡出时长",
      "desc_rocket_fade_duration": "标记淡出动画的持续时间。",
      "rocket_max_markers_zone": "最大标记/区域",
      "desc_rocket_max_markers_zone": "每个区域显示的最大建议数。",
      "rocket_phase_styles": "阶段样式",
      "desc_rocket_phase_styles": "允许当前阶段覆盖标记样式。",
      "rocket_tb_in_key": "调性绑定：仅在调内",
      "desc_rocket_tb_in_key": "仅建议当前调内的音符/和弦。",
      "rocket_aa_autokey": "自适应分析：自动换调",
      "desc_rocket_aa_autokey": "允许根据输入自适应更改调性。",
      "rocket_sf_basekey": "半自由：基础调性",
      "desc_rocket_sf_basekey": "半自由模式的基础调性。",
      "rocket_sf_deviations": "半自由：模态偏差",
      "desc_rocket_sf_deviations": "允许临时偏离基础调性。",
      "rocket_sf_return": "半自由：高亮返回",
      "desc_rocket_sf_return": "高亮显示返回基础调性的建议。",
      "rocket_rd_randomlevel": "随机级别",
      "desc_rocket_rd_randomlevel": "建议中的随机性级别。",
      "select_chord": "选择和弦",
      "select_key": "选择调性",
      "select_phase": "选择阶段",
      "no_language_found": "未找到语言",
      "no_theme_found": "未找到主题",
      "no_visualizer_found": "未找到可视化工具",
      "no_touchEffect_found": "未找到触摸效果",
      "no_scale_found": "未找到音阶",
      "no_fxChain_found": "未找到效果链",
      "error_audio_fatal_restart": "严重音频错误。请重启应用。",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_preset": "保存新音色",
      "delete_preset": "删除音色",
      "synth_controls": "合成器控制",
      "synth_type": "合成器类型",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "振荡器类型",
      "sine": "正弦波",
      "square": "方波",
      "sawtooth": "锯齿波",
      "triangle": "三角波",
      "fat_sine": "Fat 正弦波",
      "fat_square": "Fat 方波",
      "fat_sawtooth": "Fat 锯齿波",
      "fat_triangle": "Fat 三角波",
      "fm_sine": "FM 正弦波",
      "fm_square": "FM 方波",
      "fm_sawtooth": "FM 锯齿波",
      "fm_triangle": "FM 三角波",
      "am_sine": "AM 正弦波",
      "am_square": "AM 方波",
      "am_sawtooth": "AM 锯齿波",
      "am_triangle": "AM 三角波",
      "pwm": "PWM",
      "pulse": "脉冲波",
      "noise_white": "白噪音",
      "noise_pink": "粉红噪音",
      "noise_brown": "布朗噪音",
      "oscillator_params": "振荡器参数",
      "phase": "相位",
      "count": "数量",
      "spread": "扩展度",
      "width": "宽度",
      "mod_freq_short": "调制频率",
      "harmonicity": "谐波性",
      "mod_index": "调制指数",
      "mod_type": "调制类型",
      "noise_type": "噪音类型",
      "envelope": "包络",
      "attack": "起音",
      "sustain": "持续",
      "release": "释音",
      "envelope_curves": "包络曲线",
      "attack_curve": "起音",
      "decay_curve": "衰减",
      "release_curve": "释音",
      "filter_advanced": "高级滤波器",
      "filter_rolloff": "滚降",
      "filter_gain": "增益 (dB)",
      "filter_envelope": "滤波器包络",
      "base_frequency": "基频",
      "exponent": "指数",
      "modulation": "调制",
      "modulation_envelope": "调制包络",
      "special_parameters": "特殊参数",
      "pitch_decay": "音高衰减",
      "attack_noise": "起音噪音",
      "dampening": "阻尼",
      "resonance": "共振",
      "lfo": "LFO",
      "lfo_type": "类型",
      "lfo_target": "目标",
      "lfo_min": "最小",
      "lfo_max": "最大",
      "save_preset_title": "保存音色预设",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_fx_chain_title": "保存效果链",
      "fx_chain_name_label": "效果链名称:",
      "fx_chain_name_placeholder": "我的效果链",
      "cancel": "取消",
      "save": "保存",
      "major": "大调",
      "minor": "小调",
      "pentatonic": "五声音阶",
      "blues": "布鲁斯",
      "chromatic": "半音阶",
      "dorian": "多利亚",
      "phrygian": "弗里几亚",
      "lydian": "利底亚",
      "mixolydian": "混合利底亚",
      "locrian": "洛克里亚",
      "day": "日间",
      "night": "夜间",
      "neon": "霓虹",
      "retro": "复古",
      "pastel": "粉彩",
      "aurora": "极光",
      "ocean": "海洋",
      "cyberpunk": "赛博朋克",
      "fire": "火焰",
      "matrix": "矩阵",
      "hologram": "全息图",
      "crystal": "水晶",
      "galaxy": "银河",
      "waves": "波形",
      "spectrum": "频谱",
      "particles": "鱼群",
      "nebula": "星云",
      "reactive_ripples": "反应涟漪",
      "touch_trails": "触摸轨迹",
      "loading": "加载中...",
      "initializing": "初始化中...",
      "loading_bridge": "连接中...",
      "loading_settings": "加载设置...",
      "loading_modules": "加载模块...",
      "loading_ui": "初始化UI...",
      "loading_presets": "应用设置...",
      "loading_audio": "加载声音...",
      "tap_to_start": "点击以启动音频",
      "starting_audio": "启动音频中...",
      "audio_suspended": "音频已暂停。点击以恢复。",
      "loading_preset": "加载预设...",
      "loading_fxchain": "加载效果链...",
      "saving_preset_progress": "保存预设中...",
      "saving_fxchain_progress": "保存效果链中...",
      "deleting_preset_progress": "删除预设中...",
      "deleting_fxchain_progress": "删除效果链中...",
      "hit_play_vibe": "点击播放，感受律动",
      "error_bridge_failed": "错误：桥接连接失败。",
      "error_init_failed": "初始化错误。请检查控制台。",
      "error_init_failed_details": "初始化错误: ${error}。请检查控制台。",
      "error_fatal_init": "严重初始化错误。请重启。",
      "error_audio_failed_retry": "启动音频错误。请再次点击。",
      "error_audio_resume": "无法恢复音频。",
      "error_apply_preset": "应用预设错误。",
      "error_apply_fxchain": "应用效果链错误。",
      "error_loading_presets": "加载预设错误。",
      "error_loading_fxchains": "加载效果链错误",
      "error_loading_effects_ui": "加载效果UI错误。",
      "no_presets_found": "未找到预设。",
      "no_fxchains_found": "未找到效果链",
      "no_effects_available": "无可用效果。",
      "enter_preset_name": "请输入预设名称。",
      "enter_fxchain_name": "请输入效果链名称。",
      "preset_saved_success": "预设 \"${name}\" 保存成功！",
      "fxchain_saved_success": "效果链 \"${name}\" 保存成功！",
      "error_saving_preset": "保存预设错误: ${error}",
      "error_saving_fxchain": "保存效果链错误: ${error}",
      "exception_saving_preset": "保存预设异常: ${error}",
      "exception_saving_fxchain": "保存效果链异常: ${error}",
      "confirm_delete_preset": "确定删除预设 \"${name}\" 吗？",
      "confirm_delete_fxchain": "确定删除效果链 \"${name}\" 吗？",
      "cannot_delete_default_preset": "无法删除默认预设。",
      "cannot_delete_default_fxchain": "无法删除默认效果链。",
      "preset_deleted_success": "预设已删除。",
      "fxchain_deleted_success": "效果链已删除。",
      "preset_delete_failed": "删除预设失败。",
      "fxchain_delete_failed": "删除效果链失败。",
      "exception_deleting_preset": "删除预设异常: ${error}",
      "exception_deleting_fxchain": "删除效果链异常: ${error}",
      "audio_not_ready_record": "音频未准备好。无法开始录制。",
      "pitch_envelope": "音高包络",
      "pitch_amount_cents": "量 (音分)",
      "macro_controls_title": "宏控制",
      "macro_space": "空间",
      "macro_time": "时间",
      "macro_motion": "动态",
      "macro_tone": "音色",
      "macro_drive": "驱动",
      "effects_intensity_min": "FX强度最小 (dB)",
      "effects_intensity_max": "FX强度最大 (dB)",
      "effects_threshold": "FX阈值",
      "none_fxchain": "-- 无 --",
      "none_touch_effect": "无",
      "restart_audio_engine_button": "重启音频",
      "reload_app_button_title": "重载应用",
      "reloading_app_message": "重新加载应用程序...",
      "master_output_title": "主输出",
      "master_volume_ceiling": "音量上限",
      "master_volume_ceiling_label": "音量上限",
      "y_axis_volume_min_output": "最小输出",
      "y_axis_volume_max_output": "最大输出",
      "y_axis_volume_y_threshold": "Y轴阈值",
      "y_axis_curve_type": "曲线类型",
      "y_axis_curve_factor": "曲线因子",
      "y_axis_effects_min_output": "最小输出 (dB)",
      "y_axis_effects_max_output": "最大输出 (dB)",
      "y_axis_effects_y_threshold": "Y轴阈值",
      "logarithmic": "对数",
      "s_curve": "S形曲线",
      "select_option": "选择选项",
      "no_options_found": "未找到选项",
      "error_loading_options": "加载选项错误。",
      "pad_modes_button": "模式",
      "pad_modes_button_title": "打击垫模式",
      "pad_modes_panel_title": "打击垫模式",
      "pad_mode_label": "打击垫模式",
      "pad_mode_select_title": "选择打击垫模式",
      "pad_mode_classic": "经典",
      "pad_mode_reactive": "反应",
      "reactive_mode_show_suggestions": "显示和声提示",
      "reactive_mode_suggestion_count": "提示数量",
      "no_specific_settings_classic": "经典模式无特定设置。",
      "no_specific_settings_reactive": "配置反应模式提示。",
      "pad_mode_rocket": "火箭",
      "rocket_highlight_active": "高亮活动音符",
      "rocket_show_markers": "显示方向标记",
      "rocket_marker_style": "标记样式",
      "rocket_valid_chords_only": "仅对有效和弦显示标记",
      "rocket_animate_fade": "动画标记淡出",
      "rocket_show_chord_name": "显示识别的和弦名称",
      "style_GlowFromNote": "音符发光",
      "style_WaveToNote": "波形至音符",
      "style_PulseRing": "脉冲环",
      "style_SparkTrail": "火花轨迹",
      "style_ShadowDrop": "音符下阴影",
      "rocket_mode_panel_title": "火箭模式",
      "rocket_mode_enable": "启用火箭模式",
      "rocket_mode_settings_placeholder": "火箭模式设置将显示在此处。",
      "error_loading_mode_settings": "加载模式设置错误。",
      "no_specific_settings_rocket": "配置火箭模式特定设置。",
      "reset_settings_button": "重置所有设置",
      "reload_app_button": "完全重载应用",
      "restart_audio_button": "重启音频引擎",
      "rocket_section_general": "通用",
      "rocket_section_phases": "阶段",
      "rocket_section_harmonic_logic": "和声逻辑",
      "rocket_section_interactive_behavior": "交互行为",
      "rocket_intensity": "强度",
      "rocket_visual_theme": "视觉主题",
      "rocket_auto_phases": "自动阶段",
      "rocket_harmonic_key": "和声调",
      "rocket_marker_logic": "标记逻辑",
      "marker_logic_tonal": "调性绑定",
      "marker_logic_adaptive": "自适应分析",
      "marker_logic_semi_free": "半自由",
      "marker_logic_random": "随机定向",
      "rocket_phase_ignition": "点火",
      "rocket_phase_lift_off": "升空",
      "rocket_phase_burst": "爆发",
      "rocket_phase_transition": "阶段转换",
      "phase_mode_activity": "按活动",
      "phase_mode_time": "按时间",
      "phase_mode_manual": "手动",
      "status_chord": "和弦",
      "status_key": "调性",
      "status_next": "下一个",
      "status_energy": "能量",
      "status_phase": "阶段",
      "status_na": "无",
      "rocket_presets_title": "模式预设",
      "rocket_select_preset": "选择预设",
      "rocket_select_preset_title": "选择火箭模式预设",
      "rocket_preset_current": "当前设置",
      "none_selected": "无",
      "preset_rocket_melodic_drift": "旋律漂移",
      "desc_rocket_melodic_drift": "温柔、漂浮、半自由的和声逻辑。",
      "preset_rocket_jazz_climb": "爵士攀升",
      "desc_rocket_jazz_climb": "活跃、自适应、爵士风格的逻辑。",
      "rocket_marker_labels": "标记标签",
      "labels_none": "无",
      "labels_function": "功能 (T/S/D)",
      "labels_chord_name": "和弦名称",
      "rocket_marker_retention": "标记保留",
      "desc_rocket_marker_retention": "在新触摸期间保持相关标记可见。",
      "desc_rocket_animate_fade": "平滑淡出不相关的标记。",
      "rocket_fade_delay": "淡出延迟",
      "desc_rocket_fade_delay": "标记开始淡出前的延迟。",
      "rocket_fade_duration": "淡出时长",
      "desc_rocket_fade_duration": "标记淡出动画的持续时间。",
      "rocket_max_markers_zone": "最大标记/区域",
      "desc_rocket_max_markers_zone": "每个区域显示的最大建议数。",
      "rocket_phase_styles": "阶段样式",
      "desc_rocket_phase_styles": "允许当前阶段覆盖标记样式。",
      "rocket_tb_in_key": "调性绑定：仅在调内",
      "desc_rocket_tb_in_key": "仅建议当前调内的音符/和弦。",
      "rocket_aa_autokey": "自适应分析：自动换调",
      "desc_rocket_aa_autokey": "允许根据输入自适应更改调性。",
      "rocket_sf_basekey": "半自由：基础调性",
      "desc_rocket_sf_basekey": "半自由模式的基础调性。",
      "rocket_sf_deviations": "半自由：模态偏差",
      "desc_rocket_sf_deviations": "允许临时偏离基础调性。",
      "rocket_sf_return": "半自由：高亮返回",
      "desc_rocket_sf_return": "高亮显示返回基础调性的建议。",
      "rocket_rd_randomlevel": "随机级别",
      "desc_rocket_rd_randomlevel": "建议中的随机性级别。",
      "select_chord": "选择和弦",
      "select_key": "选择调性",
      "select_phase": "选择阶段",
      "no_language_found": "未找到语言",
      "no_theme_found": "未找到主题",
      "no_visualizer_found": "未找到可视化工具",
      "no_touchEffect_found": "未找到触摸效果",
      "no_scale_found": "未找到音阶",
      "no_fxChain_found": "未找到效果链",
      "error_audio_fatal_restart": "严重音频错误。请重启应用。",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_preset": "保存新音色",
      "delete_preset": "删除音色",
      "synth_controls": "合成器控制",
      "synth_type": "合成器类型",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "振荡器类型",
      "sine": "正弦波",
      "square": "方波",
      "sawtooth": "锯齿波",
      "triangle": "三角波",
      "fat_sine": "Fat 正弦波",
      "fat_square": "Fat 方波",
      "fat_sawtooth": "Fat 锯齿波",
      "fat_triangle": "Fat 三角波",
      "fm_sine": "FM 正弦波",
      "fm_square": "FM 方波",
      "fm_sawtooth": "FM 锯齿波",
      "fm_triangle": "FM 三角波",
      "am_sine": "AM 正弦波",
      "am_square": "AM 方波",
      "am_sawtooth": "AM 锯齿波",
      "am_triangle": "AM 三角波",
      "pwm": "PWM",
      "pulse": "脉冲波",
      "noise_white": "白噪音",
      "noise_pink": "粉红噪音",
      "noise_brown": "布朗噪音",
      "oscillator_params": "振荡器参数",
      "phase": "相位",
      "count": "数量",
      "spread": "扩展度",
      "width": "宽度",
      "mod_freq_short": "调制频率",
      "harmonicity": "谐波性",
      "mod_index": "调制指数",
      "mod_type": "调制类型",
      "noise_type": "噪音类型",
      "envelope": "包络",
      "attack": "起音",
      "sustain": "持续",
      "release": "释音",
      "envelope_curves": "包络曲线",
      "attack_curve": "起音",
      "decay_curve": "衰减",
      "release_curve": "释音",
      "filter_advanced": "高级滤波器",
      "filter_rolloff": "滚降",
      "filter_gain": "增益 (dB)",
      "filter_envelope": "滤波器包络",
      "base_frequency": "基频",
      "exponent": "指数",
      "modulation": "调制",
      "modulation_envelope": "调制包络",
      "special_parameters": "特殊参数",
      "pitch_decay": "音高衰减",
      "attack_noise": "起音噪音",
      "dampening": "阻尼",
      "resonance": "共振",
      "lfo": "LFO",
      "lfo_type": "类型",
      "lfo_target": "目标",
      "lfo_min": "最小",
      "lfo_max": "最大",
      "save_preset_title": "保存音色预设",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_fx_chain_title": "保存效果链",
      "fx_chain_name_label": "效果链名称:",
      "fx_chain_name_placeholder": "我的效果链",
      "cancel": "取消",
      "save": "保存",
      "major": "大调",
      "minor": "小调",
      "pentatonic": "五声音阶",
      "blues": "布鲁斯",
      "chromatic": "半音阶",
      "dorian": "多利亚",
      "phrygian": "弗里几亚",
      "lydian": "利底亚",
      "mixolydian": "混合利底亚",
      "locrian": "洛克里亚",
      "day": "日间",
      "night": "夜间",
      "neon": "霓虹",
      "retro": "复古",
      "pastel": "粉彩",
      "aurora": "极光",
      "ocean": "海洋",
      "cyberpunk": "赛博朋克",
      "fire": "火焰",
      "matrix": "矩阵",
      "hologram": "全息图",
      "crystal": "水晶",
      "galaxy": "银河",
      "waves": "波形",
      "spectrum": "频谱",
      "particles": "鱼群",
      "nebula": "星云",
      "reactive_ripples": "反应涟漪",
      "touch_trails": "触摸轨迹",
      "loading": "加载中...",
      "initializing": "初始化中...",
      "loading_bridge": "连接中...",
      "loading_settings": "加载设置...",
      "loading_modules": "加载模块...",
      "loading_ui": "初始化UI...",
      "loading_presets": "应用设置...",
      "loading_audio": "加载声音...",
      "tap_to_start": "点击以启动音频",
      "starting_audio": "启动音频中...",
      "audio_suspended": "音频已暂停。点击以恢复。",
      "loading_preset": "加载预设...",
      "loading_fxchain": "加载效果链...",
      "saving_preset_progress": "保存预设中...",
      "saving_fxchain_progress": "保存效果链中...",
      "deleting_preset_progress": "删除预设中...",
      "deleting_fxchain_progress": "删除效果链中...",
      "hit_play_vibe": "点击播放，感受律动",
      "error_bridge_failed": "错误：桥接连接失败。",
      "error_init_failed": "初始化错误。请检查控制台。",
      "error_init_failed_details": "初始化错误: ${error}。请检查控制台。",
      "error_fatal_init": "严重初始化错误。请重启。",
      "error_audio_failed_retry": "启动音频错误。请再次点击。",
      "error_audio_resume": "无法恢复音频。",
      "error_apply_preset": "应用预设错误。",
      "error_apply_fxchain": "应用效果链错误。",
      "error_loading_presets": "加载预设错误。",
      "error_loading_fxchains": "加载效果链错误",
      "error_loading_effects_ui": "加载效果UI错误。",
      "no_presets_found": "未找到预设。",
      "no_fxchains_found": "未找到效果链",
      "no_effects_available": "无可用效果。",
      "enter_preset_name": "请输入预设名称。",
      "enter_fxchain_name": "请输入效果链名称。",
      "preset_saved_success": "预设 \"${name}\" 保存成功！",
      "fxchain_saved_success": "效果链 \"${name}\" 保存成功！",
      "error_saving_preset": "保存预设错误: ${error}",
      "error_saving_fxchain": "保存效果链错误: ${error}",
      "exception_saving_preset": "保存预设异常: ${error}",
      "exception_saving_fxchain": "保存效果链异常: ${error}",
      "confirm_delete_preset": "确定删除预设 \"${name}\" 吗？",
      "confirm_delete_fxchain": "确定删除效果链 \"${name}\" 吗？",
      "cannot_delete_default_preset": "无法删除默认预设。",
      "cannot_delete_default_fxchain": "无法删除默认效果链。",
      "preset_deleted_success": "预设已删除。",
      "fxchain_deleted_success": "效果链已删除。",
      "preset_delete_failed": "删除预设失败。",
      "fxchain_delete_failed": "删除效果链失败。",
      "exception_deleting_preset": "删除预设异常: ${error}",
      "exception_deleting_fxchain": "删除效果链异常: ${error}",
      "audio_not_ready_record": "音频未准备好。无法开始录制。",
      "pitch_envelope": "音高包络",
      "pitch_amount_cents": "量 (音分)",
      "macro_controls_title": "宏控制",
      "macro_space": "空间",
      "macro_time": "时间",
      "macro_motion": "动态",
      "macro_tone": "音色",
      "macro_drive": "驱动",
      "effects_intensity_min": "FX强度最小 (dB)",
      "effects_intensity_max": "FX强度最大 (dB)",
      "effects_threshold": "FX阈值",
      "none_fxchain": "-- 无 --",
      "none_touch_effect": "无",
      "restart_audio_engine_button": "重启音频",
      "reload_app_button_title": "重载应用",
      "reloading_app_message": "重新加载应用程序...",
      "master_output_title": "主输出",
      "master_volume_ceiling": "音量上限",
      "master_volume_ceiling_label": "音量上限",
      "y_axis_volume_min_output": "最小输出",
      "y_axis_volume_max_output": "最大输出",
      "y_axis_volume_y_threshold": "Y轴阈值",
      "y_axis_curve_type": "曲线类型",
      "y_axis_curve_factor": "曲线因子",
      "y_axis_effects_min_output": "最小输出 (dB)",
      "y_axis_effects_max_output": "最大输出 (dB)",
      "y_axis_effects_y_threshold": "Y轴阈值",
      "logarithmic": "对数",
      "s_curve": "S形曲线",
      "select_option": "选择选项",
      "no_options_found": "未找到选项",
      "error_loading_options": "加载选项错误。",
      "pad_modes_button": "模式",
      "pad_modes_button_title": "打击垫模式",
      "pad_modes_panel_title": "打击垫模式",
      "pad_mode_label": "打击垫模式",
      "pad_mode_select_title": "选择打击垫模式",
      "pad_mode_classic": "经典",
      "pad_mode_reactive": "反应",
      "reactive_mode_show_suggestions": "显示和声提示",
      "reactive_mode_suggestion_count": "提示数量",
      "no_specific_settings_classic": "经典模式无特定设置。",
      "no_specific_settings_reactive": "配置反应模式提示。",
      "pad_mode_rocket": "火箭",
      "rocket_highlight_active": "高亮活动音符",
      "rocket_show_markers": "显示方向标记",
      "rocket_marker_style": "标记样式",
      "rocket_valid_chords_only": "仅对有效和弦显示标记",
      "rocket_animate_fade": "动画标记淡出",
      "rocket_show_chord_name": "显示识别的和弦名称",
      "style_GlowFromNote": "音符发光",
      "style_WaveToNote": "波形至音符",
      "style_PulseRing": "脉冲环",
      "style_SparkTrail": "火花轨迹",
      "style_ShadowDrop": "音符下阴影",
      "rocket_mode_panel_title": "火箭模式",
      "rocket_mode_enable": "启用火箭模式",
      "rocket_mode_settings_placeholder": "火箭模式设置将显示在此处。",
      "error_loading_mode_settings": "加载模式设置错误。",
      "no_specific_settings_rocket": "配置火箭模式特定设置。",
      "reset_settings_button": "重置所有设置",
      "reload_app_button": "完全重载应用",
      "restart_audio_button": "重启音频引擎",
      "rocket_section_general": "通用",
      "rocket_section_phases": "阶段",
      "rocket_section_harmonic_logic": "和声逻辑",
      "rocket_section_interactive_behavior": "交互行为",
      "rocket_intensity": "强度",
      "rocket_visual_theme": "视觉主题",
      "rocket_auto_phases": "自动阶段",
      "rocket_harmonic_key": "和声调",
      "rocket_marker_logic": "标记逻辑",
      "marker_logic_tonal": "调性绑定",
      "marker_logic_adaptive": "自适应分析",
      "marker_logic_semi_free": "半自由",
      "marker_logic_random": "随机定向",
      "rocket_phase_ignition": "点火",
      "rocket_phase_lift_off": "升空",
      "rocket_phase_burst": "爆发",
      "rocket_phase_transition": "阶段转换",
      "phase_mode_activity": "按活动",
      "phase_mode_time": "按时间",
      "phase_mode_manual": "手动",
      "status_chord": "和弦",
      "status_key": "调性",
      "status_next": "下一个",
      "status_energy": "能量",
      "status_phase": "阶段",
      "status_na": "无",
      "rocket_presets_title": "模式预设",
      "rocket_select_preset": "选择预设",
      "rocket_select_preset_title": "选择火箭模式预设",
      "rocket_preset_current": "当前设置",
      "none_selected": "无",
      "preset_rocket_melodic_drift": "旋律漂移",
      "desc_rocket_melodic_drift": "温柔、漂浮、半自由的和声逻辑。",
      "preset_rocket_jazz_climb": "爵士攀升",
      "desc_rocket_jazz_climb": "活跃、自适应、爵士风格的逻辑。",
      "rocket_marker_labels": "标记标签",
      "labels_none": "无",
      "labels_function": "功能 (T/S/D)",
      "labels_chord_name": "和弦名称",
      "rocket_marker_retention": "标记保留",
      "desc_rocket_marker_retention": "在新触摸期间保持相关标记可见。",
      "desc_rocket_animate_fade": "平滑淡出不相关的标记。",
      "rocket_fade_delay": "淡出延迟",
      "desc_rocket_fade_delay": "标记开始淡出前的延迟。",
      "rocket_fade_duration": "淡出时长",
      "desc_rocket_fade_duration": "标记淡出动画的持续时间。",
      "rocket_max_markers_zone": "最大标记/区域",
      "desc_rocket_max_markers_zone": "每个区域显示的最大建议数。",
      "rocket_phase_styles": "阶段样式",
      "desc_rocket_phase_styles": "允许当前阶段覆盖标记样式。",
      "rocket_tb_in_key": "调性绑定：仅在调内",
      "desc_rocket_tb_in_key": "仅建议当前调内的音符/和弦。",
      "rocket_aa_autokey": "自适应分析：自动换调",
      "desc_rocket_aa_autokey": "允许根据输入自适应更改调性。",
      "rocket_sf_basekey": "半自由：基础调性",
      "desc_rocket_sf_basekey": "半自由模式的基础调性。",
      "rocket_sf_deviations": "半自由：模态偏差",
      "desc_rocket_sf_deviations": "允许临时偏离基础调性。",
      "rocket_sf_return": "半自由：高亮返回",
      "desc_rocket_sf_return": "高亮显示返回基础调性的建议。",
      "rocket_rd_randomlevel": "随机级别",
      "desc_rocket_rd_randomlevel": "建议中的随机性级别。",
      "select_chord": "选择和弦",
      "select_key": "选择调性",
      "select_phase": "选择阶段",
      "no_language_found": "未找到语言",
      "no_theme_found": "未找到主题",
      "no_visualizer_found": "未找到可视化工具",
      "no_touchEffect_found": "未找到触摸效果",
      "no_scale_found": "未找到音阶",
      "no_fxChain_found": "未找到效果链",
      "error_audio_fatal_restart": "严重音频错误。请重启应用。",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_preset": "保存新音色",
      "delete_preset": "删除音色",
      "synth_controls": "合成器控制",
      "synth_type": "合成器类型",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "振荡器类型",
      "sine": "正弦波",
      "square": "方波",
      "sawtooth": "锯齿波",
      "triangle": "三角波",
      "fat_sine": "Fat 正弦波",
      "fat_square": "Fat 方波",
      "fat_sawtooth": "Fat 锯齿波",
      "fat_triangle": "Fat 三角波",
      "fm_sine": "FM 正弦波",
      "fm_square": "FM 方波",
      "fm_sawtooth": "FM 锯齿波",
      "fm_triangle": "FM 三角波",
      "am_sine": "AM 正弦波",
      "am_square": "AM 方波",
      "am_sawtooth": "AM 锯齿波",
      "am_triangle": "AM 三角波",
      "pwm": "PWM",
      "pulse": "脉冲波",
      "noise_white": "白噪音",
      "noise_pink": "粉红噪音",
      "noise_brown": "布朗噪音",
      "oscillator_params": "振荡器参数",
      "phase": "相位",
      "count": "数量",
      "spread": "扩展度",
      "width": "宽度",
      "mod_freq_short": "调制频率",
      "harmonicity": "谐波性",
      "mod_index": "调制指数",
      "mod_type": "调制类型",
      "noise_type": "噪音类型",
      "envelope": "包络",
      "attack": "起音",
      "sustain": "持续",
      "release": "释音",
      "envelope_curves": "包络曲线",
      "attack_curve": "起音",
      "decay_curve": "衰减",
      "release_curve": "释音",
      "filter_advanced": "高级滤波器",
      "filter_rolloff": "滚降",
      "filter_gain": "增益 (dB)",
      "filter_envelope": "滤波器包络",
      "base_frequency": "基频",
      "exponent": "指数",
      "modulation": "调制",
      "modulation_envelope": "调制包络",
      "special_parameters": "特殊参数",
      "pitch_decay": "音高衰减",
      "attack_noise": "起音噪音",
      "dampening": "阻尼",
      "resonance": "共振",
      "lfo": "LFO",
      "lfo_type": "类型",
      "lfo_target": "目标",
      "lfo_min": "最小",
      "lfo_max": "最大",
      "save_preset_title": "保存音色预设",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_fx_chain_title": "保存效果链",
      "fx_chain_name_label": "效果链名称:",
      "fx_chain_name_placeholder": "我的效果链",
      "cancel": "取消",
      "save": "保存",
      "major": "大调",
      "minor": "小调",
      "pentatonic": "五声音阶",
      "blues": "布鲁斯",
      "chromatic": "半音阶",
      "dorian": "多利亚",
      "phrygian": "弗里几亚",
      "lydian": "利底亚",
      "mixolydian": "混合利底亚",
      "locrian": "洛克里亚",
      "day": "日间",
      "night": "夜间",
      "neon": "霓虹",
      "retro": "复古",
      "pastel": "粉彩",
      "aurora": "极光",
      "ocean": "海洋",
      "cyberpunk": "赛博朋克",
      "fire": "火焰",
      "matrix": "矩阵",
      "hologram": "全息图",
      "crystal": "水晶",
      "galaxy": "银河",
      "waves": "波形",
      "spectrum": "频谱",
      "particles": "鱼群",
      "nebula": "星云",
      "reactive_ripples": "反应涟漪",
      "touch_trails": "触摸轨迹",
      "loading": "加载中...",
      "initializing": "初始化中...",
      "loading_bridge": "连接中...",
      "loading_settings": "加载设置...",
      "loading_modules": "加载模块...",
      "loading_ui": "初始化UI...",
      "loading_presets": "应用设置...",
      "loading_audio": "加载声音...",
      "tap_to_start": "点击以启动音频",
      "starting_audio": "启动音频中...",
      "audio_suspended": "音频已暂停。点击以恢复。",
      "loading_preset": "加载预设...",
      "loading_fxchain": "加载效果链...",
      "saving_preset_progress": "保存预设中...",
      "saving_fxchain_progress": "保存效果链中...",
      "deleting_preset_progress": "删除预设中...",
      "deleting_fxchain_progress": "删除效果链中...",
      "hit_play_vibe": "点击播放，感受律动",
      "error_bridge_failed": "错误：桥接连接失败。",
      "error_init_failed": "初始化错误。请检查控制台。",
      "error_init_failed_details": "初始化错误: ${error}。请检查控制台。",
      "error_fatal_init": "严重初始化错误。请重启。",
      "error_audio_failed_retry": "启动音频错误。请再次点击。",
      "error_audio_resume": "无法恢复音频。",
      "error_apply_preset": "应用预设错误。",
      "error_apply_fxchain": "应用效果链错误。",
      "error_loading_presets": "加载预设错误。",
      "error_loading_fxchains": "加载效果链错误",
      "error_loading_effects_ui": "加载效果UI错误。",
      "no_presets_found": "未找到预设。",
      "no_fxchains_found": "未找到效果链",
      "no_effects_available": "无可用效果。",
      "enter_preset_name": "请输入预设名称。",
      "enter_fxchain_name": "请输入效果链名称。",
      "preset_saved_success": "预设 \"${name}\" 保存成功！",
      "fxchain_saved_success": "效果链 \"${name}\" 保存成功！",
      "error_saving_preset": "保存预设错误: ${error}",
      "error_saving_fxchain": "保存效果链错误: ${error}",
      "exception_saving_preset": "保存预设异常: ${error}",
      "exception_saving_fxchain": "保存效果链异常: ${error}",
      "confirm_delete_preset": "确定删除预设 \"${name}\" 吗？",
      "confirm_delete_fxchain": "确定删除效果链 \"${name}\" 吗？",
      "cannot_delete_default_preset": "无法删除默认预设。",
      "cannot_delete_default_fxchain": "无法删除默认效果链。",
      "preset_deleted_success": "预设已删除。",
      "fxchain_deleted_success": "效果链已删除。",
      "preset_delete_failed": "删除预设失败。",
      "fxchain_delete_failed": "删除效果链失败。",
      "exception_deleting_preset": "删除预设异常: ${error}",
      "exception_deleting_fxchain": "删除效果链异常: ${error}",
      "audio_not_ready_record": "音频未准备好。无法开始录制。",
      "pitch_envelope": "音高包络",
      "pitch_amount_cents": "量 (音分)",
      "macro_controls_title": "宏控制",
      "macro_space": "空间",
      "macro_time": "时间",
      "macro_motion": "动态",
      "macro_tone": "音色",
      "macro_drive": "驱动",
      "effects_intensity_min": "FX强度最小 (dB)",
      "effects_intensity_max": "FX强度最大 (dB)",
      "effects_threshold": "FX阈值",
      "none_fxchain": "-- 无 --",
      "none_touch_effect": "无",
      "restart_audio_engine_button": "重启音频",
      "reload_app_button_title": "重载应用",
      "reloading_app_message": "重新加载应用程序...",
      "master_output_title": "主输出",
      "master_volume_ceiling": "音量上限",
      "master_volume_ceiling_label": "音量上限",
      "y_axis_volume_min_output": "最小输出",
      "y_axis_volume_max_output": "最大输出",
      "y_axis_volume_y_threshold": "Y轴阈值",
      "y_axis_curve_type": "曲线类型",
      "y_axis_curve_factor": "曲线因子",
      "y_axis_effects_min_output": "最小输出 (dB)",
      "y_axis_effects_max_output": "最大输出 (dB)",
      "y_axis_effects_y_threshold": "Y轴阈值",
      "logarithmic": "对数",
      "s_curve": "S形曲线",
      "select_option": "选择选项",
      "no_options_found": "未找到选项",
      "error_loading_options": "加载选项错误。",
      "pad_modes_button": "模式",
      "pad_modes_button_title": "打击垫模式",
      "pad_modes_panel_title": "打击垫模式",
      "pad_mode_label": "打击垫模式",
      "pad_mode_select_title": "选择打击垫模式",
      "pad_mode_classic": "经典",
      "pad_mode_reactive": "反应",
      "reactive_mode_show_suggestions": "显示和声提示",
      "reactive_mode_suggestion_count": "提示数量",
      "no_specific_settings_classic": "经典模式无特定设置。",
      "no_specific_settings_reactive": "配置反应模式提示。",
      "pad_mode_rocket": "火箭",
      "rocket_highlight_active": "高亮活动音符",
      "rocket_show_markers": "显示方向标记",
      "rocket_marker_style": "标记样式",
      "rocket_valid_chords_only": "仅对有效和弦显示标记",
      "rocket_animate_fade": "动画标记淡出",
      "rocket_show_chord_name": "显示识别的和弦名称",
      "style_GlowFromNote": "音符发光",
      "style_WaveToNote": "波形至音符",
      "style_PulseRing": "脉冲环",
      "style_SparkTrail": "火花轨迹",
      "style_ShadowDrop": "音符下阴影",
      "rocket_mode_panel_title": "火箭模式",
      "rocket_mode_enable": "启用火箭模式",
      "rocket_mode_settings_placeholder": "火箭模式设置将显示在此处。",
      "error_loading_mode_settings": "加载模式设置错误。",
      "no_specific_settings_rocket": "配置火箭模式特定设置。",
      "reset_settings_button": "重置所有设置",
      "reload_app_button": "完全重载应用",
      "restart_audio_button": "重启音频引擎",
      "rocket_section_general": "通用",
      "rocket_section_phases": "阶段",
      "rocket_section_harmonic_logic": "和声逻辑",
      "rocket_section_interactive_behavior": "交互行为",
      "rocket_intensity": "强度",
      "rocket_visual_theme": "视觉主题",
      "rocket_auto_phases": "自动阶段",
      "rocket_harmonic_key": "和声调",
      "rocket_marker_logic": "标记逻辑",
      "marker_logic_tonal": "调性绑定",
      "marker_logic_adaptive": "自适应分析",
      "marker_logic_semi_free": "半自由",
      "marker_logic_random": "随机定向",
      "rocket_phase_ignition": "点火",
      "rocket_phase_lift_off": "升空",
      "rocket_phase_burst": "爆发",
      "rocket_phase_transition": "阶段转换",
      "phase_mode_activity": "按活动",
      "phase_mode_time": "按时间",
      "phase_mode_manual": "手动",
      "status_chord": "和弦",
      "status_key": "调性",
      "status_next": "下一个",
      "status_energy": "能量",
      "status_phase": "阶段",
      "status_na": "无",
      "rocket_presets_title": "模式预设",
      "rocket_select_preset": "选择预设",
      "rocket_select_preset_title": "选择火箭模式预设",
      "rocket_preset_current": "当前设置",
      "none_selected": "无",
      "preset_rocket_melodic_drift": "旋律漂移",
      "desc_rocket_melodic_drift": "温柔、漂浮、半自由的和声逻辑。",
      "preset_rocket_jazz_climb": "爵士攀升",
      "desc_rocket_jazz_climb": "活跃、自适应、爵士风格的逻辑。",
      "rocket_marker_labels": "标记标签",
      "labels_none": "无",
      "labels_function": "功能 (T/S/D)",
      "labels_chord_name": "和弦名称",
      "rocket_marker_retention": "标记保留",
      "desc_rocket_marker_retention": "在新触摸期间保持相关标记可见。",
      "desc_rocket_animate_fade": "平滑淡出不相关的标记。",
      "rocket_fade_delay": "淡出延迟",
      "desc_rocket_fade_delay": "标记开始淡出前的延迟。",
      "rocket_fade_duration": "淡出时长",
      "desc_rocket_fade_duration": "标记淡出动画的持续时间。",
      "rocket_max_markers_zone": "最大标记/区域",
      "desc_rocket_max_markers_zone": "每个区域显示的最大建议数。",
      "rocket_phase_styles": "阶段样式",
      "desc_rocket_phase_styles": "允许当前阶段覆盖标记样式。",
      "rocket_tb_in_key": "调性绑定：仅在调内",
      "desc_rocket_tb_in_key": "仅建议当前调内的音符/和弦。",
      "rocket_aa_autokey": "自适应分析：自动换调",
      "desc_rocket_aa_autokey": "允许根据输入自适应更改调性。",
      "rocket_sf_basekey": "半自由：基础调性",
      "desc_rocket_sf_basekey": "半自由模式的基础调性。",
      "rocket_sf_deviations": "半自由：模态偏差",
      "desc_rocket_sf_deviations": "允许临时偏离基础调性。",
      "rocket_sf_return": "半自由：高亮返回",
      "desc_rocket_sf_return": "高亮显示返回基础调性的建议。",
      "rocket_rd_randomlevel": "随机级别",
      "desc_rocket_rd_randomlevel": "建议中的随机性级别。",
      "select_chord": "选择和弦",
      "select_key": "选择调性",
      "select_phase": "选择阶段",
      "no_language_found": "未找到语言",
      "no_theme_found": "未找到主题",
      "no_visualizer_found": "未找到可视化工具",
      "no_touchEffect_found": "未找到触摸效果",
      "no_scale_found": "未找到音阶",
      "no_fxChain_found": "未找到效果链",
      "error_audio_fatal_restart": "严重音频错误。请重启应用。",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_preset": "保存新音色",
      "delete_preset": "删除音色",
      "synth_controls": "合成器控制",
      "synth_type": "合成器类型",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "振荡器类型",
      "sine": "正弦波",
      "square": "方波",
      "sawtooth": "锯齿波",
      "triangle": "三角波",
      "fat_sine": "Fat 正弦波",
      "fat_square": "Fat 方波",
      "fat_sawtooth": "Fat 锯齿波",
      "fat_triangle": "Fat 三角波",
      "fm_sine": "FM 正弦波",
      "fm_square": "FM 方波",
      "fm_sawtooth": "FM 锯齿波",
      "fm_triangle": "FM 三角波",
      "am_sine": "AM 正弦波",
      "am_square": "AM 方波",
      "am_sawtooth": "AM 锯齿波",
      "am_triangle": "AM 三角波",
      "pwm": "PWM",
      "pulse": "脉冲波",
      "noise_white": "白噪音",
      "noise_pink": "粉红噪音",
      "noise_brown": "布朗噪音",
      "oscillator_params": "振荡器参数",
      "phase": "相位",
      "count": "数量",
      "spread": "扩展度",
      "width": "宽度",
      "mod_freq_short": "调制频率",
      "harmonicity": "谐波性",
      "mod_index": "调制指数",
      "mod_type": "调制类型",
      "noise_type": "噪音类型",
      "envelope": "包络",
      "attack": "起音",
      "sustain": "持续",
      "release": "释音",
      "envelope_curves": "包络曲线",
      "attack_curve": "起音",
      "decay_curve": "衰减",
      "release_curve": "释音",
      "filter_advanced": "高级滤波器",
      "filter_rolloff": "滚降",
      "filter_gain": "增益 (dB)",
      "filter_envelope": "滤波器包络",
      "base_frequency": "基频",
      "exponent": "指数",
      "modulation": "调制",
      "modulation_envelope": "调制包络",
      "special_parameters": "特殊参数",
      "pitch_decay": "音高衰减",
      "attack_noise": "起音噪音",
      "dampening": "阻尼",
      "resonance": "共振",
      "lfo": "LFO",
      "lfo_type": "类型",
      "lfo_target": "目标",
      "lfo_min": "最小",
      "lfo_max": "最大",
      "save_preset_title": "保存音色预设",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_fx_chain_title": "保存效果链",
      "fx_chain_name_label": "效果链名称:",
      "fx_chain_name_placeholder": "我的效果链",
      "cancel": "取消",
      "save": "保存",
      "major": "大调",
      "minor": "小调",
      "pentatonic": "五声音阶",
      "blues": "布鲁斯",
      "chromatic": "半音阶",
      "dorian": "多利亚",
      "phrygian": "弗里几亚",
      "lydian": "利底亚",
      "mixolydian": "混合利底亚",
      "locrian": "洛克里亚",
      "day": "日间",
      "night": "夜间",
      "neon": "霓虹",
      "retro": "复古",
      "pastel": "粉彩",
      "aurora": "极光",
      "ocean": "海洋",
      "cyberpunk": "赛博朋克",
      "fire": "火焰",
      "matrix": "矩阵",
      "hologram": "全息图",
      "crystal": "水晶",
      "galaxy": "银河",
      "waves": "波形",
      "spectrum": "频谱",
      "particles": "鱼群",
      "nebula": "星云",
      "reactive_ripples": "反应涟漪",
      "touch_trails": "触摸轨迹",
      "loading": "加载中...",
      "initializing": "初始化中...",
      "loading_bridge": "连接中...",
      "loading_settings": "加载设置...",
      "loading_modules": "加载模块...",
      "loading_ui": "初始化UI...",
      "loading_presets": "应用设置...",
      "loading_audio": "加载声音...",
      "tap_to_start": "点击以启动音频",
      "starting_audio": "启动音频中...",
      "audio_suspended": "音频已暂停。点击以恢复。",
      "loading_preset": "加载预设...",
      "loading_fxchain": "加载效果链...",
      "saving_preset_progress": "保存预设中...",
      "saving_fxchain_progress": "保存效果链中...",
      "deleting_preset_progress": "删除预设中...",
      "deleting_fxchain_progress": "删除效果链中...",
      "hit_play_vibe": "点击播放，感受律动",
      "error_bridge_failed": "错误：桥接连接失败。",
      "error_init_failed": "初始化错误。请检查控制台。",
      "error_init_failed_details": "初始化错误: ${error}。请检查控制台。",
      "error_fatal_init": "严重初始化错误。请重启。",
      "error_audio_failed_retry": "启动音频错误。请再次点击。",
      "error_audio_resume": "无法恢复音频。",
      "error_apply_preset": "应用预设错误。",
      "error_apply_fxchain": "应用效果链错误。",
      "error_loading_presets": "加载预设错误。",
      "error_loading_fxchains": "加载效果链错误",
      "error_loading_effects_ui": "加载效果UI错误。",
      "no_presets_found": "未找到预设。",
      "no_fxchains_found": "未找到效果链",
      "no_effects_available": "无可用效果。",
      "enter_preset_name": "请输入预设名称。",
      "enter_fxchain_name": "请输入效果链名称。",
      "preset_saved_success": "预设 \"${name}\" 保存成功！",
      "fxchain_saved_success": "效果链 \"${name}\" 保存成功！",
      "error_saving_preset": "保存预设错误: ${error}",
      "error_saving_fxchain": "保存效果链错误: ${error}",
      "exception_saving_preset": "保存预设异常: ${error}",
      "exception_saving_fxchain": "保存效果链异常: ${error}",
      "confirm_delete_preset": "确定删除预设 \"${name}\" 吗？",
      "confirm_delete_fxchain": "确定删除效果链 \"${name}\" 吗？",
      "cannot_delete_default_preset": "无法删除默认预设。",
      "cannot_delete_default_fxchain": "无法删除默认效果链。",
      "preset_deleted_success": "预设已删除。",
      "fxchain_deleted_success": "效果链已删除。",
      "preset_delete_failed": "删除预设失败。",
      "fxchain_delete_failed": "删除效果链失败。",
      "exception_deleting_preset": "删除预设异常: ${error}",
      "exception_deleting_fxchain": "删除效果链异常: ${error}",
      "audio_not_ready_record": "音频未准备好。无法开始录制。",
      "pitch_envelope": "音高包络",
      "pitch_amount_cents": "量 (音分)",
      "macro_controls_title": "宏控制",
      "macro_space": "空间",
      "macro_time": "时间",
      "macro_motion": "动态",
      "macro_tone": "音色",
      "macro_drive": "驱动",
      "effects_intensity_min": "FX强度最小 (dB)",
      "effects_intensity_max": "FX强度最大 (dB)",
      "effects_threshold": "FX阈值",
      "none_fxchain": "-- 无 --",
      "none_touch_effect": "无",
      "restart_audio_engine_button": "重启音频",
      "reload_app_button_title": "重载应用",
      "reloading_app_message": "重新加载应用程序...",
      "master_output_title": "主输出",
      "master_volume_ceiling": "音量上限",
      "master_volume_ceiling_label": "音量上限",
      "y_axis_volume_min_output": "最小输出",
      "y_axis_volume_max_output": "最大输出",
      "y_axis_volume_y_threshold": "Y轴阈值",
      "y_axis_curve_type": "曲线类型",
      "y_axis_curve_factor": "曲线因子",
      "y_axis_effects_min_output": "最小输出 (dB)",
      "y_axis_effects_max_output": "最大输出 (dB)",
      "y_axis_effects_y_threshold": "Y轴阈值",
      "logarithmic": "对数",
      "s_curve": "S形曲线",
      "select_option": "选择选项",
      "no_options_found": "未找到选项",
      "error_loading_options": "加载选项错误。",
      "pad_modes_button": "模式",
      "pad_modes_button_title": "打击垫模式",
      "pad_modes_panel_title": "打击垫模式",
      "pad_mode_label": "打击垫模式",
      "pad_mode_select_title": "选择打击垫模式",
      "pad_mode_classic": "经典",
      "pad_mode_reactive": "反应",
      "reactive_mode_show_suggestions": "显示和声提示",
      "reactive_mode_suggestion_count": "提示数量",
      "no_specific_settings_classic": "经典模式无特定设置。",
      "no_specific_settings_reactive": "配置反应模式提示。",
      "pad_mode_rocket": "火箭",
      "rocket_highlight_active": "高亮活动音符",
      "rocket_show_markers": "显示方向标记",
      "rocket_marker_style": "标记样式",
      "rocket_valid_chords_only": "仅对有效和弦显示标记",
      "rocket_animate_fade": "动画标记淡出",
      "rocket_show_chord_name": "显示识别的和弦名称",
      "style_GlowFromNote": "音符发光",
      "style_WaveToNote": "波形至音符",
      "style_PulseRing": "脉冲环",
      "style_SparkTrail": "火花轨迹",
      "style_ShadowDrop": "音符下阴影",
      "rocket_mode_panel_title": "火箭模式",
      "rocket_mode_enable": "启用火箭模式",
      "rocket_mode_settings_placeholder": "火箭模式设置将显示在此处。",
      "error_loading_mode_settings": "加载模式设置错误。",
      "no_specific_settings_rocket": "配置火箭模式特定设置。",
      "reset_settings_button": "重置所有设置",
      "reload_app_button": "完全重载应用",
      "restart_audio_button": "重启音频引擎",
      "rocket_section_general": "通用",
      "rocket_section_phases": "阶段",
      "rocket_section_harmonic_logic": "和声逻辑",
      "rocket_section_interactive_behavior": "交互行为",
      "rocket_intensity": "强度",
      "rocket_visual_theme": "视觉主题",
      "rocket_auto_phases": "自动阶段",
      "rocket_harmonic_key": "和声调",
      "rocket_marker_logic": "标记逻辑",
      "marker_logic_tonal": "调性绑定",
      "marker_logic_adaptive": "自适应分析",
      "marker_logic_semi_free": "半自由",
      "marker_logic_random": "随机定向",
      "rocket_phase_ignition": "点火",
      "rocket_phase_lift_off": "升空",
      "rocket_phase_burst": "爆发",
      "rocket_phase_transition": "阶段转换",
      "phase_mode_activity": "按活动",
      "phase_mode_time": "按时间",
      "phase_mode_manual": "手动",
      "status_chord": "和弦",
      "status_key": "调性",
      "status_next": "下一个",
      "status_energy": "能量",
      "status_phase": "阶段",
      "status_na": "无",
      "rocket_presets_title": "模式预设",
      "rocket_select_preset": "选择预设",
      "rocket_select_preset_title": "选择火箭模式预设",
      "rocket_preset_current": "当前设置",
      "none_selected": "无",
      "preset_rocket_melodic_drift": "旋律漂移",
      "desc_rocket_melodic_drift": "温柔、漂浮、半自由的和声逻辑。",
      "preset_rocket_jazz_climb": "爵士攀升",
      "desc_rocket_jazz_climb": "活跃、自适应、爵士风格的逻辑。",
      "rocket_marker_labels": "标记标签",
      "labels_none": "无",
      "labels_function": "功能 (T/S/D)",
      "labels_chord_name": "和弦名称",
      "rocket_marker_retention": "标记保留",
      "desc_rocket_marker_retention": "在新触摸期间保持相关标记可见。",
      "desc_rocket_animate_fade": "平滑淡出不相关的标记。",
      "rocket_fade_delay": "淡出延迟",
      "desc_rocket_fade_delay": "标记开始淡出前的延迟。",
      "rocket_fade_duration": "淡出时长",
      "desc_rocket_fade_duration": "标记淡出动画的持续时间。",
      "rocket_max_markers_zone": "最大标记/区域",
      "desc_rocket_max_markers_zone": "每个区域显示的最大建议数。",
      "rocket_phase_styles": "阶段样式",
      "desc_rocket_phase_styles": "允许当前阶段覆盖标记样式。",
      "rocket_tb_in_key": "调性绑定：仅在调内",
      "desc_rocket_tb_in_key": "仅建议当前调内的音符/和弦。",
      "rocket_aa_autokey": "自适应分析：自动换调",
      "desc_rocket_aa_autokey": "允许根据输入自适应更改调性。",
      "rocket_sf_basekey": "半自由：基础调性",
      "desc_rocket_sf_basekey": "半自由模式的基础调性。",
      "rocket_sf_deviations": "半自由：模态偏差",
      "desc_rocket_sf_deviations": "允许临时偏离基础调性。",
      "rocket_sf_return": "半自由：高亮返回",
      "desc_rocket_sf_return": "高亮显示返回基础调性的建议。",
      "rocket_rd_randomlevel": "随机级别",
      "desc_rocket_rd_randomlevel": "建议中的随机性级别。",
      "select_chord": "选择和弦",
      "select_key": "选择调性",
      "select_phase": "选择阶段",
      "no_language_found": "未找到语言",
      "no_theme_found": "未找到主题",
      "no_visualizer_found": "未找到可视化工具",
      "no_touchEffect_found": "未找到触摸效果",
      "no_scale_found": "未找到音阶",
      "no_fxChain_found": "未找到效果链",
      "error_audio_fatal_restart": "严重音频错误。请重启应用。",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_preset": "保存新音色",
      "delete_preset": "删除音色",
      "synth_controls": "合成器控制",
      "synth_type": "合成器类型",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "振荡器类型",
      "sine": "正弦波",
      "square": "方波",
      "sawtooth": "锯齿波",
      "triangle": "三角波",
      "fat_sine": "Fat 正弦波",
      "fat_square": "Fat 方波",
      "fat_sawtooth": "Fat 锯齿波",
      "fat_triangle": "Fat 三角波",
      "fm_sine": "FM 正弦波",
      "fm_square": "FM 方波",
      "fm_sawtooth": "FM 锯齿波",
      "fm_triangle": "FM 三角波",
      "am_sine": "AM 正弦波",
      "am_square": "AM 方波",
      "am_sawtooth": "AM 锯齿波",
      "am_triangle": "AM 三角波",
      "pwm": "PWM",
      "pulse": "脉冲波",
      "noise_white": "白噪音",
      "noise_pink": "粉红噪音",
      "noise_brown": "布朗噪音",
      "oscillator_params": "振荡器参数",
      "phase": "相位",
      "count": "数量",
      "spread": "扩展度",
      "width": "宽度",
      "mod_freq_short": "调制频率",
      "harmonicity": "谐波性",
      "mod_index": "调制指数",
      "mod_type": "调制类型",
      "noise_type": "噪音类型",
      "envelope": "包络",
      "attack": "起音",
      "sustain": "持续",
      "release": "释音",
      "envelope_curves": "包络曲线",
      "attack_curve": "起音",
      "decay_curve": "衰减",
      "release_curve": "释音",
      "filter_advanced": "高级滤波器",
      "filter_rolloff": "滚降",
      "filter_gain": "增益 (dB)",
      "filter_envelope": "滤波器包络",
      "base_frequency": "基频",
      "exponent": "指数",
      "modulation": "调制",
      "modulation_envelope": "调制包络",
      "special_parameters": "特殊参数",
      "pitch_decay": "音高衰减",
      "attack_noise": "起音噪音",
      "dampening": "阻尼",
      "resonance": "共振",
      "lfo": "LFO",
      "lfo_type": "类型",
      "lfo_target": "目标",
      "lfo_min": "最小",
      "lfo_max": "最大",
      "save_preset_title": "保存音色预设",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_fx_chain_title": "保存效果链",
      "fx_chain_name_label": "效果链名称:",
      "fx_chain_name_placeholder": "我的效果链",
      "cancel": "取消",
      "save": "保存",
      "major": "大调",
      "minor": "小调",
      "pentatonic": "五声音阶",
      "blues": "布鲁斯",
      "chromatic": "半音阶",
      "dorian": "多利亚",
      "phrygian": "弗里几亚",
      "lydian": "利底亚",
      "mixolydian": "混合利底亚",
      "locrian": "洛克里亚",
      "day": "日间",
      "night": "夜间",
      "neon": "霓虹",
      "retro": "复古",
      "pastel": "粉彩",
      "aurora": "极光",
      "ocean": "海洋",
      "cyberpunk": "赛博朋克",
      "fire": "火焰",
      "matrix": "矩阵",
      "hologram": "全息图",
      "crystal": "水晶",
      "galaxy": "银河",
      "waves": "波形",
      "spectrum": "频谱",
      "particles": "鱼群",
      "nebula": "星云",
      "reactive_ripples": "反应涟漪",
      "touch_trails": "触摸轨迹",
      "loading": "加载中...",
      "initializing": "初始化中...",
      "loading_bridge": "连接中...",
      "loading_settings": "加载设置...",
      "loading_modules": "加载模块...",
      "loading_ui": "初始化UI...",
      "loading_presets": "应用设置...",
      "loading_audio": "加载声音...",
      "tap_to_start": "点击以启动音频",
      "starting_audio": "启动音频中...",
      "audio_suspended": "音频已暂停。点击以恢复。",
      "loading_preset": "加载预设...",
      "loading_fxchain": "加载效果链...",
      "saving_preset_progress": "保存预设中...",
      "saving_fxchain_progress": "保存效果链中...",
      "deleting_preset_progress": "删除预设中...",
      "deleting_fxchain_progress": "删除效果链中...",
      "hit_play_vibe": "点击播放，感受律动",
      "error_bridge_failed": "错误：桥接连接失败。",
      "error_init_failed": "初始化错误。请检查控制台。",
      "error_init_failed_details": "初始化错误: ${error}。请检查控制台。",
      "error_fatal_init": "严重初始化错误。请重启。",
      "error_audio_failed_retry": "启动音频错误。请再次点击。",
      "error_audio_resume": "无法恢复音频。",
      "error_apply_preset": "应用预设错误。",
      "error_apply_fxchain": "应用效果链错误。",
      "error_loading_presets": "加载预设错误。",
      "error_loading_fxchains": "加载效果链错误",
      "error_loading_effects_ui": "加载效果UI错误。",
      "no_presets_found": "未找到预设。",
      "no_fxchains_found": "未找到效果链",
      "no_effects_available": "无可用效果。",
      "enter_preset_name": "请输入预设名称。",
      "enter_fxchain_name": "请输入效果链名称。",
      "preset_saved_success": "预设 \"${name}\" 保存成功！",
      "fxchain_saved_success": "效果链 \"${name}\" 保存成功！",
      "error_saving_preset": "保存预设错误: ${error}",
      "error_saving_fxchain": "保存效果链错误: ${error}",
      "exception_saving_preset": "保存预设异常: ${error}",
      "exception_saving_fxchain": "保存效果链异常: ${error}",
      "confirm_delete_preset": "确定删除预设 \"${name}\" 吗？",
      "confirm_delete_fxchain": "确定删除效果链 \"${name}\" 吗？",
      "cannot_delete_default_preset": "无法删除默认预设。",
      "cannot_delete_default_fxchain": "无法删除默认效果链。",
      "preset_deleted_success": "预设已删除。",
      "fxchain_deleted_success": "效果链已删除。",
      "preset_delete_failed": "删除预设失败。",
      "fxchain_delete_failed": "删除效果链失败。",
      "exception_deleting_preset": "删除预设异常: ${error}",
      "exception_deleting_fxchain": "删除效果链异常: ${error}",
      "audio_not_ready_record": "音频未准备好。无法开始录制。",
      "pitch_envelope": "音高包络",
      "pitch_amount_cents": "量 (音分)",
      "macro_controls_title": "宏控制",
      "macro_space": "空间",
      "macro_time": "时间",
      "macro_motion": "动态",
      "macro_tone": "音色",
      "macro_drive": "驱动",
      "effects_intensity_min": "FX强度最小 (dB)",
      "effects_intensity_max": "FX强度最大 (dB)",
      "effects_threshold": "FX阈值",
      "none_fxchain": "-- 无 --",
      "none_touch_effect": "无",
      "restart_audio_engine_button": "重启音频",
      "reload_app_button_title": "重载应用",
      "reloading_app_message": "重新加载应用程序...",
      "master_output_title": "主输出",
      "master_volume_ceiling": "音量上限",
      "master_volume_ceiling_label": "音量上限",
      "y_axis_volume_min_output": "最小输出",
      "y_axis_volume_max_output": "最大输出",
      "y_axis_volume_y_threshold": "Y轴阈值",
      "y_axis_curve_type": "曲线类型",
      "y_axis_curve_factor": "曲线因子",
      "y_axis_effects_min_output": "最小输出 (dB)",
      "y_axis_effects_max_output": "最大输出 (dB)",
      "y_axis_effects_y_threshold": "Y轴阈值",
      "logarithmic": "对数",
      "s_curve": "S形曲线",
      "select_option": "选择选项",
      "no_options_found": "未找到选项",
      "error_loading_options": "加载选项错误。",
      "pad_modes_button": "模式",
      "pad_modes_button_title": "打击垫模式",
      "pad_modes_panel_title": "打击垫模式",
      "pad_mode_label": "打击垫模式",
      "pad_mode_select_title": "选择打击垫模式",
      "pad_mode_classic": "经典",
      "pad_mode_reactive": "反应",
      "reactive_mode_show_suggestions": "显示和声提示",
      "reactive_mode_suggestion_count": "提示数量",
      "no_specific_settings_classic": "经典模式无特定设置。",
      "no_specific_settings_reactive": "配置反应模式提示。",
      "pad_mode_rocket": "火箭",
      "rocket_highlight_active": "高亮活动音符",
      "rocket_show_markers": "显示方向标记",
      "rocket_marker_style": "标记样式",
      "rocket_valid_chords_only": "仅对有效和弦显示标记",
      "rocket_animate_fade": "动画标记淡出",
      "rocket_show_chord_name": "显示识别的和弦名称",
      "style_GlowFromNote": "音符发光",
      "style_WaveToNote": "波形至音符",
      "style_PulseRing": "脉冲环",
      "style_SparkTrail": "火花轨迹",
      "style_ShadowDrop": "音符下阴影",
      "rocket_mode_panel_title": "火箭模式",
      "rocket_mode_enable": "启用火箭模式",
      "rocket_mode_settings_placeholder": "火箭模式设置将显示在此处。",
      "error_loading_mode_settings": "加载模式设置错误。",
      "no_specific_settings_rocket": "配置火箭模式特定设置。",
      "reset_settings_button": "重置所有设置",
      "reload_app_button": "完全重载应用",
      "restart_audio_button": "重启音频引擎",
      "rocket_section_general": "通用",
      "rocket_section_phases": "阶段",
      "rocket_section_harmonic_logic": "和声逻辑",
      "rocket_section_interactive_behavior": "交互行为",
      "rocket_intensity": "强度",
      "rocket_visual_theme": "视觉主题",
      "rocket_auto_phases": "自动阶段",
      "rocket_harmonic_key": "和声调",
      "rocket_marker_logic": "标记逻辑",
      "marker_logic_tonal": "调性绑定",
      "marker_logic_adaptive": "自适应分析",
      "marker_logic_semi_free": "半自由",
      "marker_logic_random": "随机定向",
      "rocket_phase_ignition": "点火",
      "rocket_phase_lift_off": "升空",
      "rocket_phase_burst": "爆发",
      "rocket_phase_transition": "阶段转换",
      "phase_mode_activity": "按活动",
      "phase_mode_time": "按时间",
      "phase_mode_manual": "手动",
      "status_chord": "和弦",
      "status_key": "调性",
      "status_next": "下一个",
      "status_energy": "能量",
      "status_phase": "阶段",
      "status_na": "无",
      "rocket_presets_title": "模式预设",
      "rocket_select_preset": "选择预设",
      "rocket_select_preset_title": "选择火箭模式预设",
      "rocket_preset_current": "当前设置",
      "none_selected": "无",
      "preset_rocket_melodic_drift": "旋律漂移",
      "desc_rocket_melodic_drift": "温柔、漂浮、半自由的和声逻辑。",
      "preset_rocket_jazz_climb": "爵士攀升",
      "desc_rocket_jazz_climb": "活跃、自适应、爵士风格的逻辑。",
      "rocket_marker_labels": "标记标签",
      "labels_none": "无",
      "labels_function": "功能 (T/S/D)",
      "labels_chord_name": "和弦名称",
      "rocket_marker_retention": "标记保留",
      "desc_rocket_marker_retention": "在新触摸期间保持相关标记可见。",
      "desc_rocket_animate_fade": "平滑淡出不相关的标记。",
      "rocket_fade_delay": "淡出延迟",
      "desc_rocket_fade_delay": "标记开始淡出前的延迟。",
      "rocket_fade_duration": "淡出时长",
      "desc_rocket_fade_duration": "标记淡出动画的持续时间。",
      "rocket_max_markers_zone": "最大标记/区域",
      "desc_rocket_max_markers_zone": "每个区域显示的最大建议数。",
      "rocket_phase_styles": "阶段样式",
      "desc_rocket_phase_styles": "允许当前阶段覆盖标记样式。",
      "rocket_tb_in_key": "调性绑定：仅在调内",
      "desc_rocket_tb_in_key": "仅建议当前调内的音符/和弦。",
      "rocket_aa_autokey": "自适应分析：自动换调",
      "desc_rocket_aa_autokey": "允许根据输入自适应更改调性。",
      "rocket_sf_basekey": "半自由：基础调性",
      "desc_rocket_sf_basekey": "半自由模式的基础调性。",
      "rocket_sf_deviations": "半自由：模态偏差",
      "desc_rocket_sf_deviations": "允许临时偏离基础调性。",
      "rocket_sf_return": "半自由：高亮返回",
      "desc_rocket_sf_return": "高亮显示返回基础调性的建议。",
      "rocket_rd_randomlevel": "随机级别",
      "desc_rocket_rd_randomlevel": "建议中的随机性级别。",
      "select_chord": "选择和弦",
      "select_key": "选择调性",
      "select_phase": "选择阶段",
      "no_language_found": "未找到语言",
      "no_theme_found": "未找到主题",
      "no_visualizer_found": "未找到可视化工具",
      "no_touchEffect_found": "未找到触摸效果",
      "no_scale_found": "未找到音阶",
      "no_fxChain_found": "未找到效果链",
      "error_audio_fatal_restart": "严重音频错误。请重启应用。",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_preset": "保存新音色",
      "delete_preset": "删除音色",
      "synth_controls": "合成器控制",
      "synth_type": "合成器类型",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "振荡器类型",
      "sine": "正弦波",
      "square": "方波",
      "sawtooth": "锯齿波",
      "triangle": "三角波",
      "fat_sine": "Fat 正弦波",
      "fat_square": "Fat 方波",
      "fat_sawtooth": "Fat 锯齿波",
      "fat_triangle": "Fat 三角波",
      "fm_sine": "FM 正弦波",
      "fm_square": "FM 方波",
      "fm_sawtooth": "FM 锯齿波",
      "fm_triangle": "FM 三角波",
      "am_sine": "AM 正弦波",
      "am_square": "AM 方波",
      "am_sawtooth": "AM 锯齿波",
      "am_triangle": "AM 三角波",
      "pwm": "PWM",
      "pulse": "脉冲波",
      "noise_white": "白噪音",
      "noise_pink": "粉红噪音",
      "noise_brown": "布朗噪音",
      "oscillator_params": "振荡器参数",
      "phase": "相位",
      "count": "数量",
      "spread": "扩展度",
      "width": "宽度",
      "mod_freq_short": "调制频率",
      "harmonicity": "谐波性",
      "mod_index": "调制指数",
      "mod_type": "调制类型",
      "noise_type": "噪音类型",
      "envelope": "包络",
      "attack": "起音",
      "sustain": "持续",
      "release": "释音",
      "envelope_curves": "包络曲线",
      "attack_curve": "起音",
      "decay_curve": "衰减",
      "release_curve": "释音",
      "filter_advanced": "高级滤波器",
      "filter_rolloff": "滚降",
      "filter_gain": "增益 (dB)",
      "filter_envelope": "滤波器包络",
      "base_frequency": "基频",
      "exponent": "指数",
      "modulation": "调制",
      "modulation_envelope": "调制包络",
      "special_parameters": "特殊参数",
      "pitch_decay": "音高衰减",
      "attack_noise": "起音噪音",
      "dampening": "阻尼",
      "resonance": "共振",
      "lfo": "LFO",
      "lfo_type": "类型",
      "lfo_target": "目标",
      "lfo_min": "最小",
      "lfo_max": "最大",
      "save_preset_title": "保存音色预设",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_fx_chain_title": "保存效果链",
      "fx_chain_name_label": "效果链名称:",
      "fx_chain_name_placeholder": "我的效果链",
      "cancel": "取消",
      "save": "保存",
      "major": "大调",
      "minor": "小调",
      "pentatonic": "五声音阶",
      "blues": "布鲁斯",
      "chromatic": "半音阶",
      "dorian": "多利亚",
      "phrygian": "弗里几亚",
      "lydian": "利底亚",
      "mixolydian": "混合利底亚",
      "locrian": "洛克里亚",
      "day": "日间",
      "night": "夜间",
      "neon": "霓虹",
      "retro": "复古",
      "pastel": "粉彩",
      "aurora": "极光",
      "ocean": "海洋",
      "cyberpunk": "赛博朋克",
      "fire": "火焰",
      "matrix": "矩阵",
      "hologram": "全息图",
      "crystal": "水晶",
      "galaxy": "银河",
      "waves": "波形",
      "spectrum": "频谱",
      "particles": "鱼群",
      "nebula": "星云",
      "reactive_ripples": "反应涟漪",
      "touch_trails": "触摸轨迹",
      "loading": "加载中...",
      "initializing": "初始化中...",
      "loading_bridge": "连接中...",
      "loading_settings": "加载设置...",
      "loading_modules": "加载模块...",
      "loading_ui": "初始化UI...",
      "loading_presets": "应用设置...",
      "loading_audio": "加载声音...",
      "tap_to_start": "点击以启动音频",
      "starting_audio": "启动音频中...",
      "audio_suspended": "音频已暂停。点击以恢复。",
      "loading_preset": "加载预设...",
      "loading_fxchain": "加载效果链...",
      "saving_preset_progress": "保存预设中...",
      "saving_fxchain_progress": "保存效果链中...",
      "deleting_preset_progress": "删除预设中...",
      "deleting_fxchain_progress": "删除效果链中...",
      "hit_play_vibe": "点击播放，感受律动",
      "error_bridge_failed": "错误：桥接连接失败。",
      "error_init_failed": "初始化错误。请检查控制台。",
      "error_init_failed_details": "初始化错误: ${error}。请检查控制台。",
      "error_fatal_init": "严重初始化错误。请重启。",
      "error_audio_failed_retry": "启动音频错误。请再次点击。",
      "error_audio_resume": "无法恢复音频。",
      "error_apply_preset": "应用预设错误。",
      "error_apply_fxchain": "应用效果链错误。",
      "error_loading_presets": "加载预设错误。",
      "error_loading_fxchains": "加载效果链错误",
      "error_loading_effects_ui": "加载效果UI错误。",
      "no_presets_found": "未找到预设。",
      "no_fxchains_found": "未找到效果链",
      "no_effects_available": "无可用效果。",
      "enter_preset_name": "请输入预设名称。",
      "enter_fxchain_name": "请输入效果链名称。",
      "preset_saved_success": "预设 \"${name}\" 保存成功！",
      "fxchain_saved_success": "效果链 \"${name}\" 保存成功！",
      "error_saving_preset": "保存预设错误: ${error}",
      "error_saving_fxchain": "保存效果链错误: ${error}",
      "exception_saving_preset": "保存预设异常: ${error}",
      "exception_saving_fxchain": "保存效果链异常: ${error}",
      "confirm_delete_preset": "确定删除预设 \"${name}\" 吗？",
      "confirm_delete_fxchain": "确定删除效果链 \"${name}\" 吗？",
      "cannot_delete_default_preset": "无法删除默认预设。",
      "cannot_delete_default_fxchain": "无法删除默认效果链。",
      "preset_deleted_success": "预设已删除。",
      "fxchain_deleted_success": "效果链已删除。",
      "preset_delete_failed": "删除预设失败。",
      "fxchain_delete_failed": "删除效果链失败。",
      "exception_deleting_preset": "删除预设异常: ${error}",
      "exception_deleting_fxchain": "删除效果链异常: ${error}",
      "audio_not_ready_record": "音频未准备好。无法开始录制。",
      "pitch_envelope": "音高包络",
      "pitch_amount_cents": "量 (音分)",
      "macro_controls_title": "宏控制",
      "macro_space": "空间",
      "macro_time": "时间",
      "macro_motion": "动态",
      "macro_tone": "音色",
      "macro_drive": "驱动",
      "effects_intensity_min": "FX强度最小 (dB)",
      "effects_intensity_max": "FX强度最大 (dB)",
      "effects_threshold": "FX阈值",
      "none_fxchain": "-- 无 --",
      "none_touch_effect": "无",
      "restart_audio_engine_button": "重启音频",
      "reload_app_button_title": "重载应用",
      "reloading_app_message": "重新加载应用程序...",
      "master_output_title": "主输出",
      "master_volume_ceiling": "音量上限",
      "master_volume_ceiling_label": "音量上限",
      "y_axis_volume_min_output": "最小输出",
      "y_axis_volume_max_output": "最大输出",
      "y_axis_volume_y_threshold": "Y轴阈值",
      "y_axis_curve_type": "曲线类型",
      "y_axis_curve_factor": "曲线因子",
      "y_axis_effects_min_output": "最小输出 (dB)",
      "y_axis_effects_max_output": "最大输出 (dB)",
      "y_axis_effects_y_threshold": "Y轴阈值",
      "logarithmic": "对数",
      "s_curve": "S形曲线",
      "select_option": "选择选项",
      "no_options_found": "未找到选项",
      "error_loading_options": "加载选项错误。",
      "pad_modes_button": "模式",
      "pad_modes_button_title": "打击垫模式",
      "pad_modes_panel_title": "打击垫模式",
      "pad_mode_label": "打击垫模式",
      "pad_mode_select_title": "选择打击垫模式",
      "pad_mode_classic": "经典",
      "pad_mode_reactive": "反应",
      "reactive_mode_show_suggestions": "显示和声提示",
      "reactive_mode_suggestion_count": "提示数量",
      "no_specific_settings_classic": "经典模式无特定设置。",
      "no_specific_settings_reactive": "配置反应模式提示。",
      "pad_mode_rocket": "火箭",
      "rocket_highlight_active": "高亮活动音符",
      "rocket_show_markers": "显示方向标记",
      "rocket_marker_style": "标记样式",
      "rocket_valid_chords_only": "仅对有效和弦显示标记",
      "rocket_animate_fade": "动画标记淡出",
      "rocket_show_chord_name": "显示识别的和弦名称",
      "style_GlowFromNote": "音符发光",
      "style_WaveToNote": "波形至音符",
      "style_PulseRing": "脉冲环",
      "style_SparkTrail": "火花轨迹",
      "style_ShadowDrop": "音符下阴影",
      "rocket_mode_panel_title": "火箭模式",
      "rocket_mode_enable": "启用火箭模式",
      "rocket_mode_settings_placeholder": "火箭模式设置将显示在此处。",
      "error_loading_mode_settings": "加载模式设置错误。",
      "no_specific_settings_rocket": "配置火箭模式特定设置。",
      "reset_settings_button": "重置所有设置",
      "reload_app_button": "完全重载应用",
      "restart_audio_button": "重启音频引擎",
      "rocket_section_general": "通用",
      "rocket_section_phases": "阶段",
      "rocket_section_harmonic_logic": "和声逻辑",
      "rocket_section_interactive_behavior": "交互行为",
      "rocket_intensity": "强度",
      "rocket_visual_theme": "视觉主题",
      "rocket_auto_phases": "自动阶段",
      "rocket_harmonic_key": "和声调",
      "rocket_marker_logic": "标记逻辑",
      "marker_logic_tonal": "调性绑定",
      "marker_logic_adaptive": "自适应分析",
      "marker_logic_semi_free": "半自由",
      "marker_logic_random": "随机定向",
      "rocket_phase_ignition": "点火",
      "rocket_phase_lift_off": "升空",
      "rocket_phase_burst": "爆发",
      "rocket_phase_transition": "阶段转换",
      "phase_mode_activity": "按活动",
      "phase_mode_time": "按时间",
      "phase_mode_manual": "手动",
      "status_chord": "和弦",
      "status_key": "调性",
      "status_next": "下一个",
      "status_energy": "能量",
      "status_phase": "阶段",
      "status_na": "无",
      "rocket_presets_title": "模式预设",
      "rocket_select_preset": "选择预设",
      "rocket_select_preset_title": "选择火箭模式预设",
      "rocket_preset_current": "当前设置",
      "none_selected": "无",
      "preset_rocket_melodic_drift": "旋律漂移",
      "desc_rocket_melodic_drift": "温柔、漂浮、半自由的和声逻辑。",
      "preset_rocket_jazz_climb": "爵士攀升",
      "desc_rocket_jazz_climb": "活跃、自适应、爵士风格的逻辑。",
      "rocket_marker_labels": "标记标签",
      "labels_none": "无",
      "labels_function": "功能 (T/S/D)",
      "labels_chord_name": "和弦名称",
      "rocket_marker_retention": "标记保留",
      "desc_rocket_marker_retention": "在新触摸期间保持相关标记可见。",
      "desc_rocket_animate_fade": "平滑淡出不相关的标记。",
      "rocket_fade_delay": "淡出延迟",
      "desc_rocket_fade_delay": "标记开始淡出前的延迟。",
      "rocket_fade_duration": "淡出时长",
      "desc_rocket_fade_duration": "标记淡出动画的持续时间。",
      "rocket_max_markers_zone": "最大标记/区域",
      "desc_rocket_max_markers_zone": "每个区域显示的最大建议数。",
      "rocket_phase_styles": "阶段样式",
      "desc_rocket_phase_styles": "允许当前阶段覆盖标记样式。",
      "rocket_tb_in_key": "调性绑定：仅在调内",
      "desc_rocket_tb_in_key": "仅建议当前调内的音符/和弦。",
      "rocket_aa_autokey": "自适应分析：自动换调",
      "desc_rocket_aa_autokey": "允许根据输入自适应更改调性。",
      "rocket_sf_basekey": "半自由：基础调性",
      "desc_rocket_sf_basekey": "半自由模式的基础调性。",
      "rocket_sf_deviations": "半自由：模态偏差",
      "desc_rocket_sf_deviations": "允许临时偏离基础调性。",
      "rocket_sf_return": "半自由：高亮返回",
      "desc_rocket_sf_return": "高亮显示返回基础调性的建议。",
      "rocket_rd_randomlevel": "随机级别",
      "desc_rocket_rd_randomlevel": "建议中的随机性级别。",
      "select_chord": "选择和弦",
      "select_key": "选择调性",
      "select_phase": "选择阶段",
      "no_language_found": "未找到语言",
      "no_theme_found": "未找到主题",
      "no_visualizer_found": "未找到可视化工具",
      "no_touchEffect_found": "未找到触摸效果",
      "no_scale_found": "未找到音阶",
      "no_fxChain_found": "未找到效果链",
      "error_audio_fatal_restart": "严重音频错误。请重启应用。",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_preset": "保存新音色",
      "delete_preset": "删除音色",
      "synth_controls": "合成器控制",
      "synth_type": "合成器类型",
      "synth_basic": "Synth",
      "synth_mono": "MonoSynth",
      "synth_fm": "FMSynth",
      "synth_am": "AMSynth",
      "synth_duo": "DuoSynth",
      "synth_membrane": "MembraneSynth",
      "synth_metal": "MetalSynth",
      "synth_pluck": "PluckSynth",
      "synth_noise": "NoiseSynth",
      "oscillator_type": "振荡器类型",
      "sine": "正弦波",
      "square": "方波",
      "sawtooth": "锯齿波",
      "triangle": "三角波",
      "fat_sine": "Fat 正弦波",
      "fat_square": "Fat 方波",
      "fat_sawtooth": "Fat 锯齿波",
      "fat_triangle": "Fat 三角波",
      "fm_sine": "FM 正弦波",
      "fm_square": "FM 方波",
      "fm_sawtooth": "FM 锯齿波",
      "fm_triangle": "FM 三角波",
      "am_sine": "AM 正弦波",
      "am_square": "AM 方波",
      "am_sawtooth": "AM 锯齿波",
      "am_triangle": "AM 三角波",
      "pwm": "PWM",
      "pulse": "脉冲波",
      "noise_white": "白噪音",
      "noise_pink": "粉红噪音",
      "noise_brown": "布朗噪音",
      "oscillator_params": "振荡器参数",
      "phase": "相位",
      "count": "数量",
      "spread": "扩展度",
      "width": "宽度",
      "mod_freq_short": "调制频率",
      "harmonicity": "谐波性",
      "mod_index": "调制指数",
      "mod_type": "调制类型",
      "noise_type": "噪音类型",
      "envelope": "包络",
      "attack": "起音",
      "sustain": "持续",
      "release": "释音",
      "envelope_curves": "包络曲线",
      "attack_curve": "起音",
      "decay_curve": "衰减",
      "release_curve": "释音",
      "filter_advanced": "高级滤波器",
      "filter_rolloff": "滚降",
      "filter_gain": "增益 (dB)",
      "filter_envelope": "滤波器包络",
      "base_frequency": "基频",
      "exponent": "指数",
      "modulation": "调制",
      "modulation_envelope": "调制包络",
      "special_parameters": "特殊参数",
      "pitch_decay": "音高衰减",
      "attack_noise": "起音噪音",
      "dampening": "阻尼",
      "resonance": "共振",
      "lfo": "LFO",
      "lfo_type": "类型",
      "lfo_target": "目标",
      "lfo_min": "最小",
      "lfo_max": "最大",
      "save_preset_title": "保存音色预设",
      "preset_name_label": "预设名称:",
      "preset_name_placeholder": "我的音色预设",
      "save_fx_chain_title": "保存效果链",
      "fx_chain_name_label": "效果链名称:",
      "fx_chain_name_placeholder": "我的效果链",
      "cancel": "取消",
      "save": "保存",
      "major": "大调",
      "minor": "小调",
      "pentatonic": "五声音阶",
      "blues": "布鲁斯",
      "chromatic": "半音阶",
      "dorian": "多利亚",
      "phrygian": "弗里几亚",
      "lydian": "利底亚",
      "mixolydian": "混合利底亚",
      "locrian": "洛克里亚",
      "day": "日间",
      "night": "夜间",
      "neon": "霓虹",
      "retro": "复古",
      "pastel": "粉彩",
      "aurora": "极光",
      "ocean": "海洋",
      "cyberpunk": "赛博朋克",
      "fire": "火焰",
      "matrix": "矩阵",
      "hologram": "全息图",
      "crystal": "水晶",
      "galaxy": "银河",
      "waves": "波形",
      "spectrum": "频谱",
      "particles": "鱼群",
      "nebula": "星云",
      "reactive_ripples": "反应涟漪",
      "touch_trails": "触摸轨迹",
      "loading": "加载中...",
      "initializing": "初始化中...",
      "loading_bridge": "连接中...",
      "loading_settings": "加载设置...",
      "loading_modules": "加载模块...",
      "loading_ui": "初始化UI...",
      "loading_presets": "应用设置...",
      "loading_audio": "加载声音...",
      "tap_to_start": "点击以启动音频",
      "starting_audio": "启动音频中...",
      "audio_suspended": "音频已暂停。点击以恢复。",
      "loading_preset": "加载预设...",
      "loading_fxchain": "加载效果链...",
      "saving_preset_progress": "保存预设中...",
      "saving_fxchain_progress": "保存效果链中...",
      "deleting_preset_progress": "删除预设中...",
      "deleting_fxchain_progress": "删除效果链中...",
      "hit_play_vibe": "点击播放，感受律动",
      "error_bridge_failed": "错误：桥接连接失败。",
      "error_init_failed": "初始化错误。请检查控制台。",
      "error_init_failed_details": "初始化错误: ${error}。请检查控制台。",
      "error_fatal_init": "严重初始化错误。请重启。",
      "error_audio_failed_retry": "启动音频错误。请再次点击。",
      "error_audio_resume": "无法恢复音频。",
      "error_apply_preset": "应用预设错误。",
      "error_apply_fxchain": "应用效果链错误。",
      "error_loading_presets": "加载预设错误。",
      "error_loading_fxchains": "加载效果链错误",
      "error_loading_effects_ui": "加载效果UI错误。",
      "no_presets_found": "未找到预设。",
      "no_fxchains_found": "未找到效果链",
      "no_effects_available": "无可用效果。",
      "enter_preset_name": "请输入预设名称。",
      "enter_fxchain_name": "请输入效果链名称。",
      "preset_saved_success": "预设 \"${name}\" 保存成功！",
      "fxchain_saved_success": "效果链 \"${name}\" 保存成功！",
      "error_saving_preset": "保存预设错误: ${error}",
      "error_saving_fxchain": "保存效果链错误: ${error}",
      "exception_saving_preset": "保存预设异常: ${error}",
      "exception_saving_fxchain": "保存效果链异常: ${error}",
      "confirm_delete_preset": "确定删除预设 \"${name}\" 吗？",
      "confirm_delete_fxchain": "确定删除效果链 \"${name}\" 吗？",
      "cannot_delete_default_preset": "无法删除默认预设。",
      "cannot_delete_default_fxchain": "无法删除默认效果链。",
      "preset_deleted_success": "预设已删除。",
      "fxchain_deleted_success": "效果链已删除。",
      "preset_delete_failed": "删除预设失败。",
      "fxchain_delete_failed": "删除效果链失败。",
      "exception_deleting_preset": "删除预设异常: ${error}",
      "exception_deleting_fxchain": "删除效果链异常: ${error}",
      "audio_not_ready_record": "音频未准备好。无法开始录制。",
      "pitch_envelope": "音高包络",
      "pitch_amount_cents": "量 (音分)",
      "macro_controls_title": "宏控制",
      "macro_space": "空间",
      "macro_time": "时间",
      "macro_motion": "动态",
      "macro_tone": "音色",
      "macro_drive": "驱动",
      "effects_intensity_min": "FX强度最小 (dB)",
      "effects_intensity_max": "FX强度最大 (dB)",
      "effects_threshold": "FX阈值",
      "none_fxchain": "-- 无 --",
      "none_touch_effect": "无",
      "restart_audio_engine_button": "重启音频",
      "reload_app_button_title": "重载应用",
      "reloading_app_message": "重新加载应用程序...",
      "master_output_title": "主输出",
      "master_volume_ceiling": "音量上限",
      "master_volume_ceiling_label": "音量上限",
      "y_axis_volume_min_output": "最小输出",
      "y_axis_volume_max_output": "最大输出",
      "y_axis_volume_y_threshold": "Y轴阈值",
      "y_axis_curve_type": "曲线类型",
      "y_axis_curve_factor": "曲线因子",
      "y_axis_effects_min_output": "最小输出 (dB)",
      "y_axis_effects_max_output": "最大输出 (dB)",
      "y_axis_effects_y_threshold": "Y轴阈值",
      "logarithmic": "对数",
      "s_curve": "S形曲线",
      "select_option": "选择选项",
      "no_options_found": "未找到选项",
      "error_loading_options": "加载选项错误。",
      "pad_modes_button": "模式",
      "pad_modes_button_title": "打击垫模式",
     
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\scale\blues.json
{
  "id": "blues",
  "type": "scale",
  "name": "Blues",
  "version": "1.0.0",
  "description": "Blues scale with the characteristic 'blue note'",
  "active": true,
  "data": {
    "intervals": [0, 3, 5, 6, 7, 10]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\scale\chromatic.json
{
  "id": "chromatic",
  "type": "scale",
  "name": "Chromatic",
  "version": "1.0.0",
  "description": "Chromatic scale with all semitones",
  "active": true,
  "data": {
    "intervals": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\scale\dorian.json
{
  "id": "dorian",
  "type": "scale",
  "name": "dorian",
  "version": "1.0.0",
  "description": "Dorian mode, a minor-type scale with a major sixth.",
  "active": true,
  "data": {
    "intervals": [0, 2, 3, 5, 7, 9, 10]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\scale\harmonic_minor.json
{
  "id": "harmonic_minor",
  "type": "scale",
  "name": "harmonic_minor",
  "version": "1.0.0",
  "description": "Harmonic minor scale with a raised seventh degree.",
  "active": true,
  "data": {
    "intervals": [0, 2, 3, 5, 7, 8, 11]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\scale\locrian.json
{
  "id": "locrian",
  "type": "scale",
  "name": "locrian",
  "version": "1.0.0",
  "description": "Locrian mode, a diminished-type scale with a minor second and diminished fifth.",
  "active": true,
  "data": {
    "intervals": [0, 1, 3, 5, 6, 8, 10]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\scale\lydian.json
{
  "id": "lydian",
  "type": "scale",
  "name": "lydian",
  "version": "1.0.0",
  "description": "Lydian mode, a major-type scale with an augmented fourth.",
  "active": true,
  "data": {
    "intervals": [0, 2, 4, 6, 7, 9, 11]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\scale\major.json
{
  "id": "major",
  "type": "scale",
  "name": "Major",
  "version": "1.0.0",
  "description": "Standard major scale (Ionian mode)",
  "active": true,
  "data": {
    "intervals": [0, 2, 4, 5, 7, 9, 11]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\scale\melodic_minor_ascending.json
{
  "id": "melodic_minor_ascending",
  "type": "scale",
  "name": "melodic_minor_ascending",
  "version": "1.0.0",
  "description": "Melodic minor scale (ascending form) with raised sixth and seventh degrees.",
  "active": true,
  "data": {
    "intervals": [0, 2, 3, 5, 7, 9, 11]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\scale\minor.json
{
  "id": "minor",
  "type": "scale",
  "name": "Minor",
  "version": "1.0.0",
  "description": "Natural minor scale (Aeolian mode)",
  "active": true,
  "data": {
    "intervals": [0, 2, 3, 5, 7, 8, 10]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\scale\minor_pentatonic.json
{
  "id": "minor_pentatonic",
  "type": "scale",
  "name": "minor_pentatonic",
  "version": "1.0.0",
  "description": "Minor pentatonic scale.",
  "active": true,
  "data": {
    "intervals": [0, 3, 5, 7, 10]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\scale\mixolydian.json
{
  "id": "mixolydian",
  "type": "scale",
  "name": "mixolydian",
  "version": "1.0.0",
  "description": "Mixolydian mode, a dominant-type scale with a minor seventh.",
  "active": true,
  "data": {
    "intervals": [0, 2, 4, 5, 7, 9, 10]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\scale\pentatonic.json
{
  "id": "pentatonic",
  "type": "scale",
  "name": "Pentatonic",
  "version": "1.0.0",
  "description": "Major pentatonic scale (5 notes per octave)",
  "active": true,
  "data": {
    "intervals": [0, 2, 4, 7, 9]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\scale\phrygian.json
{
  "id": "phrygian",
  "type": "scale",
  "name": "phrygian",
  "version": "1.0.0",
  "description": "Phrygian mode, a minor-type scale with a minor second.",
  "active": true,
  "data": {
    "intervals": [0, 1, 3, 5, 7, 8, 10]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\scale\spanish_8_note.json
{
  "id": "spanish_8_note",
  "type": "scale",
  "name": "spanish_8_note",
  "version": "1.0.0",
  "description": "Spanish 8-note scale (Phrygian dominant).",
  "active": true,
  "data": {
    "intervals": [0, 1, 4, 5, 7, 8, 10, 11]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\scale\wholetone.json
{
  "id": "wholetone",
  "type": "scale",
  "name": "wholetone",
  "version": "1.0.0",
  "description": "Whole tone scale, consisting entirely of whole steps.",
  "active": true,
  "data": {
    "intervals": [0, 2, 4, 6, 8, 10]
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\soundpreset\angelic_choir_pad.json
{
  "id": "angelic_choir_pad",
  "type": "soundpreset",
  "name": "Angelic Choir Pad",
  "version": "1.0.0",
  "description": "Simulated choir/vocal pad using multiple detuned fat oscillators.",
  "active": true,
  "data": {
    "oscillator": {
      "params": {
        "type": "fatsawtooth",
        "count": 5,
        "spread": 35
      }
    },
    "amplitudeEnv": {
      "params": {
        "attack": 1.8,
        "decay": 1.5,
        "sustain": 0.8,
        "release": 3.5
      }
    },
    "filter": {
      "enabled": true,
      "params": {
        "type": "lowpass",
        "frequency": 2000,
        "Q": 1.8
      }
    },
    "outputGain": { "params": { "gain": 0 } },
    "pitchEnvelope": { "enabled": false },
    "filterEnvelope": {
      "enabled": true,
      "params": {
        "attack": 2.0,
        "decay": 1.0,
        "sustain": 0.7,
        "release": 3.0,
        "amount": 1500
      }
    },
    "lfo1": {
      "enabled": true,
      "params": {
        "type": "sine",
        "rate": 0.3,
        "depth": 0.03,
        "target": "oscillator.detune"
      }
    },
    "portamento": {
      "enabled": true,
      "time": 0.15
    },
    "colors": { "primary": "#E1F5FE", "text": "#01579B" }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\soundpreset\crystal_pluck.json
{
  "id": "crystal_pluck",
  "type": "soundpreset",
  "name": "Crystal Pluck",
  "version": "1.0.0",
  "description": "Short, bright, percussive pluck sound.",
  "active": true,
  "data": {
    "oscillator": {
      "params": {
        "type": "fmtriangle",
        "harmonicity": 2.5,
        "modulationIndex": 15
      }
    },
    "amplitudeEnv": {
      "params": {
        "attack": 0.005,
        "decay": 0.15,
        "sustain": 0.0,
        "release": 0.1
      }
    },
    "filter": {
      "enabled": true,
      "params": {
        "type": "highpass",
        "frequency": 800,
        "Q": 1.0
      }
    },
    "outputGain": { "params": { "gain": 0 } },
    "pitchEnvelope": {
      "enabled": true,
      "params": {
        "attack": 0.001,
        "decay": 0.05,
        "sustain": 0,
        "release": 0.01,
        "amount": 1200
      }
    },
    "filterEnvelope": {
      "enabled": true,
      "params": {
        "attack": 0.01,
        "decay": 0.1,
        "sustain": 0,
        "release": 0.05,
        "amount": 4000
      }
    },
    "lfo1": { "enabled": false },
    "portamento": { "enabled": false },
    "colors": { "primary": "#4DD0E1", "text": "#006064" }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\soundpreset\ethereal_pad.json
{
  "id": "ethereal_pad",
  "type": "soundpreset",
  "name": "Ethereal Pad",
  "version": "1.0.0",
  "description": "Slow evolving atmospheric pad.",
  "active": true,
  "data": {
    "oscillator": {
      "params": {
        "type": "fatsine",
        "count": 5,
        "spread": 35
      }
    },
    "amplitudeEnv": {
      "params": {
        "attack": 2.5,
        "decay": 1.0,
        "sustain": 0.9,
        "release": 4.0
      }
    },
    "filter": {
      "enabled": true,
      "params": {
        "type": "lowpass",
        "frequency": 1500,
        "Q": 1.5,
        "rolloff": -12
      }
    },
    "outputGain": { "params": { "gain": 0 } },
    "pitchEnvelope": { "enabled": false },
    "filterEnvelope": {
      "enabled": true,
      "params": {
        "attack": 3.0,
        "decay": 2.0,
        "sustain": 0.6,
        "release": 3.5,
        "amount": 2500
      }
    },
    "lfo1": {
      "enabled": true,
      "params": {
        "type": "sine",
        "rate": 0.2,
        "depth": 0.4,
        "target": "filter.frequency",
        "retrigger": false
      }
    },
    "portamento": { "enabled": false },
    "colors": { "primary": "#64B5F6", "text": "#0D47A1" }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\soundpreset\fm_bell_tones.json
{
  "id": "fm_bell_tones",
  "type": "soundpreset",
  "name": "FM Bell Tones",
  "version": "1.0.0",
  "description": "Metallic, bell-like tones using FM synthesis.",
  "active": true,
  "data": {
    "oscillator": {
      "params": {
        "type": "fmsine",
        "harmonicity": 3.5,
        "modulationIndex": 20,
        "modulationType": "sine"
      }
    },
    "amplitudeEnv": {
      "params": {
        "attack": 0.002,
        "decay": 0.8,
        "sustain": 0.05,
        "release": 0.6
      }
    },
    "filter": {
      "enabled": true,
      "params": {
        "type": "lowpass",
        "frequency": 12000,
        "Q": 0.7
      }
    },
    "outputGain": { "params": { "gain": 0 } },
    "pitchEnvelope": {
      "enabled": true,
      "params": {
        "attack": 0.001,
        "decay": 0.03,
        "sustain": 0,
        "release": 0.01,
        "amount": 200
      }
    },
    "filterEnvelope": { "enabled": false },
    "lfo1": {
      "enabled": true,
      "params": {
        "type": "sine",
        "rate": 0.3,
        "depth": 0.1,
        "target": "oscillator.modulationIndex",
        "retrigger": false
      }
    },
    "portamento": { "enabled": false },
    "colors": { "primary": "#FFEE58", "text": "#3E2723" }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\soundpreset\glassy_resonance_drone.json
{
  "id": "glassy_resonance_drone",
  "type": "soundpreset",
  "name": "Glassy Resonance Drone",
  "version": "1.0.0",
  "description": "High-frequency resonant drone with a metallic character.",
  "active": true,
  "data": {
    "oscillator": {
      "params": {
        "type": "fmtriangle",
        "harmonicity": 2.0,
        "modulationIndex": 5,
        "modulationType": "sine"
      }
    },
    "amplitudeEnv": {
      "params": {
        "attack": 2.0,
        "decay": 1.5,
        "sustain": 1.0,
        "release": 4.5
      }
    },
    "filter": {
      "enabled": true,
      "params": {
        "type": "bandpass",
        "frequency": 2500,
        "Q": 18,
        "rolloff": -24
      }
    },
    "outputGain": { "params": { "gain": 0 } },
    "pitchEnvelope": { "enabled": false },
    "filterEnvelope": {
      "enabled": true,
      "params": {
        "attack": 3.0,
        "decay": 1.0,
        "sustain": 0.8,
        "release": 2.0,
        "amount": 1500
      }
    },
    "lfo1": {
      "enabled": true,
      "params": {
        "type": "sine",
        "rate": 0.08,
        "depth": 0.3,
        "target": "filter.Q",
        "retrigger": false
      }
    },
    "portamento": { "enabled": false },
    "colors": { "primary": "#B2EBF2", "text": "#006064" }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\soundpreset\mystic_flute_pad.json
{
  "id": "mystic_flute_pad",
  "type": "soundpreset",
  "name": "Mystic Flute Pad",
  "version": "1.0.1",
  "description": "Pad imitating a breathy flute sound with a slow attack and custom Y-Axis effect send.",
  "active": true,
  "data": {
    "oscillator": {
      "params": {
        "type": "fmtriangle",
        "harmonicity": 0.5,
        "modulationIndex": 2,
        "modulationType": "sine"
      }
    },
    "amplitudeEnv": {
      "params": {
        "attack": 0.6,
        "decay": 0.8,
        "sustain": 0.9,
        "release": 1.5,
        "attackCurve": "sine"
      }
    },
    "filter": {
      "enabled": true,
      "params": {
        "type": "lowpass",
        "frequency": 2200,
        "Q": 1.0
      }
    },
    "outputGain": { "params": { "gain": 0 } },
    "pitchEnvelope": { "enabled": false },
    "filterEnvelope": {
      "enabled": true,
      "params": {
        "attack": 0.7,
        "decay": 0.5,
        "sustain": 0.7,
        "release": 1.0,
        "amount": 1000
      }
    },
    "lfo1": {
      "enabled": true,
      "params": {
        "type": "sine",
        "rate": 0.4,
        "depth": 0.15,
        "target": "filter.frequency"
      }
    },
    "portamento": { "enabled": false },

    "yAxisControls": {
      "effects": {
        "minOutput": -30,
        "maxOutput": -25,
        "yThreshold": 0.3,
        "curveType": "exponential",
        "curveFactor": 1.5,
        "outputType": "db"
      }
    },

    "colors": { "primary": "#4DB6AC", "text": "#FFFFFF" }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\soundpreset\pwm_sweep_pad.json
{
  "id": "pwm_sweep_pad",
  "type": "soundpreset",
  "name": "PWM Sweep Pad",
  "version": "1.0.0",
  "description": "A pad sound using Pulse Width Modulation with a slow sweep.",
  "active": true,
  "data": {
    "oscillator": {
      "params": {
        "type": "pulse",
        "width": 0.1
      }
    },
    "amplitudeEnv": {
      "params": {
        "attack": 1.2,
        "decay": 1.0,
        "sustain": 0.85,
        "release": 2.5
      }
    },
    "filter": {
      "enabled": true,
      "params": {
        "type": "lowpass",
        "frequency": 2200,
        "Q": 1.2,
        "rolloff": -12
      }
    },
    "outputGain": { "params": { "gain": 0 } },
    "pitchEnvelope": { "enabled": false },
    "filterEnvelope": { "enabled": false },
    "lfo1": {
      "enabled": true,
      "params": {
        "type": "sine",
        "rate": 0.1,
        "depth": 0.8,
        "target": "oscillator.width",
        "retrigger": false
      }
    },
    "portamento": { "enabled": false },
    "colors": { "primary": "#26A69A", "text": "#FFFFFF" }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\soundpreset\resonant_high_drone.json
{
  "id": "resonant_high_drone_v2",
  "type": "soundpreset",
  "name": "Resonant Deep Drone",
  "version": "1.0.0",
  "description": "Evolving drone with pronounced filter resonance in lower-mid frequencies.",
  "active": true,
  "data": {
    "oscillator": {
      "params": {
        "type": "fatsawtooth",
        "count": 2,
        "spread": 15
      }
    },
    "amplitudeEnv": {
      "params": {
        "attack": 2.5,
        "decay": 1.0,
        "sustain": 1.0,
        "release": 4.0
      }
    },
    "filter": {
      "enabled": true,
      "params": {
        "type": "lowpass",
        "frequency": 400,
        "Q": 12,
        "rolloff": -24
      }
    },
    "outputGain": { "params": { "gain": 0 } },
    "pitchEnvelope": { "enabled": false },
    "filterEnvelope": {
      "enabled": true,
      "params": {
        "attack": 5.0,
        "decay": 2.0,
        "sustain": 0.7,
        "release": 3.0,
        "amount": 2000
      }
    },
    "lfo1": {
      "enabled": true,
      "params": {
        "type": "sine",
        "rate": 0.1,
        "depth": 0.6,
        "target": "filter.Q",
        "retrigger": false
      }
    },
    "portamento": { "enabled": false },
    "colors": { "primary": "#78909C", "text": "#ECEFF1" }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\soundpreset\soft_sine_bells.json
{
  "id": "soft_sine_bells",
  "type": "soundpreset",
  "name": "Soft Sine Bells",
  "version": "1.0.0",
  "description": "Gentle, pure bell-like tones using sine waves.",
  "active": true,
  "data": {
    "oscillator": {
      "params": {
        "type": "sine"
      }
    },
    "amplitudeEnv": {
      "params": {
        "attack": 0.001,
        "decay": 1.2,
        "sustain": 0.0,
        "release": 0.8
      }
    },
    "filter": {
      "enabled": false
    },
    "outputGain": { "params": { "gain": 0 } },
    "pitchEnvelope": {
      "enabled": true,
      "params": {
        "attack": 0.001,
        "decay": 0.02,
        "sustain": 0,
        "release": 0.01,
        "amount": 700
      }
    },
    "filterEnvelope": { "enabled": false },
    "lfo1": { "enabled": false },
    "portamento": { "enabled": false },
    "colors": { "primary": "#AED581", "text": "#33691E" }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\soundpreset\subtle_square_pluck.json
{
  "id": "subtle_square_pluck",
  "type": "soundpreset",
  "name": "Subtle Square Pluck",
  "version": "1.0.0",
  "description": "Soft, slightly hollow pluck sound with a square wave.",
  "active": true,
  "data": {
    "oscillator": {
      "params": {
        "type": "square"
      }
    },
    "amplitudeEnv": {
      "params": {
        "attack": 0.002,
        "decay": 0.25,
        "sustain": 0.0,
        "release": 0.1
      }
    },
    "filter": {
      "enabled": true,
      "params": {
        "type": "lowpass",
        "frequency": 1200,
        "Q": 1.0
      }
    },
    "outputGain": { "params": { "gain": 0 } },
    "pitchEnvelope": { "enabled": false },
    "filterEnvelope": {
      "enabled": true,
      "params": {
        "attack": 0.005,
        "decay": 0.1,
        "sustain": 0,
        "release": 0.08,
        "amount": 2500
      }
    },
    "lfo1": { "enabled": false },
    "portamento": { "enabled": false },
    "colors": { "primary": "#80CBC4", "text": "#004D40" }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\theme\aurora_theme.json
{
  "id": "aurora",
  "type": "theme",
  "name": "Aurora",
  "version": "1.0.0",
  "description": "A cosmic theme inspired by northern lights with cyan and magenta accents",
  "active": true,
  "data": {
    "colors": {
      "background": "#0a0a1a",
      "surface": "#1a1a2e",
      "primary": "#00ffcc",
      "primaryLight": "#66ffeb",
      "primaryDark": "#00cc9f",
      "accent": "#ff00ff",
      "textPrimary": "#e0e0ff",
      "textSecondary": "#a0a0ff",
      "border": "#2a2a4a"
    },
    "effects": {
      "knobGlow": true,
      "knobGlowIntensity": 1.5,
      "touchGlow": true,
      "touchGlowIntensity": 1.2,
      "textGlow": true,
      "textGlowIntensity": 1.3,
      "gradientBackground": true,
      "gradientAngle": 45
    }
  }
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\theme\crystal_theme.json
{
  "id": "crystal",
  "type": "theme",
  "name": "Crystal",
  "version": "1.0.0",
  "description": "A crystalline theme with prismatic light effects",
  "active": true,
  "data": {
    "colors": {
      "background": "#000033",
      "surface": "#000066",
      "primary": "#00ffff",
      "primaryLight": "#66ffff",
      "primaryDark": "#00cccc",
      "accent": "#ff00ff",
      "textPrimary": "#00ffff",
      "textSecondary": "#66ffff",
      "border": "#000099"
    },
    "effects": {
      "knobGlow": true,
      "knobGlowIntensity": 1.8,
      "touchGlow": true,
      "touchGlowIntensity": 1.6,
      "textGlow": true,
      "textGlowIntensity": 1.4,
      "crystalShine": true,
      "shineSpeed": 8,
      "prismEffect": true
    }
  }
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\theme\cyberpunk_theme.json
{
  "id": "cyberpunk",
  "type": "theme",
  "name": "Cyberpunk",
  "version": "1.0.0",
  "description": "A futuristic cyberpunk theme with acid neon colors",
  "active": true,
  "data": {
    "colors": {
      "background": "#000000",
      "surface": "#1a1a1a",
      "primary": "#39ff14",
      "primaryLight": "#7fff00",
      "primaryDark": "#32cd32",
      "accent": "#ff00ff",
      "textPrimary": "#39ff14",
      "textSecondary": "#7fff00",
      "border": "#333333"
    },
    "effects": {
      "knobGlow": true,
      "knobGlowIntensity": 2.0,
      "touchGlow": true,
      "touchGlowIntensity": 1.8,
      "textGlow": true,
      "textGlowIntensity": 1.5,
      "gradientBackground": true,
      "gradientAngle": 45,
      "gridPattern": true,
      "gridSize": 20,
      "gridColor": "rgba(57, 255, 20, 0.1)"
    }
  }
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\theme\fire_theme.json
{
  "id": "fire",
  "type": "theme",
  "name": "Fire",
  "version": "1.0.0",
  "description": "A dynamic fire theme with realistic flame effects",
  "active": true,
  "data": {
    "colors": {
      "background": "#1a0000",
      "surface": "#330000",
      "primary": "#ff3300",
      "primaryLight": "#ff6633",
      "primaryDark": "#cc2900",
      "accent": "#ffcc00",
      "textPrimary": "#ff3300",
      "textSecondary": "#ffcc00",
      "border": "#4d0000"
    },
    "effects": {
      "knobGlow": true,
      "knobGlowIntensity": 1.8,
      "touchGlow": true,
      "touchGlowIntensity": 1.6,
      "textGlow": true,
      "textGlowIntensity": 1.4,
      "fireFlicker": true,
      "flickerSpeed": 2,
      "flickerIntensity": 0.8,
      "fireWave": true,
      "waveSpeed": 4,
      "waveIntensity": 1.1,
      "flameLayers": true,
      "layerCount": 3
    }
  }
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\theme\galaxy_theme.json
{
  "id": "galaxy",
  "type": "theme",
  "name": "Galaxy",
  "version": "1.0.0",
  "description": "A cosmic galaxy theme with harmonious nebula effects",
  "active": true,
  "data": {
    "colors": {
      "background": "#0a0a2a",
      "surface": "#1a1a4a",
      "primary": "#7b68ee",
      "primaryLight": "#9f8fff",
      "primaryDark": "#483d8b",
      "accent": "#ff4500",
      "textPrimary": "#00ff00",
      "textSecondary": "#ffff00",
      "border": "#2a2a6a"
    },
    "effects": {
      "knobGlow": true,
      "knobGlowIntensity": 1.8,
      "touchGlow": true,
      "touchGlowIntensity": 1.6,
      "textGlow": true,
      "textGlowIntensity": 1.4,
      "gradientBackground": true,
      "gradientAngle": 135,
      "animatedBackground": true,
      "animationDuration": 20,
      "starEffect": true,
      "starCount": 50,
      "starColor": "rgba(255, 255, 255, 0.5)"
    }
  }
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\theme\hologram_theme.json
{
  "id": "hologram",
  "type": "theme",
  "name": "Hologram",
  "version": "1.0.0",
  "description": "A futuristic hologram theme with scanning effects",
  "active": true,
  "data": {
    "colors": {
      "background": "#000000",
      "surface": "#001a1a",
      "primary": "#00ffff",
      "primaryLight": "#66ffff",
      "primaryDark": "#00cccc",
      "accent": "#ff00ff",
      "textPrimary": "#00ffff",
      "textSecondary": "#66ffff",
      "border": "#003333"
    },
    "effects": {
      "knobGlow": true,
      "knobGlowIntensity": 1.8,
      "touchGlow": true,
      "touchGlowIntensity": 1.6,
      "textGlow": true,
      "textGlowIntensity": 1.4,
      "hologramScan": true,
      "scanSpeed": 4,
      "scanPattern": "diagonal"
    }
  }
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\theme\matrix_theme.json
{
  "id": "matrix",
  "type": "theme",
  "name": "Matrix",
  "version": "1.0.0",
  "description": "A digital rain matrix theme with falling green code",
  "active": true,
  "data": {
    "colors": {
      "background": "#000000",
      "surface": "#001100",
      "primary": "#00ff00",
      "primaryLight": "#33ff33",
      "primaryDark": "#00cc00",
      "accent": "#00ff66",
      "textPrimary": "#00ff00",
      "textSecondary": "#33ff33",
      "border": "#003300"
    },
    "effects": {
      "knobGlow": true,
      "knobGlowIntensity": 1.8,
      "touchGlow": true,
      "touchGlowIntensity": 1.6,
      "textGlow": true,
      "textGlowIntensity": 1.4,
      "matrixRain": true,
      "rainSpeed": 20,
      "rainDensity": 40
    }
  }
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\theme\neon_theme.json
{
  "id": "neon",
  "type": "theme",
  "name": "Neon",
  "version": "1.0.0",
  "description": "A dark cyberpunk theme with bright neon colors",
  "active": true,
  "data": {
    "colors": {
      "background": "#000000",
      "surface": "#0a1a2a",
      "primary": "#00ff41",
      "primaryLight": "#92ff9d",
      "primaryDark": "#00cc33",
      "accent": "#ff00ff",
      "textPrimary": "#00ff41",
      "textSecondary": "#00cc33",
      "border": "#004411"
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\theme\night_theme.json
{
  "id": "night",
  "type": "theme",
  "name": "Night",
  "version": "1.0.0",
  "description": "A dark theme with purple accents",
  "active": true,
  "data": {
    "colors": {
      "background": "#121212",
      "surface": "#1e1e1e",
      "primary": "#bb86fc",
      "primaryLight": "#d9b6fc",
      "primaryDark": "#9d4edd",
      "accent": "#03dac6",
      "textPrimary": "#e0e0e0",
      "textSecondary": "#a0a0a0",
      "border": "#333333"
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\theme\ocean_theme.json
{
  "id": "ocean",
  "type": "theme",
  "name": "Ocean",
  "version": "1.0.0",
  "description": "A deep ocean theme with blue tones and coral accents",
  "active": true,
  "data": {
    "colors": {
      "background": "#001f3f",
      "surface": "#003366",
      "primary": "#00bfff",
      "primaryLight": "#66d9ff",
      "primaryDark": "#0099cc",
      "accent": "#ff6b6b",
      "textPrimary": "#e0f7ff",
      "textSecondary": "#a0d8ff",
      "border": "#004080"
    },
    "effects": {
      "knobGlow": true,
      "knobGlowIntensity": 1.2,
      "touchGlow": true,
      "touchGlowIntensity": 1.0,
      "textGlow": true,
      "textGlowIntensity": 1.1,
      "gradientBackground": true,
      "gradientAngle": 180
    }
  }
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\theme\retro_theme.json
{
  "id": "retro",
  "type": "theme",
  "name": "Retro",
  "version": "1.0.0",
  "description": "A warm retro theme with vintage colors",
  "active": true,
  "data": {
    "colors": {
      "background": "#fff8e1",
      "surface": "#ffe0b2",
      "primary": "#ff5722",
      "primaryLight": "#ff8a65",
      "primaryDark": "#e64a19",
      "accent": "#795548",
      "textPrimary": "#5d4037",
      "textSecondary": "#8d6e63",
      "border": "#bcaaa4"
    },
    "textures": {
      "background": "grid",
      "gridSize": 60,
      "gridColor": "rgba(188, 170, 164, 0.1)",
      "xyPadGrid": true,
      "xyPadGridSize": 20,
      "xyPadGridColor": "rgba(188, 170, 164, 0.05)"
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\touchEffect\ballLightningLink.json
{
  "id": "ballLightningLink",
  "type": "touchEffect",
  "name": "Ball Lightning Link",
  "version": "1.2.0",
  "description": "Interactive ball lightning with linking arcs for multi-touch.",
  "active": true,
  "data": {
    "rendererScript": "js/touchEffects/ballLightningLinkEffect.js",
    "settings": {
      "colorSourceAura": "note",
      "coreBaseColor": "#FFFFFF",
      "coreColorFromAura": true,
      "coreMinRadius": 7,
      "coreRadiusYMultiplier": 12,
      "corePulseSpeed": 1.8,
      "corePulseAmount": 0.2,
      "auraRadiusFactor": 2.8,
      "auraBaseOpacity": 0.25,

      "sparkEmitInterval": 40,
      "sparksPerEmitBase": 1,
      "sparksPerEmitYMultiplier": 3,
      "sparkMaxLifetime": 350,
      "sparkBaseLength": 100,
      "sparkLengthYMultiplier": 50,
      "sparkSegments": 3,
      "sparkJitter": 10,
      "sparkSegmentAngleJitter": 0.6,
      "sparkBranchChance": 0.08,
      "sparkCoreColor": "#FEFEFE",
      "sparkCoreColorFromAura": false,
      "sparkGlowOpacity": 0.6,
      "sparkGlowWidthFactor": 2.5,
      "sparkCoreWidthFactor": 0.8,
      "sparkRotationSpeed": 0.008,
      "sparkBundleSpread": 1.8,
      "sparkAngleFactor": 1,


      "attractionRadiusPx": 300,
      "linkCoreColorStart": "#FFFFFF",
      "linkCoreColorEnd": "#F0F0FF",
      "linkGlowOpacity": 0.75,
      "linkBaseThickness": 3,
      "linkThicknessYMultiplier": 2.5,
      "linkSegments": 8,
      "linkJitter": 18,
      "linkGlowThicknessFactor": 2.0,
      "linkBranchChance": 0.03,
      "linkSecondarySparks": true,
      "linkSecondarySparkInterval": 80,
      "linkSecondarySparkCount": 1,

      "fadeDurationCore": 280,
      "fadeDurationSparks": 180,
      "fadeDurationLink": 220,

      "compositeOperation": "lighter"
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\touchEffect\energy.json
{
    "id": "energy",
    "type": "touchEffect",
    "name": "Energy Burst",
    "version": "1.1.0",
    "description": "Creates dynamic energy bursts with rotating spikes that expand from touch points",
    "data": {
        "rendererScript": "js/touchEffects/energyEffect.js",
        "settings": {
            "colorSource": "note",
            "baseOpacity": 1.0,
            "energySpeed": 2,
            "energyInterval": 200,
            "maxRadius": 150,
            "fadeDuration": 1000,
            "spikes": 8,
            "innerRadiusFactor": 0.5,
            "spawnSpread": 5,
            "strokeWidth": 0,
            "compositeOperation": "lighter"
        }
    }
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\touchEffect\geometricShards.json
{
  "id": "geometricShards",
  "type": "touchEffect",
  "name": "Live Geometric Shards",
  "version": "1.1.0",
  "description": "Continuously emits and animates geometric shards from touch point.",
  "active": true,
  "data": {
    "rendererScript": "js/touchEffects/geometricShardsEffect.js",
    "settings": {
      "colorSource": "note",
      "emitRate": 15,
      "maxActiveShardsPerTouch": 50,
      "shardTypes": ["triangle", "rectangle", "line"],
      "shardMaxSize": 18,
      "shardMinSize": 5,
      "shardLife": 800,
      "launchSpeedBase": 0.5,
      "launchSpeedYMultiplier": 1.5,
      "rotationSpeed": 0.03,
      "shrinkFactor": 0.98,
      "fadeOutFactor": 0.97,
      "gravity": 0.02,
      "baseOpacity": 0.9,
      "compositeOperation": "lighter",
      "fadeDurationOnUp": 300
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\touchEffect\glow.json
{
  "id": "glow",
  "type": "touchEffect",
  "name": "Glow",
  "version": "1.0.0",
  "description": "Creates glowing effects at touch points",
  "active": true,
  "data": {
    "rendererScript": "js/touchEffects/glowEffect.js",
    "settings": {
      "colorSource": "note",
      "baseOpacity": 0.7,
      "duration": 350,
      "maxRadius": 60,
      "reactToTouches": true,
      "reactToAudio": true,
      "audioReactivity": {
        "radiusMultiplier": 1.5,
        "opacityMultiplier": 1.2
      }
    }
  }
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\touchEffect\marker.json
{
  "id": "marker",
  "type": "touchEffect",
  "name": "Marker",
  "version": "1.0.0",
  "description": "Creates a glowing trail that follows touch movement",
  "active": true,
  "data": {
    "rendererScript": "js/touchEffects/markerEffect.js",
    "settings": {
      "colorSource": "note",
      "baseOpacity": 1.0,
      "maxPoints": 50,
      "maxWidth": 20,
      "minWidth": 5,
      "reactToAudio": true,
      "audioReactivity": {
        "widthMultiplier": 1.5,
        "opacityMultiplier": 1.2
      }
    }
  }
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\touchEffect\none.json
{
  "id": "none",
  "type": "touchEffect",
  "name": "None",
  "version": "1.0.0",
  "description": "Disables touch visual effects.",
  "active": true,
  "data": {
    "rendererScript": null,
    "settings": {}
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\touchEffect\novaSparkEffect.json
{
  "id": "novaSpark",
  "type": "touchEffect",
  "name": "Nova Spark",
  "version": "1.0.0",
  "description": "A pulsating core based on note color, emitting colored sparks. Connects with other touches via a powerful arc.",
  "active": true,
  "data": {
    "rendererScript": "js/touchEffects/novaSparkEffect.js",
    "settings": {

      "coreColorSource": "note",
      "coreBrightnessFactor": 0.95,
      "coreMinRadius": 7,
      "coreMaxRadiusYFactor": 15,
      "corePulseSpeed": 2.0,
      "corePulseAmount": 0.15,
      "auraRadiusFactor": 2.2,
      "auraOpacityFactor": 0.35,


      "sparkEmitIntervalMs": 40,
      "sparksPerEmit": 2,
      "sparkCoreBrightnessFactor": 0.9,
      "sparkGlowColorSource": "note",
      "sparkLineWidthBase": 1.0,
      "sparkLineWidthYFactor": 0.6,
      "sparkMaxSegments": 3,
      "sparkSegmentLengthBase": 12,
      "sparkSegmentLengthYFactor": 35,
      "sparkJitter": 7,
      "sparkLifeTimeMs": 400,
      "sparkOpacityCore": 0.8,
      "sparkOpacityGlow": 0.6,
      "sparkAngleSpreadDeg": 140,
      "sparkBranchChance": 0.1,


      "connectionCoreCenterColor": "rgba(255, 255, 255, 1.0)",
      "connectionCoreEdgeBrightnessFactor": 0.85,
      "connectionGlowColorMixType": "gradient",
      "connectionLineWidthBase": 3.0,
      "connectionLineWidthYFactor": 2.0,
      "connectionWidthBoost": 1.9,
      "connectionMaxSegments": 9,
      "connectionJitter": 20,
      "connectionBranchChanceMain": 0.12,
      "connectionBranchColorSource": "mixed",
      "opacityConnectionCore": 1.0,
      "opacityConnectionGlow": 0.9,


      "lineGlowRadiusFactor": 1.6,
      "lineGlowOpacityFactor": 0.65,
      "attractionRadiusPx": 180,
      "targetAttractionFactor": 0.3,
      "fadeDurationMs": 200,
      "compositeOperation": "lighter"
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\touchEffect\spark.json
{
  "id": "spark",
  "type": "touchEffect",
  "name": "Spark",
  "version": "1.0.0",
  "description": "Creates electric-like sparks from touch points",
  "active": true,
  "data": {
    "rendererScript": "js/touchEffects/sparkEffect.js",
    "settings": {
      "colorSource": "note",
      "baseOpacity": 1.0,
      "sparkCount": 8,
      "minLength": 10,
      "maxLength": 50,
      "reactToAudio": true,
      "audioReactivity": {
        "lengthMultiplier": 1.5,
        "opacityMultiplier": 1.2
      }
    }
  }
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\touchEffect\wave.json
{
  "id": "wave",
  "type": "touchEffect",
  "name": "Ripple Waves",
  "version": "1.1.0",
  "description": "Creates expanding ripple waves from touch points.",
  "active": true,
  "data": {
    "rendererScript": "js/touchEffects/waveEffect.js",
    "settings": {
      "colorSource": "note",
      "baseOpacity": 0.8,
      "waveSpeed": 3,
      "waveInterval": 300,
      "maxRadius": 1000,
      "minRadius": 40,
      "fadeDuration": 1000,
      "compositeOperation": "lighter"
    }
  }
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\visualizer\nebula.json
{
  "id": "nebula",
  "type": "visualizer",
  "name": "Nebula",
  "version": "1.0.0",
  "description": "Cosmic nebula and stars visualizer",
  "active": true,
  "data": {
    "rendererScript": "js/visualizers/nebulaRenderer.js",
    "settings": {
      "starCount": 30,
      "starMinRadius": 2,
      "starMaxRadius": 5,
      "starBrightnessMultiplier": 0.5,
      "starColor": null,
      "cloudBaseSize": 0.4,
      "cloudSizeReact": 0.4,
      "primaryAlpha": 0.3,
      "accentAlpha": 0.1,
      "gradientMidpoint": 0.5,
      "energyMultiplier": 3,
      "opacity": 0.5,
      "reactToTouches": true,
      "touchGlowColor": "accent",
      "touchGlowRadius": 50,
      "touchGlowDuration": 300,
      "gravityStrength": 0.08,
      "touchGravityStrength": 8,
      "collisionShrinkFactor": 0.7,
      "starMinSpeed": 0.1,
      "starMaxSpeed": 0.5,
      "starTwinkleFactor": 0.2,
      "starColors": ["#fffbe6", "#ffe0b2", "#b3e5fc", "#ffd180", "#ff8a80", "#b388ff"]
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\visualizer\particles.json
{
  "id": "schoolOfFish",
  "type": "visualizer",
  "name": "School of Fish",
  "version": "1.0.0",
  "description": "Animated school of fish with realistic flocking and water effects",
  "active": true,
  "data": {
    "rendererScript": "js/visualizers/schoolOfFishRenderer.js",
    "settings": {
      "count": 200,
      "minRadius": 0.5,
      "maxRadius": 1.5,
      "baseSpeed": 1,
      "particleColor": "primary",
      "opacity": 0.6,
      "glow": false,
      "energyMultiplier": 5,
      "speedMultiplier": 1,
      "radiusMultiplier": 1,
      "followTouches": true,
      "followStrength": 0.05,
      "disperseWhenIdle": true,
      "disperseStrength": 0.02,
      "connectionLines": false,
      "connectionThreshold": 100,
      "connectionColor": "border",
      "connectionAlpha": 0.1,
      "gravityStrength": 0.08,
      "repulsionStrength": 15,
      "gravityMinDistance": 15  ,
      "touchGravityStrength": 50.0,
      "centerGravityStrength": 0.01,
      "particleColors": ["#fffbe6", "#ffe0b2", "#b3e5fc", "#ffd180", "#ff8a80", "#b388ff", "#69f0ae", "#ffd54f", "#ff5252", "#40c4ff"]
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\visualizer\reactive_ripples.json
{
  "id": "reactive_ripples",
  "type": "visualizer",
  "name": "Reactive Ripples",
  "version": "1.0.0",
  "description": "Touch-activated ripples on the surface, can overlay other visuals",
  "active": true,
  "data": {
    "rendererScript": "js/visualizers/reactiveRipplesRenderer.js",
    "settings": {
      "rippleColor": "accent",
      "rippleMaxRadius": 150,
      "rippleDuration": 1000,
      "rippleLineWidth": 2,
      "rippleCountPerTouch": 3,
      "rippleDelayBetween": 150,
      "rippleFadeOut": true,
      "rippleWidthFade": true,
      "backgroundVisualizer": "waves",
      "reactToTouches": true,
      "reactToAudio": true,
      "audioReactivity": {
        "radiusMultiplier": 1.5,
        "opacityMultiplier": 1.2,
        "lineWidthMultiplier": 1.3
      },
      "colors": {
        "primary": "#4CAF50",
        "secondary": "#81C784",
        "accent": "#FF4081",
        "background": "#000000",
        "text": "#FFFFFF"
      }
    }
  }
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\visualizer\spectrum.json
{
  "id": "spectrum",
  "type": "visualizer",
  "name": "Spectrum",
  "version": "1.0.0",
  "description": "Frequency spectrum visualizer",
  "active": true,
  "data": {
    "rendererScript": "js/visualizers/spectrumRenderer.js",
    "settings": {
      "barWidthMultiplier": 2.2,
      "barSpacing": 1,
      "maxHeightMultiplier": 0.9,
      "colorMode": "neon",
      "barGlow": true,
      "barRadius": 10,
      "capEnabled": true,
      "capColor": "#fffbe6",
      "capRadius": 7,
      "backgroundGradient": ["#0a0a23", "#23234a"],
      "hueRange": 240,
      "opacity": 0.8,
      "reactToTouches": false,
      "touchHighlightColor": "accent",
      "smoothingTimeConstant": 0.8,
      "fftSize": 512
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\visualizer\touch_trails.json
{
  "id": "touch_trails",
  "type": "visualizer",
  "name": "Touch Trails Visualizer",
  "version": "1.0.0",
  "description": "Displays trails following touch movements.",
  "active": false,
  "data": {
    "rendererScript": "js/visualizers/touchTrailsRenderer.js",
    "settings": {
      "trailColorSource": "note",
      "trailDuration": 1000,
      "trailBaseWidth": 3,
      "trailWidthMultiplierY": 1.5,
      "maxPoints": 30,
      "opacity": 0.7
    }
  }
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\modules\visualizer\waves.json
{
  "id": "waves",
  "type": "visualizer",
  "name": "Waves",
  "version": "1.0.0",
  "description": "Classic waveform visualizer",
  "active": true,
  "data": {
    "rendererScript": "js/visualizers/wavesRenderer.js",
    "settings": {
      "lineWidth": 2,
      "lineColor": "primary",
      "opacity": 0.7,
      "smoothing": 0.8,
      "fill": false,
      "fillColor": "primary",
      "fillAlpha": 0.1,
      "reactToTouches": true,
      "touchColorSource": "note"
    }
  }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\BaseModule.java
package com.example.prismtone;

import android.content.Context;

import com.google.gson.JsonObject;

public abstract class BaseModule {
    protected final Context context;
    protected final ModuleInfo info;

    public BaseModule(Context context, ModuleInfo info) {
        this.context = context;
        this.info = info;
    }

    /**
     * Initialize the module - load and validate data
     * @return true if initialization succeeded
     */
    public abstract boolean initialize();

    /**
     * Apply the module's settings to the application
     * @return true if settings were applied successfully
     */
    public abstract boolean apply();

    /**
     * Cleanup resources when the module is unloaded
     * @return true if cleanup succeeded
     */
    public boolean onUnload() {
        // Default implementation does nothing
        return true;
    }

    /**
     * Gets the ID of this module
     */
    public String getId() {
        return info.getId();
    }

    /**
     * Gets the type of this module
     */
    public String getType() {
        return info.getType();
    }

    /**
     * Gets the name of this module
     */
    public String getName() {
        return info.getName();
    }

    /**
     * Gets the description of this module
     */
    public String getDescription() {
        return info.getDescription();
    }

    /**
     * Gets the version of this module
     */
    public String getVersion() {
        return info.getVersion();
    }

    /**
     * Gets the raw module data
     */
    protected JsonObject getData() {
        return info.getData();
    }
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\CorsAssetsPathHandler.java
package com.example.prismtone; // Убедитесь, что пакет правильный

import android.content.Context;
import android.util.Log;
import android.webkit.WebResourceResponse;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.webkit.WebViewAssetLoader;

import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

/**
 * A custom PathHandler that wraps AssetsPathHandler to add CORS headers
 * and ensures a valid status code (200 OK) is always set for successful responses.
 */
public class CorsAssetsPathHandler implements WebViewAssetLoader.PathHandler {
    private static final String TAG = "CorsAssetsPathHandler";
    private final WebViewAssetLoader.AssetsPathHandler defaultHandler;

    public CorsAssetsPathHandler(Context context) {
        this.defaultHandler = new WebViewAssetLoader.AssetsPathHandler(context);
    }

    @Nullable
    @Override
    public WebResourceResponse handle(@NonNull String path) {
        WebResourceResponse response = null;
        try {
            response = defaultHandler.handle(path);
        } catch (Exception e) {
            Log.e(TAG, "Error in default AssetsPathHandler for path: " + path, e);
            return null;
        }

        // Если стандартный обработчик вернул ответ с данными
        if (response != null && response.getData() != null) {
            Map<String, String> headers = response.getResponseHeaders();
            if (headers == null) {
                headers = new HashMap<>();
            } else {
                headers = new HashMap<>(headers); // Создаем копию
            }

            // Добавляем CORS-заголовок
            headers.put("Access-Control-Allow-Origin", "*");

            // --- НОВОЕ ИСПРАВЛЕНИЕ: Всегда используем 200 OK для успешного ответа ---
            // Игнорируем statusCode и reasonPhrase из оригинального response,
            // так как они могут быть некорректными для локальных файлов.
            int statusCode = 200;
            String reasonPhrase = "OK";
            // --- КОНЕЦ НОВОГО ИСПРАВЛЕНИЯ ---

            Log.d(TAG, "Serving asset with CORS: " + path + " (Status: " + statusCode + ")");

            // Создаем новый WebResourceResponse с нашими заголовками и статусом 200 OK
            return new WebResourceResponse(
                    response.getMimeType(),
                    response.getEncoding(),
                    statusCode,      // Всегда 200
                    reasonPhrase,    // Всегда "OK"
                    headers,         // Наши заголовки
                    response.getData() // Оригинальный поток данных
            );
        } else {
            // Если файл не найден или данные null
            Log.d(TAG, "Asset not found or null data for path: " + path);
            return null;
        }
    }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\EffectModule.java
package com.example.prismtone;

import android.content.Context;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;

public class EffectModule extends BaseModule {
    private JsonArray parameters;

    public EffectModule(Context context, ModuleInfo info) {
        super(context, info);
    }

    @Override
    public boolean initialize() {
        // Extract effect parameters from module data
        JsonObject data = getData().getAsJsonObject("data");
        if (data == null || !data.has("parameters")) {
            return false;
        }

        parameters = data.getAsJsonArray("parameters");
        return parameters != null && parameters.size() > 0;
    }

    @Override
    public boolean apply() {
        // Nothing to do here - parameters will be fetched via getParameters()
        return true;
    }

    /**
     * Gets the effect parameters
     */
    public JsonArray getParameters() {
        return parameters;
    }
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\FileUtils.java
package com.example.prismtone;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

/**
 * Utility class for file operations
 */
public class FileUtils {
    /**
     * Read a file into a string
     */
    public static String readFile(File file) throws IOException {
        StringBuilder content = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append("\n");
            }
        }
        return content.toString();
    }
    
    /**
     * Write a string to a file
     */
    public static void writeFile(File file, String content) throws IOException {
        try (FileWriter writer = new FileWriter(file)) {
            writer.write(content);
        }
    }
    
    /**
     * Delete a file
     */
    public static boolean deleteFile(File file) {
        return file.exists() && file.delete();
    }
    
    /**
     * Get all files in a directory with a specific extension
     */
    public static File[] getFilesWithExtension(File directory, String extension) {
        return directory.listFiles((dir, name) -> name.toLowerCase().endsWith(extension));
    }
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\FxChainModule.java
package com.example.prismtone;

import android.content.Context;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;

public class FxChainModule extends BaseModule {
    private JsonArray effectsSettings;

    public FxChainModule(Context context, ModuleInfo info) {
        super(context, info);
    }

    @Override
    public boolean initialize() {
        // Extract effects settings from module data
        JsonObject data = getData().getAsJsonObject("data");
        if (data == null || !data.has("effects")) {
            return false;
        }

        effectsSettings = data.getAsJsonArray("effects");
        return effectsSettings != null && effectsSettings.size() > 0;
    }

    @Override
    public boolean apply() {
        // Nothing to do here - settings will be fetched via getEffects()
        return true;
    }

    /**
     * Gets the effects settings for this FX chain
     */
    public JsonArray getEffects() {
        return effectsSettings;
    }
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\FxChainRepository.java
package com.example.prismtone;

import android.content.Context;
import android.util.Log;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class FxChainRepository {
    private static FxChainRepository instance;
    private final Context context;
    private final File chainDir;
    private final Gson gson;
    private static final String TAG = "FxChainRepository";

    private FxChainRepository(Context context) {
        this.context = context.getApplicationContext();
        this.chainDir = new File(context.getExternalFilesDir(null), "modules/fxchain");
        this.gson = new Gson();
        
        if (!chainDir.exists()) {
            chainDir.mkdirs();
        }
    }

    public static synchronized FxChainRepository getInstance(Context context) {
        if (instance == null) {
            instance = new FxChainRepository(context);
        }
        return instance;
    }

    /**
     * Returns a list of all user-created FX chains
     */
    public List<JsonObject> getUserFxChains() {
        List<JsonObject> chains = new ArrayList<>();
        
        File[] files = chainDir.listFiles((dir, name) -> name.endsWith(".json"));
        if (files == null) return chains;
        
        for (File file : files) {
            try {
                String json = FileUtils.readFile(file);
                JsonObject chain = gson.fromJson(json, JsonObject.class);
                chains.add(chain);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        
        return chains;
    }

    /**
     * Save a chain
     */
    public String saveChain(JsonObject chain) {
        try {
            // Generate a unique ID
            String id = "user_" + System.currentTimeMillis();
            
            // Set the ID in the chain data
            chain.addProperty("id", id);
            
            // Create directory if needed
            File userDir = new File(context.getExternalFilesDir(null), "modules/fxchain");
            if (!userDir.exists()) {
                userDir.mkdirs();
            }
            
            // Create the chain file
            File chainFile = new File(userDir, id + ".json");
            
            try {
                // Fixed: Using Gson to properly format the JSON with indentation
                String jsonOutput = new GsonBuilder().setPrettyPrinting().create().toJson(chain);
                FileUtils.writeFile(chainFile, jsonOutput);
                
                // Return the ID
                return id;
            } catch (IOException e) {
                Log.e(TAG, "Error saving chain file", e);
                return "Error: " + e.getMessage();
            }
        } catch (Exception e) {
            Log.e(TAG, "Error saving chain", e);
            return "Error: " + e.getMessage();
        }
    }
    
    /**
     * Save an FX chain from JSONObject
     */
    public String saveFxChain(JSONObject chain) {
        try {
            // Convert JSONObject to JsonObject
            JsonObject jsonObject = JsonParser.parseString(chain.toString()).getAsJsonObject();
            return saveChain(jsonObject);
        } catch (Exception e) {
            Log.e(TAG, "Error converting JSONObject to JsonObject", e);
            return "Error: " + e.getMessage();
        }
    }
    
    /**
     * Deletes a user FX chain
     * @return true if deleted successfully
     */
    public boolean deleteFxChain(String chainId) {
        // Don't allow deletion of default chains
        if (!chainId.startsWith("user_")) {
            return false;
        }
        
        File chainFile = new File(chainDir, chainId + ".json");
        return chainFile.exists() && chainFile.delete();
    }
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\I18nManager.java
package com.example.prismtone;

import android.content.Context;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;

import java.util.HashMap;
import java.util.Map;

public class I18nManager {
    private static I18nManager instance;
    private final Context context;
    private final Map<String, JsonObject> languageStrings;
    private String currentLanguage;

    private I18nManager(Context context) {
        this.context = context.getApplicationContext();
        this.languageStrings = new HashMap<>();
        this.currentLanguage = "en"; // Default language
    }

    public static synchronized I18nManager getInstance(Context context) {
        if (instance == null) {
            instance = new I18nManager(context);
        }
        return instance;
    }

    /**
     * Registers a language module
     */
    public void registerLanguage(String languageId, JsonObject strings) {
        languageStrings.put(languageId, strings);
    }

    /**
     * Sets the current language
     */
    public void setCurrentLanguage(String languageId) {
        if (languageStrings.containsKey(languageId)) {
            this.currentLanguage = languageId;
        }
    }

    /**
     * Gets a translated string by key
     */
    public String getString(String key) {
        return getString(key, null);
    }

    /**
     * Gets a translated string by key with fallback
     */
    public String getString(String key, String fallback) {
        JsonObject strings = languageStrings.get(currentLanguage);
        if (strings != null && strings.has(key)) {
            JsonElement element = strings.get(key);
            if (element.isJsonPrimitive()) {
                return element.getAsString();
            }
        }
        
        // Try English as fallback
        if (!currentLanguage.equals("en")) {
            JsonObject enStrings = languageStrings.get("en");
            if (enStrings != null && enStrings.has(key)) {
                JsonElement element = enStrings.get(key);
                if (element.isJsonPrimitive()) {
                    return element.getAsString();
                }
            }
        }
        
        return fallback != null ? fallback : key;
    }

    /**
     * Gets all strings for the current language
     */
    public JsonObject getAllStrings() {
        return languageStrings.getOrDefault(currentLanguage, new JsonObject());
    }
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\LanguageModule.java
package com.example.prismtone;

import android.content.Context;

import com.google.gson.JsonObject;

public class LanguageModule extends BaseModule {
    private JsonObject stringSettings;

    public LanguageModule(Context context, ModuleInfo info) {
        super(context, info);
    }

    @Override
    public boolean initialize() {
        // Extract string settings from module data
        JsonObject data = getData().getAsJsonObject("data");
        if (data == null || !data.has("strings")) {
            return false;
        }

        stringSettings = data.getAsJsonObject("strings");
        return stringSettings != null && stringSettings.size() > 0;
    }

    @Override
    public boolean apply() {
        // Nothing to do here - settings will be fetched via getStrings()
        return true;
    }

    /**
     * Gets the string settings for this language
     */
    public JsonObject getStrings() {
        return stringSettings;
    }
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\MainActivity.java
package com.example.prismtone;

import android.annotation.SuppressLint;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.WindowInsets;
import android.view.WindowInsetsController;
import android.view.WindowManager;
import android.webkit.WebResourceRequest;
import android.webkit.WebResourceResponse;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.view.WindowCompat;
import androidx.core.view.WindowInsetsCompat;
import androidx.core.view.WindowInsetsControllerCompat;
import androidx.lifecycle.ViewModelProvider;
import androidx.webkit.WebViewAssetLoader;

public class MainActivity extends AppCompatActivity {
    private WebView webView;
    private PrismtoneBridge bridge;
    private MainViewModel viewModel;
    private ModuleManager moduleManager;
    private WebViewAssetLoader assetLoader;

    @SuppressLint({"SetJavaScriptEnabled", "WrongConstant"})
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        WindowCompat.setDecorFitsSystemWindows(getWindow(), false);
        setContentView(R.layout.activity_main);
        hideSystemBars();

        viewModel = new ViewModelProvider(this).get(MainViewModel.class);

        assetLoader = new WebViewAssetLoader.Builder()
                .addPathHandler("/assets/", new CorsAssetsPathHandler(this))
                .setDomain("appassets.androidplatform.net")
                .build();

        webView = findViewById(R.id.webview);
        webView.setWebViewClient(new LocalContentWebViewClient(assetLoader));

        WebSettings webSettings = webView.getSettings();
        webSettings.setJavaScriptEnabled(true);
        webSettings.setDomStorageEnabled(true);
        webSettings.setAllowFileAccess(true);
        webSettings.setAllowContentAccess(true);
        webSettings.setAllowFileAccessFromFileURLs(false); // Безопасность: обычно false
        webSettings.setAllowUniversalAccessFromFileURLs(false); // Безопасность: обычно false
        webSettings.setMediaPlaybackRequiresUserGesture(false);
        WebView.setWebContentsDebuggingEnabled(true); // Для разработки

        moduleManager = new ModuleManager(this, viewModel);
        bridge = new PrismtoneBridge(this, webView, viewModel, moduleManager);
        webView.addJavascriptInterface(bridge, "PrismtoneBridge");

        webView.loadUrl("https://appassets.androidplatform.net/assets/index.html");

        moduleManager.scanModules();
    }

    private static class LocalContentWebViewClient extends WebViewClient {
        private final WebViewAssetLoader mAssetLoader;

        LocalContentWebViewClient(WebViewAssetLoader assetLoader) {
            mAssetLoader = assetLoader;
        }

        @Override
        @Nullable
        public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {
            Uri requestedUri = request.getUrl();
            return mAssetLoader.shouldInterceptRequest(requestedUri);
        }
    }

    @SuppressLint("WrongConstant")
    private void hideSystemBars() {
        WindowInsetsControllerCompat windowInsetsController =
                WindowCompat.getInsetsController(getWindow(), getWindow().getDecorView());
        if (windowInsetsController == null) {
            return;
        }
        windowInsetsController.hide(WindowInsetsCompat.Type.systemBars());
        windowInsetsController.setSystemBarsBehavior(
                WindowInsetsControllerCompat.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE
        );
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            getWindow().getAttributes().layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES;
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (webView != null) {
            webView.onResume();
            webView.evaluateJavascript("if(window.app && typeof window.app.resumeAudio === 'function') app.resumeAudio(); else console.warn('app.resumeAudio not found');", null);
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
        if (webView != null) {
            webView.onPause();
            webView.evaluateJavascript("if(window.app && typeof window.app.suspendAudio === 'function') app.suspendAudio(); else console.warn('app.suspendAudio not found');", null);
            // Вызов сохранения настроек при сворачивании
            webView.evaluateJavascript("if(window.triggerSaveSettingsOnPause) window.triggerSaveSettingsOnPause(); else console.warn('window.triggerSaveSettingsOnPause not found');", null);
        }
    }

    @Override
    protected void onDestroy() {
        if (webView != null) {
            android.view.ViewGroup parent = (android.view.ViewGroup) webView.getParent();
            if (parent != null) {
                parent.removeView(webView);
            }
            webView.stopLoading();
            webView.getSettings().setJavaScriptEnabled(false);
            webView.clearHistory();
            webView.clearCache(true);
            webView.loadUrl("about:blank");
            webView.onPause();
            webView.removeAllViews();
            webView.destroyDrawingCache();
            webView.destroy();
            webView = null;
            Log.d("MainActivity", "WebView destroyed");
        }
        super.onDestroy();
    }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\MainViewModel.java
// Файл: app\src\main\java\com\example\prismtone\MainViewModel.java
package com.example.prismtone;

import androidx.lifecycle.LiveData;
import androidx.lifecycle.MutableLiveData;
import androidx.lifecycle.ViewModel;
import com.google.gson.Gson; // Для десериализации JSON в setYAxisControlsFromJson

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import com.example.prismtone.model.YAxisControls;

public class MainViewModel extends ViewModel {

    // YAxisControls класс теперь определен в YAxisControls.java

    private final MutableLiveData<String> currentTheme = new MutableLiveData<>("day");
    private final MutableLiveData<String> currentLanguage = new MutableLiveData<>("en");
    private final MutableLiveData<String> currentSoundPreset = new MutableLiveData<>("default_piano");
    private final MutableLiveData<String> currentFxChain = new MutableLiveData<>("default_ambient");
    private final MutableLiveData<String> currentVisualizer = new MutableLiveData<>("waves");
    private final MutableLiveData<String> touchEffect = new MutableLiveData<>("glow");
    private final MutableLiveData<String> currentScale = new MutableLiveData<>("major");
    private final MutableLiveData<Integer> octaveOffset = new MutableLiveData<>(0);
    private final MutableLiveData<Integer> zoneCount = new MutableLiveData<>(12);

    // === НОВОЕ: Состояние для текущей тоники ===
    private final MutableLiveData<String> currentTonic = new MutableLiveData<>("C4");
    // ==========================================

    // Используем новый класс YAxisControls
    private final MutableLiveData<YAxisControls> yAxisControlsLiveData = new MutableLiveData<>(new YAxisControls());

    private final Map<String, Object> genericSettings = new HashMap<>();

    public MainViewModel() {
        genericSettings.put("theme", currentTheme.getValue());
        genericSettings.put("language", currentLanguage.getValue());
        genericSettings.put("soundPreset", currentSoundPreset.getValue());
        genericSettings.put("fxChain", currentFxChain.getValue());
        genericSettings.put("visualizer", currentVisualizer.getValue());
        genericSettings.put("touchEffect", touchEffect.getValue());
        genericSettings.put("scale", currentScale.getValue());
        genericSettings.put("octaveOffset", octaveOffset.getValue());
        genericSettings.put("zoneCount", zoneCount.getValue());
        genericSettings.put("showNoteNames", true);
        genericSettings.put("showLines", true); // Изменил обратно на showLines для соответствия HTML
        genericSettings.put("masterVolumeCeiling", 1.0);
        genericSettings.put("enablePolyphonyVolumeScaling", true);
        // yAxisControlsLiveData уже инициализирован экземпляром YAxisControls с дефолтными значениями VolumeControl и EffectsControl
        // === НОВОЕ: Настройки по умолчанию для тоники и стилизации ===
        genericSettings.put("currentTonic", currentTonic.getValue());
        genericSettings.put("highlightSharpsFlats", false);
        // ===========================================================
    }

    public LiveData<String> getCurrentTheme() { return currentTheme; }
    public LiveData<String> getCurrentLanguage() { return currentLanguage; }
    public LiveData<String> getCurrentSoundPreset() { return currentSoundPreset; }
    public LiveData<String> getCurrentFxChain() { return currentFxChain; }
    public LiveData<String> getCurrentVisualizer() { return currentVisualizer; }
    public LiveData<String> getTouchEffect() { return touchEffect; }
    public LiveData<String> getCurrentScale() { return currentScale; }
    public LiveData<Integer> getOctaveOffset() { return octaveOffset; }
    public LiveData<Integer> getZoneCount() { return zoneCount; }
    public LiveData<YAxisControls> getYAxisControls() { return yAxisControlsLiveData; }

    // === НОВОЕ: Getter для текущей тоники ===
    public LiveData<String> getCurrentTonic() { return currentTonic; }
    // ========================================

    public void setCurrentTheme(String themeId) {
        currentTheme.setValue(themeId);
        genericSettings.put("theme", themeId);
    }
    public void setCurrentLanguage(String languageId) {
        currentLanguage.setValue(languageId);
        genericSettings.put("language", languageId);
    }
    public void setCurrentSoundPreset(String presetId) {
        currentSoundPreset.setValue(presetId);
        genericSettings.put("soundPreset", presetId);
    }
    public void setCurrentFxChain(String chainId) {
        currentFxChain.setValue(chainId);
        genericSettings.put("fxChain", chainId);
    }
    public void setCurrentVisualizer(String visualizerId) {
        currentVisualizer.setValue(visualizerId);
        genericSettings.put("visualizer", visualizerId);
    }
    public void setTouchEffect(String effectId) {
        touchEffect.setValue(effectId);
        genericSettings.put("touchEffect", effectId);
    }
    public void setCurrentScale(String scaleId) {
        currentScale.setValue(scaleId);
        genericSettings.put("scale", scaleId);
    }

    // === НОВОЕ: Setter для текущей тоники ===
    public void setCurrentTonic(String tonic) {
        currentTonic.setValue(tonic);
        genericSettings.put("currentTonic", tonic);
    }
    // ========================================

    public void setOctaveOffset(int offset) {
        int clampedOffset = Math.max(-7, Math.min(7, offset));
        octaveOffset.setValue(clampedOffset);
        genericSettings.put("octaveOffset", clampedOffset);
    }

    public void setZoneCount(int count) {
        if (count == 7 || count == 12 || count == 24 || count == 36) {
            zoneCount.setValue(count);
            genericSettings.put("zoneCount", count);
        }
    }

    public void setYAxisControls(YAxisControls newControls) {
        if (newControls != null) {
            yAxisControlsLiveData.setValue(newControls);
            // genericSettings.put("yAxisControls", newControls); // Не храним весь объект в genericSettings, т.к. он сложный
        }
    }

    // Метод для обновления YAxisControls из JSON строки (например, от Bridge)
    public void setYAxisControlsFromJson(String jsonString) {
        try {
            Gson gson = new Gson();
            YAxisControls newControls = gson.fromJson(jsonString, YAxisControls.class);
            if (newControls != null) {
                // Обеспечиваем, что вложенные объекты не null
                if (newControls.getVolume() == null) newControls.setVolume(new YAxisControls.VolumeControl());
                if (newControls.getEffects() == null) newControls.setEffects(new YAxisControls.EffectsControl());
                setYAxisControls(newControls);
            }
        } catch (Exception e) {
            // Log error
        }
    }


    public void setGenericSetting(String key, Object value) {
        // ... (логика для masterVolumeCeiling и enablePolyphonyVolumeScaling остается) ...
        switch (key) {
            case "theme": setCurrentTheme((String) value); break;
            case "language": setCurrentLanguage((String) value); break;
            case "soundPreset": setCurrentSoundPreset((String) value); break;
            case "fxChain": setCurrentFxChain((String) value); break;
            case "visualizer": setCurrentVisualizer((String) value); break;
            case "touchEffect": setTouchEffect((String) value); break;
            case "scale": setCurrentScale((String) value); break;
            case "octaveOffset":
                if (value instanceof Number) setOctaveOffset(((Number) value).intValue());
                else if (value instanceof String) setOctaveOffset(Integer.parseInt((String) value));
                break;
            case "zoneCount":
                if (value instanceof Number) setZoneCount(((Number) value).intValue());
                else if (value instanceof String) setZoneCount(Integer.parseInt((String) value));
                break;
            case "showNoteNames":
            case "showLines": // Изменено обратно на showLines
            case "enablePolyphonyVolumeScaling":
                if (value instanceof Boolean) genericSettings.put(key, value);
                else if (value instanceof String) genericSettings.put(key, Boolean.parseBoolean((String) value));
                break;
            case "masterVolumeCeiling":
                if (value instanceof Number) genericSettings.put(key, ((Number) value).doubleValue());
                else if (value instanceof String) {
                    try {
                        genericSettings.put(key, Double.parseDouble((String) value));
                    } catch (NumberFormatException e) {
                        // Log error or handle
                    }
                }
                break;
            case "currentTonic":
                if (value instanceof String) setCurrentTonic((String) value);
                break;
            case "highlightSharpsFlats":
                if (value instanceof Boolean) genericSettings.put(key, value);
                else if (value instanceof String) genericSettings.put(key, Boolean.parseBoolean((String) value));
                break;
            default:
                genericSettings.put(key, value);
                break;
        }
    }

    public Object getSetting(String key) {
        // ... (логика для masterVolumeCeiling и enablePolyphonyVolumeScaling остается) ...
        switch (key) {
            case "theme": return Objects.requireNonNullElse(currentTheme.getValue(), genericSettings.get(key));
            case "language": return Objects.requireNonNullElse(currentLanguage.getValue(), genericSettings.get(key));
            case "soundPreset": return Objects.requireNonNullElse(currentSoundPreset.getValue(), genericSettings.get(key));
            case "fxChain": return currentFxChain.getValue();
            case "visualizer": return Objects.requireNonNullElse(currentVisualizer.getValue(), genericSettings.get(key));
            case "touchEffect": return Objects.requireNonNullElse(touchEffect.getValue(), genericSettings.get(key));
            case "scale": return Objects.requireNonNullElse(currentScale.getValue(), genericSettings.get(key));
            case "octaveOffset": return Objects.requireNonNullElse(octaveOffset.getValue(), genericSettings.get(key));
            case "zoneCount": return Objects.requireNonNullElse(zoneCount.getValue(), genericSettings.get(key));
            // yAxisControls получается целиком через getYAxisControls().getValue()
            case "masterVolumeCeiling":
            case "enablePolyphonyVolumeScaling":
            case "currentTonic": return Objects.requireNonNullElse(currentTonic.getValue(), genericSettings.get(key));
            default:
                return genericSettings.get(key);
        }
    }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\ModuleInfo.java
package com.example.prismtone;

import com.google.gson.JsonObject;

public class ModuleInfo {
    private final String id;
    private final String type;
    private final String name;
    private final String version;
    private final String description;
    private final boolean active;
    private final String path;
    private final JsonObject data;

    public ModuleInfo(String id, String type, String name, String version, 
                     String description, boolean active, String path, JsonObject data) {
        this.id = id;
        this.type = type;
        this.name = name;
        this.version = version;
        this.description = description;
        this.active = active;
        this.path = path;
        this.data = data;
    }

    public String getId() {
        return id;
    }

    public String getType() {
        return type;
    }

    public String getName() {
        return name;
    }

    public String getVersion() {
        return version;
    }

    public String getDescription() {
        return description;
    }

    public boolean isActive() {
        return active;
    }

    public String getPath() {
        return path;
    }

    public JsonObject getData() {
        return data;
    }
    
    @Override
    public String toString() {
        return "ModuleInfo{" +
                "id='" + id + '\'' +
                ", type='" + type + '\'' +
                ", name='" + name + '\'' +
                ", version='" + version + '\'' +
                '}';
    }
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\ModuleLoader.java
package com.example.prismtone;

import android.content.Context;

import com.google.gson.JsonObject;

import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;

public class ModuleLoader {
    private final Context context;
    private final ModuleRegistry registry;
    private final Map<String, BaseModule> loadedModules;

    public ModuleLoader(Context context, ModuleRegistry registry) {
        this.context = context;
        this.registry = registry;
        this.loadedModules = new HashMap<>();
    }

    /**
     * Loads a module based on its info
     */
    public BaseModule loadModule(ModuleInfo info) {
        String moduleId = info.getId();
        String moduleType = info.getType();
        
        // Check if already loaded
        if (loadedModules.containsKey(moduleId)) {
            return loadedModules.get(moduleId);
        }
        
        try {
            // Get the module class for this type
            Class<? extends BaseModule> moduleClass = registry.getModuleClass(moduleType);
            if (moduleClass == null) {
                throw new IllegalArgumentException("Unknown module type: " + moduleType);
            }
            
            // Create module instance using reflection
            Constructor<? extends BaseModule> constructor = moduleClass.getConstructor(Context.class, ModuleInfo.class);
            BaseModule module = constructor.newInstance(context, info);
            
            // Initialize the module
            if (module.initialize()) {
                loadedModules.put(moduleId, module);
                return module;
            } else {
                throw new RuntimeException("Failed to initialize module: " + moduleId);
            }
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * Unloads a module by ID
     */
    public boolean unloadModule(String moduleId) {
        if (loadedModules.containsKey(moduleId)) {
            BaseModule module = loadedModules.get(moduleId);
            if (module.onUnload()) {
                loadedModules.remove(moduleId);
                return true;
            }
        }
        return false;
    }

    /**
     * Gets a loaded module by ID
     */
    public BaseModule getModule(String moduleId) {
        return loadedModules.get(moduleId);
    }

    /**
     * Gets a loaded module by ID and casts it to the specified type
     */
    @SuppressWarnings("unchecked")
    public <T extends BaseModule> T getModuleAs(String moduleId, Class<T> moduleClass) {
        BaseModule module = loadedModules.get(moduleId);
        if (module != null && moduleClass.isInstance(module)) {
            return (T) module;
        }
        return null;
    }
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\ModuleManager.java
package com.example.prismtone;

import android.content.Context;
import android.util.Log;
import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonSyntaxException;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays; // Для Arrays.toString()
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner; // Для более надежного чтения файла

public class ModuleManager {
    private final Context context;
    private final MainViewModel viewModel;
    private final Map<String, List<ModuleInfo>> modules;
    private final Gson gson;
    private static final String TAG = "ModuleManager";

    public ModuleManager(Context context, MainViewModel viewModel) {
        this.context = context.getApplicationContext();
        this.viewModel = viewModel;
        this.modules = new HashMap<>();
        this.gson = new Gson();

        // Инициализация карты модулей для всех известных типов
        String[] knownModuleTypes = {
                "soundpreset", "fxchain", "theme", "language", "visualizer",
                "effect", "scale", "audioComponent", "touchEffect"
        };
        for (String type : knownModuleTypes) {
            modules.put(type, new ArrayList<>());
        }
        Log.d(TAG, "ModuleManager initialized. Known module types: " + Arrays.toString(knownModuleTypes));
    }

    public void scanModules() {
        Log.i(TAG, "Starting module scan...");
        scanAssetsModules();
        // scanExternalModules(); // Если потребуется в будущем

        if (viewModel != null) {
            ensureDefaultModules();
        } else {
            Log.w(TAG, "ViewModel is null, skipping ensureDefaultModules during scan.");
        }

        Log.i(TAG, "Module scanning complete. Summary:");
        for (Map.Entry<String, List<ModuleInfo>> entry : modules.entrySet()) {
            Log.i(TAG, "  Type: " + entry.getKey() + ", Count: " + entry.getValue().size());
        }
    }

    private void scanAssetsModules() {
        Log.d(TAG, "scanAssetsModules: Attempting to list 'modules' directory in assets...");
        String[] moduleDirs;
        try {
            moduleDirs = context.getAssets().list("modules");
        } catch (IOException e) {
            Log.e(TAG, "scanAssetsModules: IOException listing root 'modules' directory.", e);
            return;
        }

        if (moduleDirs == null || moduleDirs.length == 0) {
            Log.e(TAG, "scanAssetsModules: 'modules' directory in assets is empty or not found!");
            return;
        }
        Log.d(TAG, "scanAssetsModules: Found asset sub-directories: " + Arrays.toString(moduleDirs));

        for (String moduleTypeDirName : moduleDirs) {
            Log.d(TAG, "scanAssetsModules: Processing directory: modules/" + moduleTypeDirName);

            if (!modules.containsKey(moduleTypeDirName)) {
                Log.w(TAG, "scanAssetsModules: Skipping directory '" + moduleTypeDirName + "' as it's not a known module type.");
                continue;
            }

            String[] moduleFiles;
            try {
                moduleFiles = context.getAssets().list("modules/" + moduleTypeDirName);
            } catch (IOException e) {
                Log.e(TAG, "scanAssetsModules: IOException listing files in 'modules/" + moduleTypeDirName + "'. Skipping this directory.", e);
                continue;
            }

            if (moduleFiles == null || moduleFiles.length == 0) {
                Log.w(TAG, "scanAssetsModules: No files found in directory: modules/" + moduleTypeDirName);
                continue;
            }
            Log.d(TAG, "scanAssetsModules: Files in 'modules/" + moduleTypeDirName + "': " + Arrays.toString(moduleFiles));

            for (String moduleFile : moduleFiles) {
                if (moduleFile.endsWith(".json")) {
                    String path = "modules/" + moduleTypeDirName + "/" + moduleFile;
                    Log.d(TAG, "--- Processing file: " + path + " ---");

                    String jsonString;
                    try (InputStream is = context.getAssets().open(path);
                         Scanner scanner = new Scanner(is, StandardCharsets.UTF_8.name()).useDelimiter("\\A")) {
                        jsonString = scanner.hasNext() ? scanner.next() : "";
                    } catch (IOException e) {
                        Log.e(TAG, "IOException reading file " + path, e);
                        continue; // Пропустить этот файл
                    }

                    if (jsonString.isEmpty()) {
                        Log.w(TAG, "File content is empty for: " + path);
                        continue; // Пропустить этот файл
                    }
                    // Логируем только начало, чтобы не засорять Logcat полностью
                    Log.v(TAG, "Raw JSON for " + path + " (first 200 chars): " + jsonString.substring(0, Math.min(jsonString.length(), 200)));

                    JsonObject moduleJson = null;
                    try {
                        moduleJson = gson.fromJson(jsonString, JsonObject.class);
                    } catch (JsonSyntaxException e) {
                        Log.e(TAG, "GSON parsing error for " + path + ". Invalid JSON content.", e);
                        continue; // Пропустить этот файл
                    }

                    if (moduleJson == null) {
                        // Это может случиться, если JSON строка была, например, "null"
                        Log.e(TAG, "GSON parsing resulted in NULL JsonObject for " + path + ".");
                        continue; // Пропустить этот файл
                    }
                    Log.d(TAG, "Successfully parsed JSON for " + path);

                    // Проверка обязательных полей верхнего уровня
                    boolean hasId = moduleJson.has("id") && moduleJson.get("id").isJsonPrimitive() && moduleJson.get("id").getAsJsonPrimitive().isString();
                    boolean hasType = moduleJson.has("type") && moduleJson.get("type").isJsonPrimitive() && moduleJson.get("type").getAsJsonPrimitive().isString();
                    boolean hasName = moduleJson.has("name") && moduleJson.get("name").isJsonPrimitive() && moduleJson.get("name").getAsJsonPrimitive().isString();
                    boolean hasVersion = moduleJson.has("version") && moduleJson.get("version").isJsonPrimitive() && moduleJson.get("version").getAsJsonPrimitive().isString();

                    String parsedType = hasType ? moduleJson.get("type").getAsString() : "N/A_TYPE";
                    String parsedId = hasId ? moduleJson.get("id").getAsString() : "N/A_ID";

                    Log.d(TAG, "Validation for " + path + ": id=" + parsedId + " (valid: " + hasId + ")" +
                            ", type=" + parsedType + " (valid: " + hasType + ")" +
                            ", name=" + (hasName ? moduleJson.get("name").getAsString() : "N/A_NAME") + " (valid: " + hasName + ")" +
                            ", version=" + (hasVersion ? moduleJson.get("version").getAsString() : "N/A_VERSION") + " (valid: " + hasVersion + ")");

                    if (hasId && hasType && hasName && hasVersion) {
                        // Важно: Проверяем, что тип из JSON совпадает с именем директории
                        if (!parsedType.equals(moduleTypeDirName)) {
                            Log.w(TAG, "Module type mismatch for " + path + ": Directory is '" + moduleTypeDirName + "', but JSON 'type' is '" + parsedType + "'. Skipping.");
                            continue;
                        }

                        ModuleInfo info = new ModuleInfo(
                                parsedId,
                                parsedType,
                                moduleJson.get("name").getAsString(),
                                moduleJson.get("version").getAsString(),
                                (moduleJson.has("description") && moduleJson.get("description").isJsonPrimitive()) ? moduleJson.get("description").getAsString() : "",
                                (moduleJson.has("active") && moduleJson.get("active").isJsonPrimitive()) ? moduleJson.get("active").getAsBoolean() : true,
                                "asset://" + path,
                                moduleJson // Передаем весь JSON-объект
                        );
                        Log.d(TAG, "ModuleInfo created for: " + info.getId() + " of type " + info.getType());
                        addModule(info);
                    } else {
                        Log.w(TAG, "Skipping module " + path + " due to missing or invalid required fields (id, type, name, version).");
                    }
                }
            }
        }
    }

    // scanExternalModules() - остается без изменений или закомментирован

    private void addModule(ModuleInfo info) {
        String type = info.getType();
        // Лог о попытке добавлен в scanAssetsModules перед вызовом addModule
        List<ModuleInfo> list = modules.get(type); // Тип уже должен быть валидным и присутствовать в карте

        boolean replaced = false;
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i).getId().equals(info.getId())) {
                list.set(i, info); // Заменяем существующий с тем же ID
                replaced = true;
                Log.i(TAG, "addModule: Successfully REPLACED module: " + info.getId() + " (type: " + type + ")");
                break;
            }
        }
        if (!replaced) {
            list.add(info);
            Log.i(TAG, "addModule: Successfully ADDED module: " + info.getId() + " (type: " + type + ")");
        }
    }

    private void ensureDefaultModules() {
        if (viewModel == null) {
            Log.w(TAG, "ensureDefaultModules: ViewModel is null. Cannot set defaults.");
            return;
        }
        Log.d(TAG, "ensureDefaultModules: Setting default modules...");

        setDefault(viewModel::setCurrentSoundPreset, "soundpreset", "default_piano");
        // Для FX Chain, если вы хотите "никакой цепочки по умолчанию", передайте null.
        // Если вы хотите, чтобы "default_ambient" (или другой) был по умолчанию, если он существует:
        setDefault(viewModel::setCurrentFxChain, "fxchain", "default_ambient"); // Или null, если хотите "никакой"
        setDefault(viewModel::setCurrentTheme, "theme", "day");
        setDefault(viewModel::setCurrentLanguage, "language", "en");
        setDefault(viewModel::setCurrentVisualizer, "visualizer", "waves");
        setDefault(viewModel::setTouchEffect, "touchEffect", "glow");
        setDefault(viewModel::setCurrentScale, "scale", "major");
    }

    private void setDefault(java.util.function.Consumer<String> setter, String moduleType, String defaultId) {
        List<ModuleInfo> list = modules.get(moduleType);
        String selectedIdToSet = defaultId;

        Log.d(TAG, "setDefault: Processing type '" + moduleType + "' with defaultId '" + defaultId + "'. Found " + (list != null ? list.size() : "null list") + " modules.");

        if (list != null && !list.isEmpty()) {
            ModuleInfo activeModule = list.stream()
                    .filter(ModuleInfo::isActive) // Ищем активный
                    .findFirst()
                    .orElse(null);

            if (activeModule != null) {
                selectedIdToSet = activeModule.getId();
                Log.d(TAG, "setDefault: Found active module for type '" + moduleType + "': " + selectedIdToSet);
            } else {
                final String finalDefaultId = defaultId; // Для использования в лямбде
                boolean defaultIdExistsInList = (defaultId != null) && list.stream().anyMatch(m -> m.getId().equals(finalDefaultId));

                if (defaultIdExistsInList) {
                    selectedIdToSet = defaultId;
                    Log.d(TAG, "setDefault: No active module for '" + moduleType + "', but provided defaultId '" + defaultId + "' exists. Using it.");
                } else {
                    selectedIdToSet = list.get(0).getId(); // Берем первый из списка
                    Log.d(TAG, "setDefault: No active module for '" + moduleType + "' and defaultId '" + defaultId + "' not in list (or was null). Using first from list: " + selectedIdToSet);
                }
            }
        } else {
            Log.w(TAG, "setDefault: Module list for type '" + moduleType + "' is empty. Using provided defaultId: " + defaultId);
            // selectedIdToSet остается равным defaultId
        }

        // Особая обработка для fxChain, где null является валидным значением
        if (moduleType.equals("fxchain")) {
            Log.d(TAG, "setDefault for fxChain: Final ID to set is '" + selectedIdToSet + "'. Calling setter.");
            setter.accept(selectedIdToSet); // selectedIdToSet может быть null
        } else if (selectedIdToSet != null) {
            Log.d(TAG, "setDefault for " + moduleType + ": Final ID to set is '" + selectedIdToSet + "'. Calling setter.");
            setter.accept(selectedIdToSet);
        } else {
            Log.w(TAG, "setDefault: No valid module ID to set for type '" + moduleType + "' (selectedIdToSet is null and it's not fxchain). Setter NOT called.");
        }
    }

    public List<ModuleInfo> getModules(String moduleType) {
        Log.d(TAG, "getModules (Java): Received moduleType: " + moduleType);
        List<ModuleInfo> result = modules.getOrDefault(moduleType, new ArrayList<>());
        Log.d(TAG, "getModules (Java): Found " + result.size() + " modules in cache for type: " + moduleType);
        return result;
    }
    // compareVersions не нужен, если мы просто заменяем по ID
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\ModuleRegistry.java
package com.example.prismtone;

import java.util.HashMap;
import java.util.Map;

public class ModuleRegistry {
    private final Map<String, Class<? extends BaseModule>> moduleClasses;

    public ModuleRegistry() {
        moduleClasses = new HashMap<>();
        
        // Register built-in module types
        registerModuleClass("soundpreset", SoundPresetModule.class);
        registerModuleClass("fxchain", FxChainModule.class);
        registerModuleClass("theme", ThemeModule.class);
        registerModuleClass("language", LanguageModule.class);
        registerModuleClass("visualizer", VisualizerModule.class);
        registerModuleClass("effect", EffectModule.class);
        registerModuleClass("scale", ScaleModule.class);
        registerModuleClass("touchEffect", TouchEffectModule.class);
    }

    /**
     * Registers a module class for a specific module type
     */
    public void registerModuleClass(String moduleType, Class<? extends BaseModule> moduleClass) {
        moduleClasses.put(moduleType, moduleClass);
    }

    /**
     * Returns the module class for a specific module type
     */
    public Class<? extends BaseModule> getModuleClass(String moduleType) {
        return moduleClasses.get(moduleType);
    }
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\ModuleUpdater.java
package com.example.prismtone;

import android.content.Context;
import android.os.Handler;
import android.os.Looper;
import androidx.concurrent.futures.CallbackToFutureAdapter;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.gson.Gson;
import com.google.gson.JsonObject;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

public class ModuleUpdater {
    private final Context context;
    private final ModuleManager moduleManager;
    private final Map<String, ModuleUpdateListener> updateListeners;
    private final Executor executor = Executors.newSingleThreadExecutor();
    private final Handler mainHandler = new Handler(Looper.getMainLooper());
    
    /**
     * Interface for module update callbacks
     */
    public interface ModuleUpdateListener {
        void onUpdateStarted(String moduleType);
        void onUpdateProgress(String moduleType, int progress, int total);
        void onUpdateCompleted(String moduleType, int updated);
        void onUpdateFailed(String moduleType, String error);
        void onUpdateCheckStarted();
        void onUpdateCheckCompleted(int result);
    }

    public ModuleUpdater(Context context, ModuleManager moduleManager) {
        this.context = context;
        this.moduleManager = moduleManager;
        this.updateListeners = new HashMap<>();
    }

    /**
     * Add an update listener
     */
    public void addUpdateListener(String moduleType, ModuleUpdateListener listener) {
        updateListeners.put(moduleType, listener);
    }

    /**
     * Remove an update listener
     */
    public void removeUpdateListener(String moduleType) {
        updateListeners.remove(moduleType);
    }

    /**
     * Check for module updates
     */
    public void checkForUpdates(String moduleType) {
        // Replace deprecated AsyncTask with modern concurrency
        startUpdateCheck(moduleType);
    }
    
    /**
     * Start the update check process
     */
    private void startUpdateCheck(String moduleType) {
        ModuleUpdateListener listener = updateListeners.get(moduleType);
        if (listener != null) {
            listener.onUpdateCheckStarted();
        }
        
        ListenableFuture<Integer> future = CallbackToFutureAdapter.getFuture(completer -> {
            executor.execute(() -> {
                try {
                    int result = performUpdateCheck(moduleType);
                    mainHandler.post(() -> {
                        if (listener != null) {
                            listener.onUpdateCheckCompleted(result);
                        }
                    });
                    completer.set(result);
                } catch (Exception e) {
                    completer.setException(e);
                }
            });
            return "UpdateCheck";
        });
    }
    
    /**
     * Perform the actual update check
     */
    private int performUpdateCheck(String moduleType) {
        int total = 10; // Example total
        for (int i = 0; i < total; i++) {
            // Simulating work
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return -1;
            }
            
            final int progress = i + 1;
            ModuleUpdateListener listener = updateListeners.get(moduleType);
            mainHandler.post(() -> {
                if (listener != null) {
                    listener.onUpdateProgress(moduleType, progress, total);
                }
            });
        }
        
        return 1; // Success
    }

    /**
     * Update a module to a newer version
     */
    public boolean updateModule(ModuleInfo oldModule, JsonObject newModuleData) {
        try {
            // Create a temporary file for the new module
            File moduleDir = new File(context.getExternalFilesDir(null), 
                                     "modules/" + oldModule.getType());
            if (!moduleDir.exists()) {
                moduleDir.mkdirs();
            }
            
            // Create file for new module
            File newModuleFile = new File(moduleDir, oldModule.getId() + ".json");
            
            // Write updated module to file
            Gson gson = new Gson();
            FileUtils.writeFile(newModuleFile, gson.toJson(newModuleData));
            
            return true;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\ModuleValidator.java
package com.example.prismtone;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class ModuleValidator {
    private static final Set<String> VALID_MODULE_TYPES = new HashSet<>(Arrays.asList(
        "soundpreset", "fxchain", "theme", "language", "visualizer", "effect", "scale"
    ));

    /**
     * Validates a module JSON structure
     * @return true if the module is valid
     */
    public boolean validateModule(JsonObject moduleJson) {
        if (moduleJson == null) {
            return false;
        }

        // Check required fields
        if (!hasRequiredFields(moduleJson)) {
            return false;
        }

        // Check module type
        String moduleType = moduleJson.get("type").getAsString();
        if (!VALID_MODULE_TYPES.contains(moduleType)) {
            return false;
        }

        // Validate module data based on type
        if (moduleJson.has("data")) {
            return validateModuleData(moduleType, moduleJson.getAsJsonObject("data"));
        }

        return true;
    }

    /**
     * Checks if the module has all required fields
     */
    private boolean hasRequiredFields(JsonObject moduleJson) {
        return moduleJson.has("id") && !moduleJson.get("id").getAsString().isEmpty() &&
               moduleJson.has("type") && !moduleJson.get("type").getAsString().isEmpty() &&
               moduleJson.has("name") && !moduleJson.get("name").getAsString().isEmpty() &&
               moduleJson.has("version") && !moduleJson.get("version").getAsString().isEmpty() &&
               moduleJson.has("description") &&
               moduleJson.has("active");
    }

    /**
     * Validates module data based on module type
     */
    private boolean validateModuleData(String moduleType, JsonObject data) {
        if (data == null) {
            return false;
        }

        switch (moduleType) {
            case "soundpreset":
                return validateSoundPresetData(data);
            case "fxchain":
                return validateFxChainData(data);
            case "theme":
                return validateThemeData(data);
            case "language":
                return validateLanguageData(data);
            case "visualizer":
                return validateVisualizerData(data);
            case "effect":
                return validateEffectData(data);
            case "scale":
                return validateScaleData(data);
            default:
                return false;
        }
    }

    private boolean validateSoundPresetData(JsonObject data) {
        // Sound preset must have oscillator or envelope or filter
        return data.has("oscillator") || data.has("envelope") || data.has("filter");
    }

    private boolean validateFxChainData(JsonObject data) {
        // FX chain must have effects array
        return data.has("effects") && data.get("effects").isJsonArray();
    }

    private boolean validateThemeData(JsonObject data) {
        // Theme must have colors object
        return data.has("colors") && data.get("colors").isJsonObject();
    }

    private boolean validateLanguageData(JsonObject data) {
        // Language must have strings object
        return data.has("strings") && data.get("strings").isJsonObject();
    }

    private boolean validateVisualizerData(JsonObject data) {
        // Minimal validation for visualizer
        return true;
    }

    private boolean validateEffectData(JsonObject data) {
        // Effect must have parameters array
        return data.has("parameters") && data.get("parameters").isJsonArray();
    }

    private boolean validateScaleData(JsonObject data) {
        // Scale must have intervals array
        return data.has("intervals") && data.get("intervals").isJsonArray();
    }
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\PrismtoneBridge.java
// Файл: app\src\main\java\com\example\prismtone\PrismtoneBridge.java
package com.example.prismtone;

import android.content.Context;
import android.os.Handler;
import android.os.Looper;
import android.util.Log;
import android.webkit.JavascriptInterface;
import android.webkit.WebView;
import androidx.annotation.Keep;
import com.example.prismtone.model.YAxisControls;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonSyntaxException;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonNull; // <<<--- ДОБАВЛЕН ИМПОРТ

import java.util.List;
import java.util.Objects;

@Keep
public class PrismtoneBridge {
    private final Context context;
    private final WebView webView;
    private final MainViewModel viewModel;
    private final ModuleManager moduleManager;
    private final Handler mainHandler;
    private final Gson gson;
    private static final String TAG = "PrismtoneBridge";

    public PrismtoneBridge(Context context, WebView webView, MainViewModel viewModel, ModuleManager moduleManager) {
        this.context = context.getApplicationContext();
        this.webView = webView;
        this.viewModel = viewModel;
        this.moduleManager = moduleManager;
        this.mainHandler = new Handler(Looper.getMainLooper());
        this.gson = new GsonBuilder().serializeNulls().create();
    }

    private void runJavaScript(final String script) {
        if (Looper.myLooper() == Looper.getMainLooper()) {
            evaluateJs(script);
        } else {
            mainHandler.post(() -> evaluateJs(script));
        }
    }

    private void evaluateJs(final String script) {
        if (webView != null) {
            try {
                webView.evaluateJavascript(script, null);
            } catch (Exception e) {
                Log.e(TAG, "Exception evaluating JavaScript: " + script, e);
            }
        } else {
            Log.e(TAG, "WebView is null, cannot execute JavaScript: " + script);
        }
    }

    public void callJsFunction(String functionName, Object... args) {
        if (functionName == null || functionName.trim().isEmpty()) {
            Log.e(TAG, "callJsFunction called with empty function name.");
            return;
        }
        StringBuilder builder = new StringBuilder();
        builder.append(functionName).append("(");
        for (int i = 0; i < args.length; i++) {
            if (i > 0) builder.append(",");
            Object arg = args[i];
            if (arg == null) {
                builder.append("null");
            } else if (arg instanceof String) {
                builder.append("'").append(escapeStringForJs((String) arg)).append("'");
            } else if (arg instanceof Number || arg instanceof Boolean) {
                builder.append(arg);
            } else {
                try {
                    builder.append(gson.toJson(arg));
                } catch (Exception e) {
                    Log.e(TAG, "Error converting argument to JSON for JS call: " + arg, e);
                    builder.append("null");
                }
            }
        }
        builder.append(")");
        runJavaScript(builder.toString());
    }

    private String escapeStringForJs(String s) {
        if (s == null) return "";
        return s.replace("\\", "\\\\")
                .replace("'", "\\'")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t")
                .replace("\b", "\\b")
                .replace("\f", "\\f")
                .replace("</", "<\\/");
    }

    @JavascriptInterface
    public String getModules(String moduleType) {
        Log.d(TAG, "getModules called for type: " + moduleType);
        try {
            if (moduleManager != null) {
                List<ModuleInfo> moduleList = moduleManager.getModules(moduleType);
                return gson.toJson(moduleList);
            } else {
                Log.e(TAG, "getModules: moduleManager is null!");
                return "[]";
            }
        } catch (Exception e) {
            Log.e(TAG, "Error in getModules for type: " + moduleType, e);
            return "[]";
        }
    }

    @JavascriptInterface
    public String getCurrentSettings() {
        Log.d(TAG, "getCurrentSettings called");
        JsonObject settings = new JsonObject();
        if (viewModel == null) {
            Log.e(TAG, "getCurrentSettings: viewModel is null!");
            return settings.toString();
        }
        try {
            settings.addProperty("theme", Objects.requireNonNullElse(viewModel.getCurrentTheme().getValue(), "day"));
            settings.addProperty("language", Objects.requireNonNullElse(viewModel.getCurrentLanguage().getValue(), "en"));
            settings.addProperty("soundPreset", Objects.requireNonNullElse(viewModel.getCurrentSoundPreset().getValue(), "default_piano"));
            settings.addProperty("fxChain", viewModel.getCurrentFxChain().getValue());
            settings.addProperty("visualizer", Objects.requireNonNullElse(viewModel.getCurrentVisualizer().getValue(), "waves"));
            settings.addProperty("touchEffect", Objects.requireNonNullElse(viewModel.getTouchEffect().getValue(), "glow"));
            settings.addProperty("scale", Objects.requireNonNullElse(viewModel.getCurrentScale().getValue(), "major"));
            settings.addProperty("octaveOffset", Objects.requireNonNullElse(viewModel.getOctaveOffset().getValue(), 0));
            settings.addProperty("zoneCount", Objects.requireNonNullElse(viewModel.getZoneCount().getValue(), 12));

            Object showNoteNamesVal = viewModel.getSetting("showNoteNames");
            settings.addProperty("showNoteNames", showNoteNamesVal instanceof Boolean ? (Boolean)showNoteNamesVal : true);

            Object showLinesVal = viewModel.getSetting("showLines");
            settings.addProperty("showLines", showLinesVal instanceof Boolean ? (Boolean)showLinesVal : true);

            Object masterVolCeilingVal = viewModel.getSetting("masterVolumeCeiling");
            settings.addProperty("masterVolumeCeiling", masterVolCeilingVal instanceof Number ? ((Number)masterVolCeilingVal).doubleValue() : 1.0);

            Object enablePolyScalingVal = viewModel.getSetting("enablePolyphonyVolumeScaling");
            settings.addProperty("enablePolyphonyVolumeScaling", enablePolyScalingVal instanceof Boolean ? (Boolean)enablePolyScalingVal : true);

            // === НОВОЕ: Добавление currentTonic и highlightSharpsFlats в настройки ===
            settings.addProperty("currentTonic", Objects.requireNonNullElse(viewModel.getCurrentTonic().getValue(), "C4"));
            Object highlightVal = viewModel.getSetting("highlightSharpsFlats");
            settings.addProperty("highlightSharpsFlats", highlightVal instanceof Boolean ? (Boolean)highlightVal : false);
            // =======================================================================

            YAxisControls yAxis = viewModel.getYAxisControls().getValue();
            if (yAxis != null) {
                settings.add("yAxisControls", gson.toJsonTree(yAxis));
            } else {
                settings.add("yAxisControls", JsonNull.INSTANCE);
            }

        } catch (Exception e) {
            Log.e(TAG, "Error getting current settings", e);
        }
        Log.d(TAG, "getCurrentSettings returning: " + settings.toString());
        return settings.toString();
    }


    @JavascriptInterface
    public void setSoundPreset(String presetId) {
        Log.d(TAG, "setSoundPreset: " + presetId);
        mainHandler.post(() -> {
            if (viewModel != null) viewModel.setCurrentSoundPreset(presetId);
            else Log.e(TAG, "setSoundPreset: viewModel is null");
        });
    }

    @JavascriptInterface
    public void setFxChain(String chainId) {
        Log.d(TAG, "setFxChain: " + chainId);
        mainHandler.post(() -> {
            if (viewModel != null) viewModel.setCurrentFxChain(chainId);
            else Log.e(TAG, "setFxChain: viewModel is null");
        });
    }

    @JavascriptInterface
    public void setTheme(String themeId) {
        Log.d(TAG, "setTheme: " + themeId);
        mainHandler.post(() -> {
            if (viewModel != null) viewModel.setCurrentTheme(themeId);
            else Log.e(TAG, "setTheme: viewModel is null");
        });
    }

    @JavascriptInterface
    public void setLanguage(String languageId) {
        Log.d(TAG, "setLanguage: " + languageId);
        mainHandler.post(() -> {
            if (viewModel != null) viewModel.setCurrentLanguage(languageId);
            else Log.e(TAG, "setLanguage: viewModel is null");
        });
    }

    @JavascriptInterface
    public void setVisualizer(String visualizerId) {
        Log.d(TAG, "setVisualizer: " + visualizerId);
        mainHandler.post(() -> {
            if (viewModel != null) viewModel.setCurrentVisualizer(visualizerId);
            else Log.e(TAG, "setVisualizer: viewModel is null");
        });
    }

    @JavascriptInterface
    public void setSetting(String key, String value) {
        Log.d(TAG, "setSetting called for key: " + key + ", string value: " + value);
        mainHandler.post(() -> {
            if (viewModel != null) {
                viewModel.setGenericSetting(key, value);
                Log.d(TAG, "ViewModel setting '" + key + "' updated via generic setter.");
            } else {
                Log.e(TAG, "Cannot setSetting: viewModel is null");
            }
        });
    }

    @JavascriptInterface
    public void setYAxisControlGroup(String groupName, String settingsJson) {
        Log.d(TAG, "setYAxisControlGroup called for group: " + groupName + ", json: " + settingsJson);
        mainHandler.post(() -> {
            if (viewModel != null) {
                try {
                    YAxisControls currentControls = viewModel.getYAxisControls().getValue();
                    if (currentControls == null) currentControls = new YAxisControls();

                    JsonObject groupSettings = JsonParser.parseString(settingsJson).getAsJsonObject();

                    if ("volume".equals(groupName)) {
                        YAxisControls.VolumeControl volCtrl = gson.fromJson(groupSettings, YAxisControls.VolumeControl.class);
                        currentControls.setVolume(volCtrl);
                    } else if ("effects".equals(groupName)) {
                        YAxisControls.EffectsControl fxCtrl = gson.fromJson(groupSettings, YAxisControls.EffectsControl.class);
                        currentControls.setEffects(fxCtrl);
                    }
                    viewModel.setYAxisControls(currentControls);
                    Log.d(TAG, "ViewModel YAxisControls group '" + groupName + "' updated.");
                } catch (JsonSyntaxException e) {
                    Log.e(TAG, "Error parsing YAxisControlGroup JSON for group " + groupName, e);
                } catch (Exception e) {
                    Log.e(TAG, "Error setting YAxisControlGroup for group " + groupName, e);
                }
            } else {
                Log.e(TAG, "Cannot setYAxisControlGroup: viewModel is null");
            }
        });
    }

    @JavascriptInterface
    public void setScale(String scaleId) {
        Log.d(TAG, "setScale: " + scaleId);
        mainHandler.post(() -> {
            if (viewModel != null) {
                viewModel.setCurrentScale(scaleId);
                // callJsFunction("app.updateZones"); // Удалено согласно инструкции
            } else Log.e(TAG, "setScale: viewModel is null");
        });
    }

    @JavascriptInterface
    public void setOctaveOffset(int offset) {
        Log.d(TAG, "setOctaveOffset: " + offset);
        mainHandler.post(() -> {
            if (viewModel != null) {
                viewModel.setOctaveOffset(offset);
                // callJsFunction("app.updateZones"); // Удалено согласно инструкции
            } else Log.e(TAG, "setOctaveOffset: viewModel is null");
        });
    }

    @JavascriptInterface
    public void setZoneCount(int count) {
        Log.d(TAG, "setZoneCount: " + count);
        mainHandler.post(() -> {
            if (viewModel != null) {
                viewModel.setZoneCount(count);
                // callJsFunction("app.updateZones"); // Удалено согласно инструкции
            } else Log.e(TAG, "setZoneCount: viewModel is null");
        });
    }

    @JavascriptInterface
    public String saveSoundPreset(String presetDataJson) {
        Log.d(TAG, "saveSoundPreset called");
        if (context == null) { Log.e(TAG, "saveSoundPreset: context is null"); return "Error: Context is null"; }
        try {
            com.google.gson.JsonObject preset = gson.fromJson(presetDataJson, com.google.gson.JsonObject.class);
            SoundPresetRepository repo = SoundPresetRepository.getInstance(context);
            if (repo == null) { Log.e(TAG, "saveSoundPreset: Repository instance is null"); return "Error: Repository failed"; }
            return repo.savePreset(preset);
        } catch (JsonSyntaxException e) {
            Log.e(TAG, "Error parsing presetData JSON", e); return "Error: Invalid JSON format";
        } catch (Exception e) {
            Log.e(TAG, "Error saving sound preset", e); return "Error: " + e.getMessage();
        }
    }

    @JavascriptInterface
    public String saveFxChain(String chainDataJson) {
        Log.d(TAG, "saveFxChain called");
        if (context == null) { Log.e(TAG, "saveFxChain: context is null"); return "Error: Context is null"; }
        try {
            com.google.gson.JsonObject chain = gson.fromJson(chainDataJson, com.google.gson.JsonObject.class);
            FxChainRepository repo = FxChainRepository.getInstance(context);
            if (repo == null) { Log.e(TAG, "saveFxChain: Repository instance is null"); return "Error: Repository failed"; }
            return repo.saveChain(chain);
        } catch (JsonSyntaxException e) {
            Log.e(TAG, "Error parsing chainData JSON", e); return "Error: Invalid JSON format";
        } catch (Exception e) {
            Log.e(TAG, "Error saving FX chain", e); return "Error: " + e.getMessage();
        }
    }

    @JavascriptInterface
    public boolean deleteSoundPreset(String presetId) {
        Log.d(TAG, "deleteSoundPreset for: " + presetId);
        if (context == null) { Log.e(TAG, "deleteSoundPreset: context is null"); return false; }
        try {
            SoundPresetRepository repo = SoundPresetRepository.getInstance(context);
            if (repo == null) { Log.e(TAG, "deleteSoundPreset: Repository instance is null"); return false; }
            return repo.deleteSoundPreset(presetId);
        } catch (Exception e) {
            Log.e(TAG, "Error deleting sound preset: " + presetId, e); return false;
        }
    }

    @JavascriptInterface
    public boolean deleteFxChain(String chainId) {
        Log.d(TAG, "deleteFxChain for: " + chainId);
        if (context == null) { Log.e(TAG, "deleteFxChain: context is null"); return false; }
        try {
            FxChainRepository repo = FxChainRepository.getInstance(context);
            if (repo == null) { Log.e(TAG, "deleteFxChain: Repository instance is null"); return false; }
            return repo.deleteFxChain(chainId);
        } catch (Exception e) {
            Log.e(TAG, "Error deleting FX chain: " + chainId, e); return false;
        }
    }

    @JavascriptInterface
    public void logDebug(String message) {
        Log.d("JS_" + TAG, message);
    }

    @JavascriptInterface
    public void logError(String message, String errorStack) {
        Log.e("JS_" + TAG, message + "\nStack: " + errorStack);
    }

    @JavascriptInterface
    @Keep
    public void reloadWebView() {
        Log.w(TAG, "JavaScript запросил полную перезагрузку WebView.");
        mainHandler.post(new Runnable() {
            @Override
            public void run() {
                if (webView != null) {
                    Log.i(TAG, "Выполняется webView.reload()...");
                    webView.reload();
                } else {
                    Log.e(TAG, "Невозможно перезагрузить WebView: webView is null.");
                }
            }
        });
    }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\ScaleModule.java
package com.example.prismtone;

import android.content.Context;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;

public class ScaleModule extends BaseModule {
    private int[] intervals;

    public ScaleModule(Context context, ModuleInfo info) {
        super(context, info);
    }

    @Override
    public boolean initialize() {
        // Extract scale intervals from module data
        JsonObject data = getData().getAsJsonObject("data");
        if (data == null || !data.has("intervals")) {
            return false;
        }

        JsonArray intervalArray = data.getAsJsonArray("intervals");
        if (intervalArray == null || intervalArray.size() == 0) {
            return false;
        }

        intervals = new int[intervalArray.size()];
        for (int i = 0; i < intervalArray.size(); i++) {
            intervals[i] = intervalArray.get(i).getAsInt();
        }

        return true;
    }

    @Override
    public boolean apply() {
        // ZonesManager удалён, регистрация зон больше не требуется
        return true;
    }

    /**
     * Gets the scale intervals
     */
    public int[] getIntervals() {
        return intervals;
    }
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\SoundPresetModule.java
package com.example.prismtone;

import android.content.Context;

import com.google.gson.JsonObject;

public class SoundPresetModule extends BaseModule {
    private JsonObject synthSettings;

    public SoundPresetModule(Context context, ModuleInfo info) {
        super(context, info);
    }

    @Override
    public boolean initialize() {
        // Extract synth settings from module data
        JsonObject data = getData().getAsJsonObject("data");
        if (data == null) {
            return false;
        }

        synthSettings = new JsonObject();

        // Copy oscillator settings if present
        if (data.has("oscillator")) {
            synthSettings.add("oscillator", data.get("oscillator"));
        }

        // Copy envelope settings if present
        if (data.has("envelope")) {
            synthSettings.add("envelope", data.get("envelope"));
        }

        // Copy filter settings if present
        if (data.has("filter")) {
            synthSettings.add("filter", data.get("filter"));
        }

        return true;
    }

    @Override
    public boolean apply() {
        // Nothing to do here - settings will be fetched via getSettings()
        return true;
    }

    /**
     * Gets the synth settings for this sound preset
     */
    public JsonObject getSettings() {
        return synthSettings;
    }
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\SoundPresetRepository.java
package com.example.prismtone;

import android.content.Context;
import android.util.Log;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class SoundPresetRepository {
    private static final String TAG = "SoundPresetRepository";
    private static SoundPresetRepository instance;
    private final Context context;
    private final File presetDir;
    private final Gson gson;

    private SoundPresetRepository(Context context) {
        this.context = context.getApplicationContext();
        this.presetDir = new File(context.getExternalFilesDir(null), "modules/soundpreset");
        this.gson = new Gson();
        
        if (!presetDir.exists()) {
            presetDir.mkdirs();
        }
    }

    public static synchronized SoundPresetRepository getInstance(Context context) {
        if (instance == null) {
            instance = new SoundPresetRepository(context);
        }
        return instance;
    }

    /**
     * Returns a list of all user-created sound presets
     */
    public List<JsonObject> getUserPresets() {
        List<JsonObject> presets = new ArrayList<>();
        
        File[] files = presetDir.listFiles((dir, name) -> name.endsWith(".json"));
        if (files == null) return presets;
        
        for (File file : files) {
            try {
                String json = FileUtils.readFile(file);
                JsonObject preset = gson.fromJson(json, JsonObject.class);
                presets.add(preset);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        
        return presets;
    }

    /**
     * Save a preset
     */
    public String savePreset(JsonObject preset) {
        try {
            // Generate a unique ID
            String id = "user_" + System.currentTimeMillis();
            
            // Set the ID in the preset data
            preset.addProperty("id", id);
            
            // Create directory if needed
            File userDir = new File(context.getExternalFilesDir(null), "modules/soundpreset");
            if (!userDir.exists()) {
                userDir.mkdirs();
            }
            
            // Create the preset file
            File presetFile = new File(userDir, id + ".json");
            
            try {
                // Fixed: Using Gson to properly format the JSON with indentation
                String jsonOutput = new GsonBuilder().setPrettyPrinting().create().toJson(preset);
                FileUtils.writeFile(presetFile, jsonOutput);
                
                // Return the ID
                return id;
            } catch (IOException e) {
                Log.e(TAG, "Error saving preset file", e);
                return "Error: " + e.getMessage();
            }
        } catch (Exception e) {
            Log.e(TAG, "Error saving preset", e);
            return "Error: " + e.getMessage();
        }
    }
    
    /**
     * Save a sound preset from JSONObject
     */
    public String saveSoundPreset(JSONObject preset) {
        try {
            // Convert JSONObject to JsonObject
            JsonObject jsonObject = JsonParser.parseString(preset.toString()).getAsJsonObject();
            return savePreset(jsonObject);
        } catch (Exception e) {
            Log.e(TAG, "Error converting JSONObject to JsonObject", e);
            return "Error: " + e.getMessage();
        }
    }
    
    /**
     * Deletes a user sound preset
     * @return true if deleted successfully
     */
    public boolean deleteSoundPreset(String presetId) {
        // Don't allow deletion of default presets
        if (!presetId.startsWith("user_")) {
            return false;
        }
        
        File presetFile = new File(presetDir, presetId + ".json");
        return presetFile.exists() && presetFile.delete();
    }
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\ThemeModule.java
package com.example.prismtone;

import android.content.Context;

import com.google.gson.JsonObject;

public class ThemeModule extends BaseModule {
    private JsonObject colorSettings;

    public ThemeModule(Context context, ModuleInfo info) {
        super(context, info);
    }

    @Override
    public boolean initialize() {
        // Extract color settings from module data
        JsonObject data = getData().getAsJsonObject("data");
        if (data == null || !data.has("colors")) {
            return false;
        }

        colorSettings = data.getAsJsonObject("colors");
        return colorSettings != null && colorSettings.size() > 0;
    }

    @Override
    public boolean apply() {
        // Nothing to do here - settings will be fetched via getColors()
        return true;
    }

    /**
     * Gets the color settings for this theme
     */
    public JsonObject getColors() {
        return colorSettings;
    }
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\TouchEffectModule.java
package com.example.prismtone;

import android.content.Context;
import com.google.gson.JsonObject;

public class TouchEffectModule extends BaseModule {
    public TouchEffectModule(Context context, ModuleInfo info) {
        super(context, info);
    }

    @Override
    public boolean initialize() {
        // Touch effects are initialized on the JavaScript side
        return true;
    }

    @Override
    public boolean apply() {
        // Touch effects are applied on the JavaScript side
        return true;
    }

    @Override
    public boolean onUnload() {
        // Cleanup is handled on the JavaScript side
        return true;
    }
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\VisualizerModule.java
package com.example.prismtone;

import android.content.Context;

import com.google.gson.JsonObject;

public class VisualizerModule extends BaseModule {
    private JsonObject visualizerSettings;

    public VisualizerModule(Context context, ModuleInfo info) {
        super(context, info);
    }

    @Override
    public boolean initialize() {
        // Extract visualizer settings from module data
        JsonObject data = getData().getAsJsonObject("data");
        if (data == null) {
            return false;
        }

        visualizerSettings = data;
        return true;
    }

    @Override
    public boolean apply() {
        // Nothing to do here - settings will be fetched via getSettings()
        return true;
    }

    /**
     * Gets the visualizer settings
     */
    public JsonObject getSettings() {
        return visualizerSettings;
    }
}

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\java\com\example\prismtone\model\YAxisControls.java
// Файл: app\src\main\java\com\example\prismtone\YAxisControls.java
package com.example.prismtone.model;

public class YAxisControls {
    private VolumeControl volume;
    private EffectsControl effects;

    public YAxisControls() {
        this.volume = new VolumeControl();
        this.effects = new EffectsControl();
    }

    public YAxisControls(VolumeControl volume, EffectsControl effects) {
        this.volume = volume != null ? volume : new VolumeControl();
        this.effects = effects != null ? effects : new EffectsControl();
    }

    public VolumeControl getVolume() { return volume; }
    public void setVolume(VolumeControl volume) { this.volume = volume; }

    public EffectsControl getEffects() { return effects; }
    public void setEffects(EffectsControl effects) { this.effects = effects; }

    public static class VolumeControl {
        private double minOutput = 0.0;
        private double maxOutput = 1.0;
        private double yThreshold = 0.0;
        private String curveType = "linear";
        private double curveFactor = 1.0;
        private String outputType = "gain"; // Не используется в UI, но может быть в логике

        public VolumeControl() {}

        // Getters and Setters
        public double getMinOutput() { return minOutput; }
        public void setMinOutput(double minOutput) { this.minOutput = minOutput; }
        public double getMaxOutput() { return maxOutput; }
        public void setMaxOutput(double maxOutput) { this.maxOutput = maxOutput; }
        public double getyThreshold() { return yThreshold; } // Имя геттера изменено
        public void setyThreshold(double yThreshold) { this.yThreshold = yThreshold; } // Имя сеттера изменено
        public String getCurveType() { return curveType; }
        public void setCurveType(String curveType) { this.curveType = curveType; }
        public double getCurveFactor() { return curveFactor; }
        public void setCurveFactor(double curveFactor) { this.curveFactor = curveFactor; }
        public String getOutputType() { return outputType; }
        public void setOutputType(String outputType) { this.outputType = outputType; }
    }

    public static class EffectsControl {
        private double minOutput = -60.0;
        private double maxOutput = 0.0;
        private double yThreshold = 0.1;
        private String curveType = "exponential";
        private double curveFactor = 2.0;
        private String outputType = "db"; // Не используется в UI, но может быть в логике

        public EffectsControl() {}

        // Getters and Setters
        public double getMinOutput() { return minOutput; }
        public void setMinOutput(double minOutput) { this.minOutput = minOutput; }
        public double getMaxOutput() { return maxOutput; }
        public void setMaxOutput(double maxOutput) { this.maxOutput = maxOutput; }
        public double getyThreshold() { return yThreshold; } // Имя геттера изменено
        public void setyThreshold(double yThreshold) { this.yThreshold = yThreshold; } // Имя сеттера изменено
        public String getCurveType() { return curveType; }
        public void setCurveType(String curveType) { this.curveType = curveType; }
        public double getCurveFactor() { return curveFactor; }
        public void setCurveFactor(double curveFactor) { this.curveFactor = curveFactor; }
        public String getOutputType() { return outputType; }
        public void setOutputType(String outputType) { this.outputType = outputType; }
    }
}
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\res\drawable\ic_launcher_background.xml
<!-- res/drawable/ic_launcher_background.xml -->
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path android:pathData="M0,0h108v108h-108z">
        <aapt:attr name="android:fillColor">
            <gradient
                android:type="radial"
                android:centerX="54"
                android:centerY="54"
                android:gradientRadius="70">
                <item android:color="#0f0c29" android:offset="0.0"/>
                <item android:color="#302b63" android:offset="0.6"/>
                <item android:color="#24243e" android:offset="1.0"/>
            </gradient>
        </aapt:attr>
    </path>
    <!-- Можно добавить пару очень простых звезд, если поместятся в маску -->

</vector>
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\res\drawable\ic_launcher_foreground.xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="85.84757"
                android:endY="92.4963"
                android:startX="42.9492"
                android:startY="49.59793"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
        android:strokeWidth="1"
        android:strokeColor="#00000000" />
</vector>
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\res\layout\activity_main.xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout 
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <WebView
        android:id="@+id/webview"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\res\mipmap-anydpi\ic_launcher.xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\res\mipmap-anydpi\ic_launcher_round.xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\res\values-night\themes.xml
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Theme.Prismtone" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
        <!-- Primary brand color. -->
        <item name="colorPrimary">@color/purple_200</item>
        <item name="colorPrimaryVariant">@color/purple_700</item>
        <item name="colorOnPrimary">@color/black</item>
        <!-- Secondary brand color. -->
        <item name="colorSecondary">@color/teal_200</item>
        <item name="colorSecondaryVariant">@color/teal_200</item>
        <item name="colorOnSecondary">@color/black</item>
        <!-- Status bar color. -->
        <item name="android:statusBarColor">?attr/colorPrimaryVariant</item>
        <!-- Customize your theme here. -->
    </style>
</resources>
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\res\values\colors.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="primary">#4285F4</color>
    <color name="primary_dark">#3367D6</color>
    <color name="accent">#EA4335</color>
    <color name="background">#F5F5F5</color>
    <color name="text_primary">#333333</color>
    <color name="text_secondary">#757575</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
    
    <!-- Material theme default colors -->
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
</resources>

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\res\values\strings.xml

<resources>
    <string name="app_name">Prismtone</string>
    <string name="loading">Loading...</string>
    <string name="error_loading">Error loading application</string>
    <string name="permission_storage_rationale">Storage permission is needed to save recordings and custom presets</string>
    <string name="permission_record_audio_rationale">Microphone permission is needed for recording audio</string>
    <string name="permission_denied">Permission denied. Some features may not work properly.</string>
</resources>

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\res\values\styles.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Remove the duplicate Theme.Prismtone definition -->
    
    <!-- Fullscreen application theme -->
    <style name="Theme.Prismtone.Fullscreen" parent="Theme.MaterialComponents.DayNight.NoActionBar">
        <item name="android:windowNoTitle">true</item>
        <item name="android:windowFullscreen">true</item>
        <item name="android:windowContentOverlay">@null</item>
        <item name="android:windowLayoutInDisplayCutoutMode">shortEdges</item>
        <item name="android:navigationBarColor">@android:color/transparent</item>
        <item name="android:statusBarColor">@android:color/transparent</item>
    </style>
</resources>

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\res\values\themes.xml
<!-- res/values/themes.xml -->
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Базовая тема приложения (может наследоваться от DayNight для поддержки темной/светлой темы системы) -->
    <style name="Theme.Prismtone" parent="Theme.MaterialComponents.DayNight.NoActionBar">
        <!-- Основные цвета бренда (можно настроить) -->
        <item name="colorPrimary">@color/purple_500</item>
        <item name="colorPrimaryVariant">@color/purple_700</item>
        <item name="colorOnPrimary">@color/white</item>
        <!-- Вторичные цвета бренда -->
        <item name="colorSecondary">@color/teal_200</item>
        <item name="colorSecondaryVariant">@color/teal_700</item>
        <item name="colorOnSecondary">@color/black</item>
        <!-- Цвет статус-бара (будет прозрачным в fullscreen) -->
        <item name="android:statusBarColor">@android:color/transparent</item>
        <!-- Цвет навигационной панели (будет прозрачным в fullscreen) -->
        <item name="android:navigationBarColor">@android:color/transparent</item>
        <!-- Дополнительно: убедимся, что окно может рисовать под системными панелями -->
        <item name="android:windowLightStatusBar" tools:targetApi="m">true</item> <!-- Настройте для темной/светлой темы -->
        <item name="android:windowLightNavigationBar" tools:targetApi="o_mr1">true</item> <!-- Настройте для темной/светлой темы -->
    </style>

    <!-- Можно определить отдельную Fullscreen тему, если нужно больше настроек -->
    <!-- <style name="Theme.Prismtone.Fullscreen" parent="Theme.Prismtone"> -->
    <!-- Дополнительные атрибуты для fullscreen, если нужны -->
    <!-- </style> -->
</resources>
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\res\xml\backup_rules.xml
<?xml version="1.0" encoding="utf-8"?><!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older than API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\res\xml\data_extraction_rules.xml
<?xml version="1.0" encoding="utf-8"?><!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>
================================================================================

