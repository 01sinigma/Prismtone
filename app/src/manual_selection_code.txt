// Файл: C:\Py\Prismtone\app\src\main\assets\css\styles.css
/* Файл: app/src/main/assets/css/styles.css */

/* Base Styles */
:root {
    --color-background: #ffffff;
    --color-background-rgb: 255, 255, 255;
    --color-surface: #f5f5f5;
    --color-surface-rgb: 245, 245, 245;
    --color-primary: #2196f3;
    --color-primary-rgb: 33, 150, 243;
    --color-primary-light: #64b5f6;
    --color-primary-dark: #1976d2;
    --color-accent: #ff4081;
    --color-accent-rgb: 255, 64, 129;
    --color-text-primary: #333333;
    --color-text-secondary: #757575;
    --color-text-secondary-rgb: 117, 117, 117;
    --color-text-on-dark: #e0e0e0; /* Цвет текста для темного фона загрузки */
    --color-border: #e0e0e0;
    --color-border-rgb: 224, 224, 224;
    --osc-icon-invert: 0%; /* Управляется темами */

    --topbar-height: 50px;
    --panel-width: 320px;
    --knob-size: 60px;
    --knob-size-small: 48px;
    --button-height: 48px;
    --border-radius: 8px;
    --knob-border-radius: 50%;
    --xy-label-height: 30px;

    --preset-cube-size: 80px;
    --preset-grid-gap: 12px;
    --color-calm-marker: #FFDC00;
    --color-tense-marker: #0074D9;
    --color-powerful-marker: #FF4136;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

html, body {
    height: 100%;
    width: 100%;
    overflow: hidden;
    position: fixed;
    touch-action: manipulation;
    font-family: 'Roboto', Arial, sans-serif;
    background-color: var(--color-background);
    color: var(--color-text-primary);
    overscroll-behavior: none;
}

#app-container {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    position: relative;
    overflow: hidden;
}

/* Typography */
h1, h2, h3, h4, h5, h6 { font-weight: 500; margin-bottom: 10px; color: var(--color-text-primary); }
h2 { font-size: 20px; }
h3 { font-size: 18px; }
h4 { font-size: 16px; }
h5 { font-size: 14px; font-weight: normal; color: var(--color-text-secondary); margin-bottom: 5px; }
label:not(.toggle) { display: block; margin-bottom: 5px; font-weight: 500; font-size: 14px; }

/* Buttons */
button { background-color: var(--color-surface); color: var(--color-text-primary); border: 1px solid var(--color-border); border-radius: var(--border-radius); padding: 8px 16px; font-size: 14px; cursor: pointer; transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s; outline: none; height: var(--button-height); display: inline-flex; align-items: center; justify-content: center; vertical-align: middle; }
button:active { background-color: rgba(var(--color-primary-rgb), 0.15); transform: scale(0.98); box-shadow: none; }
button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; background-color: var(--color-border); }
.round-button { width: 40px; height: 40px; border-radius: 50%; padding: 0; font-size: 18px; flex-shrink: 0; }
.text-button { background: none; border: none; color: var(--color-primary); padding: 0 16px; height: 36px; border-radius: 18px; font-size: 14px; font-weight: 500; text-transform: uppercase; transition: background-color 0.2s, color 0.2s; }
.text-button:hover { background-color: rgba(var(--color-primary-rgb), 0.08); }
.text-button:active { background-color: rgba(var(--color-primary-rgb), 0.15); transform: none; }
#sound-library-button { background-color: var(--color-surface); border: 1px solid var(--color-border); color: var(--color-text-primary); text-transform: none; font-weight: normal; }
#sound-library-button:hover { background-color: rgba(var(--color-border-rgb), 0.5); color: var(--color-text-primary); }
#sound-library-button:active { background-color: rgba(var(--color-border-rgb), 0.8); color: var(--color-text-primary); }
.action-button { background-color: var(--color-primary); color: white; font-size: 14px; height: 36px; margin: 8px 4px; padding: 0 12px; }
.action-button:active { background-color: var(--color-primary-dark); }
.close-button { width: 36px; height: 36px; font-size: 24px; padding: 0; margin: 0; background: none; border: none; color: var(--color-text-secondary); border-radius: 50%; transition: background-color 0.2s; }
.close-button:hover { background-color: rgba(var(--color-border-rgb), 0.5); }
.close-button:active { background-color: rgba(var(--color-border-rgb), 0.8); transform: none; }
.slider-button { width: 36px; height: 36px; font-size: 18px; border-radius: 50%; padding: 0; margin: 0 8px; flex-shrink: 0; }

/* Toggles */
.toggle { position: relative; display: inline-block; width: 50px; height: 26px; flex-shrink: 0; }
.toggle input { opacity: 0; width: 0; height: 0; }
.toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--border-radius); transition: background-color 0.2s ease-out, border-color 0.2s ease-out; box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }
.toggle-slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 2px; bottom: 2px; background-color: var(--color-text-secondary); border-radius: calc(var(--border-radius) - 2px); transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.25s; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
input:checked + .toggle-slider { background-color: var(--color-primary); border-color: var(--color-primary-dark); }
input:checked + .toggle-slider:before { transform: translateX(24px); background-color: var(--color-surface); box-shadow: 0 1px 2px rgba(0,0,0,0.3); }
.toggle input:focus-visible + .toggle-slider { outline: 2px solid var(--color-primary-light); outline-offset: 2px; }

/* Sliders */
.slider-container { display: flex; align-items: center; justify-content: space-between; margin: 10px 0; gap: 10px; }
.slider { flex-grow: 1; -webkit-appearance: none; appearance: none; width: 100%; height: 4px; background: var(--color-border); outline: none; border-radius: 2px; cursor: pointer; }
.slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--color-primary); cursor: pointer; border: 2px solid var(--color-surface); box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
.slider::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: var(--color-primary); cursor: pointer; border: 2px solid var(--color-surface); box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
.slider-value { min-width: 30px; text-align: center; font-weight: bold; font-size: 14px; color: var(--color-text-secondary); }

/* Dropdowns */
.dropdown-container { margin-bottom: 10px; }
.dropdown-container.small { margin-bottom: 5px; }
.dropdown-container label { font-size: 14px; margin-bottom: 4px; }
.dropdown { width: 100%; height: 40px; padding: 0 30px 0 10px; border: 1px solid var(--color-border); border-radius: var(--border-radius); background-color: var(--color-surface); color: var(--color-text-primary); font-size: 14px; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23757575' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e"); background-repeat: no-repeat; background-position: right 10px center; background-size: 16px; cursor: pointer; transition: border-color 0.2s; }
.dropdown:focus { border-color: var(--color-primary); outline: none; box-shadow: 0 0 0 2px rgba(var(--color-primary-rgb), 0.2); }
.dropdown.small { height: 32px; font-size: 12px; padding: 0 25px 0 8px; background-size: 14px; }

/* Top Bar */
#topbar {
    height: var(--topbar-height);
    width: 100%;
    background-color: var(--color-surface);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 12px;
    border-bottom: 1px solid var(--color-border);
    z-index: 100;
    flex-shrink: 0;
    gap: 10px;
}
.topbar-group {
    display: flex;
    align-items: center;
    gap: 8px;
}
#app-title {
    text-align: center;
    font-size: 20px;
    font-weight: bold;
    color: var(--color-primary);
    margin: 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    animation: titleGlow 3s ease-in-out infinite;
    min-width: 100px;
}
.topbar-button {
    margin: 0;
    flex-shrink: 0;
}
.topbar-button.active { background-color: rgba(var(--color-primary-rgb), 0.2); box-shadow: inset 0 0 4px rgba(var(--color-primary-rgb), 0.3); color: var(--color-primary-dark); }
#sound-library-button.active { background-color: rgba(var(--color-primary-rgb), 0.2); border-color: var(--color-primary); color: var(--color-primary-dark); }

#effects-button { font-size: 16px; font-weight: bold; text-transform: uppercase; }
@keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(229, 57, 53, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(229, 57, 53, 0); } 100% { box-shadow: 0 0 0 0 rgba(229, 57, 53, 0); } }
@keyframes titleGlow { 0% { text-shadow: 0 0 5px rgba(var(--color-primary-rgb), 0.4), 0 0 10px rgba(var(--color-primary-rgb), 0.3); } 50% { text-shadow: 0 0 10px rgba(var(--color-primary-rgb), 0.6), 0 0 20px rgba(var(--color-primary-rgb), 0.4); } 100% { text-shadow: 0 0 5px rgba(var(--color-primary-rgb), 0.4), 0 0 10px rgba(var(--color-primary-rgb), 0.3); } }

/* XY Pad */
#xy-pad-container { flex-grow: 1; width: 100%; position: relative; overflow: hidden; background-color: var(--color-background); touch-action: none; }
#xy-labels { position: absolute; top: 0; left: 0; width: 100%; height: var(--xy-label-height); display: flex; z-index: 25; pointer-events: none; background-color: rgba(var(--color-surface-rgb), 0.85); border-bottom: 1px solid var(--color-border); }
.xy-label { position: absolute; top: 50%; transform: translate(-50%, -50%); font-size: 12px; color: var(--color-text-secondary); text-align: center; pointer-events: none; white-space: nowrap; padding: 2px 4px; border-bottom: 2px solid transparent; }

/* Обновленные стили для контейнера зон и новые классы для областей и разделителей */
#xy-visualizer, #xy-zones, #xy-touches { position: absolute; top: var(--xy-label-height); left: 0; width: 100%; height: calc(100% - var(--xy-label-height)); pointer-events: none; }
#xy-zones { z-index: 20; /* Теперь это контейнер для .xy-pad-zone-area и .xy-zone-divider */
           /* Убедитесь, что #xy-zones имеет position: relative; или absolute; */
          }
#xy-visualizer { z-index: 10; }
#xy-touches { z-index: 30; }

/* Новый класс для области зоны (тела клавиши) */
.xy-pad-zone-area {
    position: absolute;
    top: 0;
    height: 100%;
    background-color: transparent; /* Дефолтный фон для "белых" клавиш (прозрачный) */
    /* transition: background-color 0.1s ease-out; */ /* Плавный переход цвета */
    pointer-events: none; /* Должны быть ниже touch events */
    /* border-right: 1px solid transparent; */ /* Если линии делаются через границу */
}

/* Стиль для диезов/бемолей */
.xy-pad-zone-area.sharp-flat-zone {
    /*background-color: rgba(var(--color-text-primary-rgb, 51,51,51), 0.2); !* Пример: полупрозрачный темный фон *!*/
    background-color: rgba(var(--color-border-rgb), 0.3); /* Более светлый серый фон для контраста */
    /* Если нужно изменить ширину, это сложнее и потребует корректировки startX/width в JS */
}

/* Новый класс для линий-разделителей */
.xy-zone-divider {
    position: absolute;
    height: 100%;
    top: 0;
    border-left: 2px solid rgba(var(--color-border-rgb), 0.4); /* Дефолтный стиль линии */
    pointer-events: none; /* Не мешает касаниям */
    /* transition: border-left-color 0.3s ease-out; */ /* Плавный переход цвета линии */
    z-index: 21; /* Выше областей зон, но ниже меток и визуализатора касаний */
}

/* Удаляем или переименовываем старый класс .xy-zone, если он больше не нужен для линий */
/* .xy-zone { display: none; } *//* Или удалите полностью */
/* Если старый .xy-zone использовался только для линий, то просто его переиспользуем */

/* OLD .xy-zone styles - если они были только для линий */
/*
.xy-zone {
    position: absolute;
    height: 100%;
    top: 0;
    border-left: 2px solid rgba(var(--color-border-rgb), 0.4);
    pointer-events: none;
    transition: border-left-color 0.3s ease-out;
}
.xy-zone:hover {
    border-left-color: rgba(var(--color-primary-rgb), 0.6);
}
*/

/* XY-touch (визуализация касаний) - оставляем как есть */
.xy-touch { position: absolute; width: 40px; height: 40px; border-radius: 50%; transform: translate(-50%, -50%) scale(1); pointer-events: none; background: radial-gradient(circle, rgba(var(--color-primary-rgb), 0.8) 0%, rgba(var(--color-primary-rgb), 0) 70%); opacity: 0; transition: opacity 0.3s ease-out, transform 0.1s ease-out, box-shadow 0.1s ease-out, background 0.1s ease-out; will-change: transform, opacity, background, box-shadow; }

/* Panels */
.side-panel, .top-panel { position: absolute; background-color: var(--color-surface); z-index: 200; display: flex; flex-direction: column; box-shadow: 0 0 15px rgba(0, 0, 0, 0.1); overflow: hidden; }
.side-panel { top: var(--topbar-height); height: calc(100% - var(--topbar-height)); width: var(--panel-width); max-width: 85%; transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
.left-panel { left: 0; transform: translateX(-100%); border-right: 1px solid var(--color-border); }
.right-panel { right: 0; transform: translateX(100%); border-left: 1px solid var(--color-border); }
.left-panel.show, .right-panel.show { transform: translateX(0); }
.top-panel { top: var(--topbar-height); left: 0; width: 100%; height: 0; max-height: 70vh; transition: height 0.25s ease-out; border-bottom: 1px solid var(--color-border); }
.top-panel.show { height: 70vh; }
.panel-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; border-bottom: 1px solid var(--color-border); flex-shrink: 0; }
.panel-header h2 { margin: 0; }
.panel-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 12px;
    -webkit-overflow-scrolling: touch;
}
.setting-group {
    margin-bottom: 12px;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(var(--color-border-rgb), 0.5);
}
.setting-group:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
}

/* Убедимся, что у label внутри .setting-group есть консистентный нижний отступ,
   если за ним сразу идет select, как в случае с Visualizer и Touch Effect. */
.setting-group > label { /* Прямой потомок label */
    display: block; /* Если еще не так */
    margin-bottom: 8px; /* Консистентный отступ под заголовком группы */
    font-weight: 500;
    font-size: 14px; /* Уже есть, но для примера */
}

/* Для выпадающих списков, которые идут сразу после label в группе */
.setting-group > .dropdown,
.setting-group > .dropdown-container > .dropdown { /* Если есть обертка .dropdown-container */
    /* Можно добавить margin-top, если нужно, но обычно отступа label достаточно */
}
.toggle-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 4px;
    margin-bottom: 8px;
}
.toggle-container span {
    flex-grow: 1;
    margin-right: 15px;
    font-size: 14px;
    color: var(--color-text-primary);
    font-weight: 500;
}

/* Grid layout for controls */
.control-grid { display: flex; flex-wrap: wrap; gap: 15px; align-items: flex-start; margin-top: 10px; }
.control-grid .knob-container, .control-grid .dropdown-container { margin: 0; flex: 1 1 100px; min-width: 80px; }
.control-grid .dropdown-container { flex-basis: 150px; }

/* Effects Panel - Стили для макро-ручек и Y-Axis */
#effects-panel h4 { margin-top: 15px; }
#macro-controls { justify-content: space-around; margin-bottom: 20px; }
.effect-actions { display: flex; justify-content: center; margin-top: 20px; }
.fx-chain-container { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 10px; }
.fx-chain-container label { flex-basis: 100%; margin-bottom: 5px; }
.fx-chain-container select { flex: 1 1 150px; min-width: 120px; }
.y-axis-controls h4 { margin-bottom: 15px; }
.y-axis-row { display: flex; flex-wrap: wrap; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 15px; }
.y-axis-row .knob-container { flex: 1; min-width: 70px; }
.y-axis-row .dropdown-container { flex: 1; min-width: 100px; }
.y-axis-row .knob-container[data-param^="effectsIntensity"],
.y-axis-row .knob-container[data-param="effectsThreshold"] { }

/* === НОВЫЕ СТИЛИ для Master Output Controls (Часть 1) === */
.master-output-controls h4 { margin-bottom: 15px; }
.master-output-controls .control-grid {
    justify-content: center; /* Центрируем одну ручку */
}
/* ======================================================== */

/* Knobs */
.knob-container { display: flex; flex-direction: column; align-items: center; margin: 5px; min-width: 65px; text-align: center; }
.knob { width: var(--knob-size); height: var(--knob-size); border-radius: var(--knob-border-radius); background-color: var(--color-background); border: 2px solid var(--color-border); position: relative; cursor: ns-resize; touch-action: none; box-shadow: inset 0 1px 2px rgba(0,0,0,0.1), 0 1px 1px rgba(255,255,255,0.5); }
.knob.small { width: var(--knob-size-small); height: var(--knob-size-small); border-width: 1px; }
.knob-dial { position: absolute; top: 5px; left: 50%; width: 3px; height: calc(50% - 7px); background-color: var(--color-primary); transform-origin: bottom center; transform: translateX(-50%) rotate(0deg); border-radius: 2px; pointer-events: none; transition: background-color 0.2s; }
.knob.small .knob-dial { width: 2px; height: calc(50% - 6px); top: 4px; }
.knob-value { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 12px; font-weight: 500; color: var(--color-text-secondary); pointer-events: none; }
.knob.small .knob-value { font-size: 10px; }
.knob-container label { margin-top: 4px; font-size: 11px; color: var(--color-text-secondary); white-space: nowrap; }

/* Sound Library */
.sound-library-container { display: flex; flex-direction: column; gap: 20px; height: 100%; }
.sound-presets { flex: 1; display: flex; flex-direction: column; }
.preset-grid {
    flex-grow: 1;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(var(--preset-cube-size), 1fr));
    gap: var(--preset-grid-gap);
    padding: var(--preset-grid-gap);
    overflow-y: auto;
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius);
    background-color: var(--color-background);
    min-height: 150px;
}
.preset-cube {
    width: var(--preset-cube-size);
    height: var(--preset-cube-size);
    border: 2px solid var(--color-border);
    border-radius: var(--border-radius);
    background-color: var(--color-surface);
    color: var(--color-text-secondary);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 8px;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    overflow: hidden;
    white-space: normal;
    word-break: break-word;
    transition: background-color 0.2s ease-out, border-color 0.2s ease-out,
                box-shadow 0.2s ease-out, transform 0.15s cubic-bezier(0.2, 0.8, 0.4, 1.2);
}
.preset-cube:hover {
    border-color: var(--color-primary-light);
    box-shadow: 0 3px 8px rgba(var(--color-primary-rgb), 0.2);
    transform: translateY(-2px);
}
.preset-cube.active {
    border-color: var(--color-accent);
    color: var(--color-accent);
    font-weight: bold;
    box-shadow: 0 0 12px rgba(var(--color-accent-rgb), 0.5),
                inset 0 0 6px rgba(var(--color-accent-rgb), 0.2);
    transform: scale(1.05);
}
.preset-cube.disabled {
    opacity: 0.6;
    cursor: default;
    font-style: italic;
    background-color: var(--color-border);
    transform: none;
    box-shadow: none;
}

/* Loading Overlay Styles */
#loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(ellipse at center,
        rgba(10, 26, 42, 0.95) 0%,
        rgba(5, 13, 21, 0.98) 50%,
        rgba(0, 0, 0, 1) 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 1;
    visibility: visible;
    cursor: pointer;
    transition: opacity 0.5s ease-out, transform 0.5s ease-out, visibility 0s linear 0.5s;
    overflow: hidden;
}
#loading-overlay::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background:
        radial-gradient(circle at 20% 30%, rgba(33, 150, 243, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(255, 64, 129, 0.15) 0%, transparent 50%);
    pointer-events: none;
}
#loading-overlay.hidden {
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
    cursor: default;
    transition: opacity 0.5s ease-out, transform 0.5s ease-out, visibility 0s linear 0.5s;
}
#loading-overlay.hiding {
    opacity: 0 !important;
    transform: scale(1.2);
    pointer-events: none;
}
#loading-stars-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    pointer-events: none;
}
#loading-prism-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 3;
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
}
.loading-text {
    position: relative;
    z-index: 2;
    font-size: 18px;
    color: var(--color-text-on-dark, #e0e0e0);
    text-align: center;
    padding: 0 20px;
    pointer-events: none;
    transition: opacity 0.3s ease-out;
    text-shadow: 0 0 10px rgba(var(--color-primary-rgb), 0.5);
}
.loading-text.fade-out {
    opacity: 0;
}
#loading-title {
    position: relative;
    z-index: 4;
    font-size: 3.5em;
    font-weight: bold;
    color: var(--color-primary);
    text-shadow: 0 0 8px rgba(var(--color-primary-rgb), 0.6),
                 0 0 15px rgba(var(--color-primary-rgb), 0.4);
    margin-bottom: 10px;
    text-align: center;
    opacity: 0;
    transform: scale(0.8);
    visibility: hidden;
    transition: opacity 0.8s ease-out 0.2s,
                transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) 0.2s,
                visibility 0s linear 1s;
}
#loading-title.show {
    opacity: 1;
    transform: scale(1);
    visibility: visible;
    transition: opacity 0.8s ease-out 0.2s,
                transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) 0.2s,
                visibility 0s linear 0s;
}
.loading-prompt {
    position: relative;
    z-index: 4;
    font-size: 1.2em;
    color: var(--color-text-on-dark, #e0e0e0);
    margin-top: 5px;
    text-align: center;
    font-weight: 500;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.5s ease-out 0.8s,
                visibility 0s linear 1.3s;
    text-shadow: 0 0 8px rgba(var(--color-primary-rgb), 0.4);
}
.loading-prompt.show {
    opacity: 1;
    visibility: visible;
    transition: opacity 0.5s ease-out 0.8s,
                visibility 0s linear 0s;
    animation: promptPulse 2s infinite ease-in-out;
}
@keyframes promptPulse {
    0% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(1.03); }
    100% { opacity: 1; transform: scale(1); }
}

/* Responsive Adjustments & Landscape */
.landscape-mode { }
@media (orientation: landscape) {
    .side-panel { width: 300px; max-width: 40%; }
    .top-panel { max-height: 65vh; }
    .sound-presets { flex: 1; }
    .control-grid .knob-container { flex-basis: 80px; }
    .control-grid .dropdown-container { flex-basis: 120px; }
    #loading-title { font-size: 4em; }
    .loading-prompt { font-size: 1.3em; }
}
@media (max-width: 700px) {
    .side-panel { width: 280px; max-width: 85%; }
    .top-panel { max-height: 75vh; }
    .sound-presets { width: 100%; }
    .fx-chain-container select { flex-basis: 100%; }
    .y-axis-row { justify-content: space-around; }
    .y-axis-row .knob-container, .y-axis-row .dropdown-container { flex-basis: 120px; }
     #loading-title { font-size: 3em; }
     .loading-prompt { font-size: 1.1em; }
}
@media (max-width: 400px) {
     #app-title { font-size: 16px; }
     .topbar-button { padding: 6px; }
     .round-button { width: 36px; height: 36px; font-size: 16px; }
     .text-button { font-size: 12px; }
     .knob { width: 50px; height: 50px; }
     .knob.small { width: 40px; height: 40px; }
     .knob-value { font-size: 10px; }
     .knob.small .knob-value { font-size: 9px; }
     .knob-container label { font-size: 10px; }
     .control-grid .knob-container { min-width: 60px; }
     .control-grid .dropdown-container { min-width: 100px; }
     .preset-cube { --preset-cube-size: 65px; font-size: 10px; }
     .action-button { font-size: 12px; height: 32px; }
     #loading-title { font-size: 2.5em; }
     .loading-prompt { font-size: 1em; }
}

.reload-app-button-style {
    background-color: #e53935;
    color: white;
    border: 1px solid #c62828;
    transition: background-color 0.2s ease-out, transform 0.15s cubic-bezier(0.2, 0.8, 0.4, 1.2), box-shadow 0.2s ease-out;
}
.reload-app-button-style:hover {
    background-color: #d32f2f;
    border-color: #b71c1c;
    transform: translateY(-1px) scale(1.05);
}
.reload-app-button-style:active {
    background-color: #b71c1c;
    transform: scale(0.95);
}
.reload-app-button-style .restart-icon {
    fill: currentColor;
}
.reload-app-button-style.reloading .restart-icon {
    animation: spinReload 2s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
}
@keyframes spinReload {
    0% { transform: rotate(0deg) scale(1); }
    50% { transform: rotate(-360deg) scale(1.1); }
    100% { transform: rotate(-720deg) scale(1); }
}
.reload-app-button-style:disabled {
    background-color: #a0a0a0 !important;
    color: #e0e0e0 !important;
    cursor: wait !important;
    transform: none !important;
    box-shadow: none !important;
}
.reload-app-button-style:disabled .restart-icon {
    opacity: 0.5;
    animation: none !important;
}

@keyframes restartSpin {
    0% { transform: rotate(0deg) scale(1); }
    20% { transform: rotate(-180deg) scale(1.1); }
    40% { transform: rotate(-360deg) scale(1); }
    60% { transform: rotate(-540deg) scale(1.1); }
    80% { transform: rotate(-720deg) scale(1); }
    100% { transform: rotate(-720deg) scale(1); }
}
.restart-audio-button.animating { pointer-events: none; }
.restart-audio-button.animating svg { animation: restartSpin 2s cubic-bezier(0.4, 0, 0.2, 1); }
.restart-audio-button::after {
    content: '';
    position: absolute;
    top: 50%; left: 50%;
    width: 100%; height: 100%;
    background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 70%);
    transform: translate(-50%, -50%) scale(0);
    opacity: 0;
    transition: transform 0.3s ease-out, opacity 0.3s ease-out;
}
.restart-audio-button:hover::after { transform: translate(-50%, -50%) scale(1.5); opacity: 1; }

/* === Custom Selector Popover === */
.custom-selector-popover {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  z-index: 9999;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
}
.custom-selector-popover[style*="display: block"],
.custom-selector-popover.active {
  pointer-events: auto;
}
.custom-selector-backdrop {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(var(--color-background-rgb, 10,10,26), 0.7);
  backdrop-filter: blur(2px);
  z-index: 0;
  transition: background 0.2s;
}
.custom-selector-modal {
  position: relative;
  background: var(--color-surface);
  border-radius: 18px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.25), 0 1.5px 8px rgba(var(--color-primary-rgb,0,191,255),0.08);
  min-width: 260px;
  max-width: 90vw;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  z-index: 1;
  animation: popoverIn 0.18s cubic-bezier(0.4,0,0.2,1);
}
@keyframes popoverIn {
  0% { opacity: 0; transform: scale(0.95) translateY(30px); }
  100% { opacity: 1; transform: scale(1) translateY(0); }
}
.custom-selector-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px 8px 20px;
  border-bottom: 1px solid var(--color-border);
}
#custom-selector-title {
  font-size: 18px;
  font-weight: 600;
  color: var(--color-primary);
}
#custom-selector-close {
  font-size: 22px;
  background: none;
  border: none;
  color: var(--color-text-secondary);
  cursor: pointer;
  border-radius: 50%;
  width: 36px; height: 36px;
  transition: background 0.2s;
}
#custom-selector-close:hover {
  background: rgba(var(--color-border-rgb),0.15);
}
.custom-selector-options {
  padding: 10px 0 10px 0;
  overflow-y: auto;
  max-height: 55vh;
  min-width: 220px;
  scrollbar-width: thin;
  scrollbar-color: var(--color-primary) var(--color-surface);
}
.custom-selector-options::-webkit-scrollbar {
  width: 10px;
  background: var(--color-surface);
}
.custom-selector-options::-webkit-scrollbar-thumb {
  background: var(--color-primary);
  border-radius: 8px;
  border: 2px solid var(--color-surface);
}
.custom-selector-options::-webkit-scrollbar-thumb:hover {
  background: var(--color-primary-dark);
}
.custom-selector-options::-webkit-scrollbar-corner {
  background: var(--color-surface);
}
.custom-selector-option {
  display: flex;
  align-items: center;
  gap: 14px;
  padding: 12px 24px;
  font-size: 16px;
  color: var(--color-text-primary);
  cursor: pointer;
  border: none;
  background: none;
  width: 100%;
  transition: background 0.15s, color 0.15s;
  border-radius: 10px;
  margin: 2px 0;
  outline: none;
}
.custom-selector-option:hover, .custom-selector-option:focus {
  background: rgba(var(--color-primary-rgb),0.10);
  color: var(--color-primary);
}
.custom-selector-option.active {
  background: rgba(var(--color-primary-rgb),0.18);
  color: var(--color-accent, var(--color-primary));
  font-weight: 600;
}
.custom-selector-option .option-preview {
  width: 22px; height: 22px;
  border-radius: 6px;
  flex-shrink: 0;
  background: var(--color-border);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  margin-right: 2px;
}
.custom-selector-option .option-preview.theme {
  border: 2px solid var(--color-primary);
}
.custom-selector-option .option-preview.visualizer {
  border: 2px solid var(--color-accent);
}
.custom-selector-option .option-preview.fxchain {
  border: 2px solid var(--color-primary-dark);
}
.custom-selector-option .option-preview.language {
  font-size: 15px;
  background: none;
  border: none;
}
.custom-selector-option .option-preview.scale {
  font-size: 15px;
  background: none;
  border: none;
}
.custom-selector-option .option-label {
  flex-grow: 1;
  text-align: left;
  font-size: 16px;
  font-weight: 500;
  color: inherit;
}
@media (max-width: 600px) {
  .custom-selector-modal { min-width: 90vw; max-width: 98vw; }
  .custom-selector-options { min-width: 0; }
}

/* styles.css */
.dropdown-display {
    width: 100%;
    height: 40px; /* Такой же, как у .dropdown */
    padding: 0 30px 0 10px;
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius);
    background-color: var(--color-surface);
    color: var(--color-text-primary);
    font-size: 14px;
    line-height: 38px; /* Для вертикального выравнивания текста */
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23757575' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 10px center;
    background-size: 16px;
    cursor: pointer;
    transition: border-color 0.2s;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.dropdown-display:hover {
    border-color: var(--color-primary-light);
}

/* Если нужно кастомизировать отображение выбранного режима */
/* #pad-mode-selector-display { ... } */

/* Для контейнера специфичных настроек, если нужны отступы */
/* #mode-specific-controls-container {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid var(--color-border-rgb, 0.2);
} */

/* Сообщение об отсутствии настроек */
.no-controls-message {
    padding: 10px;
    text-align: center;
    color: var(--color-text-secondary);
    font-style: italic;
}

/* Общий класс для групп контролов в специфичных для режима настройках */
.mode-control-group {
    /* Можно добавить специфичные отступы, если нужно */
}

.knob-sub-label { /* Для метки под ручкой, если используется */
    font-size: 10px;
    color: var(--color-text-secondary);
    margin-top: 2px;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    width: 100%;
}

.xy-pad-zone-area.hint-harmonic-suggestion {
    background-color: yellow !important;
    border-left-color: rgba(var(--color-accent-rgb), 0.7) !important;
    border-right-color: rgba(var(--color-accent-rgb), 0.7) !important;
    transition: background-color 0.2s ease-out, box-shadow 0.2s ease-out;
}
.xy-pad-zone-area.hint-tonic {
    background-color: rgba(var(--color-primary-rgb), 0.25);
}

#rocket-mode-controls-content .setting-group {
    padding-left: 10px;
    border-left: 2px solid var(--color-primary-light);
    margin-top: 15px;
}
#rocket-mode-controls-content h5 {
    color: var(--color-primary);
    margin-bottom: 10px;
    font-size: 1em;
    border-bottom: 1px solid var(--color-border);
    padding-bottom: 5px;
}
.mode-control-item label:not(.toggle) {
    display: block;
    margin-bottom: 5px;
    font-weight: normal;
    font-size: 0.9em;
}
.mode-control-item .dropdown-display,
#rocket-mode-controls-content .dropdown-display {
    font-size: 0.9em;
    height: 36px;
    line-height: 34px;
}
.mode-control-item .knob-container.small-knob-container .knob.small {
    width: var(--knob-size-small, 48px);
    height: var(--knob-size-small, 48px);
}
.mode-control-item .knob-container.small-knob-container .knob-sub-label {
    font-size: 10px;
}
.display-value {
    padding: 8px 0;
    font-weight: bold;
    color: var(--color-text-primary);
}

/* Rocket Mode Phase Buttons */
.rocket-phase-buttons-group {
    display: flex;
    gap: 10px;
    margin: 12px 0 0 0;
    justify-content: flex-start;
}
.rocket-phase-buttons-group .action-button.active {
    background-color: var(--color-accent);
    color: #fff;
    font-weight: bold;
    border-color: var(--color-accent);
    box-shadow: 0 0 8px rgba(var(--color-accent-rgb,255,64,129),0.25);
}
.rocket-phase-buttons-group .action-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

#rocket-status-panel {
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding: 6px 10px;
    background-color: rgba(var(--color-surface-rgb), 0.9);
    border-bottom: 1px solid var(--color-border);
    font-size: 11px;
    color: var(--color-text-secondary);
    height: 30px;
    overflow: hidden;
    white-space: nowrap;
    transition: opacity 0.3s ease-out, height 0.3s ease-out;
    z-index: 90;
}
#rocket-status-panel.rocket-status-panel-hidden {
    opacity: 0;
    height: 0;
    padding-top: 0;
    padding-bottom: 0;
    border-bottom-width: 0;
    pointer-events: none;
}
.status-item {
    display: inline-flex;
    align-items: center;
    margin: 0 5px;
    overflow: hidden;
    text-overflow: ellipsis;
}
.status-icon {
    margin-right: 4px;
    font-size: 13px;
}
.status-item strong {
    color: var(--color-text-primary);
    margin-right: 3px;
}
.status-value {
    font-weight: bold;
    color: var(--color-primary);
    max-width: 120px;
    overflow: hidden;
    text-overflow: ellipsis;
    vertical-align: middle;
}
#status-energy-level {
    letter-spacing: -1px;
}

.rocket-status-hide-btn {
  position: absolute;
  top: 4px;
  right: 8px;
  background: transparent;
  border: none;
  font-size: 1.2em;
  color: var(--color-text-secondary, #888);
  cursor: pointer;
  z-index: 2;
}
.rocket-status-hide-btn:hover {
  color: var(--color-accent, #ff4081);
}
.rocket-status-show-btn {
  position: fixed;
  top: 60px;
  right: 24px;
  z-index: 1000;
  background: var(--color-bg-secondary, #fff);
  border: 1px solid var(--color-border, #ccc);
  border-radius: 50%;
  width: 36px;
  height: 36px;
  font-size: 1.3em;
  color: var(--color-accent, #ff4081);
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(0,0,0,0.08);
  display: flex;
  align-items: center;
  justify-content: center;
}
.rocket-status-show-btn:hover {
  background: var(--color-accent, #ff4081);
  color: #fff;
}
.status-clickable {
  cursor: pointer;
  text-decoration: underline dotted;
  transition: color 0.15s;
}
.status-clickable:hover {
  color: var(--color-accent, #ff4081);
}

.hg-display {
    position: absolute;
    top: calc(var(--topbar-height, 48px) + 5px);
    left: 50%;
    transform: translateX(-50%);
    font-size: 28px;
    font-weight: bold;
    color: var(--color-primary);
    padding: 5px 15px;
    background-color: rgba(var(--color-surface-rgb,255,255,255), 0.8);
    border-radius: var(--border-radius, 12px);
    z-index: 90;
    text-align: center;
    min-width: 100px;
    opacity: 0;
    transition: opacity 0.3s ease-out;
    pointer-events: none;
}
.hg-display.visible { opacity: 1; }
.hg-subbar {
    position: absolute;
    bottom: 5px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 14px;
    color: var(--color-text-secondary, #888);
    padding: 3px 10px;
    background-color: rgba(var(--color-surface-rgb,255,255,255), 0.7);
    border-radius: var(--border-radius, 12px);
    z-index: 90;
    text-align: center;
    min-width: 150px;
    opacity: 0;
    transition: opacity 0.3s ease-out;
    pointer-events: none;
}
.hg-subbar.visible { opacity: 1; }
.hg-subbar .function-T { color: var(--color-calm-marker, #FFDC00); font-weight: bold; }
.hg-subbar .function-S { color: var(--color-tense-marker, #0074D9); font-weight: bold; }
.hg-subbar .function-D { color: var(--color-powerful-marker, #FF4136); font-weight: bold; }


================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Prismtone</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/themes.css">
    <style>
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: fixed;
            touch-action: manipulation;
            overscroll-behavior: none;
        }
    </style>
</head>
<body class="theme-day landscape-mode">

<div id="app-container">

    <div id="loading-overlay">
        <canvas id="loading-stars-canvas"></canvas>
        <canvas id="loading-prism-canvas"></canvas>
        <div class="loading-text">Loading...</div>
        <div id="loading-title" data-i18n="app_title">Prismtone</div>
        <div class="loading-prompt" data-i18n="hit_play_vibe">Hit Play, Feel the Vibe</div>
    </div>

    <div id="topbar">
        <div class="topbar-group left">
            <button id="menu-button" class="round-button topbar-button" data-i18n-title="menu_button" title="Menu">☰</button>
            <button id="sound-library-button" class="text-button topbar-button" data-i18n="sound_library_button">Sound Library</button>
        </div>
        <div id="app-title" data-i18n="app_title">Prismtone</div>
        <div class="topbar-group right">
            <button id="tonality-button" class="round-button topbar-button" data-i18n-title="tonality_button" title="Tonality">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55c-2.21 0-4 1.79-4 4s1.79 4 4 4s4-1.79 4-4V7h4V3h-6z"/>
                </svg>
            </button>
            <button id="pad-modes-button" class="round-button topbar-button" data-i18n-title="pad_modes_button_title" title="Pad Modes">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M4 4h6v6H4V4zm0 10h6v6H4v-6zm10-10h6v6h-6V4zm0 10h6v6h-6v-6z"/>
                </svg>
            </button>
            <button id="effects-button" class="round-button topbar-button" data-i18n-title="effects_button" title="Effects">fx</button>
            <button id="reload-app-button" class="round-button topbar-button reload-app-button-style" data-i18n-title="reload_app_button_title" title="Reload Application">
                <svg class="restart-icon" xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/>
                </svg>
            </button>
        </div>
    </div>

    <div id="harmonic-glide-main-display" class="hg-display"></div>
    <div id="harmonic-glide-subbar" class="hg-subbar"></div>

    <div id="rocket-status-panel" class="rocket-status-panel-hidden">
        <button id="rocket-status-hide-btn" class="rocket-status-hide-btn" title="Hide Rocket Status Panel">×</button>
        <span class="status-item">
            <span class="status-icon"></span>
            <strong data-i18n="status_chord">Chord</strong>:
            <span id="status-current-chord" class="status-value status-clickable">N/A</span>
        </span>
        <span class="status-item">
            <span class="status-icon"></span>
            <strong data-i18n="status_key">Key</strong>:
            <span id="status-current-key" class="status-value status-clickable">C Major</span>
        </span>
        <span class="status-item">
            <span class="status-icon">🎯</span>
            <strong data-i18n="status_next">Next</strong>:
            <span id="status-next-suggestions" class="status-value status-clickable">-</span>
        </span>
        <span class="status-item">
            <span class="status-icon">🌀</span>
            <strong data-i18n="status_energy">Energy</strong>:
            <span id="status-energy-level" class="status-value status-clickable"></span>
        </span>
        <span class="status-item">
            <span class="status-icon">🔥</span>
            <strong data-i18n="status_phase">Phase</strong>:
            <span id="status-current-phase" class="status-value status-clickable">Ignition</span>
        </span>
    </div>
    <button id="rocket-status-show-btn" class="rocket-status-show-btn" style="display:none;" title="Show Rocket Status Panel">🚀</button>

    <div id="xy-pad-container">
        <canvas id="xy-visualizer"></canvas>
        <div id="xy-zones"></div>
        <div id="xy-labels"></div>
    </div>

    <div id="settings-panel" class="side-panel left-panel">
        <div class="panel-header"> <h2 data-i18n="settings_title">Settings</h2> <button class="close-button" data-panel-id="settings-panel">×</button> </div>
        <div class="panel-content">
            <div class="setting-group">
                <label for="language-select" data-i18n="language_label">Language</label>
                <select id="language-select" class="dropdown"></select>
            </div>
            <div class="setting-group">
                <label for="theme-select" data-i18n="theme_label">Theme</label>
                <select id="theme-select" class="dropdown"></select>
            </div>
            <div class="setting-group">
                <label for="visualizer-select" data-i18n="visualizer_label">Visualizer</label>
                <select id="visualizer-select" class="dropdown"></select>
            </div>
            <div class="setting-group">
                <label for="touch-effect-select" data-i18n="touch_effect_label">Touch Effect</label>
                <select id="touch-effect-select" class="dropdown"></select>
            </div>
            <div class="setting-group">
                <h4 data-i18n="display_options_header">Display & Behavior</h4>
                <div class="toggle-container">
                    <span data-i18n="show_note_names">Show Note Names</span>
                    <label class="toggle">
                        <input type="checkbox" id="show-note-names-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-container">
                    <span data-i18n="show_lines">Show Grid Lines</span>
                    <label class="toggle">
                        <input type="checkbox" id="show-lines-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-container">
                    <span data-i18n="highlight_sharps_flats">Highlight Accidentals</span>
                    <label class="toggle">
                        <input type="checkbox" id="highlight-sharps-flats-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-container">
                    <span data-i18n="enable_polyphony_scaling">Polyphony Volume Scaling</span>
                    <label class="toggle">
                        <input type="checkbox" id="enable-polyphony-volume-scaling-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

        </div>
    </div>

    <div id="tonality-panel" class="side-panel right-panel">
        <div class="panel-header"> <h2 data-i18n="tonality_title">Tonality</h2> <button class="close-button" data-panel-id="tonality-panel">×</button> </div>
        <div class="panel-content">
            <div class="setting-group"> <label for="scale-select" data-i18n="scale_label">Scale</label> <div id="scale-select-display" class="dropdown-display" tabindex="0"></div>  </div>
            <div class="setting-group"> <label data-i18n="size_label">Size</label> <div class="slider-container"> <button id="size-down" class="slider-button">-</button> <input type="range" id="size-slider" class="slider" min="8" max="36" value="12" step="2"> <button id="size-up" class="slider-button">+</button> <span id="size-value" class="slider-value">12</span> </div> </div>
            <div class="setting-group"> <label data-i18n="octave_label">Octave</label> <div class="slider-container"> <button id="octave-down" class="slider-button">-</button> <input type="range" id="octave-slider" class="slider" min="-7" max="7" value="0" step="1"> <button id="octave-up" class="slider-button">+</button> <span id="octave-value" class="slider-value">0</span> </div> </div>
        </div>
    </div>

    <div id="effects-panel" class="side-panel right-panel">
        <div class="panel-header"> <h2 data-i18n="effects_title">Effects</h2> <button class="close-button" data-panel-id="effects-panel">×</button> </div>
        <div class="panel-content">
            <div class="setting-group fx-chain-container">
                <label for="fx-chain-select" data-i18n="fx_chain_label">FX Chain</label>
                <select id="fx-chain-select" class="dropdown"></select>
            </div>
            <h4 data-i18n="macro_controls_title">Macro Controls</h4>
            <div id="macro-controls" class="control-grid">
                <div class="knob-container"> <div class="knob" data-param="macro1" data-min="0" data-max="1" data-step="0.01"> <div class="knob-dial"></div><span class="knob-value">0.5</span> </div> <label data-i18n="macro_space">Space</label> </div>
                <div class="knob-container"> <div class="knob" data-param="macro2" data-min="0" data-max="1" data-step="0.01"> <div class="knob-dial"></div><span class="knob-value">0.5</span> </div> <label data-i18n="macro_time">Time</label> </div>
                <div class="knob-container"> <div class="knob" data-param="macro3" data-min="0" data-max="1" data-step="0.01"> <div class="knob-dial"></div><span class="knob-value">0.5</span> </div> <label data-i18n="macro_motion">Motion</label> </div>
                <div class="knob-container"> <div class="knob" data-param="macro4" data-min="0" data-max="1" data-step="0.01"> <div class="knob-dial"></div><span class="knob-value">0.5</span> </div> <label data-i18n="macro_tone">Tone</label> </div>
            </div>
            <div class="setting-group y-axis-controls">
                <h4 data-i18n="y_axis_controls">Y-Axis Controls</h4>
                <h5>Volume</h5>
                <div class="y-axis-row">
                    <div class="knob-container"> <div class="knob small" data-param="volume_minOutput" data-min="0" data-max="1" data-step="0.01"><div class="knob-dial"></div><span class="knob-value">0.0</span></div> <label data-i18n="y_axis_volume_min_output">Min Output</label> </div>
                    <div class="knob-container"> <div class="knob small" data-param="volume_maxOutput" data-min="0" data-max="1" data-step="0.01"><div class="knob-dial"></div><span class="knob-value">1.0</span></div> <label data-i18n="y_axis_volume_max_output">Max Output</label> </div>
                    <div class="knob-container"> <div class="knob small" data-param="volume_yThreshold" data-min="0" data-max="1" data-step="0.01"><div class="knob-dial"></div><span class="knob-value">0.0</span></div> <label data-i18n="y_axis_volume_y_threshold">Y Threshold</label> </div>
                </div>
                <div class="y-axis-row">
                    <div class="dropdown-container small" style="flex-basis: 120px;"> <label for="volume_curveType-select" data-i18n="y_axis_curve_type">Curve Type</label> <select id="volume_curveType-select" class="dropdown small"> <option value="linear" data-i18n="linear">Linear</option> <option value="exponential" data-i18n="exponential">Exponential</option> <option value="logarithmic" data-i18n="logarithmic">Logarithmic</option> <option value="sCurve" data-i18n="s_curve">S-Curve</option> </select> </div>
                    <div class="knob-container"> <div class="knob small" data-param="volume_curveFactor" data-min="0.1" data-max="5" data-step="0.1"><div class="knob-dial"></div><span class="knob-value">1.0</span></div> <label data-i18n="y_axis_curve_factor">Curve Factor</label> </div>
                </div>
                <h5 style="margin-top: 15px;">Effects Send</h5>
                <div class="y-axis-row">
                    <div class="knob-container"> <div class="knob small" data-param="effects_minOutput" data-min="-60" data-max="0" data-step="1"><div class="knob-dial"></div><span class="knob-value">-60</span></div> <label data-i18n="y_axis_effects_min_output">Min Output (dB)</label> </div>
                    <div class="knob-container"> <div class="knob small" data-param="effects_maxOutput" data-min="-60" data-max="0" data-step="1"><div class="knob-dial"></div><span class="knob-value">0</span></div> <label data-i18n="y_axis_effects_max_output">Max Output (dB)</label> </div>
                    <div class="knob-container"> <div class="knob small" data-param="effects_yThreshold" data-min="0" data-max="1" data-step="0.01"><div class="knob-dial"></div><span class="knob-value">0.1</span></div> <label data-i18n="y_axis_effects_y_threshold">Y Threshold</label> </div>
                </div>
                <div class="y-axis-row">
                    <div class="dropdown-container small" style="flex-basis: 120px;"> <label for="effects_curveType-select" data-i18n="y_axis_curve_type">Curve Type</label> <select id="effects_curveType-select" class="dropdown small"> <option value="linear" data-i18n="linear">Linear</option> <option value="exponential" data-i18n="exponential">Exponential</option> <option value="logarithmic" data-i18n="logarithmic">Logarithmic</option> <option value="sCurve" data-i18n="s_curve">S-Curve</option></select> </div>
                    <div class="knob-container"> <div class="knob small" data-param="effects_curveFactor" data-min="0.1" data-max="5" data-step="0.1"><div class="knob-dial"></div><span class="knob-value">2.0</span></div> <label data-i18n="y_axis_curve_factor">Curve Factor</label> </div>
                </div>
            </div>
            <div class="setting-group master-output-controls">
                <h4 data-i18n="master_output_title">Master Output</h4>
                <div class="control-grid">
                    <div class="knob-container">
                        <div class="knob" data-param="masterVolumeCeiling" data-min="0" data-max="1" data-step="0.01" data-default="1.0">
                            <div class="knob-dial"></div><span class="knob-value">1.0</span>
                        </div>
                        <label data-i18n="master_volume_ceiling">Volume Ceiling</label>
                    </div>
                </div>
            </div>
            <div class="effect-actions"> <button id="reset-fx-button" class="action-button" data-i18n="reset_fx">Reset FX</button> </div>
        </div>
    </div>

    <div id="sound-library-panel" class="top-panel">
        <div class="panel-header">
            <h2 data-i18n="presets_panel_title">Presets</h2>
            <button class="close-button" data-panel-id="sound-library-panel">×</button>
        </div>
        <div class="panel-content sound-library-container">
            <div class="sound-presets">
                <div id="preset-grid" class="preset-list preset-grid">

                </div>
            </div>
        </div>
    </div>

    <div id="pad-modes-panel" class="side-panel right-panel">
        <div class="panel-header">
            <h2 data-i18n="pad_modes_panel_title">Pad Modes</h2>
            <button class="close-button" data-panel-id="pad-modes-panel">×</button>
        </div>
        <div class="panel-content">
            <div class="setting-group">
                <label for="pad-mode-selector-display" data-i18n="pad_mode_label">Pad Mode</label>
                <div id="pad-mode-selector-display" class="dropdown-display" tabindex="0" role="combobox" aria-haspopup="listbox" aria-expanded="false">
                    Classic
                </div>
                <select id="pad-mode-selector" class="dropdown" style="display: none;"></select>
            </div>
            <div id="mode-specific-controls-container">
            </div>
            <div class="setting-group" id="harmonic-glide-mode-select-group" style="display:none;">
                <label for="hg-submode-selector-display">Submode:</label>
                <div id="hg-submode-selector-display" class="dropdown-display" tabindex="0"></div>
            </div>
            <div id="harmonic-glide-common-settings-container" style="display:none;"></div>
            <div id="hg-submode-specific-controls-container" style="display:none;"></div>
        </div>
    </div>

    <div id="custom-selector-popover" class="custom-selector-popover" style="display:none;">
      <div class="custom-selector-backdrop"></div>
      <div class="custom-selector-modal">
        <div class="custom-selector-header">
          <span id="custom-selector-title"></span>
          <button id="custom-selector-close" class="close-button" title="Close">×</button>
        </div>
        <div id="custom-selector-options" class="custom-selector-options"></div>
      </div>
    </div>

</div>

<script src="js/lib/tone.min.js"></script>
<script src="js/lib/tonal.min.js"></script>
<script src="js/MusicTheoryService.js"></script>
<script src="js/PadModeManager.js"></script>
<script src="js/harmonicMarkerEngine.js"></script>
<script src="js/padModes/ClassicModeStrategy.js"></script>
<script src="js/padModes/RocketModeStrategy.js"></script>
<script src="js/padModes/subModes/TonalBindingSubModeStrategy.js"></script>
<script src="js/padModes/subModes/AdaptiveAnalysisSubModeStrategy.js"></script>
<script src="js/padModes/subModes/SemiFreeSubModeStrategy.js"></script>
<script src="js/padModes/subModes/RandomDirectedSubModeStrategy.js"></script>
<script src="js/padModes/HarmonicGlideStrategy.js"></script>
<script src="js/bridge-fix.js"></script>
<script src="js/config/audioConfig.js"></script>
<script src="js/moduleManager.js"></script>
<script src="js/i18n.js"></script>
<script src="js/voiceBuilder.js"></script>
<script src="js/synth.js"></script>
<script src="js/visualizer.js"></script>
<script src="js/visualizers/wavesRenderer.js"></script>
<script src="js/visualizers/spectrumRenderer.js"></script>
<script src="js/visualizers/particlesRenderer.js"></script>
<script src="js/visualizers/nebulaRenderer.js"></script>
<script src="js/visualizers/reactiveRipplesRenderer.js"></script>
<script src="js/visualizers/touchTrailsRenderer.js"></script>
<script src="js/touchEffects/glowEffect.js"></script>
<script src="js/touchEffects/markerEffect.js"></script>
<script src="js/touchEffects/rippleEffect.js"></script>
<script src="js/touchEffects/trailEffect.js"></script>
<script src="js/touchEffects/waveEffect.js"></script>
<script src="js/touchEffects/sparkEffect.js"></script>
<script src="js/touchEffects/energyEffect.js"></script>
<script src="js/touchEffects/geometricShardsEffect.js"></script>
<script src="js/touchEffects/novaSparkEffect.js"></script>
<script src="js/touchEffects/ballLightningLinkEffect.js"></script>
<script src="js/managers/blankManager.js"></script>
<script src="js/managers/oscillatorManager.js"></script>
<script src="js/managers/ampEnvManager.js"></script>
<script src="js/managers/filterManager.js"></script>
<script src="js/managers/outputGainManager.js"></script>
<script src="js/managers/pitchEnvManager.js"></script>
<script src="js/managers/lfoManager.js"></script>
<script src="js/managers/filterEnvelopeManager.js"></script>
<script src="js/managers/voiceFxSlotManager.js"></script>
<script src="js/managers/delayFxManager.js"></script>
<script src="js/managers/reverbFxManager.js"></script>
<script src="js/managers/chorusFxManager.js"></script>
<script src="js/managers/distortionFxManager.js"></script>
<script src="js/pad.js"></script>
<script src="js/soundpresets.js"></script>
<script src="js/fxchains.js"></script>
<script src="js/customSelectorPopover.js"></script>
<script src="js/sidepanel.js"></script>
<script src="js/topbar.js"></script>
<script src="js/loading/audio.js"></script>
<script src="js/loading/stars-animation.js"></script>
<script src="js/loading/prism-effect.js"></script>
<script src="js/app.js"></script>

</body>
</html>
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\app.js
// Файл: app/src/main/assets/js/app.js

const app = {
    state: {
        theme: 'day',
        language: 'en',
        soundPreset: '_test_single_preset',
        fxChain: null,
        visualizer: 'waves',
        touchEffect: 'glow',
        scale: 'major',
        octaveOffset: 0,
        zoneCount: 12,
        isAudioReady: false,
        isBridgeReady: false,
        isInitialized: false,
        hasUserInteracted: false,
        showNoteNames: true,
        showLines: true, // Используем showLines, как было изначально в UI HTML
        masterVolumeCeiling: 1.0,
        enablePolyphonyVolumeScaling: true,
        // === ДОБАВЛЕНА currentTonic ===
        currentTonic: "C4", // Дефолтная тоника
        // === ДОБАВЛЕНА highlightSharpsFlats ===
        highlightSharpsFlats: false, // Дефолтное состояние для подсветки диезов/бемолей
        // === ОБНОВЛЕННАЯ СТРУКТУРА yAxisControls для Части 2 ===
        yAxisControls: {
            volume: {
                minOutput: 0.0, // Изменено с 0.1 для полного диапазона, если yThreshold=0
                maxOutput: 1.0,
                yThreshold: 0.0,
                curveType: 'linear',
                curveFactor: 1.0, // Для exponential/log - степень, для sCurve - крутизна
                outputType: 'gain' // 'gain' (0-1)
            },
            effects: {
                minOutput: -60,    // Значение в dB
                maxOutput: 0,      // Значение в dB
                yThreshold: 0.1,
                curveType: 'exponential',
                curveFactor: 2.0,
                outputType: 'db'   // 'db'
            }
        },
        // +++ НОВОЕ СВОЙСТВО +++
        presetYAxisEffectsConfig: null, // Будет хранить yAxisEffectsSendConfig из активного пресета
        // +++ КОНЕЦ НОВОГО СВОЙСТВА +++
        // === НОВОЕ: Состояние для режима пэда ===
        padMode: "classic", // Режим по умолчанию
        currentChordName: null, // Для будущего ChordMode
        rocketModeSettings: {
            highlightActiveNotes: true,
            showDirectionalMarkers: true,
            markerStyle: "GlowFromNote",
            showOnlyForValidChords: false,
            animateMarkerFadeOut: true,
            showChordName: true,
            intensity: 0.5,
            autoPhases: true,
            phaseTransitionMode: 'activity',
            phaseDurations: { ignition: 30, liftOff: 60, burst: 90 },
            // === Новые поля для Rocket Status Panel ===
            chordBehavior: 'analyze', // 'analyze' | 'ignore' | 'fixed'
            nextSuggestionType: 'chords', // 'chords' | 'notes' | 'cadences' | 'improv'
            phaseHintMode: 'phaseAware', // 'phaseAware' | 'ignorePhase' | 'burstOnly'
            energyAffectsHints: true, // true | false
            keyBehavior: 'auto' // 'auto' | 'fixed' | 'ignore'
        },
        // === Rocket Mode Phase State ===
        rocketModePhase: 'ignition',
        rocketModeCurrentPhaseStartTime: 0,
        rocketModeCurrentPhaseActivityCounter: 0,
        rocketModeEnergy: 0,
        // ==============================
        yAxisDefinedByPreset: false, // true, если yAxisControls были установлены из текущего звукового пресета

        // === HARMONIC GLIDE SETTINGS ===
        harmonicGlide: {
            activeSubMode: "tonalBinding",
            intensity: 0.7,
            markerStyle: "Glow",
            activeNoteHighlightStyle: "WhiteGlow",
            highlightActiveNotes: true,
            fadeOutOldMarkers: true,
            markerFadeOutDurationMs: 600,
            markerDisappearOnNewTouch: true,
            showSubBarInfo: true,
            maxMarkersToShow: 5,
            phaseTransitionMode: "activity",
            phaseDurations: { ignition: 30, liftOff: 60, burst: 90 },
            phaseVisualStyle: "fade",
            tonalBinding: {
                showChordFunctions: true,
                diatonicOnly: true,
                preferredIntervals: ["P5", "P4", "M3", "m3", "M6", "m6"],
                showRomanNumerals: false
            },
            adaptiveAnalysis: {
                changeSensitivity: 0.6,
                stabilityPriority: 0.5,
                showInterpretation: true,
                allowChromaticSuggestions: true
            },
            semiFree: {
                deviationLevel: 0.4,
                allowNonDiatonicPassing: true,
                highlightReturnToTonic: true
            },
            randomDirected: {
                chaosLevel: 0.6,
                tonalFilterStrength: 0.5
            }
        },
        // Runtime данные для Harmonic Glide
        currentHarmonicGlideContext: {
            isPlayingChord: false,
            detectedChordSymbol: null
            // ... и другие поля из hmeAnalysisResult по мере необходимости
        },
        currentHarmonicGlideSuggestions: [] // Массив объектов SuggestionObject
    },
    elements: {
        loadingOverlay: null,
        loadingText: null,
        loadingTitle: null,
        loadingPrompt: null,
        body: document.body,
        appContainer: null,
        rocketStatusPanel: null,
        statusCurrentChord: null,
        statusCurrentKey: null,
        statusNextSuggestions: null,
        statusEnergyLevel: null,
        statusCurrentPhase: null,
        hgMainDisplay: null,
        hgSubBar: null,
    },
    loadingAudio: null,
    starsAnimation: null,
    prismEffect: null,
    loadingTimeoutId: null,
    isStartingApp: false,
    isRestartingAudio: false,

    async init() {
        console.log('[App.init v2.5.1 PadModeManager] Starting application initialization...');
        this.elements.body = document.body;
        this.elements.appContainer = document.getElementById('app-container');

        this.elements.loadingOverlay = document.getElementById('loading-overlay');
        this.elements.loadingText = this.elements.loadingOverlay?.querySelector('.loading-text');
        this.elements.loadingTitle = document.getElementById('loading-title');
        this.elements.loadingPrompt = document.querySelector('.loading-prompt');

        if (!this.elements.loadingOverlay || !this.elements.loadingText || !this.elements.loadingTitle || !this.elements.loadingPrompt) {
            console.error("[App.init v6] Critical error: Loading overlay elements not found!");
            if (this.elements.loadingText) this.elements.loadingText.textContent = "Initialization Error: UI elements missing.";
            return;
        }

        if (typeof i18n !== 'undefined') {
            i18n.init(this.state.language);
            this.updateLoadingText('initializing', 'Initializing...');
        } else { console.warn("[App.init v6] i18n module not found."); }

        let audioInitPromise = Promise.resolve(false);
        try {
            if (typeof loadingAudio !== 'undefined') {
                this.loadingAudio = loadingAudio;
                const audioBaseUrl = "https://appassets.androidplatform.net/assets/";
                const audioUrls = {
                    stars_warp: audioBaseUrl + 'audio/loading/stars_warp.mp3',
                    logo_reveal: audioBaseUrl + 'audio/loading/logo_reveal.mp3',
                    transition_burst: audioBaseUrl + 'audio/loading/transition_burst.mp3',
                    idle_loop: audioBaseUrl + 'audio/loading/idle_loop.mp3'
                };
                audioInitPromise = this.loadingAudio.init(audioUrls);
            } else { console.warn("[App.init v6] loadingAudio module not found."); }

            if (typeof starsAnimation !== 'undefined') {
                this.starsAnimation = starsAnimation;
                if (!this.starsAnimation.init('loading-stars-canvas')) { console.error("App.init v6: Failed to initialize stars animation."); }
                else { this.starsAnimation.start(); }
            } else { console.warn("[App.init v6] starsAnimation module not found."); }

            if (typeof prismEffect !== 'undefined') {
                this.prismEffect = prismEffect;
                if (!this.prismEffect.init('loading-prism-canvas')) { console.error("App.init v6: Failed to initialize prism effect."); }
            } else { console.warn("[App.init v6] prismEffect module not found."); }

        } catch (loadingModulesError) {
             console.error("App.init v6: Error initializing loading animation/audio modules:", loadingModulesError);
        }

        audioInitPromise.then(audioInitialized => {
            if (audioInitialized) { setTimeout(() => { this.loadingAudio?.playSFX('stars_warp'); }, 150); }
        });

        try {
            console.log('[App.init v6] Waiting for DOM Ready...');
            if (document.readyState === 'loading') { await new Promise(resolve => document.addEventListener('DOMContentLoaded', resolve)); }
            console.log('[App.init v6] DOM Ready.');

            console.log('[App.init v6] Waiting for bridge...');
            this.updateLoadingText('loading_bridge', 'Connecting...');
            await this.waitForBridge();
            console.log('[App.init v6] Bridge Ready.');

            console.log('[App.init v6] Starting main initialization sequence...');
            this.updateLoadingText('loading_settings', 'Loading settings...');
            await this.loadInitialSettings();
            console.log("[App.init v6] Initial currentTonic:", this.state.currentTonic);

            console.log('[App.init v6] Initializing i18n with loaded language...');
            await i18n.loadLanguage(this.state.language);

            this.updateLoadingText('loading_modules', 'Loading modules...');
            if (typeof moduleManager === 'undefined') throw new Error("moduleManager.js is not loaded!");
            await moduleManager.init();

            // MusicTheoryService
            if (typeof MusicTheoryService === 'undefined') throw new Error("MusicTheoryService is not loaded!");
            await MusicTheoryService.init(moduleManager);
            console.log("[App.init v2.5.1] MusicTheoryService initialized. isTonalJsLoaded:", MusicTheoryService.isTonalJsLoaded, "Scale defs count:", Object.keys(MusicTheoryService.scaleDefinitions).length);

            // Pad.js - ИНИЦИАЛИЗИРУЕМ ДО PadModeManager, чтобы pad.isReady было true
            if (typeof pad === 'undefined') throw new Error("pad.js is not loaded!");
            pad.init(document.getElementById('xy-pad-container'));
            console.log("[App.init v2.5.1] Pad initialized. pad.isReady:", pad.isReady);

            // PadModeManager
            console.log('[App.init] Before PadModeManager.init, this (app) is:', this);
            console.log('[App.init PadModes] Initializing PadModeManager...');
            if (typeof PadModeManager === 'undefined') throw new Error("PadModeManager.js is not loaded!");
            if (typeof harmonicMarkerEngine === 'undefined') throw new Error("harmonicMarkerEngine.js is not loaded!");
            harmonicMarkerEngine.init(MusicTheoryService);
            console.log("[App.init] HarmonicMarkerEngine initialized.");
            PadModeManager.init(this, MusicTheoryService, harmonicMarkerEngine);
            console.log("[App.init] PadModeManager initialized.");

            this.state.isInitialized = true; // Перемещаем сюда, если sidePanel зависит от isInitialized
            console.log('[App.init PadModes] Core services initialized (isInitialized = true).');
            
            // Инициализация UI Panels (включая sidePanel)
            if (typeof sidePanel === 'undefined') throw new Error("sidepanel.js is not loaded!");
            sidePanel.init(); // populateStaticSelects и populatePadModeSelectDisplay вызовутся здесь
            
            // Установка активного режима пэда (это вызовет app.updateZones() И sidePanel.displayModeSpecificControls())
            await this.setPadMode(this.state.padMode, true); // true для initialLoad

            // Synth
            if (typeof synth === 'undefined') throw new Error("synth.js is not loaded!");
            synth.init();
            if(synth.isReady) synth.applyMasterVolumeSettings();

            // Visualizer
            let analyserNode = (synth?.isReady) ? synth.getAnalyser() : null;
            if (typeof visualizer === 'undefined') throw new Error("visualizer.js is not loaded!");
            await visualizer.init(document.getElementById('xy-visualizer'), analyserNode);
            if (visualizer.isReady) {
                await visualizer.setVisualizerType(this.state.visualizer);
                await visualizer.setTouchEffectType(this.state.touchEffect);
            }

            // UI Panels
            this.updateLoadingText('loading_ui', 'Initializing UI...');
            if (typeof sidePanel === 'undefined') throw new Error("sidepanel.js is not loaded!");
            sidePanel.init(); // populateStaticSelects вызовется здесь
            // populatePadModeSelect уже вызван выше
            console.log('[App.init v2.5.1] UI modules initialized.');

            if (typeof topbar === 'undefined') throw new Error("topbar.js is not loaded!");
            topbar.init();
            if (typeof soundPresets === 'undefined') throw new Error("soundpresets.js is not loaded!");
            soundPresets.init();
            if (typeof fxChains === 'undefined') throw new Error("fxchains.js is not loaded!");
            fxChains.init();

            // Применение начального UI состояния
            this.updateLoadingText('loading_presets', 'Applying settings...');
            this.applyTheme(this.state.theme);
            await this.applySoundPreset(this.state.soundPreset); // Этот вызов уже содержит _determineEffectiveYAxisControls и обновление UI
            await this.applyFxChain(this.state.fxChain); // Этот вызов также должен содержать _determineEffectiveYAxisControls и обновление UI
            console.log('[App.init v2.5.1] Initial UI state applied.');

            this._updateSidePanelSettingsUI(); // Обновляем все настройки UI
            sidePanel.updateTonalityControls(this.state.octaveOffset, this.state.scale, this.state.zoneCount);
            if (fxChains.updateMasterOutputControlsUI) fxChains.updateMasterOutputControlsUI(this.state.masterVolumeCeiling);
            if (fxChains.updateYAxisControlsUI && this.state.fxChain === null) {
                fxChains.updateYAxisControlsUI(this.state.yAxisControls);
            }
            // app.updateZones() уже был вызван из PadModeManager.setActiveMode()

            this.elements.body.classList.add('landscape-mode');
            console.log('-----------------------------------------');
            console.log('[App.init v2.5.1] Core Initialization Complete.');
            console.log('Waiting for user interaction or timeout...');
            console.log('-----------------------------------------');

            const audioInitializedDone = await audioInitPromise;
            this.elements.loadingText?.classList.add('fade-out');
            if (audioInitializedDone) {
                 this.loadingAudio?.playSFX('logo_reveal');
                 this.loadingAudio?.startMusicLoop();
            }
            this.elements.loadingTitle?.classList.add('show');
            this.elements.loadingPrompt?.classList.add('show');
            if (typeof i18n !== 'undefined') i18n.updateUI();

            this.loadingTimeoutId = setTimeout(() => { this.triggerAppStart(); }, 14500);
            this.elements.loadingOverlay.addEventListener('click', this.handleOverlayClick, { once: true });

            this.elements.rocketStatusPanel = document.getElementById('rocket-status-panel');
            if (this.elements.rocketStatusPanel) {
                this.elements.statusCurrentChord = document.getElementById('status-current-chord');
                this.elements.statusCurrentKey = document.getElementById('status-current-key');
                this.elements.statusNextSuggestions = document.getElementById('status-next-suggestions');
                this.elements.statusEnergyLevel = document.getElementById('status-energy-level');
                this.elements.statusCurrentPhase = document.getElementById('status-current-phase');
            }

            // В app.init() или после создания элементов:
            app.elements.hgMainDisplay = document.getElementById('harmonic-glide-main-display');
            app.elements.hgSubBar = document.getElementById('harmonic-glide-subbar');

            app.updateMainDisplay = function(text) {
                if (!app.elements.hgMainDisplay) return;
                if (text === null || text === undefined || text === '') {
                    app.elements.hgMainDisplay.innerHTML = '';
                    app.elements.hgMainDisplay.style.display = 'none';
                } else {
                    app.elements.hgMainDisplay.innerHTML = `<span>${text}</span>`;
                    app.elements.hgMainDisplay.style.display = '';
                }
            };

            app.updateSubBar = function(htmlContent) {
                if (!app.elements.hgSubBar) return;
                if (htmlContent === null || htmlContent === undefined || htmlContent === '') {
                    app.elements.hgSubBar.innerHTML = '';
                    app.elements.hgSubBar.style.display = 'none';
                } else {
                    app.elements.hgSubBar.innerHTML = htmlContent;
                    app.elements.hgSubBar.style.display = '';
                }
            };

        } catch (error) {
            console.error('[App.init v2.5.1] Initialization sequence failed:', error, error.stack);
            this.state.isInitialized = false;
            this.updateLoadingText('error_init_failed_details', `Initialization Error: ${error.message}. Check console.`, true);
            this.starsAnimation?.stop();
            this.loadingAudio?.stopMusicLoop();
            this.loadingAudio?.dispose();
            this.starsAnimation?.cleanup();
            this.prismEffect?.cleanup();
            if (this.loadingTimeoutId) clearTimeout(this.loadingTimeoutId);
        }
    },

    updateLoadingText(key, fallback, isError = false) {
        if (this.elements.loadingText) {
            const message = (typeof i18n !== 'undefined' && i18n.translate) ? i18n.translate(key, fallback) : fallback;
            this.elements.loadingText.textContent = message;
            this.elements.loadingText.style.color = isError ? 'var(--color-accent, #ff4081)' : 'var(--color-text-on-dark, #e0e0e0)';
            this.elements.loadingText.classList.remove('fade-out');
        }
    },

    handleOverlayClick() {
        console.log("[App v6] Loading overlay clicked by user.");
        if (app.loadingTimeoutId) { clearTimeout(app.loadingTimeoutId); app.loadingTimeoutId = null; }
        app.triggerAppStart();
    },

    triggerAppStart() {
        if (app.isStartingApp || !app.state.isInitialized) { return; }
        console.log("[App v6] Triggering app start sequence...");
        app.isStartingApp = true;
        app.loadingAudio?.stopMusicLoop(0.3);
        app.starsAnimation?.stop();
        app.loadingAudio?.playSFX('transition_burst');
        app.elements.loadingTitle?.classList.remove('show');
        app.elements.loadingPrompt?.classList.remove('show');
        if (app.prismEffect) { app.prismEffect.play(() => { app.startAudioAndShowApp(); }); }
        else { app.startAudioAndShowApp(); }
    },

    async startAudioAndShowApp() {
        console.log("[App v6] Starting audio and hiding overlay...");
        try {
            if (Tone.context.state !== 'running') { await Tone.start(); }
            if (Tone.context.state === 'running') {
                app.state.isAudioReady = true;
                // === Экспериментальные настройки Tone.js context ===
                try {
                    Tone.context.lookAhead = 0.15; // По умолчанию ~0.1
                    Tone.context.updateInterval = 0.04; // По умолчанию ~0.03
                    console.log(`[App] Tone.context.lookAhead set to ${Tone.context.lookAhead}, updateInterval set to ${Tone.context.updateInterval}`);
                } catch (e) { console.warn('[App] Could not set Tone.context lookAhead/updateInterval:', e); }
                Tone.context.on('statechange', (e) => {
                    app.state.isAudioReady = Tone.context.state === 'running';
                    if (!app.state.isAudioReady) console.warn("[App v6] Audio context suspended after start!");
                });
                app.hideLoading();
                setTimeout(() => {
                    app.loadingAudio?.dispose(); app.starsAnimation?.cleanup(); app.prismEffect?.cleanup();
                }, 600);
            } else { throw new Error(`Audio context failed to start. State: ${Tone.context.state}`); }
        } catch (error) {
            console.error("[App v6] Failed to start/resume Tone.js:", error);
            app.elements.loadingOverlay?.classList.remove('hiding', 'hidden');
            app.updateLoadingText('error_audio_failed_retry', 'Error starting audio. Please tap again.', true);
            app.elements.loadingTitle?.classList.remove('show');
            app.elements.loadingPrompt?.classList.remove('show');
            app.elements.loadingText?.classList.add('fade-out');
            app.isStartingApp = false; app.state.isAudioReady = false; app.prismEffect?.stop();
            if (this.elements.loadingOverlay) { this.elements.loadingOverlay.removeEventListener('click', this.handleOverlayClick); this.elements.loadingOverlay.addEventListener('click', this.handleOverlayClick, { once: true }); }
        }
    },

    hideLoading() {
        if (this.elements.loadingOverlay && !this.elements.loadingOverlay.classList.contains('hidden')) {
            this.elements.loadingOverlay.classList.add('hiding');
            this.elements.loadingOverlay.addEventListener('transitionend', (event) => {
                 if (event.propertyName === 'opacity' || event.propertyName === 'transform') {
                     if (this.elements.loadingOverlay) { this.elements.loadingOverlay.classList.add('hidden'); this.elements.loadingOverlay.classList.remove('hiding'); }
                 }
            }, { once: true });
        }
    },

    waitForBridge() {
        const timeoutMs = 10000; const checkInterval = 100;
        return new Promise((resolve, reject) => {
            if (window.PrismtoneBridge?.getModules) { this.state.isBridgeReady = true; resolve(); }
            else { let attempts = 0; const maxAttempts = timeoutMs / checkInterval;
                const interval = setInterval(() => { attempts++;
                    if (window.PrismtoneBridge?.getModules) { clearInterval(interval); this.state.isBridgeReady = true; resolve(); }
                    else if (attempts > maxAttempts) { clearInterval(interval); reject(new Error("Bridge connection timed out")); }
                }, checkInterval);
            }
        });
    },

    async loadInitialSettings() {
        console.log("[App.loadInitialSettings] Loading settings...");
        // Пример загрузки из localStorage, замените на реальный вызов Bridge, если нужно
        const savedState = {
            theme: localStorage.getItem('theme') || 'day',
            language: localStorage.getItem('language') || 'en',
            soundPreset: localStorage.getItem('soundPreset') || '_test_single_preset', // Дефолт
            visualizer: localStorage.getItem('visualizer') || 'waves', // Дефолт
            touchEffect: localStorage.getItem('touchEffect') || 'glow', // Дефолт
            scale: localStorage.getItem('scale') || 'major', // Дефолт
            octaveOffset: parseInt(localStorage.getItem('octaveOffset') || '0', 10), // Дефолт 0
            zoneCount: parseInt(localStorage.getItem('zoneCount') || '12', 10), // Дефолт 12
            showNoteNames: localStorage.getItem('showNoteNames') === 'true',
            showLines: localStorage.getItem('showLines') === 'true',
            masterVolumeCeiling: parseFloat(localStorage.getItem('masterVolumeCeiling') || '1.0'),
            enablePolyphonyVolumeScaling: localStorage.getItem('enablePolyphonyVolumeScaling') === 'true',
            // === ЗАГРУЗКА ТОНИКИ ===
            currentTonic: localStorage.getItem('currentTonic') || "C4", // Загружаем или используем дефолт
            // === ЗАГРУЗКА highlightSharpsFlats ===
            highlightSharpsFlats: localStorage.getItem('highlightSharpsFlats') === 'true', // Загружаем или используем дефолт false
            // === ЗАГРУЗКА rocketModeSettings ===
            rocketModeSettings: {
                highlightActiveNotes: localStorage.getItem('rocketModeSettings.highlightActiveNotes') === 'true',
                showDirectionalMarkers: localStorage.getItem('rocketModeSettings.showDirectionalMarkers') === 'true',
                markerStyle: localStorage.getItem('rocketModeSettings.markerStyle') || "GlowFromNote",
                showOnlyForValidChords: localStorage.getItem('rocketModeSettings.showOnlyForValidChords') === 'true',
                animateMarkerFadeOut: localStorage.getItem('rocketModeSettings.animateMarkerFadeOut') === 'true',
                showChordName: localStorage.getItem('rocketModeSettings.showChordName') === 'true',
                // Новые поля:
                chordBehavior: localStorage.getItem('rocketModeSettings.chordBehavior') || 'analyze',
                nextSuggestionType: localStorage.getItem('rocketModeSettings.nextSuggestionType') || 'chords',
                phaseHintMode: localStorage.getItem('rocketModeSettings.phaseHintMode') || 'phaseAware',
                energyAffectsHints: localStorage.getItem('rocketModeSettings.energyAffectsHints') !== 'false',
                keyBehavior: localStorage.getItem('rocketModeSettings.keyBehavior') || 'auto'
            },
            // =======================
        };

        if (!this.state.isBridgeReady) {
             console.warn('[App.loadInitialSettings v6] Bridge not ready. Using defaults.');
             // Применяем дефолтные или загруженные из localStorage, если Bridge недоступен сразу
             this.state = { ...this.state, ...savedState };
             console.log('[App.loadInitialSettings] Initial state updated from localStorage (Bridge not ready):', this.state);
             return; // Выходим, если Bridge не готов
        }
        try {
            const settingsJson = await Promise.race([
                bridgeFix.callBridge('getCurrentSettings'),
                new Promise((_, reject) => setTimeout(() => reject(new Error("getCurrentSettings timeout")), 5000))
            ]);

            if (settingsJson) {
                const settings = JSON.parse(settingsJson);
                console.log('[App.loadInitialSettings v6] Received settings:', settings);
                this.state.theme = settings.theme || this.state.theme;
                this.state.language = settings.language || this.state.language;
                this.state.soundPreset = settings.soundPreset || this.state.soundPreset;
                this.state.fxChain = settings.fxChain ?? this.state.fxChain;
                this.state.visualizer = settings.visualizer || this.state.visualizer;
                this.state.touchEffect = settings.touchEffect || this.state.touchEffect;
                this.state.scale = settings.scale || this.state.scale;
                this.state.octaveOffset = settings.octaveOffset ?? this.state.octaveOffset;
                this.state.zoneCount = settings.zoneCount || this.state.zoneCount;
                this.state.showNoteNames = settings.showNoteNames ?? this.state.showNoteNames;
                this.state.showLines = settings.showLines ?? this.state.showLines; // Было showGrid

                this.state.masterVolumeCeiling = settings.masterVolumeCeiling ?? this.state.masterVolumeCeiling;
                this.state.enablePolyphonyVolumeScaling = settings.enablePolyphonyVolumeScaling ?? this.state.enablePolyphonyVolumeScaling;

                // === ЗАГРУЗКА highlightSharpsFlats из Bridge ===
                this.state.highlightSharpsFlats = settings.highlightSharpsFlats ?? this.state.highlightSharpsFlats; // Загружаем из bridge
                // ===============================================

                // === ОБНОВЛЕНИЕ ЗАГРУЗКИ yAxisControls для Части 2 ===
                const defaultVolY = this.state.yAxisControls.volume;
                const defaultFxY = this.state.yAxisControls.effects;

                if (settings.yAxisControls && typeof settings.yAxisControls === 'object') {
                    const receivedY = settings.yAxisControls;
                    if (receivedY.volume && typeof receivedY.volume === 'object') {
                        this.state.yAxisControls.volume.minOutput = receivedY.volume.minOutput ?? defaultVolY.minOutput;
                        this.state.yAxisControls.volume.maxOutput = receivedY.volume.maxOutput ?? defaultVolY.maxOutput;
                        this.state.yAxisControls.volume.yThreshold = receivedY.volume.yThreshold ?? defaultVolY.yThreshold;
                        this.state.yAxisControls.volume.curveType = receivedY.volume.curveType || defaultVolY.curveType;
                        this.state.yAxisControls.volume.curveFactor = receivedY.volume.curveFactor ?? defaultVolY.curveFactor;
                        this.state.yAxisControls.volume.outputType = receivedY.volume.outputType || defaultVolY.outputType;
                    }
                    if (receivedY.effects && typeof receivedY.effects === 'object') {
                        this.state.yAxisControls.effects.minOutput = receivedY.effects.minOutput ?? defaultFxY.minOutput;
                        this.state.yAxisControls.effects.maxOutput = receivedY.effects.maxOutput ?? defaultFxY.maxOutput;
                        this.state.yAxisControls.effects.yThreshold = receivedY.effects.yThreshold ?? defaultFxY.yThreshold;
                        this.state.yAxisControls.effects.curveType = receivedY.effects.curveType || defaultFxY.curveType;
                        this.state.yAxisControls.effects.curveFactor = receivedY.effects.curveFactor ?? defaultFxY.curveFactor;
                        this.state.yAxisControls.effects.outputType = receivedY.effects.outputType || defaultFxY.outputType;
                    }
                }
                // =====================================================

                // === НОВОЕ: Загрузка currentTonic и highlightSharpsFlats ===
                if (settings.currentTonic !== undefined) this.state.currentTonic = settings.currentTonic;
                if (settings.highlightSharpsFlats !== undefined) this.state.highlightSharpsFlats = settings.highlightSharpsFlats;
                // =======================================================

                // === ЗАГРУЗКА rocketModeSettings ===
                let rocketDefaults = {
                    highlightActiveNotes: true,
                    showDirectionalMarkers: true,
                    markerStyle: "GlowFromNote",
                    showOnlyForValidChords: false,
                    animateMarkerFadeOut: true,
                    showChordName: true,
                    intensity: 0.5,
                    autoPhases: true,
                    phaseTransitionMode: 'activity',
                    phaseDurations: { ignition: 30, liftOff: 60, burst: 90 },
                    // === Новые поля для Rocket Status Panel ===
                    chordBehavior: 'analyze', // 'analyze' | 'ignore' | 'fixed'
                    nextSuggestionType: 'chords', // 'chords' | 'notes' | 'cadences' | 'improv'
                    phaseHintMode: 'phaseAware', // 'phaseAware' | 'ignorePhase' | 'burstOnly'
                    energyAffectsHints: true, // true | false
                    keyBehavior: 'auto' // 'auto' | 'fixed' | 'ignore'
                };
                let loadedRocket = {};
                try {
                    loadedRocket = JSON.parse(localStorage.getItem('rocketModeSettings') || '{}');
                } catch(e) { loadedRocket = {}; }
                this.state.rocketModeSettings = { ...rocketDefaults, ...loadedRocket };
                // ... если есть settings.rocketModeSettings из Bridge, применить его ...
                if (settings && settings.rocketModeSettings) {
                    try {
                        const parsed = typeof settings.rocketModeSettings === 'string' ? JSON.parse(settings.rocketModeSettings) : settings.rocketModeSettings;
                        this.state.rocketModeSettings = { ...rocketDefaults, ...parsed };
                    } catch(e) { console.warn('[App] Failed to parse rocketModeSettings from bridge:', e); }
                }
                // =======================================================

                console.log('[App.loadInitialSettings v6] Final rocketModeSettings:', this.state.rocketModeSettings);
                console.log('[App.loadInitialSettings v6] Initial state updated:', this.state);
            } else {
                 console.warn('[App.loadInitialSettings v6] Received null or empty settings from bridge. Using defaults.');
            }
        } catch (error) {
            console.error('[App.loadInitialSettings v6] Error loading initial settings:', error);
        }
        // После загрузки настроек Rocket Mode из localStorage/Bridge
        const defaultRocketSettings = /* импортировать или получить из defaultAppSettings.json */ window.defaultRocketSettings || {};
        const loadedRocketSettings = this.state.rocketModeSettings || {};
        this.state.rocketModeSettings = {
            ...defaultRocketSettings,
            ...loadedRocketSettings,
            displayMarkers: { ...defaultRocketSettings.displayMarkers, ...(loadedRocketSettings.displayMarkers || {}) },
            phaseDurations: { ...defaultRocketSettings.phaseDurations, ...(loadedRocketSettings.phaseDurations || {}) }
        };
        if (this.state.padMode === 'rocket' && this.state.isInitialized && PadModeManager.getCurrentStrategy()?.getName() === 'rocket') {
            PadModeManager.getCurrentStrategy().updateInternalSetting('all', this.state.rocketModeSettings);
            this.updateZoneLayout();
            this.updateRocketStatusPanel();
        }

        // === Глубокое объединение rocketModeSettings ===
        const baseRocketDefaults = JSON.parse(JSON.stringify(this.state.rocketModeSettings));
        let finalRocketSettings = baseRocketDefaults;
        try {
            const savedJsSettingsJson = localStorage.getItem('prismtoneAppSettings_js');
            if (savedJsSettingsJson) {
                const savedJsSettings = JSON.parse(savedJsSettingsJson);
                if (savedJsSettings.rocketModeSettings) {
                    finalRocketSettings = {
                        ...baseRocketDefaults,
                        ...savedJsSettings.rocketModeSettings,
                        displayMarkers: {
                            ...(baseRocketDefaults.displayMarkers || {}),
                            ...(savedJsSettings.rocketModeSettings.displayMarkers || {})
                        },
                        phaseDurations: {
                            ...(baseRocketDefaults.phaseDurations || {}),
                            ...(savedJsSettings.rocketModeSettings.phaseDurations || {})
                        }
                    };
                    console.log('[App.loadInitialSettings] Loaded and merged rocketModeSettings from localStorage.');
                }
            }
        } catch (e) {
            console.error('[App.loadInitialSettings] Error loading/merging JS-specific settings from localStorage:', e);
        }
        this.state.rocketModeSettings = finalRocketSettings;
        console.log('[App.loadInitialSettings] Final initial rocketModeSettings:', JSON.parse(JSON.stringify(this.state.rocketModeSettings)));
        // ... остальной код ...

        // --- Загрузка presetYAxisEffectsConfig из начального звукового пресета ---
        if (this.state.soundPreset && typeof moduleManager !== 'undefined' && moduleManager) { // Добавлена проверка moduleManager
            const initialPresetModule = await moduleManager.getModule(this.state.soundPreset);
            if (initialPresetModule?.data?.data?.yAxisEffectsSendConfig) {
                this.state.presetYAxisEffectsConfig = JSON.parse(JSON.stringify(initialPresetModule.data.data.yAxisEffectsSendConfig));
                console.log("[App.loadInitialSettings] Initial presetYAxisEffectsConfig set from:", this.state.soundPreset, this.state.presetYAxisEffectsConfig);
            } else {
                this.state.presetYAxisEffectsConfig = null;
                console.log("[App.loadInitialSettings] No yAxisEffectsSendConfig in initial preset:", this.state.soundPreset);
            }
        } else {
            this.state.presetYAxisEffectsConfig = null; // На случай, если soundPreset не определен или moduleManager еще нет
            console.warn("[App.loadInitialSettings] Could not load initial presetYAxisEffectsConfig (soundPreset or moduleManager missing).");
        }
        // --- Конец загрузки presetYAxisEffectsConfig ---

        await this._determineEffectiveYAxisControls(); // Определяем и применяем финальные Y-axis controls

        console.log('[App.loadInitialSettings] Final initial state updated:', JSON.parse(JSON.stringify(this.state))); // Логируем всё состояние
        this.state.yAxisDefinedByPreset = false; // потому что мы еще не знаем, откуда пришли загруженные yAxisControls
    },

    resumeAudio() {
        if (this.state.isInitialized && Tone.context && Tone.context.state !== 'running') {
             console.log(`[App.resumeAudio] Attempting to resume audio. Current state: ${Tone.context.state}, isAudioReady: ${this.state.isAudioReady}`);
            Tone.context.resume().then(() => {
                this.state.isAudioReady = Tone.context.state === 'running';
                console.log(`[App.resumeAudio] Audio resumed. New state: ${Tone.context.state}, isAudioReady: ${this.state.isAudioReady}`);
            }).catch(err => {
                this.state.isAudioReady = false;
                console.error("[App.resumeAudio] Error resuming audio:", err);
            });
        } else if (Tone.context) {
            this.state.isAudioReady = Tone.context.state === 'running';
        } else {
            console.warn("[App.resumeAudio] Tone.context not available.");
            this.state.isAudioReady = false;
        }
    },

    suspendAudio() {
        console.log("[App.suspendAudio] Suspending audio.");
        if (synth?.stopAllNotes) {
            synth.stopAllNotes();
        }
    },

    applyTheme(themeId) {
        if (!themeId) return;
        try {
            const currentClasses = Array.from(this.elements.body.classList);
            const themeClasses = currentClasses.filter(cls => cls.startsWith('theme-'));
            this.elements.body.classList.remove(...themeClasses);
            this.elements.body.classList.add(`theme-${themeId}`);
            this.state.theme = themeId;
            if (visualizer?.updateTheme) visualizer.updateTheme();
            this._updateSidePanelSettingsUI(); // Вынесли в отдельный метод
        } catch (error) { console.error(`[App] Error applying theme ${themeId}:`, error); }
    },

    async applyLanguage(languageId) {
         if (!languageId) return;
        try {
            if (i18n?.loadLanguage) {
                await i18n.loadLanguage(languageId);
                this.state.language = languageId;
                if (this.elements.loadingOverlay && !this.elements.loadingOverlay.classList.contains('hidden')) {
                     const currentTextKey = this.elements.loadingText?.dataset.i18nKey || 'loading';
                     this.updateLoadingText(currentTextKey, currentTextKey);
                }
                 this._updateSidePanelSettingsUI();
            } else { console.error('[App] i18n module not available.'); }
        } catch (error) { console.error(`[App] Error applying language ${languageId}:`, error); }
    },

    async applyVisualizer(visualizerId) {
        if (!visualizerId) return;
        try {
            this.state.visualizer = visualizerId;
            if (visualizer?.setVisualizerType) {
                await visualizer.setVisualizerType(visualizerId);
                 bridgeFix.callBridge('setSetting', 'visualizer', visualizerId).catch(err => console.error("[App] Bridge setVisualizer failed:", err));
            }
            this._updateSidePanelSettingsUI();
        } catch (error) { console.error(`[App] Error applying visualizer ${visualizerId}:`, error); }
    },

    async applyTouchEffect(effectId) {
        if (effectId === undefined) return;
        const targetEffectId = effectId || 'none';
        try {
            this.state.touchEffect = targetEffectId;
            if (visualizer?.setTouchEffectType) {
                await visualizer.setTouchEffectType(targetEffectId);
                 bridgeFix.callBridge('setSetting', 'touchEffect', targetEffectId).catch(err => console.error("[App] Bridge setTouchEffect failed:", err));
            }
            this._updateSidePanelSettingsUI();
        } catch (error) {
            console.error(`[App] Error applying touch effect ${targetEffectId}:`, error);
        }
    },

    _applyAndSyncYAxisState() {
        console.log(`[App._applyAndSyncYAxisState v8] Syncing Y-Axis state from app.state:`, JSON.parse(JSON.stringify(this.state.yAxisControls)));
        if (synth) {
            if (synth.updateAllActiveVoiceMainLevels) synth.updateAllActiveVoiceMainLevels();
            if (synth.updateAllActiveVoiceSendLevels) synth.updateAllActiveVoiceSendLevels();
        }
        if (fxChains?.updateYAxisControlsUI) {
            fxChains.updateYAxisControlsUI(this.state.yAxisControls);
        }
        if (this.state.isInitialized && this.state.isBridgeReady) {
            bridgeFix.callBridge('setYAxisControlGroup', 'volume', JSON.stringify(this.state.yAxisControls.volume))
                .catch(err => console.error("[App._applyAndSyncYAxisState v8] Bridge setYAxis volume failed:", err));
            bridgeFix.callBridge('setYAxisControlGroup', 'effects', JSON.stringify(this.state.yAxisControls.effects))
                .catch(err => console.error("[App._applyAndSyncYAxisState v8] Bridge setYAxis effects failed:", err));
        }
    },

    async applySoundPreset(presetId) {
        const targetPresetId = presetId || (this.config.defaultPreset ? this.config.defaultPreset.id : 'default_piano');
        console.log(`[App.applySoundPreset] Applying preset: ${targetPresetId}`);
        try {
            // ... (существующая логика загрузки presetModuleData) ...
            const presetModule = await moduleManager.getModule(targetPresetId);
            let presetModuleDataForSynth = null;
            if (presetModule?.data?.data) {
                presetModuleDataForSynth = presetModule.data.data;
            } else {
                // Fallback to synth's internal default if module load fails
                presetModuleDataForSynth = synth.config.defaultPreset; // Используем дефолт из synth
                console.warn(`[App.applySoundPreset] Could not load module for '${targetPresetId}', using synth default preset.`);
            }

            if (!presetModuleDataForSynth) {
                throw new Error(`Critical: Preset data for '${targetPresetId}' and synth default are both unavailable.`);
            }

            if (synth?.applyPreset) {
                synth.applyPreset(presetModuleDataForSynth); // Передаем data.data
            } else {
                throw new Error("Synth not ready for preset application");
            }
            if (soundPresets?.updateActivePresetCube) {
                soundPresets.updateActivePresetCube(targetPresetId);
            }
            this.state.soundPreset = targetPresetId; // Обновляем ID активного пресета
            if (targetPresetId && this.state.isBridgeReady) { // Сохраняем только если это не null/undefined
                await bridgeFix.callBridge('setSoundPreset', targetPresetId);
            }

            // === КЛЮЧЕВОЕ ИЗМЕНЕНИЕ ===
            this._resolveAndApplyYAxisControls(true); // true - флаг для принудительного обновления UI/Synth
            // ==========================

        } catch (error) {
            console.error(`[App] Error applying sound preset ${targetPresetId}:`, error, error.stack);
            // Fallback logic if needed
            // ...
        }
    },

    async applyFxChain(chainId) {
        const targetChainId = chainId ?? null;
        console.log(`[App.applyFxChain] Applying FX Chain ID: ${targetChainId}.`);
        try {
            let chainModule = null;
            let fxChainFullDataForSynth = null; // Это объект chainModule.data.data

            if (targetChainId) {
                chainModule = await moduleManager.getModule(targetChainId);
                if (chainModule?.data?.data) {
                    fxChainFullDataForSynth = chainModule.data.data;
                } else if (targetChainId) {
                    console.warn(`[App.applyFxChain] FX Chain module data for ID '${targetChainId}' not found. Will apply empty chain to synth.`);
                }
            }

            // 1. Применяем аудиоэффекты в synth
            if (synth?.applyFxChain) {
                synth.applyFxChain(fxChainFullDataForSynth); // synth.applyFxChain сам разберет fxChainFullDataForSynth.effects
            } else {
                throw new Error("Synth not ready for FX chain application");
            }

            // 2. Обновляем ID активной цепочки в app.state
            this.state.fxChain = targetChainId;
            if (this.state.isBridgeReady) {
                 await bridgeFix.callBridge('setFxChain', targetChainId); // Сохраняем null, если targetChainId - null
            }

            // 3. Обновляем UI (селект цепочки и макро-ручки)
            if (fxChains?.updateActiveChain) {
                fxChains.updateActiveChain(targetChainId);
            }
            if (fxChains?.updateMacroKnobsFromChain) {
                // Передаем полные данные цепочки (fxChainFullDataForSynth), если они есть,
                // т.к. updateMacroKnobsFromChain ожидает объект с полем macroDefaults
                fxChains.updateMacroKnobsFromChain(fxChainFullDataForSynth);
            }

            // 4. === КЛЮЧЕВОЕ ИЗМЕНЕНИЕ ===
            // Разрешаем и применяем Y-Axis настройки, учитывая приоритеты
            this._resolveAndApplyYAxisControls(true); // true - флаг для принудительного обновления UI/Synth
            // ==========================

        } catch (error) {
            console.error(`[App] Error applying FX chain ${targetChainId}:`, error, error.stack);
            // Логика отката...
            try {
                if (synth) synth.applyFxChain(null);
                this.state.fxChain = null;
                if (this.state.isBridgeReady) await bridgeFix.callBridge('setFxChain', null);
                this._resolveAndApplyYAxisControls(true);
                if (fxChains?.updateActiveChain) fxChains.updateActiveChain(null);
                if (fxChains?.updateMacroKnobsFromChain) fxChains.updateMacroKnobsFromChain(null);
            } catch (fallbackError) { console.error('[App] Error during FX chain fallback:', fallbackError); }
        }
    },

    async setScale(scaleId) {
        if (!scaleId || this.state.scale === scaleId) return;
        console.log(`[App] Setting scale to: ${scaleId}`);
        this.state.scale = scaleId;
        if (sidePanel?.updateTonalityControls) {
            sidePanel.updateTonalityControls(this.state.octaveOffset, this.state.scale, this.state.zoneCount);
        }
        bridgeFix.callBridge('setSetting', 'scale', scaleId)
            .catch(err => console.error("[App.setScale] Bridge setSetting scale failed:", err));
        await this.updateZoneLayout();
    },

    async setOctaveOffset(offset) {
        const newOffset = Math.max(-7, Math.min(7, parseInt(offset, 10)));
        if (newOffset === this.state.octaveOffset || isNaN(newOffset)) return;
        this.state.octaveOffset = newOffset;
        await this.updateZoneLayout();
        if (sidePanel?.updateTonalityControls) {
            sidePanel.updateTonalityControls(this.state.octaveOffset, this.state.scale, this.state.zoneCount);
        }
        bridgeFix.callBridge('setOctaveOffset', newOffset).catch(err => console.error("[App] Bridge setOctaveOffset failed:", err));
    },

    async setZoneCount(count) {
        const newCount = parseInt(count, 10);
        if (isNaN(newCount) || newCount < 8 || newCount > 36 || newCount % 2 !== 0) {
            console.warn(`[App.setZoneCount] Invalid zone count: ${count}. Must be an even number between 8 and 36.`);
            if (sidePanel?.updateTonalityControls) {
                sidePanel.updateTonalityControls(this.state.octaveOffset, this.state.scale, this.state.zoneCount);
            }
            return;
        }
        if (newCount === this.state.zoneCount) return;
        this.state.zoneCount = newCount;
        console.log(`[App] Zone count set to: ${this.state.zoneCount}`);
        await this.updateZoneLayout();
        if (sidePanel?.updateTonalityControls) {
            sidePanel.updateTonalityControls(this.state.octaveOffset, this.state.scale, this.state.zoneCount);
        }
        bridgeFix.callBridge('setSetting', 'zoneCount', this.state.zoneCount.toString())
            .catch(err => console.error("[App] Bridge setSetting zoneCount failed:", err));
    },

    async updateZoneLayout() {
        // Полный цикл: layout + визуальные подсказки
        if (!this.state.isInitialized || !PadModeManager || !PadModeManager.getCurrentStrategy() || !pad?.isReady) {
            console.warn(`[App.updateZoneLayout] Aborting: Not ready, no strategy, or pad not ready.`);
            return;
        }
        try {
            const currentStrategy = PadModeManager.getCurrentStrategy();
            const layoutContext = await currentStrategy.getZoneLayoutOptions(this.state);
            if (!layoutContext) {
                pad.drawZones([], this.state.currentTonic);
                await this.updateZoneVisuals([]); // Обновляем визуализацию с пустыми зонами
                return;
            }
            const servicesForStrategy = PadModeManager._getServicesBundle();
            const zonesData = await currentStrategy.generateZoneData(layoutContext, this.state, servicesForStrategy);
            pad.drawZones(zonesData, this.state.currentTonic);
            await this.updateZoneVisuals(zonesData); // ГАРАНТИРОВАННО обновляем hints для актуальных зон
        } catch (error) {
            console.error('[App.updateZoneLayout] Error:', error, error.stack);
            if (pad?.isReady) pad.drawZones([], this.state.currentTonic);
            await this.updateZoneVisuals([]);
        }
    },

    async updateZoneVisuals(currentZonesData = pad._currentDisplayedZones) {
        if (!this.state.isInitialized || !PadModeManager?.getCurrentStrategy() || !pad?.isReady) return;
        try {
            const currentStrategy = PadModeManager.getCurrentStrategy();
            if (typeof currentStrategy.getPadVisualHints === 'function') {
                const services = PadModeManager._getServicesBundle();
                console.log(`[App.updateZoneVisuals] Getting hints for mode: ${PadModeManager.getCurrentModeId()}`);
                const hints = await currentStrategy.getPadVisualHints(currentZonesData, this.state, services);
                console.log(`[App.updateZoneVisuals] ----- HINTS RECEIVED FROM STRATEGY (${hints ? hints.length : 'null/undefined'}) -----`);
                if (Array.isArray(hints)) {
                    hints.forEach((h, i) => {
                        console.log(`  [App] Hint ${i}: zoneIndex=${h.zoneIndex}, type='${h.type}', style='${h.style}', color='${h.color}', note='${h.noteName || (h.notes ? h.notes.join(',') : 'N/A')}'`);
                    });
                    let hintsForVisualizer = [];
                    try {
                        hintsForVisualizer = JSON.parse(JSON.stringify(hints));
                    } catch (e) {
                        console.error("[App.updateZoneVisuals] Error deep copying hints:", e);
                        hintsForVisualizer = hints;
                    }
                    console.log(`[App.updateZoneVisuals] Hints BEING SENT to Visualizer (${hintsForVisualizer ? hintsForVisualizer.length : 'null/undefined'}):`);
                    if (Array.isArray(hintsForVisualizer)) {
                        hintsForVisualizer.forEach((h, i) => {
                            console.log(`  [App] Hint (For Visualizer) ${i}: zoneIndex=${h.zoneIndex}, type='${h.type}', style='${h.style}', color='${h.color}', note='${h.noteName || (h.notes ? h.notes.join(',') : 'N/A')}'`);
                        });
                    }
                    visualizer.updatePadHints(hintsForVisualizer);
                } else {
                    console.warn("[App.updateZoneVisuals] Hints from strategy is not an array:", hints);
                    visualizer.updatePadHints([]);
                }
            } else {
                pad.applyVisualHints([]);
            }
        } catch (error) {
            console.error('[App.updateZoneVisuals] Error:', error);
        }
    },

    toggleNoteNames(show) {
        if (typeof show !== 'boolean') return;
        this.state.showNoteNames = show;
        if (pad?.toggleLabels) pad.toggleLabels(show);
        bridgeFix.callBridge('setSetting', 'showNoteNames', show.toString()).catch(err => console.error("[App] Bridge setSetting showNoteNames failed:", err));
        this._updateSidePanelSettingsUI();
    },

    toggleLines(show) {
        if (typeof show !== 'boolean') return;
        this.state.showLines = show;
        if (pad?.toggleLines) pad.toggleLines(show);
        bridgeFix.callBridge('setSetting', 'showLines', show.toString()).catch(err => console.error("[App] Bridge setSetting showLines failed:", err));
        this._updateSidePanelSettingsUI();
    },

    setMasterVolumeCeiling(value) {
        const processedValue = parseFloat(value);
        if (isNaN(processedValue) || processedValue < 0 || processedValue > 1) {
            console.warn('[App] Invalid value:', value);
            return;
        }
        if (this.state.masterVolumeCeiling === processedValue) return;
        this.state.masterVolumeCeiling = processedValue;
        console.log('[App] Master Volume Ceiling set to:', this.state.masterVolumeCeiling);
        if (synth && synth.isReady) {
            synth.applyMasterVolumeSettings();
        }
        bridgeFix.callBridge('setSetting', 'masterVolumeCeiling', this.state.masterVolumeCeiling.toString())
           .catch(err => console.error("[App] Bridge setSetting masterVolumeCeiling failed:", err));
        if (fxChains && typeof fxChains.updateMasterOutputControlsUI === 'function') {
            fxChains.updateMasterOutputControlsUI(this.state.masterVolumeCeiling);
        }
    },

    setEnablePolyphonyVolumeScaling(isEnabled) {
        const enabled = typeof isEnabled === 'boolean' ? isEnabled : !!isEnabled; // Ensure boolean
        if (this.state.enablePolyphonyVolumeScaling === enabled) return;
        this.state.enablePolyphonyVolumeScaling = enabled;
        console.log('[App] Enable Polyphony Volume Scaling toggled to:', this.state.enablePolyphonyVolumeScaling);
        if (synth && synth.isReady) {
            synth.applyMasterVolumeSettings(); // Re-apply settings as this affects volume calculation
        }
        bridgeFix.callBridge('setSetting', 'enablePolyphonyVolumeScaling', this.state.enablePolyphonyVolumeScaling.toString())
           .catch(err => console.error("[App] Bridge setSetting enablePolyphonyVolumeScaling failed:", err));
        this._updateSidePanelSettingsUI();
    },

    // === ОБНОВЛЕННАЯ ФУНКЦИЯ setYAxisControl для Части 2 ===
    setYAxisControl(group, controlName, value) {
        if (!this.state.yAxisControls[group] || !this.state.yAxisControls[group].hasOwnProperty(controlName)) {
            console.warn(`[App.setYAxisControl] Attempted to set unknown Y-Axis control: ${group}.${controlName}`);
            return;
        }

        let processedValue = value;
        const config = this.state.yAxisControls[group];

        // Валидация и преобразование значения
        if (['minOutput', 'maxOutput', 'yThreshold', 'curveFactor'].includes(controlName)) {
            processedValue = parseFloat(value);
            if (isNaN(processedValue)) {
                console.warn(`[App.setYAxisControl] Invalid number value for ${group}.${controlName}:`, value);
                return;
            }
            // Дополнительные ограничения для конкретных параметров
            if (controlName === 'yThreshold') processedValue = Math.max(0, Math.min(1, processedValue));
            if (group === 'volume' && (controlName === 'minOutput' || controlName === 'maxOutput')) {
                processedValue = Math.max(0, Math.min(1, processedValue));
            }
            if (group === 'effects' && (controlName === 'minOutput' || controlName === 'maxOutput')) {
                processedValue = Math.max(-100, Math.min(0, processedValue)); // Для dB
            }
            if (controlName === 'curveFactor' && config.curveType !== 'sCurve') { // Степень должна быть > 0
                 processedValue = Math.max(0.1, processedValue);
            }
        } else if (controlName === 'curveType') {
            const allowedCurves = ['linear', 'exponential', 'logarithmic', 'sCurve'];
            if (!allowedCurves.includes(value)) {
                console.warn(`[App.setYAxisControl] Invalid curve value '${value}' for ${group}.${controlName}. Ignoring.`);
                if (fxChains?.updateYAxisControlsUI) fxChains.updateYAxisControlsUI(this.state.yAxisControls); // Сбросить UI
                return;
            }
        }
        // outputType не управляется из UI напрямую

        this.state.yAxisControls[group][controlName] = processedValue;

        if (group === 'effects') {
            if (synth?.updateAllActiveVoiceSendLevels) synth.updateAllActiveVoiceSendLevels();
        } else if (group === 'volume') {
            // Если нужно немедленное обновление громкости активных нот,
            // можно добавить synth.updateAllActiveVoiceMainLevels()
            if (synth?.updateAllActiveVoiceMainLevels) synth.updateAllActiveVoiceMainLevels();
        }
        // Сохранение в нативном хранилище (пока не реализовано для новой структуры)
        // TODO: Реализовать сохранение yAxisControls как единого объекта или по группам
        // bridgeFix.callBridge('setSetting', `yAxis_${group}_${controlName}`, processedValue.toString());
        console.log(`[App.setYAxisControl] ${group}.${controlName} set to ${processedValue}`);

        // === КЛЮЧЕВОЕ ИЗМЕНЕНИЕ ===
        this.state.yAxisDefinedByPreset = false; // Ручное изменение отменяет приоритет пресета/цепочки
        this._applyYAxisChangesToUIAndSynth();
        // ==========================
        console.log(`[App.setYAxisControl] ${group}.${controlName} set to ${value}. yAxisDefinedByPreset is now false.`);
    },
    // =======================================================

    async restartAudioEngine() {
        // ... (без изменений от v5) ...
        console.warn("[App] Инициирую перезапуск аудио-движка v7 (без context.close)...");
        if (this.isRestartingAudio) {
            console.warn("[App] Перезапуск аудио уже в процессе.");
            return;
        }
        this.isRestartingAudio = true;
        this.state.isAudioReady = false;

        const restartButton = (typeof topbar !== 'undefined' && topbar.buttons) ? topbar.buttons.restartAudio : null;
        const icon = restartButton ? restartButton.querySelector('.restart-icon') : null;

        if (restartButton) {
            restartButton.disabled = true;
            restartButton.classList.add('restarting');
            if (icon && icon.style.animation !== 'spinRestart 2s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards') {
                 icon.style.animation = 'spinRestart 2s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards';
            }
        }

        if (typeof synth !== 'undefined' && typeof synth.stopAllNotes === 'function') {
            synth.stopAllNotes();
        }
        if (typeof pad !== 'undefined' && typeof pad.emergencyCleanup === 'function') {
            pad.emergencyCleanup();
        }

        console.log("[App.restartAudioEngine] Освобождаю ресурсы synth...");
        if (typeof synth !== 'undefined') {
            if (synth.voices && Array.isArray(synth.voices)) {
                synth.voices.forEach((voiceData, index) => {
                    if (voiceData && voiceData.components) {
                        voiceBuilder.disposeComponents(voiceData.components);
                    }
                    if (voiceData && voiceData.fxSend) {
                        try { voiceData.fxSend.disconnect(); voiceData.fxSend.dispose(); } catch(e) { console.warn(`Ошибка dispose fxSend ${index}:`, e.message); }
                    }
                });
            }
            synth.voices = [];
            synth.voiceState = [];
            if (synth.fxBus) { try { synth.fxBus.disconnect(); synth.fxBus.dispose(); } catch (e) { console.warn("Ошибка dispose fxBus:", e.message); } }
            Object.values(synth.effects || {}).forEach((effect, i) => {
                const effectName = Object.keys(synth.effects)[i] || 'unknown_effect';
                if (effect) {
                    if (typeof effect.disconnect === 'function') { try { effect.disconnect(); } catch (e) {} }
                    if (typeof effect.dispose === 'function') { try { effect.dispose(); } catch (e) { console.warn(`Ошибка dispose эффекта ${effectName}:`, e.message); } }
                }
            });
            synth.effects = {};
            if (synth.masterVolume) { try { synth.masterVolume.disconnect(); synth.masterVolume.dispose(); } catch (e) { console.warn("Ошибка dispose masterVolume:", e.message); } }
            if (synth.limiter) { try { synth.limiter.disconnect(); synth.limiter.dispose(); } catch (e) { console.warn("Ошибка dispose limiter:", e.message); } }
            if (synth.analyser) { try { synth.analyser.disconnect(); synth.analyser.dispose(); } catch (e) { console.warn("Ошибка dispose analyser:", e.message); } }
            synth.isReady = false;
            console.log("[App.restartAudioEngine] Ресурсы synth освобождены.");
        }

        console.log("[App.restartAudioEngine] Пропускаем явное закрытие контекста. Текущее состояние (если есть):", Tone?.context?.state);

        console.log("[App.restartAudioEngine] Попытка запустить/возобновить аудиоконтекст Tone.js...");
        try {
            if (Tone && Tone.context && Tone.context.state === 'closed') {
                console.warn("[App.restartAudioEngine] Контекст Tone.js был 'closed'. Устанавливаю новый.");
                Tone.setContext(new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive', sampleRate: 48000 }));
                console.log("[App.restartAudioEngine] Новый контекст установлен. Его состояние:", Tone.context.state);
            }

            await Tone.start();

            if (Tone.context.state === 'running') {
                this.state.isAudioReady = true;
                console.log("[App.restartAudioEngine] Аудиоконтекст успешно ЗАПУЩЕН/ВОЗОБНОВЛЕН. Состояние:", Tone.context.state);
            } else {
                console.warn(`[App.restartAudioEngine] Контекст после Tone.start() в состоянии: ${Tone.context.state}. Попытка дополнительного resume...`);
                if (Tone.context && typeof Tone.context.resume === 'function') {
                    await Tone.context.resume();
                }
                if (Tone.context.state === 'running') {
                    this.state.isAudioReady = true;
                    console.log("[App.restartAudioEngine] Аудиоконтекст успешно ВОЗОБНОВЛЕН после явного resume. Состояние:", Tone.context.state);
                } else {
                    throw new Error(`Аудиоконтекст не в состоянии 'running' (${Tone.context.state}) после всех попыток.`);
                }
            }
        } catch (e) {
            console.error("[App.restartAudioEngine] КРИТИЧЕСКАЯ ОШИБКА: Не удалось создать или запустить/возобновить аудиоконтекст:", e, e.stack);
            if (i18n) alert(i18n.translate('error_audio_fatal_restart', 'Fatal audio error. Please restart the app.'));
            if (restartButton) {
                restartButton.disabled = false;
                restartButton.classList.remove('restarting');
                if (icon) icon.style.animation = 'none';
            }
            this.isRestartingAudio = false;
            return;
        }

        console.log("[App.restartAudioEngine] Переинициализирую synth и visualizer...");
        try {
            if (typeof synth !== 'undefined' && typeof synth.init === 'function') {
                synth.init();
                if(synth.isReady) synth.applyMasterVolumeSettings();
            }
            if (typeof visualizer !== 'undefined' && typeof visualizer.init === 'function') {
                await visualizer.init(document.getElementById('xy-visualizer'));
            }
        } catch (e) {
            console.error("[App.restartAudioEngine] Ошибка при переинициализации synth/visualizer:", e);
        }

        console.log("[App.restartAudioEngine] Повторно применяю настройки...");
        try {
            await this.applySoundPreset(this.state.soundPreset);
            await this.applyFxChain(this.state.fxChain); // Это обновит YAxis из цепочки
            await this.applyVisualizer(this.state.visualizer);
            await this.applyTouchEffect(this.state.touchEffect);

            if (typeof fxChains !== 'undefined') {
                // YAxisControlsUI уже должен быть обновлен через applyFxChain
                // fxChains.updateYAxisControlsUI(this.state.yAxisControls);
                if (typeof fxChains.updateMasterOutputControlsUI === 'function') {
                    fxChains.updateMasterOutputControlsUI(this.state.masterVolumeCeiling);
                }
                if (fxChains.updateMacroKnobsFromChain) {
                     const chainModule = this.state.fxChain ? await moduleManager.getModule(this.state.fxChain) : null;
                     fxChains.updateMacroKnobsFromChain(chainModule?.data?.data || null);
                }
            }
        } catch (e) {
            console.error("[App.restartAudioEngine] Ошибка при повторном применении настроек:", e);
        }

        const animationDuration = (restartButton && icon) ? 2000 : 50;
        setTimeout(() => {
            if (restartButton) {
                restartButton.disabled = false;
                restartButton.classList.remove('restarting');
                if (icon) icon.style.animation = 'none';
            }
            this.isRestartingAudio = false;
            console.log("[App.restartAudioEngine] Перезапуск аудио-движка полностью завершен. isAudioReady:", this.state.isAudioReady);
        }, animationDuration);

        if (typeof i18n !== 'undefined' && i18n.loadLanguage) {
             await i18n.loadLanguage(this.state.language);
        }
    },
    async triggerFullReload() {
        // ... (без изменений от v5) ...
        console.warn("[App] Запрос на ПОЛНУЮ ПЕРЕЗАГРУЗКУ приложения (WebView reload)...");

        const reloadButton = (typeof topbar !== 'undefined' && topbar.buttons) ? topbar.buttons.reloadApp : null;
        const icon = reloadButton ? reloadButton.querySelector('.restart-icon') : null;

        if (reloadButton) {
            reloadButton.disabled = true;
            reloadButton.classList.add('reloading');
            if (icon && icon.style.animation !== 'spinReload 2s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards') {
                 icon.style.animation = 'spinReload 2s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards';
            }
        }

        try {
            if (window.PrismtoneBridge && typeof window.PrismtoneBridge.reloadWebView === 'function') {
                console.log("[App.triggerFullReload] Вызов PrismtoneBridge.reloadWebView()...");
                bridgeFix.callBridge('reloadWebView');
            } else {
                console.error("[App.triggerFullReload] Функция PrismtoneBridge.reloadWebView не найдена!");
                alert("Error: Cannot perform a full reload. Bridge function missing.");
                if (reloadButton) {
                    reloadButton.disabled = false;
                    reloadButton.classList.remove('reloading');
                    if (icon) icon.style.animation = 'none';
                }
            }
        } catch (error) {
            console.error("[App.triggerFullReload] Ошибка при вызове bridge.reloadWebView:", error);
            alert("Error during full reload attempt. Check console.");
            if (reloadButton) {
                reloadButton.disabled = false;
                reloadButton.classList.remove('reloading');
                if (icon) icon.style.animation = 'none';
            }
        }
    },
    /**
     * Устанавливает текущую тонику приложения.
     * @param {string} noteName - Название ноты (например, "C4", "G#5").
     */
    async setTonic(noteName) {
        if (!this.state.isInitialized || !noteName || this.state.currentTonic === noteName) {
            // Если тоника не изменилась, но updateZones все равно нужен (например, после смены режима пэда)
            if (this.state.currentTonic === noteName && PadModeManager && typeof this.updateZones === 'function') {
                console.log(`[App.setTonic] Tonic ${noteName} already active, but forcing zone update.`);
                await this.updateZones(); // Это может быть избыточным, т.к. PadModeManager сделает это
            }
            return;
        }
        console.log(`[App] Current tonic will be set to: ${noteName}`);
        this.state.currentTonic = noteName;

        if (PadModeManager) {
            await PadModeManager.onTonicChanged(this.state.currentTonic); // PadModeManager вызовет app.updateZones()
        } else {
            console.warn("[App.setTonic] PadModeManager not available, calling updateZones directly.");
            await this.updateZones();
        }
        bridgeFix.callBridge('setSetting', 'currentTonic', this.state.currentTonic)
            .catch(err => console.error("[App.setTonic] Bridge setSetting currentTonic failed:", err));

        if (pad && typeof pad.highlightTonic === "function") {
            pad.highlightTonic(this.state.currentTonic); // Для немедленной подсветки, если pad это делает
        }
        // Обновляем UI панели тональности
        if (sidePanel && typeof sidePanel.updateTonalityControls === 'function') {
            sidePanel.updateTonalityControls(this.state.octaveOffset, this.state.scale, this.state.zoneCount);
        }
    },

    // Добавьте или найдите существующий метод для переключения highlightSharpsFlats
    async toggleHighlightSharpsFlats(enabled) {
        if (typeof enabled !== 'boolean') {
            console.warn('[App] setHighlightSharpsFlats: invalid type for enabled -', typeof enabled);
            return;
        }
        if (this.state.highlightSharpsFlats === enabled) {
            console.log('[App] setHighlightSharpsFlats: no change, already', enabled);
            return;
        }
        this.state.highlightSharpsFlats = enabled;
        console.log('[App] highlightSharpsFlats state updated to:', this.state.highlightSharpsFlats);
        await this.updateZoneLayout();
        // bridgeFix.callBridge('setSetting', 'highlightSharpsFlats', enabled.toString())
        //    .catch(err => console.error("[App] Bridge setSetting highlightSharpsFlats failed:", err));
        this._updateSidePanelSettingsUI();
    },

    // === НОВЫЙ МЕТОД для Установки Аккорда ===
    async setCurrentChord(chordName) {
        const newChord = chordName || null; // null, если сбрасываем аккорд
        if (this.state.currentChordName === newChord) {
            if (PadModeManager && typeof this.updateZones === 'function') {
                 console.log(`[App.setCurrentChord] Chord ${newChord} already active/null, but forcing zone update for current mode.`);
                 await this.updateZones();
            }
            return;
        }
        console.log(`[App] Current chord will be set to: ${newChord}`);
        this.state.currentChordName = newChord;

        if (PadModeManager) {
            await PadModeManager.onChordChanged(this.state.currentChordName);
        } else {
            console.warn("[App.setCurrentChord] PadModeManager not available, calling updateZones directly.");
            await this.updateZones();
        }
        bridgeFix.callBridge('setSetting', 'currentChord', this.state.currentChordName) // Предполагаем, что мост может сохранить null
             .catch(err => console.error("[App.setCurrentChord] Bridge setSetting currentChord failed:", err));

        // TODO: Обновить UI панели аккордов, если она есть и отображает текущий аккорд
        // if (chordPanel && typeof chordPanel.updateCurrentChordDisplay === 'function') {
        //     chordPanel.updateCurrentChordDisplay(this.state.currentChordName);
        // }
    },
    // ======================================

    async setPadMode(modeId, initialLoad = false) {
        if (!modeId || (!initialLoad && this.state.padMode === modeId)) {
            if (this.state.padMode === modeId && !initialLoad) {
                 console.log(`[App.setPadMode] Mode ${modeId} already active. Forcing UI updates for specific controls.`);
                 if (sidePanel?.populatePadModeSelectDisplay) sidePanel.populatePadModeSelectDisplay();
                 if (sidePanel?.displayModeSpecificControls) sidePanel.displayModeSpecificControls(modeId);
            }
            return;
        }
        console.log(`[App.setPadMode] Setting pad mode to: ${modeId}`);
        if (PadModeManager && await PadModeManager.setActiveMode(modeId)) {
            this.state.padMode = modeId;
            bridgeFix.callBridge('setSetting', 'padMode', modeId)
                .catch(err => console.error("[App.setPadMode] Bridge setSetting padMode failed:", err));
            if (sidePanel?.populatePadModeSelectDisplay) sidePanel.populatePadModeSelectDisplay();
            if (sidePanel?.displayModeSpecificControls) sidePanel.displayModeSpecificControls(modeId);
            await this.updateZoneLayout();
        } else {
            console.error(`[App] Failed to set pad mode: ${modeId}. Strategy not found or error.`);
            if (sidePanel?.populatePadModeSelectDisplay) sidePanel.populatePadModeSelectDisplay();
            if (sidePanel?.displayModeSpecificControls) sidePanel.displayModeSpecificControls(this.state.padMode);
        }
        this.updateRocketStatusPanel();
    },
    
    _updateSidePanelSettingsUI() {
        if (sidePanel && typeof sidePanel.updateSettingsControls === 'function') {
            sidePanel.updateSettingsControls(
                this.state.language, this.state.theme, this.state.visualizer,
                this.state.touchEffect, this.state.showNoteNames, this.state.showLines,
                this.state.enablePolyphonyVolumeScaling, this.state.highlightSharpsFlats,
                this.state.padMode, // Передаем текущий режим
                this.state.rocketModeSettings
            );
             // Убедимся, что текстовое поле режима пэда также обновлено
            if (sidePanel.populatePadModeSelectDisplay) {
                sidePanel.populatePadModeSelectDisplay();
            }
        }
    },

    setModeSpecificSetting(modeId, settingName, value) {
        if (modeId === 'rocket' && this.state.rocketModeSettings) {
            let changed = false;
            let actualSettingObject = this.state.rocketModeSettings;
            let actualKey = settingName;
            if (settingName.startsWith("displayMarkers.")) {
                actualKey = settingName.split('.')[1];
                if (!this.state.rocketModeSettings.displayMarkers) {
                    this.state.rocketModeSettings.displayMarkers = {};
                }
                actualSettingObject = this.state.rocketModeSettings.displayMarkers;
            }
            // Аналогично можно добавить для phaseDurations, если потребуется
            if (actualSettingObject.hasOwnProperty(actualKey)) {
                if (actualSettingObject[actualKey] !== value) {
                    actualSettingObject[actualKey] = value;
                    changed = true;
                }
            } else {
                actualSettingObject[actualKey] = value;
                changed = true;
            }
            if (changed) {
                console.log(`[App] Rocket Mode setting '${settingName}' (maps to '${actualKey}') updated to:`, value);
                console.log(`[App] app.state.rocketModeSettings NOW:`, JSON.parse(JSON.stringify(this.state.rocketModeSettings)));
                const currentStrategy = PadModeManager.getCurrentStrategy();
                if (currentStrategy && currentStrategy.getName() === 'rocket' && typeof currentStrategy.updateInternalSetting === 'function') {
                    currentStrategy.updateInternalSetting(settingName, value);
                }
                const visualControls = ['markerStyle', 'highlightActiveNotes', 'showDirectionalMarkers', 'displayMarkers.active', 'displayMarkers.functional', 'displayMarkers.inKeyOnly', 'displayFunctionNames', 'animateMarkerFadeOut', 'visualTheme'];
                const logicControls = ['markerLogicMode', 'rocketSubMode', 'tonalTonic', 'harmonicKey', 'intensity', 'autoPhases', 'phaseTransitionMode', 'chordHistoryDepth', 'phaseDurations.ignition', 'phaseDurations.liftOff', 'phaseDurations.burst'];
                if (this.state.padMode === 'rocket') {
                    if (logicControls.includes(settingName) || settingName.startsWith('phaseDurations.')) {
                        if (currentStrategy && typeof currentStrategy._analyzeAndUpdateMarkers === 'function') {
                            console.log(`[App.setModeSpecificSetting] Logic control '${settingName}' changed, triggering _analyzeAndUpdateMarkers.`);
                            currentStrategy._analyzeAndUpdateMarkers();
                        }
                    } else if (visualControls.includes(settingName) || settingName.startsWith('displayMarkers.')) {
                        console.log(`[App.setModeSpecificSetting] Visual control '${settingName}' changed, triggering updateZoneVisuals.`);
                        this.updateZoneVisuals();
                    }
                }
                this.saveAppSettingsDebounced();
            }
        } else {
            console.warn(`[App] Unknown mode or setting for setModeSpecificSetting: ${modeId}.${settingName}`);
        }
    },

    saveAppSettingsDebounced: (() => {
        let timeout = null;
        return function() {
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                try {
                    localStorage.setItem('rocketModeSettings', JSON.stringify(this.state.rocketModeSettings));
                    // bridgeFix.callBridge('setSetting', 'rocketModeSettings', JSON.stringify(this.state.rocketModeSettings));
                    console.log('[App] Saved rocketModeSettings:', this.state.rocketModeSettings);
                } catch(e) { console.error('[App] Failed to save rocketModeSettings:', e); }
            }, 300);
        };
    })(),

    setRocketPhase(newPhase) {
        const validPhases = ['ignition', 'lift-off', 'burst'];
        if (this.state.rocketModePhase === newPhase || !validPhases.includes(newPhase)) return;
        console.log(`[App.setRocketPhase] Transitioning to phase: ${newPhase}`);
        this.state.rocketModePhase = newPhase;
        this.state.rocketModeCurrentPhaseStartTime = performance.now();
        this.state.rocketModeCurrentPhaseActivityCounter = 0;
        // Можно сбросить/установить энергию по фазе
        // this.state.rocketModeEnergy = newPhase === 'burst' ? 1 : 0;
        if (typeof synth !== 'undefined' && typeof synth.setRocketModePhase === 'function') {
            synth.setRocketModePhase(newPhase);
        }
        const currentStrategy = PadModeManager.getCurrentStrategy && PadModeManager.getCurrentStrategy();
        if (currentStrategy && currentStrategy.getName && currentStrategy.getName() === 'rocket' && typeof currentStrategy.onPhaseChanged === 'function') {
            currentStrategy.onPhaseChanged(newPhase);
        }
        // Можно обновить UI, если есть
        this.updateRocketStatusPanel();
    },
    manualSetRocketPhase(phaseName) {
        if (this.state.padMode !== 'rocket') return;
        if (this.state.rocketModeSettings.autoPhases && this.state.rocketModeSettings.phaseTransitionMode !== 'manual') {
            console.warn("[App.manualSetRocketPhase] Auto-phases enabled, manual transition might be overridden.");
        }
        this.setRocketPhase(phaseName);
    },
    updateRocketStatusPanel() {
        if (!this.elements.rocketStatusPanel || !this.state.isInitialized) return;
        const isRocketActive = this.state.padMode === 'rocket';
        this.elements.rocketStatusPanel.classList.toggle('rocket-status-panel-hidden', !isRocketActive);
        if (!isRocketActive) return;
        try {
            if (this.elements.statusCurrentChord) {
                // Удаляем select для chordBehavior, если был
                const oldSelect = this.elements.rocketStatusPanel.querySelector('#rocket-chord-behavior-select');
                if (oldSelect) oldSelect.remove();
                this.elements.statusCurrentChord.textContent = this.state.currentChordName || (typeof i18n !== 'undefined' ? i18n.translate('status_na', 'N/A') : 'N/A');
            }
            if (this.elements.statusCurrentKey) {
                // Удаляем select для keyBehavior, если был
                const oldSelect = this.elements.rocketStatusPanel.querySelector('#rocket-key-behavior-select');
                if (oldSelect) oldSelect.remove();
                const tonicNoteDetails = MusicTheoryService.getNoteDetails(this.state.currentTonic);
                const tonicDisplay = tonicNoteDetails ? (tonicNoteDetails.pc + tonicNoteDetails.oct) : this.state.currentTonic;
                const scaleDisplay = (typeof i18n !== 'undefined') ? i18n.translate(this.state.scale, this.state.scale) : this.state.scale;
                this.elements.statusCurrentKey.textContent = `${tonicDisplay} ${scaleDisplay}`;
            }
            if (this.elements.statusNextSuggestions) {
                // Удаляем select для nextSuggestionType, если был
                const oldSelect = this.elements.rocketStatusPanel.querySelector('#rocket-next-type-select');
                if (oldSelect) oldSelect.remove();
                const strategy = PadModeManager.getCurrentStrategy && PadModeManager.getCurrentStrategy();
                if (strategy && strategy.getName && strategy.getName() === 'rocket' && strategy._currentSuggestions && strategy._currentSuggestions.length > 0) {
                    const suggestionsText = strategy._currentSuggestions.slice(0, 2).map(sugg => {
                        if (sugg.isChord && sugg.targetChordSymbol) return sugg.targetChordSymbol;
                        if (!sugg.isChord && sugg.noteName) return (typeof Tonal !== 'undefined' ? Tonal.Note.pitchClass(sugg.noteName) : sugg.noteName);
                        return '?';
                    }).join(' / ');
                    this.elements.statusNextSuggestions.textContent = suggestionsText || '-';
                } else {
                    this.elements.statusNextSuggestions.textContent = '-';
                }
            }
            if (this.elements.statusEnergyLevel) {
                // Удаляем toggle для energyAffectsHints, если был
                const oldToggle = this.elements.rocketStatusPanel.querySelector('#rocket-energy-affects-toggle');
                if (oldToggle) {
                    const label = oldToggle.nextSibling;
                    if (label && label.tagName === 'LABEL') label.remove();
                    oldToggle.remove();
                }
                const energyClamped = Math.max(0, Math.min(1, this.state.rocketModeEnergy || 0));
                const barsFilled = Math.floor(energyClamped * 5);
                const barsEmpty = 5 - barsFilled;
                this.elements.statusEnergyLevel.textContent = '▰'.repeat(barsFilled) + '▱'.repeat(barsEmpty);
            }
            if (this.elements.statusCurrentPhase) {
                // Удаляем select для phaseHintMode, если был
                const oldSelect = this.elements.rocketStatusPanel.querySelector('#rocket-phase-hint-select');
                if (oldSelect) oldSelect.remove();
                this.elements.statusCurrentPhase.textContent = (typeof i18n !== 'undefined') ? i18n.translate(`phase_${this.state.rocketModePhase}`, this.state.rocketModePhase) : this.state.rocketModePhase;
            }
        } catch (e) {
            console.error("[App] Error updating status panel:", e);
        }
    },
    async applyRocketPreset(presetId) {
        // ... (загрузка presetModule) ...
        if (presetModule && presetModule.data && presetModule.data.data) {
            const newSettings = presetModule.data.data;
            const baseRocketDefaults = JSON.parse(JSON.stringify(app.state.rocketModeSettings));
            this.state.rocketModeSettings = {
                ...baseRocketDefaults,
                ...newSettings,
                displayMarkers: {
                    ...(baseRocketDefaults.displayMarkers || {}),
                    ...(newSettings.displayMarkers || {})
                },
                phaseDurations: {
                    ...(baseRocketDefaults.phaseDurations || {}),
                    ...(newSettings.phaseDurations || {})
                }
            };
            const currentStrategy = PadModeManager.getCurrentStrategy();
            if (currentStrategy && currentStrategy.getName() === 'rocket' && typeof currentStrategy.updateInternalSetting === 'function') {
                currentStrategy.updateInternalSetting('all', this.state.rocketModeSettings);
            }
            if (sidePanel && typeof sidePanel.displayModeSpecificControls === 'function' && this.state.padMode === 'rocket') {
                sidePanel.displayModeSpecificControls('rocket');
            }
            if (currentStrategy && typeof currentStrategy._analyzeAndUpdateMarkers === 'function' && this.state.padMode === 'rocket') {
                await currentStrategy._analyzeAndUpdateMarkers();
            }
            this.saveAppSettingsDebounced();
            this.updateRocketStatusPanel();
            console.log("[App] Rocket Mode preset applied. New settings:", JSON.parse(JSON.stringify(this.state.rocketModeSettings)));
        }
    },

    _determineEffectiveYAxisControls: async function() {
        console.log("[App._determineYAxis] Determining effective Y-Axis controls...");
        const t0 = performance.now();

        let defaultYVolumeSettings, defaultYEffectsSettings;
        try {
            defaultYVolumeSettings = JSON.parse(JSON.stringify(window.defaultAppSettings.yAxisControls.volume));
            defaultYEffectsSettings = JSON.parse(JSON.stringify(window.defaultAppSettings.yAxisControls.effects));
        } catch (e) {
            console.error("[App._determineYAxis] CRITICAL: Failed to load/parse defaultAppSettings.yAxisControls. Using hardcoded fallbacks.", e);
            defaultYVolumeSettings = { minOutput: 0.0, maxOutput: 1.0, yThreshold: 0.0, curveType: 'linear', curveFactor: 1.0, outputType: 'gain' };
            defaultYEffectsSettings = { minOutput: -60, maxOutput: 0, yThreshold: 0.1, curveType: 'exponential', curveFactor: 2.0, outputType: 'db' };
        }

        let finalYVolume = { ...defaultYVolumeSettings };
        let finalYEffects = { ...defaultYEffectsSettings };
        let sourceOfEffectsSettings = "defaultAppSettings (initial fallback)";
        let sourceOfVolumeSettings = "defaultAppSettings (initial fallback)";

        const currentFxChainId = this.state.fxChain;
        let fxChainData = null;

        if (currentFxChainId && moduleManager) {
            const fxChainModule = await moduleManager.getModule(currentFxChainId);
            if (fxChainModule?.data?.data) {
                fxChainData = fxChainModule.data.data;
                console.log(`[App._determineYAxis] Loaded FX Chain data for '${currentFxChainId}'`);
            } else {
                console.log(`[App._determineYAxis] No data found for FX Chain ID '${currentFxChainId}'`);
            }
        }

        // --- Логика для yAxisControls.volume ---
        if (fxChainData?.yAxisControls?.volume) {
            finalYVolume = { ...defaultYVolumeSettings, ...fxChainData.yAxisControls.volume };
            sourceOfVolumeSettings = `FX Chain (${currentFxChainId})`;
        } else {
            sourceOfVolumeSettings = "defaultAppSettings (for volume)";
        }
        console.log(`[App._determineYAxis] Volume settings source: ${sourceOfVolumeSettings}`);

        // --- Логика для yAxisControls.effects (реализация приоритетов) ---
        console.log(`[App._determineYAxis] === Evaluating Y-Axis Effects ===`);
        console.log(`[App._determineYAxis] 1. FX Chain ID: '${currentFxChainId}'`);
        if (fxChainData?.yAxisControls?.effects) {
            finalYEffects = { ...defaultYEffectsSettings, ...fxChainData.yAxisControls.effects };
            sourceOfEffectsSettings = `FX Chain ('${currentFxChainId}')`;
            console.log(`[App._determineYAxis]   -> USING FX CHAIN. Data:`, JSON.parse(JSON.stringify(fxChainData.yAxisControls.effects)));
        } else {
            console.log(`[App._determineYAxis]   -> No 'effects' config in FX Chain '${currentFxChainId || 'None'}'.`);
            console.log(`[App._determineYAxis] 2. Sound Preset ID: '${this.state.soundPreset}'. Has presetYAxisEffectsConfig:`, this.state.presetYAxisEffectsConfig ? 'YES' : 'NO');
            if (this.state.presetYAxisEffectsConfig && Object.keys(this.state.presetYAxisEffectsConfig).length > 0) {
                const effectsFromPreset = { ...this.state.presetYAxisEffectsConfig };
                if (!effectsFromPreset.outputType && defaultYEffectsSettings.outputType) {
                    effectsFromPreset.outputType = defaultYEffectsSettings.outputType;
                }
                finalYEffects = { ...defaultYEffectsSettings, ...effectsFromPreset };
                sourceOfEffectsSettings = `Sound Preset ('${this.state.soundPreset}')`;
                console.log(`[App._determineYAxis]   -> USING PRESET. Data:`, JSON.parse(JSON.stringify(this.state.presetYAxisEffectsConfig)));
            } else {
                console.log(`[App._determineYAxis]   -> No valid presetYAxisEffectsConfig found.`);
                sourceOfEffectsSettings = "defaultAppSettings (for effects)";
                console.log(`[App._determineYAxis]   -> USING DEFAULT APP SETTINGS (effects).`);
            }
        }
        console.log(`[App._determineYAxis] === Final Y-Axis Effects (Source: ${sourceOfEffectsSettings}) ===:`, JSON.parse(JSON.stringify(finalYEffects)));

        let volumeChanged = false;
        if (JSON.stringify(this.state.yAxisControls.volume) !== JSON.stringify(finalYVolume)) {
            this.state.yAxisControls.volume = { ...finalYVolume };
            volumeChanged = true;
        }

        let effectsChanged = false;
        if (JSON.stringify(this.state.yAxisControls.effects) !== JSON.stringify(finalYEffects)) {
            this.state.yAxisControls.effects = { ...finalYEffects };
            effectsChanged = true;
        }

        if (volumeChanged) {
            console.log('[App._determineYAxis] Volume settings updated in app.state:', JSON.parse(JSON.stringify(this.state.yAxisControls.volume)));
            if (synth?.updateAllActiveVoiceMainLevels) synth.updateAllActiveVoiceMainLevels();
            if (this.state.isInitialized && this.state.isBridgeReady) {
                bridgeFix.callBridge('setYAxisControlGroup', 'volume', JSON.stringify(this.state.yAxisControls.volume))
                    .catch(err => console.error("[App._determineYAxis] Bridge setYAxisControlGroup 'volume' failed:", err));
            }
        }

        if (effectsChanged) {
            console.log('[App._determineYAxis] Effects settings updated in app.state:', JSON.parse(JSON.stringify(this.state.yAxisControls.effects)));
            if (synth?.updateAllActiveVoiceSendLevels) synth.updateAllActiveVoiceSendLevels();
            if (this.state.isInitialized && this.state.isBridgeReady) {
                bridgeFix.callBridge('setYAxisControlGroup', 'effects', JSON.stringify(this.state.yAxisControls.effects))
                    .catch(err => console.error("[App._determineYAxis] Bridge setYAxisControlGroup 'effects' failed:", err));
            }
        }

        if (fxChains?.updateYAxisControlsUI) {
            fxChains.updateYAxisControlsUI(this.state.yAxisControls);
            console.log('[App._determineYAxis] FX Chains UI updated with determined Y-Axis settings.');
        }
        const t1 = performance.now();
        console.log(`[App._determineYAxis] Duration: ${(t1-t0).toFixed(2)}ms`);
    },

    _resolveAndApplyYAxisControls(forceUpdate) {
        console.log("[App._resolveYAxis] Resolving final Y-Axis controls...");
        const defaultYSettings = JSON.parse(JSON.stringify(window.defaultAppSettings?.yAxisControls || {
            volume: { minOutput: 0.0, maxOutput: 1.0, yThreshold: 0.0, curveType: 'linear', curveFactor: 1.0, outputType: 'gain' },
            effects: { minOutput: -60, maxOutput: 0, yThreshold: 0.1, curveType: 'exponential', curveFactor: 2.0, outputType: 'db' }
        }));

        let finalVolumeY = { ...defaultYSettings.volume };
        let finalEffectsY = { ...defaultYSettings.effects };
        let sourceLog = "Defaults";

        // 1. Пресет
        const currentPresetId = this.state.soundPreset;
        const presetModule = currentPresetId ? moduleManager.moduleDataCache[currentPresetId] : null;
        const presetYControls = presetModule?.data?.data?.yAxisControls;

        if (presetYControls && typeof presetYControls === 'object') {
            if (presetYControls.volume && typeof presetYControls.volume === 'object') {
                finalVolumeY = { ...defaultYSettings.volume, ...presetYControls.volume };
                sourceLog = `Preset '${currentPresetId}' (volume)`;
            }
            if (presetYControls.effects && typeof presetYControls.effects === 'object') {
                finalEffectsY = { ...defaultYSettings.effects, ...presetYControls.effects };
                sourceLog = sourceLog === "Defaults" ? `Preset '${currentPresetId}' (effects)` : `${sourceLog} & (effects)`;
            }
            this.state.yAxisDefinedByPreset = !!(presetYControls.volume || presetYControls.effects);
            console.log(`[App._resolveYAxis] Applied from Sound Preset '${currentPresetId}'. yAxisDefinedByPreset: ${this.state.yAxisDefinedByPreset}`);
        } else {
            this.state.yAxisDefinedByPreset = false;
            console.log(`[App._resolveYAxis] No yAxisControls in Sound Preset '${currentPresetId}'. yAxisDefinedByPreset: false.`);
        }

        // 2. FX-цепочка
        if (!this.state.yAxisDefinedByPreset || (presetYControls && (!presetYControls.volume || !presetYControls.effects))) {
            const currentFxChainId = this.state.fxChain;
            const fxChainModule = currentFxChainId ? moduleManager.moduleDataCache[currentFxChainId] : null;
            const fxChainYControls = fxChainModule?.data?.data?.yAxisControls;

            if (fxChainYControls && typeof fxChainYControls === 'object') {
                if (!presetYControls?.volume && fxChainYControls.volume && typeof fxChainYControls.volume === 'object') {
                    finalVolumeY = { ...defaultYSettings.volume, ...fxChainYControls.volume };
                    sourceLog = sourceLog === "Defaults" ? `FX Chain '${currentFxChainId}' (volume)` : `${sourceLog} + FX Chain (volume)`;
                    console.log(`[App._resolveYAxis] Volume Y-Axis from FX Chain '${currentFxChainId}'.`);
                }
                if (!presetYControls?.effects && fxChainYControls.effects && typeof fxChainYControls.effects === 'object') {
                    finalEffectsY = { ...defaultYSettings.effects, ...fxChainYControls.effects };
                    sourceLog = sourceLog === "Defaults" || sourceLog.includes("Preset") && !sourceLog.includes("effects") ? `FX Chain '${currentFxChainId}' (effects)` : `${sourceLog} + FX Chain (effects)`;
                    console.log(`[App._resolveYAxis] Effects Y-Axis from FX Chain '${currentFxChainId}'.`);
                }
            } else if (currentFxChainId) {
                console.log(`[App._resolveYAxis] No yAxisControls in FX Chain '${currentFxChainId}'.`);
            }
        }
        // Применяем финальные значения к app.state
        const volumeChanged = JSON.stringify(this.state.yAxisControls.volume) !== JSON.stringify(finalVolumeY);
        const effectsChanged = JSON.stringify(this.state.yAxisControls.effects) !== JSON.stringify(finalEffectsY);

        if (volumeChanged) this.state.yAxisControls.volume = finalVolumeY;
        if (effectsChanged) this.state.yAxisControls.effects = finalEffectsY;

        console.log(`[App._resolveYAxis] Final Y-Axis source: ${sourceLog}`);
        console.log('[App._resolveYAxis] Final Y-Axis state:', JSON.parse(JSON.stringify(this.state.yAxisControls)));

        // Вызываем обновление UI и Synth, если были изменения или для гарантии
        if (volumeChanged || effectsChanged || forceUpdate === true) {
            this._applyYAxisChangesToUIAndSynth();
        }
    },

    _applyYAxisChangesToUIAndSynth() {
        if (!this.state.isInitialized) return;
        console.log('[App._applyYAxisChangesToUIAndSynth] Updating UI and Synth with final Y-Axis settings.');
        if (fxChains?.updateYAxisControlsUI) {
            fxChains.updateYAxisControlsUI(this.state.yAxisControls);
        }
        if (synth?.isReady) {
            if (synth.updateAllActiveVoiceMainLevels) synth.updateAllActiveVoiceMainLevels();
            if (synth.updateAllActiveVoiceSendLevels) synth.updateAllActiveVoiceSendLevels();
        }
        if (this.state.isBridgeReady) {
            bridgeFix.callBridge('setYAxisControlGroup', 'volume', JSON.stringify(this.state.yAxisControls.volume))
                .catch(err => console.error("[App] Bridge setYAxis (volume) failed:", err));
            bridgeFix.callBridge('setYAxisControlGroup', 'effects', JSON.stringify(this.state.yAxisControls.effects))
                .catch(err => console.error("[App] Bridge setYAxis (effects) failed:", err));
        }
    },

    updateMainDisplay(text) {
        if (!this.elements.hgMainDisplay) return;
        if (text === null || text === undefined || text === '') {
            this.elements.hgMainDisplay.innerHTML = '';
            this.elements.hgMainDisplay.style.display = 'none';
        } else {
            this.elements.hgMainDisplay.innerHTML = `<span>${text}</span>`;
            this.elements.hgMainDisplay.style.display = '';
        }
    },
    updateSubBar(htmlContent) {
        if (!this.elements.hgSubBar) return;
        if (htmlContent === null || htmlContent === undefined || htmlContent === '') {
            this.elements.hgSubBar.innerHTML = '';
            this.elements.hgSubBar.style.display = 'none';
        } else {
            this.elements.hgSubBar.innerHTML = htmlContent;
            this.elements.hgSubBar.style.display = '';
        }
    },

    setHarmonicGlideSetting: function(path, value) {
        // path: e.g. 'tonalBinding.showChordFunctions' or 'intensity'
        if (!path) return;
        const keys = path.split('.');
        let obj = app.state.harmonicGlide;
        for (let i = 0; i < keys.length - 1; i++) {
            if (!(keys[i] in obj)) obj[keys[i]] = {};
            obj = obj[keys[i]];
        }
        obj[keys[keys.length - 1]] = value;
        // Триггерим реакцию стратегии
        if (app.state.padMode === 'harmonicGlide' && PadModeManager && PadModeManager.getCurrentStrategy && typeof PadModeManager.getCurrentStrategy().onSpecificControlChanged === 'function') {
            PadModeManager.getCurrentStrategy().onSpecificControlChanged(path, value, app.state.harmonicGlide);
        }
    },
};

document.addEventListener('DOMContentLoaded', () => {
    app.init().catch(error => {
        console.error("[App v6 Global Catch] Unhandled error during app initialization:", error);
        const loadingOverlay = document.getElementById('loading-overlay');
        if (loadingOverlay) {
            const loadingTextElement = loadingOverlay.querySelector('.loading-text');
            if (loadingTextElement) {
                const errorKey = 'error_fatal_init'; const fallbackErrorMsg = 'Fatal Initialization Error.';
                const translatedError = (typeof i18n !== 'undefined' && typeof i18n.translate === 'function') ? i18n.translate(errorKey, fallbackErrorMsg) : fallbackErrorMsg;
                loadingTextElement.textContent = translatedError + ` (${error.message || 'Unknown error'})`;
                loadingTextElement.style.color = '#ff4081'; loadingTextElement.classList.remove('fade-out');
            }
            loadingOverlay.classList.remove('hidden', 'hiding'); loadingOverlay.style.opacity = '1'; loadingOverlay.style.visibility = 'visible';
            const spinner = loadingOverlay.querySelector('.loading-spinner'); if (spinner) spinner.style.display = 'none';
            const title = document.getElementById('loading-title'); const prompt = document.querySelector('.loading-prompt');
            if (title) title.classList.remove('show'); if (prompt) prompt.classList.remove('show');
        }
    });

    // === Rocket Status Panel Show/Hide ===
    const rocketStatusPanel = document.getElementById('rocket-status-panel');
    const rocketStatusHideBtn = document.getElementById('rocket-status-hide-btn');
    const rocketStatusShowBtn = document.getElementById('rocket-status-show-btn');
    if (rocketStatusHideBtn && rocketStatusPanel && rocketStatusShowBtn) {
        rocketStatusHideBtn.addEventListener('click', () => {
            rocketStatusPanel.classList.add('rocket-status-panel-hidden');
            rocketStatusShowBtn.style.display = 'block';
        });
        rocketStatusShowBtn.addEventListener('click', () => {
            rocketStatusPanel.classList.remove('rocket-status-panel-hidden');
            rocketStatusShowBtn.style.display = 'none';
        });
    }
    // === Rocket Status Panel Interactivity ===
    const statusChord = document.getElementById('status-current-chord');
    const statusKey = document.getElementById('status-current-key');
    const statusPhase = document.getElementById('status-current-phase');
    if (statusChord) {
        statusChord.addEventListener('click', () => {
            if (typeof showCustomSelectorPopover === 'function') {
                // Предполагаем, что список аккордов доступен через MusicTheoryService
                const chords = MusicTheoryService.getAvailableChordNames ? MusicTheoryService.getAvailableChordNames() : [];
                showCustomSelectorPopover({
                    type: 'chord',
                    title: i18n.translate('select_chord', 'Select Chord'),
                    itemsArray: chords.map(name => ({ id: name, name })),
                    currentValue: app.state.currentChordName,
                    onSelect: (selectedChord) => {
                        app.setCurrentChord(selectedChord);
                    }
                });
            }
        });
    }
    if (statusKey) {
        statusKey.addEventListener('click', () => {
            if (typeof showCustomSelectorPopover === 'function') {
                const tonics = MusicTheoryService.getAvailableTonicNames ? MusicTheoryService.getAvailableTonicNames() : [];
                const scales = MusicTheoryService.getAvailableScaleIds ? MusicTheoryService.getAvailableScaleIds() : [];
                showCustomSelectorPopover({
                    type: 'key',
                    title: i18n.translate('select_key', 'Select Key'),
                    itemsArray: tonics.flatMap(tonic => scales.map(scale => ({ id: tonic + ' ' + scale, name: tonic + ' ' + i18n.translate(scale, scale) }))),
                    currentValue: app.state.currentTonic + ' ' + app.state.scale,
                    onSelect: (selectedKey) => {
                        const [tonic, ...scaleArr] = selectedKey.split(' ');
                        const scale = scaleArr.join(' ');
                        app.setTonic(tonic);
                        app.setScale(scale);
                    }
                });
            }
        });
    }
    if (statusPhase) {
        statusPhase.addEventListener('click', () => {
            if (typeof showCustomSelectorPopover === 'function') {
                const phases = [
                    { id: 'ignition', name: i18n.translate('rocket_phase_ignition', 'Ignition') },
                    { id: 'lift-off', name: i18n.translate('rocket_phase_lift_off', 'Lift-off') },
                    { id: 'burst', name: i18n.translate('rocket_phase_burst', 'Burst') }
                ];
                showCustomSelectorPopover({
                    type: 'rocket_phase',
                    title: i18n.translate('select_phase', 'Select Phase'),
                    itemsArray: phases,
                    currentValue: app.state.rocketModePhase,
                    onSelect: (selectedPhase) => {
                        app.manualSetRocketPhase(selectedPhase);
                    }
                });
            }
        });
    }
});

window.app = app;

================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\harmonicMarkerEngine.js
// File: assets/js/harmonicMarkerEngine.js
// Harmonic Marker Engine - Core for musical context analysis.
// Версия для Фазы 1

console.log("[HME v1.0] harmonicMarkerEngine.js loaded");

const harmonicMarkerEngine = {
    musicTheoryServiceRef: null,
    isInitialized: false,
    _debug: true, // Флаг для подробного логирования внутри движка

    /**
     * Initializes the Harmonic Marker Engine.
     * @param {object} musicTheoryServiceInstance - Instance of MusicTheoryService.
     */
    init(musicTheoryServiceInstance) {
        if (!musicTheoryServiceInstance || typeof musicTheoryServiceInstance.getNoteDetails !== 'function') {
            console.error("[HME.init] Invalid MusicTheoryService instance provided.");
            this.isInitialized = false;
            return;
        }
        this.musicTheoryServiceRef = musicTheoryServiceInstance;
        this.isInitialized = true;
        console.log(`[HME.init] Initialized. MusicTheoryService Ready: ${this.musicTheoryServiceRef.isTonalJsLoaded}`);
    },

    /**
     * Analyzes the current musical context based on active notes and rocket mode settings.
     * @param {Array<{midiNote: number, name?: string}>} activeNotes - Array of active notes.
     *        Each note object MUST have `midiNote`. `name` is optional but preferred.
     * @param {object} analysisContext - Context from RocketModeStrategy.
     *        - tonicMidi: MIDI number of the current scale's tonic.
     *        - scaleId: ID of the current scale (e.g., "major").
     *        - settings: app.state.rocketModeSettings (для доступа к настройкам, если понадобятся).
     *        - currentPhase: текущая фаза Rocket Mode.
     * @returns {object} - Object with analysis results:
     *      {
     *          isPlayingChord: boolean,
     *          detectedChordSymbol: string | null,
     *          detectedChordDetails: object | null, // Tonal.Chord.get() object
     *          currentHarmonicFunction: string | null, // e.g., "T (I)", "D (V)"
     *          activeNotePitchClasses: Array<string>, // e.g., ["C", "E", "G"]
     *          scaleNotesPitchClasses: Array<string> | null, // e.g., ["C", "D", "E", "F", "G", "A", "B"] for C Major
     *          scaleTonicPc: string | null, // e.g., "C"
     *          isDiatonic: boolean // True if all active notes belong to the current scale
     *      }
     */
    async analyzeContext(activeNotes, analysisContext) {
        if (!this.isInitialized) {
            console.warn("[HME.analyzeContext] Not initialized. Call init() first.");
            return this._getDefaultAnalysisResult();
        }
        if (!activeNotes || !Array.isArray(activeNotes) || !analysisContext ||
            analysisContext.tonicMidi === undefined || !analysisContext.scaleId) {
            console.warn("[HME.analyzeContext] Invalid arguments. activeNotes:", activeNotes, "analysisContext:", analysisContext);
            return this._getDefaultAnalysisResult();
        }

        if (this._debug) {
            console.log(`[HME.analyzeContext] INPUT - Active Notes (count: ${activeNotes.length}):`, JSON.parse(JSON.stringify(activeNotes.map(n => n.midiNote))));
            console.log(`[HME.analyzeContext] INPUT - Context: Tonic MIDI=${analysisContext.tonicMidi}, Scale=${analysisContext.scaleId}`);
        }

        const result = this._getDefaultAnalysisResult();

        // 1. Получаем детали активных нот и их pitch classes
        const activeNoteDetails = activeNotes
            .map(note => {
                // Если имя не передано, получаем его из MIDI
                const name = note.name || this.musicTheoryServiceRef.midiToNoteName(note.midiNote);
                return this.musicTheoryServiceRef.getNoteDetails(name); // getNoteDetails может принять и MIDI
            })
            .filter(Boolean); // Убираем null, если getNoteDetails не смог определить ноту

        if (activeNoteDetails.length === 0 && activeNotes.length > 0) {
            console.warn("[HME.analyzeContext] No valid note details could be derived from activeNotes.");
            // Возвращаем дефолтный результат, если не удалось получить детали ни для одной ноты
            return result;
        }

        result.activeNotePitchClasses = activeNoteDetails.map(detail => detail.pc).sort();
        if (this._debug) console.log("[HME.analyzeContext] Active Pitch Classes:", result.activeNotePitchClasses);

        // 2. Определяем аккорд, если нот достаточно
        if (result.activeNotePitchClasses.length >= 2) { // Минимум 2 ноты для попытки определения аккорда
            if (this.musicTheoryServiceRef._TonalChord && typeof this.musicTheoryServiceRef._TonalChord.detect === 'function') {
                const possibleChords = this.musicTheoryServiceRef._TonalChord.detect(result.activeNotePitchClasses);
                if (this._debug) console.log("[HME.analyzeContext] Tonal.Chord.detect found:", possibleChords);

                if (possibleChords && possibleChords.length > 0) {
                    // Выбираем "лучший" аккорд (самый простой или первый из списка)
                    result.detectedChordSymbol = possibleChords.sort((a, b) => a.length - b.length)[0];

                    if (result.detectedChordSymbol) {
                        try {
                            result.detectedChordDetails = this.musicTheoryServiceRef._TonalChord.get(result.detectedChordSymbol);
                            result.isPlayingChord = !result.detectedChordDetails.empty;
                            if (this._debug) console.log(`[HME.analyzeContext] Detected Chord: ${result.detectedChordSymbol}, Is Playing Chord: ${result.isPlayingChord}, Details:`, result.detectedChordDetails);
                        } catch (e) {
                            console.warn(`[HME.analyzeContext] Error getting chord details for ${result.detectedChordSymbol}:`, e);
                            result.detectedChordSymbol = null;
                            result.detectedChordDetails = null;
                            result.isPlayingChord = false;
                        }
                    }
                }
            } else {
                console.warn("[HME.analyzeContext] Tonal.Chord or Tonal.Chord.detect is not available.");
            }
        } else if (result.activeNotePitchClasses.length === 1) {
            result.isPlayingChord = false; // Одна нота - не аккорд
            if (this._debug) console.log("[HME.analyzeContext] Single active note. Not a chord.");
        }

        // 3. Анализ в контексте тональности и лада
        const tonicNoteDetails = this.musicTheoryServiceRef.getNoteDetails(analysisContext.tonicMidi);
        if (tonicNoteDetails) {
            result.scaleTonicPc = tonicNoteDetails.pc;
            if (result.scaleTonicPc && analysisContext.scaleId) {
                try {
                    // Используем MusicTheoryService для получения нот лада ОТНОСИТЕЛЬНО ТОНИКИ ЛАДА
                    // scaleId здесь - это тип лада, например, "major", "blues"
                    // tonicNoteDetails.name - это полная нота тоники с октавой, например "C4"
                    const scaleNotesDetails = await this.musicTheoryServiceRef.getNotesForScale(
                        tonicNoteDetails.name, // Передаем имя тоники с октавой
                        analysisContext.scaleId,
                        0, // octavesToScanBefore - достаточно 0 для получения базового набора pc
                        0  // octavesToScanAfter - достаточно 0 для получения базового набора pc
                    );
                    if (scaleNotesDetails && scaleNotesDetails.length > 0) {
                        result.scaleNotesPitchClasses = scaleNotesDetails.map(n => n.pc);
                        if (this._debug) console.log(`[HME.analyzeContext] Scale Notes PCs from MTS for ${tonicNoteDetails.name} ${analysisContext.scaleId}:`, result.scaleNotesPitchClasses);
                        // Теперь логика isDiatonic и currentHarmonicFunction должна работать с этим
                        if (result.activeNotePitchClasses.length > 0) {
                            result.isDiatonic = result.activeNotePitchClasses.every(pc => result.scaleNotesPitchClasses.includes(pc));
                        } else {
                            result.isDiatonic = true;
                        }
                        if (result.isPlayingChord && result.detectedChordDetails?.tonic) {
                            result.currentHarmonicFunction = this._getChordHarmonicFunction(result.detectedChordDetails, result.scaleTonicPc, result.scaleNotesPitchClasses, analysisContext);
                        } else if (result.activeNotePitchClasses.length === 1) {
                            result.currentHarmonicFunction = this._getNoteHarmonicFunction(result.activeNotePitchClasses[0], result.scaleTonicPc, result.scaleNotesPitchClasses);
                        }
                        if (this._debug) console.log("[HME.analyzeContext] Current Harmonic Function (after fix):", result.currentHarmonicFunction);
                    } else {
                        console.warn(`[HME.analyzeContext] Could not get scale notes from MTS for ${tonicNoteDetails.name} ${analysisContext.scaleId}. Analysis will be limited.`);
                        result.scaleNotesPitchClasses = null; // Явно указываем, что ноты лада неизвестны
                        result.isDiatonic = false;
                        result.currentHarmonicFunction = null;
                    }
                } catch (e) {
                    console.warn(`[HME.analyzeContext] Error in getNotesForScale:`, e);
                    result.scaleNotesPitchClasses = null;
                    result.isDiatonic = false;
                    result.currentHarmonicFunction = null;
                }
            } else {
                console.warn(`[HME.analyzeContext] Tonic details or scaleId missing. scaleTonicPc: ${result.scaleTonicPc}, scaleId: ${analysisContext.scaleId}`);
            }
        } else {
            console.warn(`[HME.analyzeContext] Could not get details for tonic MIDI: ${analysisContext.tonicMidi}`);
        }
        if (this._debug) console.log("[HME.analyzeContext] OUTPUT - Analysis Result:", JSON.parse(JSON.stringify(result)));
        return result;
    },

    /**
     * Возвращает объект с дефолтными значениями для результата анализа.
     */
    _getDefaultAnalysisResult() {
        return {
            isPlayingChord: false,
            detectedChordSymbol: null,
            detectedChordDetails: null,
            currentHarmonicFunction: null,
            activeNotePitchClasses: [],
            scaleNotesPitchClasses: null,
            scaleTonicPc: null,
            isDiatonic: false
        };
    },

    /**
     * Определяет гармоническую функцию аккорда в контексте лада.
     * (Копипаста из вашего плана Фазы 1, с небольшими адаптациями и проверками)
     */
    _getChordHarmonicFunction(chordDetails, scaleTonicPc, scaleNotesPc, analysisContext) {
        if (!this.isInitialized || !chordDetails || !chordDetails.tonic || !scaleTonicPc || !scaleNotesPc ||
            !this.musicTheoryServiceRef._TonalNote || !this.musicTheoryServiceRef._TonalInterval || !this.musicTheoryServiceRef._TonalRomanNumeral) {
            if (this._debug) console.warn("[HME._getChordHarmonicFunction] Missing dependencies or invalid args.");
            return null;
        }

        try {
            const chordRootPc = this.musicTheoryServiceRef._TonalNote.simplify(chordDetails.tonic);
            // Интервал от тоники лада до корня аккорда
            const intervalFromScaleTonic = this.musicTheoryServiceRef._TonalInterval.between(scaleTonicPc, chordRootPc);

            if (!intervalFromScaleTonic) {
                // Попытка найти первую диатоническую ноту в аккорде, если корень не в ладу
                const firstDiatonicNoteInChord = chordDetails.notes.find(notePc =>
                    scaleNotesPc.includes(this.musicTheoryServiceRef._TonalNote.simplify(notePc))
                );
                if (firstDiatonicNoteInChord) {
                    const degreeIndex = scaleNotesPc.indexOf(this.musicTheoryServiceRef._TonalNote.simplify(firstDiatonicNoteInChord));
                    return `Variant (contains ${this._degreeToRoman(degreeIndex + 1)})`;
                }
                return "Non-Diatonic";
            }

            // Пытаемся получить римскую цифру
            // Tonal.RomanNumeral.get() ожидает интервал ИЛИ имя ступени (1, 2, #2, b3...)
            // Мы будем использовать имя ступени, полученное из интервала
            const stepName = this.musicTheoryServiceRef._TonalInterval.num(intervalFromScaleTonic) + (this.musicTheoryServiceRef._TonalInterval.alt(intervalFromScaleTonic) || '');

            let chordTypeForRoman = ""; // Tonal.RomanNumeral.get не всегда хорошо работает с полным типом
            const type = chordDetails.type.toLowerCase();
                 if (type.includes("maj7")) chordTypeForRoman = "M7"; // M7 для major seventh
            else if (type.includes("m7")) chordTypeForRoman = "m7";   // m7 для minor seventh
            else if (type.includes("7")) chordTypeForRoman = "7";     // 7 для dominant seventh
            else if (type.includes("m")) chordTypeForRoman = "m";
            else if (type.includes("dim")) chordTypeForRoman = "dim"; // или °
            else if (type.includes("aug")) chordTypeForRoman = "aug"; // или +

            // Tonal.RomanNumeral.get (в Tonal.js > 4.x) может не иметь .get()
            // Вместо этого, Tonal.Degree.romanNumeral(degree, isMajor)
            // Или Tonal.Chord.romanNumeral(chordSymbol, keySignature, isMajor)
            // Пока оставим упрощенный вариант, который может потребовать доработки
            // в зависимости от точной версии Tonal.js и ее API.
            // Попробуем через Tonal.Chord.romanNumeral, если доступно
            let romanNumeralString = null;
            if(this.musicTheoryServiceRef._TonalChord && typeof this.musicTheoryServiceRef._TonalChord.romanNumeral === 'function') {
                try {
                    // Пытаемся определить, мажорный ли лад
                    const isMajorScale = analysisContext.scaleId.toLowerCase().includes("major") || analysisContext.scaleId.toLowerCase().includes("lydian") || analysisContext.scaleId.toLowerCase().includes("mixolydian");
                    romanNumeralString = this.musicTheoryServiceRef._TonalChord.romanNumeral(chordDetails.symbol, scaleTonicPc, isMajorScale).name;
                } catch(e) { /* ignore, try fallback */ }
            }

            if (!romanNumeralString) { // Fallback, если Tonal.Chord.romanNumeral не сработал или недоступен
                romanNumeralString = this._degreeToRoman(this.musicTheoryServiceRef._TonalInterval.num(intervalFromScaleTonic)) + chordTypeForRoman;
            }

            // Преобразование римской цифры в основную функцию (T, S, D)
            const degreeNum = this.musicTheoryServiceRef._TonalInterval.num(intervalFromScaleTonic);
            switch (degreeNum) {
                case 1: return `T (${romanNumeralString})`;
                case 4: return `S (${romanNumeralString})`;
                case 5: return `D (${romanNumeralString})`;
                case 2: return `Sp (${romanNumeralString})`; // Subdominant Parallel / Supertonic
                case 6: return `Tp (${romanNumeralString})`; // Tonic Parallel / Submediant
                case 3: return `Tx (${romanNumeralString})`; // Mediant (может быть T или D в зависимости от контекста)
                case 7: return `L (${romanNumeralString})`;  // Leading Tone (часть D)
                default: return romanNumeralString || "Unknown";
            }

        } catch (e) {
            console.error("[HME._getChordHarmonicFunction] Error:", e);
            // Фоллбэк на простую ступень, если что-то пошло не так
            const degreeIndex = scaleNotesPc.indexOf(this.musicTheoryServiceRef._TonalNote.simplify(chordDetails.tonic));
            if (degreeIndex !== -1) return this._degreeToFunction(degreeIndex + 1, chordDetails.type || "chord");
            return "Unknown Chord Function";
        }
    },

    /**
     * Определяет гармоническую функцию одиночной ноты в контексте лада.
     */
    _getNoteHarmonicFunction(notePc, scaleTonicPc, scaleNotesPc) {
        if (!this.isInitialized || !notePc || !scaleTonicPc || !scaleNotesPc ||
            !this.musicTheoryServiceRef._TonalNote) {
            if (this._debug) console.warn("[HME._getNoteHarmonicFunction] Missing dependencies or invalid args.");
            return null;
        }
        const simplifiedNotePc = this.musicTheoryServiceRef._TonalNote.simplify(notePc);
        const degreeIndex = scaleNotesPc.indexOf(simplifiedNotePc);
        if (degreeIndex !== -1) {
            return this._degreeToFunction(degreeIndex + 1, "note");
        }
        return "Chromatic Note";
    },

    /**
     * Преобразует номер ступени (1-7) в римскую цифру.
     */
    _degreeToRoman(degree) {
        const numerals = ["I", "II", "III", "IV", "V", "VI", "VII"];
        return numerals[degree - 1] || degree.toString();
    },

    /**
     * Преобразует номер ступени и тип аккорда/ноты в метку гармонической функции.
     */
    _degreeToFunction(degree, chordTypeOrNote = "note") {
        const roman = this._degreeToRoman(degree);
        let quality = "";
        // Определение качества аккорда (мажор, минор, и т.д.)
        if (chordTypeOrNote !== "note" && typeof chordTypeOrNote === 'string') {
            const type = chordTypeOrNote.toLowerCase();
                 if (type.includes("major") || type.match(/^M/) || type === "") quality = "";  // Пусто для мажора
            else if (type.includes("minor") || type.match(/^m[^a]/)) quality = "m";
            else if (type.includes("dim")) quality = "°";
            else if (type.includes("aug")) quality = "+";
            // Добавление септаккордов
                 if (type.includes("maj7")) quality = "maj7"; // Major 7th
            else if (type.includes("m7") && !type.includes("maj7")) quality = "m7"; // Minor 7th
            else if (type.includes("7") && !type.includes("maj7") && !type.includes("m7")) quality = "7"; // Dominant 7th
            // Другие типы септаккордов можно добавить по аналогии (m7b5, dim7, etc.)
        }

        // Определение основной функции по ступени
        switch (degree) {
            case 1: return `T (${roman}${quality})`;  // Тоника
            case 4: return `S (${roman}${quality})`;  // Субдоминанта
            case 5: return `D (${roman}${quality})`;  // Доминанта
            case 2: return `Sp (${roman}${quality})`; // Субдоминантовая параллель / Супертоника
            case 6: return `Tp (${roman}${quality})`; // Тоническая параллель / Субмедианта
            case 3: return `Tx (${roman}${quality})`; // Медианта (может быть T или D функцией)
            case 7: return `L (${roman}${quality})`;  // Вводный тон (часть D)
            default: return `Degree ${degree}`; // Если ступень вне 1-7
        }
    }
};

// Для доступа из других модулей, если app.js еще не инициализировал все ссылки
// window.harmonicMarkerEngine = harmonicMarkerEngine;
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\padModes\HarmonicGlideStrategy.js
// Файл: app/src/main/assets/js/padModes/HarmonicGlideStrategy.js
console.log("[HGS] HarmonicGlideStrategy.js loaded");

const HarmonicGlideStrategy = {
    appRef: null,
    musicTheoryServiceRef: null,
    harmonicMarkerEngineRef: null,
    padModeManagerRef: null, // Ссылка на PadModeManager для доступа к другим стратегиям, если нужно
    _isActive: false,
    _activeNotesMap: new Map(), // Map<pointerId, { midiNote, name, frequency, x, y, startTime }>
    _currentSubModeStrategy: null, // Будет инициализирован позже
    _currentSuggestions: [],       // Массив объектов SuggestionObject
    _previousActiveSuggestionsMap: new Map(),

    // --- Инициализация и Метаданные ---
    init(appReference, musicTheoryServiceInstance, harmonicMarkerEngineInstance, padModeManagerReference) {
        console.log("[HGS.init] Initializing HarmonicGlideStrategy...");
        if (!appReference || !musicTheoryServiceInstance || !harmonicMarkerEngineInstance || !padModeManagerReference) {
            console.error("[HGS.init] CRITICAL: Missing core dependencies!");
            this._isActive = false;
            return false;
        }
        this.appRef = appReference;
        this.musicTheoryServiceRef = musicTheoryServiceInstance;
        this.harmonicMarkerEngineRef = harmonicMarkerEngineInstance;
        this.padModeManagerRef = padModeManagerReference; // Сохраняем ссылку

        console.log(`[HGS.init] Initialized. App: ${!!this.appRef}, MTS: ${!!this.musicTheoryServiceRef}, HME: ${!!this.harmonicMarkerEngineRef}, PMM: ${!!this.padModeManagerRef}`);
        return true;
    },

    getName: () => "harmonicGlide",
    getDisplayName: () => {
        return (typeof i18n !== 'undefined' && i18n.translate)
            ? i18n.translate('pad_mode_harmonic_glide', 'Harmonic Glide')
            : "Harmonic Glide";
    },

    requiresTonic: () => true,
    requiresScale: () => true,
    requiresChord: () => false, // Основной режим не требует аккорда, подрежимы могут его использовать

    // --- Управление Жизненным Циклом Режима ---
    async onModeActivated(appState, services, uiModules) {
        console.log("[HGS.onModeActivated] Harmonic Glide activated.");
        this._isActive = true;
        this._activeNotesMap.clear();
        this._currentSuggestions = [];

        // Инициализация/обновление подстратегии (пока заглушка)
        await this._updateSubModeStrategy();

        // Первичный анализ и отрисовка (вероятно, ничего не будет, т.к. нет активных нот)
        await this._analyzeAndUpdateMarkers();
        if (this.appRef?.updateRocketStatusPanel) this.appRef.updateRocketStatusPanel(); // Для консистентности, если он используется
        if (this.appRef?.updateMainDisplay) this.appRef.updateMainDisplay(null); // Очистить главный дисплей
        if (this.appRef?.updateSubBar) this.appRef.updateSubBar(null); // Очистить подбар
    },

    async onModeDeactivated(appState, services, uiModules) {
        console.log("[HGS.onModeDeactivated] Harmonic Glide deactivated.");
        this._isActive = false;
        this._activeNotesMap.clear();
        this._currentSuggestions = [];
        if (this.appRef?.updateZoneVisuals) await this.appRef.updateZoneVisuals([]);
        if (this.appRef?.updateRocketStatusPanel) this.appRef.updateRocketStatusPanel();
        if (this.appRef?.updateMainDisplay) this.appRef.updateMainDisplay(null);
        if (this.appRef?.updateSubBar) this.appRef.updateSubBar(null);
    },

    // --- Конфигурация и Раскладка Зон (делегирование ClassicMode) ---
    async getZoneLayoutOptions(appState) {
        // Используем ClassicModeStrategy для получения стандартной раскладки зон,
        // которая будет использоваться для определения нот по координатам.
        // Визуально эти зоны могут быть скрыты.
        const classicStrategy = this.padModeManagerRef?.strategies?.classic;
        if (classicStrategy && typeof classicStrategy.getZoneLayoutOptions === 'function') {
            return classicStrategy.getZoneLayoutOptions(appState);
        }
        console.warn("[HGS.getZoneLayoutOptions] ClassicModeStrategy not found or invalid. Using fallback.");
        return {
            tonicNameWithOctave: appState.currentTonic,
            scaleId: appState.scale,
            octaveOffsetFromTonic: appState.octaveOffset
        };
    },

    async generateZoneData(layoutContext, appState, services) {
        const classicStrategy = this.padModeManagerRef?.strategies?.classic;
         // Передаем наш musicTheoryServiceRef в classicStrategy, если он его ожидает в services
        const classicServices = { musicTheoryService: this.musicTheoryServiceRef };
        if (classicStrategy && typeof classicStrategy.generateZoneData === 'function') {
            return classicStrategy.generateZoneData(layoutContext, appState, classicServices);
        }
        console.warn("[HGS.generateZoneData] ClassicModeStrategy not found or invalid. Returning empty zones.");
        return [];
    },

    // --- Обработка Касаний ---
    async onPointerDown(pointerId, x, y, currentDisplayZones, padContext) {
        if (!this._isActive) return null;
        console.log(`[HGS.onPointerDown] ID: ${pointerId}, X: ${x.toFixed(2)}, Y: ${y.toFixed(2)}`);

        const classicStrategy = this.padModeManagerRef?.strategies?.classic;
        if (!classicStrategy || typeof classicStrategy.onPointerDown !== 'function') {
             console.error("[HGS.onPointerDown] ClassicModeStrategy for note detection not available.");
             return null;
        }
        // Используем ClassicModeStrategy для определения базовой ноты
        const baseNoteAction = classicStrategy.onPointerDown(pointerId, x, y, currentDisplayZones, padContext);

        if (baseNoteAction && baseNoteAction.type === 'note_on' && baseNoteAction.note) {
            const noteDetails = {
                midiNote: baseNoteAction.note.midiNote,
                name: baseNoteAction.note.name,
                frequency: baseNoteAction.note.frequency,
                pointerId: pointerId,
                x: x, // Сохраняем нормализованные координаты
                y: y,
                startTime: performance.now()
            };
            this._activeNotesMap.set(pointerId, noteDetails);
            console.log("[HGS.onPointerDown] Active note added:", noteDetails);
            await this._analyzeAndUpdateMarkers();
            return { type: 'note_on', note: { ...baseNoteAction.note } }; // Возвращаем действие для synth.js
        }
        console.warn("[HGS.onPointerDown] No note detected by ClassicModeStrategy.");
        return null;
    },

    async onPointerMove(pointerId, x, y, currentDisplayZones, padContext) {
        if (!this._isActive || !this._activeNotesMap.has(pointerId)) return null;
        const activeTouchData = this._activeNotesMap.get(pointerId);
        activeTouchData.x = x;
        activeTouchData.y = y;

        const classicStrategy = this.padModeManagerRef?.strategies?.classic;
         if (!classicStrategy || typeof classicStrategy.onPointerMove !== 'function') {
             console.error("[HGS.onPointerMove] ClassicModeStrategy for note detection not available.");
             // Возвращаем просто обновление Y для текущей ноты, если была
             if (activeTouchData) return { type: 'note_update', note: { name: activeTouchData.name, midiNote: activeTouchData.midiNote, frequency: activeTouchData.frequency } };
             return null;
         }

        // Имитируем предыдущее состояние для onPointerMove классической стратегии
        // (ClassicModeStrategy хранит свое _activeNoteInfo, мы не можем напрямую на него влиять отсюда,
        // но для определения *новой* ноты это и не нужно, только координаты и зоны)
        const baseNoteAction = classicStrategy.onPointerMove(pointerId, x, y, currentDisplayZones, padContext);

        if (baseNoteAction) {
            if (baseNoteAction.type === 'note_change' && baseNoteAction.newNote) {
                activeTouchData.midiNote = baseNoteAction.newNote.midiNote;
                activeTouchData.name = baseNoteAction.newNote.name;
                activeTouchData.frequency = baseNoteAction.newNote.frequency;
                activeTouchData.startTime = performance.now(); // Считаем как новую ноту
                console.log("[HGS.onPointerMove] Note changed:", activeTouchData);
                await this._analyzeAndUpdateMarkers();
                return { type: 'note_change', oldNote: baseNoteAction.oldNote, newNote: baseNoteAction.newNote };
            } else if (baseNoteAction.type === 'note_update' && baseNoteAction.note) {
                // Нота не изменилась, но Y мог. Обновляем только Y в activeTouchData (уже сделано выше).
                // _analyzeAndUpdateMarkers не нужен, если только Y не влияет на предложения.
                // Но для единообразия можно вызвать, если логика подрежимов это учитывает.
                // await this._analyzeAndUpdateMarkers(); // Раскомментировать, если Y важен для предложений
                return { type: 'note_update', note: { ...baseNoteAction.note } };
            } else if (baseNoteAction.type === 'note_off') {
                this._activeNotesMap.delete(pointerId);
                console.log("[HGS.onPointerMove] Note off by strategy:", baseNoteAction.note);
                await this._analyzeAndUpdateMarkers();
                return baseNoteAction;
            }
        }
        return null;
    },

    async onPointerUp(pointerId, padContext) {
        if (!this._isActive) return null;
        const releasedNoteData = this._activeNotesMap.get(pointerId);
        if (releasedNoteData) {
            this._activeNotesMap.delete(pointerId);
            console.log("[HGS.onPointerUp] Note released:", releasedNoteData);
            await this._analyzeAndUpdateMarkers();
            // Возвращаем информацию об отпущенной ноте, чтобы synth.js мог ее остановить
            return { type: 'note_off', note: { name: releasedNoteData.name, midiNote: releasedNoteData.midiNote, frequency: releasedNoteData.frequency } };
        }
        return null;
    },

    // --- Логика Маркеров и Подрежимов (пока заглушки) ---
    _getDisplayColorForSemantic(semantic) {
        const hgColors = (this.appRef?.state?.harmonicGlide?.markerColors) || (typeof visualizer !== 'undefined' && visualizer.harmonicGlideMarkerColors) || {};
        switch (semantic) {
            case 'active': return hgColors.active;
            case 'powerful': return hgColors.powerful;
            case 'tense': return hgColors.tense;
            case 'calm': return hgColors.calm;
            case 'unexpected': return hgColors.unexpected;
            default: return hgColors.neutral || (this.appRef?.themeColors?.accent) || '#FFDC00';
        }
    },

    async _updateSubModeStrategy() {
        const subMode = this.appRef?.state?.harmonicGlide?.activeSubMode || 'tonalBinding';
        let StrategyClass = null;
        switch (subMode) {
            case 'tonalBinding':
                StrategyClass = window.TonalBindingSubModeStrategy; break;
            case 'adaptiveAnalysis':
                StrategyClass = window.AdaptiveAnalysisSubModeStrategy; break;
            case 'semiFree':
                StrategyClass = window.SemiFreeSubModeStrategy; break;
            case 'randomDirected':
                StrategyClass = window.RandomDirectedSubModeStrategy; break;
            default:
                StrategyClass = window.TonalBindingSubModeStrategy;
        }
        if (typeof StrategyClass === 'function') {
            this._currentSubModeStrategy = new StrategyClass(this.musicTheoryServiceRef, this.harmonicMarkerEngineRef, this.appRef, this);
            if (typeof this._currentSubModeStrategy.init === 'function') this._currentSubModeStrategy.init();
        } else {
            console.error('[HGS._updateSubModeStrategy] No valid submode strategy for', subMode);
            this._currentSubModeStrategy = null;
        }
    },

    async _analyzeAndUpdateMarkers() {
        if (!this._isActive || !this.appRef || !this.harmonicMarkerEngineRef || !this._currentSubModeStrategy) {
            this._currentSuggestions = [];
            if(this.appRef?.updateZoneVisuals) await this.appRef.updateZoneVisuals([]);
            if (this.appRef?.updateMainDisplay) this.appRef.updateMainDisplay(null);
            if (this.appRef?.updateSubBar) this.appRef.updateSubBar(null);
            return;
        }
        const activeNotesForAnalysis = Array.from(this._activeNotesMap.values());
        const tonicMidi = this.musicTheoryServiceRef.getNoteDetails(this.appRef.state.currentTonic)?.midi;
        const hmeContext = {
            tonicMidi: tonicMidi,
            scaleId: this.appRef.state.scale,
            settings: this.appRef.state.rocketModeSettings,
            currentPhase: this.appRef.state.rocketModePhase,
        };
        const hmeAnalysisResult = this.harmonicMarkerEngineRef.analyzeContext(activeNotesForAnalysis, hmeContext);
        const subMode = this.appRef?.state?.harmonicGlide?.activeSubMode || 'tonalBinding';
        const glideContext = {
            appState: this.appRef.state,
            padZones: (typeof pad !== 'undefined' && pad._currentDisplayedZones) ? pad._currentDisplayedZones : [],
            subModeSettings: this.appRef.state.harmonicGlide?.[subMode] || {},
        };
        let rawSuggestions = [];
        if (this._currentSubModeStrategy && typeof this._currentSubModeStrategy.analyzeAndSuggest === 'function') {
            rawSuggestions = await this._currentSubModeStrategy.analyzeAndSuggest(activeNotesForAnalysis, hmeAnalysisResult, glideContext);
        }
        // --- Обработка предложений ---
        const prevMap = this._previousActiveSuggestionsMap || new Map();
        const now = performance.now();
        const padZones = glideContext.padZones || [];
        // Присваиваем zoneIndex и фильтруем предложения без зоны
        let processed = (rawSuggestions || []).map(sugg => {
            let zoneIndex = -1;
            if (sugg.targetType === 'note' && sugg.midiNote !== undefined && padZones.length > 0) {
                zoneIndex = padZones.findIndex(z => z.midiNote === sugg.midiNote);
            } else if (sugg.targetType === 'chord' && sugg.midiNotes && sugg.midiNotes.length > 0 && padZones.length > 0) {
                zoneIndex = padZones.findIndex(z => z.midiNote === sugg.midiNotes[0]);
            }
            if (zoneIndex === -1) return null; // фильтруем "вне диапазона"
            const suggestionId = sugg.suggestionId || `${subMode}_${sugg.targetType}_${sugg.midiNote || (sugg.midiNotes ? sugg.midiNotes[0] : 'x')}`;
            const prev = prevMap.get(suggestionId);
            const isNew = !prev;
            const isStillValid = true;
            const creationTime = prev ? prev.creationTime : now;
            const lastActiveTime = now;
            return {
                ...sugg,
                suggestionId,
                zoneIndex,
                isNew,
                isStillValid,
                creationTime,
                lastActiveTime,
            };
        }).filter(Boolean);
        // Fade out для исчезающих маркеров
        prevMap.forEach((prev, id) => {
            if (!processed.find(s => s.suggestionId === id)) {
                processed.push({
                    ...prev,
                    isStillValid: false,
                    fadeOutStartTime: now,
                    fadeOutDurationMs: 600,
                });
            }
        });
        // Ограничиваем количество отображаемых маркеров
        const maxMarkers = this.appRef.state.harmonicGlide.maxMarkersToShow || 5;
        processed = processed.filter(s => s.isStillValid).slice(0, maxMarkers);
        // Обновить карту
        this._previousActiveSuggestionsMap = new Map();
        processed.forEach(s => {
            if (s.isStillValid) this._previousActiveSuggestionsMap.set(s.suggestionId, s);
        });
        this._currentSuggestions = processed;
        // UI обновления
        let mainDisplayText = null;
        if (hmeAnalysisResult.isPlayingChord && hmeAnalysisResult.detectedChordSymbol) {
            mainDisplayText = hmeAnalysisResult.detectedChordSymbol;
        } else if (activeNotesForAnalysis.length > 0) {
            const lastNote = activeNotesForAnalysis[activeNotesForAnalysis.length - 1];
            mainDisplayText = lastNote.name;
        } else if (activeNotesForAnalysis.length === 0 && !hmeAnalysisResult.isPlayingChord) {
            mainDisplayText = (typeof i18n !== 'undefined' && i18n.translate) ? i18n.translate('main_display_unrecognized_chord', 'Complex Chord') : 'Complex Chord';
        }
        if (this.appRef?.updateMainDisplay) this.appRef.updateMainDisplay(mainDisplayText);
        const subBarHtml = this._currentSubModeStrategy.getSubBarInfo(activeNotesForAnalysis, hmeAnalysisResult, this._currentSuggestions, glideContext);
        if (this.appRef?.updateSubBar) this.appRef.updateSubBar(subBarHtml);
        if (this.appRef?.updateZoneVisuals) await this.appRef.updateZoneVisuals();
    },

    async getPadVisualHints(currentDisplayZones, appState, services) {
        if (!this._isActive) return [];
        const hints = [];
        // 1. Подсветка активных нот/аккорда (белым)
        if (appState.harmonicGlide.highlightActiveNotes) {
            this._activeNotesMap.forEach(activeNote => {
                const zoneIdx = currentDisplayZones.findIndex(z => z.midiNote === activeNote.midiNote);
                if (zoneIdx !== -1) {
                    hints.push({
                        suggestionId: `active_${activeNote.midiNote}_${activeNote.pointerId}`,
                        zoneIndex: zoneIdx,
                        type: 'active_note_highlight',
                        colorSemantic: 'active',
                        noteName: activeNote.name,
                        midiNote: activeNote.midiNote,
                        style: appState.harmonicGlide.activeNoteHighlightStyle,
                        isNew: true, isStillValid: true, creationTime: activeNote.startTime
                    });
                }
            });
        }
        // 2. Отображение предложенных гармонических маркеров
        (this._currentSuggestions || []).forEach(suggestion => {
            if (suggestion.zoneIndex !== undefined && suggestion.zoneIndex >= 0 && suggestion.zoneIndex < currentDisplayZones.length) {
                // Определяем displayColor по colorSemantic
                let displayColor = this._getDisplayColorForSemantic(suggestion.colorSemantic);
                hints.push({
                    ...suggestion,
                    type: 'harmonic_suggestion',
                    style: appState.harmonicGlide.markerStyle,
                    displayColor,
                    label: suggestion.subBarLabel || (suggestion.targetType === 'chord' ? suggestion.chordSymbol : suggestion.noteName),
                });
            }
        });
        return hints;
    },

    // --- Настройки Режима ---
    getModeSpecificControlsConfig() {
        // Общие настройки HG
        const common = [
            { name: 'harmonicGlide.markerStyle', labelKey: 'setting_hg_markerStyle', type: 'select', default: this.appRef?.state?.harmonicGlide?.markerStyle, options: ['Glow','Circle','Ripple'] },
            { name: 'harmonicGlide.highlightActiveNotes', labelKey: 'setting_hg_highlightActiveNotes', type: 'toggle', default: this.appRef?.state?.harmonicGlide?.highlightActiveNotes },
            { name: 'harmonicGlide.activeNoteHighlightStyle', labelKey: 'setting_hg_activeNoteHighlightStyle', type: 'select', default: this.appRef?.state?.harmonicGlide?.activeNoteHighlightStyle, options: ['WhiteGlow','PulseRing','WaveToNote','SparkTrail','ShadowDrop'] },
            { name: 'harmonicGlide.activeSubMode', labelKey: 'setting_hg_activeSubMode', type: 'select', default: this.appRef?.state?.harmonicGlide?.activeSubMode, options: ['tonalBinding','adaptiveAnalysis','semiFree','randomDirected'] },
        ];
        // Специфичные для подрежима
        let subModeCfg = [];
        const subMode = this.appRef?.state?.harmonicGlide?.activeSubMode || 'tonalBinding';
        if (this._currentSubModeStrategy && typeof this._currentSubModeStrategy.getModeSpecificControlsConfig === 'function') {
            subModeCfg = this._currentSubModeStrategy.getModeSpecificControlsConfig(this.appRef.state.harmonicGlide?.[subMode]);
        }
        return [...common, ...subModeCfg];
    },

    async onSpecificControlChanged(settingName, value, allGlideSettings) {
        console.log(`[HGS.onSpecificControlChanged] Setting '${settingName}' changed to: ${value}`);
        if (settingName === 'activeSubMode') {
            await this._updateSubModeStrategy();
            await this._analyzeAndUpdateMarkers();
            return;
        }
        // Если настройка относится к подрежиму
        const subMode = this.appRef?.state?.harmonicGlide?.activeSubMode || 'tonalBinding';
        if (settingName.startsWith(subMode + '.')) {
            if (this._currentSubModeStrategy && typeof this._currentSubModeStrategy.onSubModeSettingChanged === 'function') {
                this._currentSubModeStrategy.onSubModeSettingChanged(settingName, value, allGlideSettings);
            }
        }
        await this._analyzeAndUpdateMarkers();
    },

    // Обработка изменений тональности/лада (вызывается из PadModeManager)
    async onTonicChanged(newTonic, appState, services) {
        console.log(`[HGS.onTonicChanged] New tonic: ${newTonic}`);
        if (this._isActive) await this._analyzeAndUpdateMarkers();
    },
    async onScaleChanged(newScale, appState, services) {
        console.log(`[HGS.onScaleChanged] New scale: ${newScale}`);
        if (this._isActive) await this._analyzeAndUpdateMarkers();
    },
    async onChordChanged(newChord, appState, services) { /* Пока не используется напрямую в HarmonicGlide */ },

    getCommonControlsConfig() {
        const s = this.appRef.state.harmonicGlide;
        return [
            { name: 'intensity', labelKey: 'setting_hg_intensity', type: 'knob', min: 0.1, max: 1.0, step: 0.05, default: s.intensity },
            { name: 'markerStyle', labelKey: 'setting_hg_markerStyle', type: 'select', options: [
                {id:'Glow', name:'Glow'}, {id:'Circle', name:'Circle'}, {id:'Ripple', name:'Ripple'}
            ], default: s.markerStyle },
            { name: 'activeNoteHighlightStyle', labelKey: 'setting_hg_activeNoteHighlightStyle', type: 'select', options: [
                {id:'WhiteGlow', name:'White Glow'}, {id:'WhitePulse', name:'White Pulse'}
            ], default: s.activeNoteHighlightStyle },
            { name: 'highlightActiveNotes', labelKey: 'setting_hg_highlightActiveNotes', type: 'toggle', default: s.highlightActiveNotes },
            { name: 'fadeOutOldMarkers', labelKey: 'setting_hg_fadeOutOldMarkers', type: 'toggle', default: s.fadeOutOldMarkers },
            { name: 'markerFadeOutDurationMs', labelKey: 'setting_hg_markerFadeOutDurationMs', type: 'knob', min: 100, max: 2000, step: 50, default: s.markerFadeOutDurationMs, unit: 'ms', condition: () => s.fadeOutOldMarkers },
            { name: 'markerDisappearOnNewTouch', labelKey: 'setting_hg_markerDisappearOnNewTouch', type: 'toggle', default: s.markerDisappearOnNewTouch },
            { name: 'showSubBarInfo', labelKey: 'setting_hg_showSubBarInfo', type: 'toggle', default: s.showSubBarInfo },
            { name: 'maxMarkersToShow', labelKey: 'setting_hg_maxMarkersToShow', type: 'knob', min:1, max:8, step:1, default: s.maxMarkersToShow },
        ];
    },
};

// Саморегистрация стратегии
if (typeof PadModeManager !== 'undefined' && PadModeManager.registerStrategy) {
    PadModeManager.registerStrategy(HarmonicGlideStrategy);
} else {
    console.error("[HGS] PadModeManager not found for self-registration!");
} 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\padModes\subModes\AdaptiveAnalysisSubModeStrategy.js
class AdaptiveAnalysisSubModeStrategy {
    constructor(musicTheoryServiceRef, harmonicMarkerEngineRef, appRef, mainStrategyRef) {
        this.musicTheoryServiceRef = musicTheoryServiceRef;
        this.harmonicMarkerEngineRef = harmonicMarkerEngineRef;
        this.appRef = appRef;
        this.mainStrategyRef = mainStrategyRef;
    }

    getName() {
        return 'adaptiveAnalysis';
    }

    getDisplayName() {
        return (typeof i18n !== 'undefined' && i18n.translate)
            ? i18n.translate('submode_adaptiveAnalysis', 'Adaptive Analysis')
            : 'Adaptive Analysis';
    }

    init() {}

    isUsable() {
        return !!(this.musicTheoryServiceRef && this.musicTheoryServiceRef.isTonalJsLoaded);
    }

    async analyzeAndSuggest(activeNotes, hmeAnalysisResult, glideContext) {
        const settings = glideContext.appState.harmonicGlide[this.getName()] || {};
        const allowChromatic = settings.allowChromaticSuggestions === true;
        const stabilityPriority = typeof settings.stabilityPriority === 'number' ? settings.stabilityPriority : 0.5;
        const suggestions = [];
        if (!activeNotes || activeNotes.length === 0 || !hmeAnalysisResult.scaleNotesPitchClasses) return suggestions;
        // Определяем локальную тональность по последним 2-3 нотам
        let localTonic = null, localScale = null;
        if (hmeAnalysisResult.detectedChordSymbol) {
            const chord = Tonal.Chord.get(hmeAnalysisResult.detectedChordSymbol);
            if (chord && chord.tonic) {
                localTonic = Tonal.Note.simplify(chord.tonic);
                localScale = glideContext.appState.scale;
            }
        } else if (activeNotes.length >= 2) {
            localTonic = Tonal.Note.simplify(activeNotes[activeNotes.length - 1].name);
            localScale = glideContext.appState.scale;
        }
        // Генерируем "стабильные" предложения (внутри локальной тональности)
        if (localTonic && localScale) {
            const scaleNotes = await this.musicTheoryServiceRef.getNotesForScale(localTonic + "4", localScale, 0, 0);
            for (const note of scaleNotes) {
                if (!allowChromatic && !hmeAnalysisResult.scaleNotesPitchClasses.includes(note.pc)) continue;
                if (Math.random() < stabilityPriority) {
                    suggestions.push({
                        suggestionId: `adaptiveAnalysis_note_${note.midi}`,
                        targetType: 'note',
                        midiNote: note.midi,
                        noteName: note.name,
                        frequency: note.freq,
                        colorSemantic: 'calm',
                        subBarLabel: `To: ${note.name}`
                    });
                }
            }
        }
        // Модуляционные/неожиданные ходы
        if (localTonic && localScale && stabilityPriority < 1) {
            const otherTonic = Tonal.Note.simplify(Tonal.transpose(localTonic, 'M3'));
            const modNotes = await this.musicTheoryServiceRef.getNotesForScale(otherTonic + "4", localScale, 0, 0);
            for (const note of modNotes) {
                if (!hmeAnalysisResult.scaleNotesPitchClasses.includes(note.pc)) {
                    if (Math.random() > stabilityPriority) {
                        suggestions.push({
                            suggestionId: `adaptiveAnalysis_mod_${note.midi}`,
                            targetType: 'note',
                            midiNote: note.midi,
                            noteName: note.name,
                            frequency: note.freq,
                            colorSemantic: 'unexpected',
                            subBarLabel: `Modulate: ${note.name}`
                        });
                    }
                }
            }
        }
        // Хроматические, если разрешено
        if (allowChromatic && activeNotes.length > 0) {
            const lastNote = activeNotes[activeNotes.length - 1];
            for (let i = -1; i <= 1; i += 2) {
                const midi = lastNote.midiNote + i;
                const details = this.musicTheoryServiceRef.getNoteDetails(midi);
                if (details && !hmeAnalysisResult.scaleNotesPitchClasses.includes(details.pc)) {
                    suggestions.push({
                        suggestionId: `adaptiveAnalysis_chromatic_${details.midi}`,
                        targetType: 'note',
                        midiNote: details.midi,
                        noteName: details.name,
                        frequency: details.freq,
                        colorSemantic: 'unexpected',
                        subBarLabel: `Chromatic: ${details.name}`
                    });
                }
            }
        }
        return suggestions;
    }

    getSubBarInfo(activeNotes, hmeAnalysisResult, currentSuggestions, glideContext) {
        const settings = glideContext.appState.harmonicGlide[this.getName()] || {};
        if (!settings.showInterpretation) return null;
        if (hmeAnalysisResult.detectedChordSymbol) {
            return `Local: <b>${hmeAnalysisResult.detectedChordSymbol}</b>`;
        }
        if (currentSuggestions && currentSuggestions.length > 0) {
            const mod = currentSuggestions.find(s => s.subBarLabel && s.subBarLabel.startsWith('Modulate:'));
            if (mod) return 'Suggesting modulation';
            return `To: ${currentSuggestions[0].noteName}`;
        }
        return '';
    }

    getModeSpecificControlsConfig(currentSubModeSettings) {
        return [
            { name: 'adaptiveAnalysis.allowChromaticSuggestions', labelKey: 'setting_hg_adaptiveAnalysis_allowChromaticSuggestions', type: 'toggle', default: currentSubModeSettings?.allowChromaticSuggestions },
            { name: 'adaptiveAnalysis.changeSensitivity', labelKey: 'setting_hg_adaptiveAnalysis_changeSensitivity', type: 'knob', min: 0, max: 1, step: 0.01, default: currentSubModeSettings?.changeSensitivity },
            { name: 'adaptiveAnalysis.stabilityPriority', labelKey: 'setting_hg_adaptiveAnalysis_stabilityPriority', type: 'knob', min: 0, max: 1, step: 0.01, default: currentSubModeSettings?.stabilityPriority },
            { name: 'adaptiveAnalysis.showInterpretation', labelKey: 'setting_hg_adaptiveAnalysis_showInterpretation', type: 'toggle', default: currentSubModeSettings?.showInterpretation }
        ];
    }

    onSubModeSettingChanged(settingName, value, allGlideSettings) {}
}
window.AdaptiveAnalysisSubModeStrategy = AdaptiveAnalysisSubModeStrategy; 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\padModes\subModes\RandomDirectedSubModeStrategy.js
class RandomDirectedSubModeStrategy {
    constructor(musicTheoryServiceRef, harmonicMarkerEngineRef, appRef, mainStrategyRef) {
        this.musicTheoryServiceRef = musicTheoryServiceRef;
        this.harmonicMarkerEngineRef = harmonicMarkerEngineRef;
        this.appRef = appRef;
        this.mainStrategyRef = mainStrategyRef;
    }

    getName() {
        return 'randomDirected';
    }

    getDisplayName() {
        return (typeof i18n !== 'undefined' && i18n.translate)
            ? i18n.translate('submode_randomDirected', 'Random Directed')
            : 'Random Directed';
    }

    init() {}

    isUsable() {
        return !!(this.musicTheoryServiceRef && this.musicTheoryServiceRef.isTonalJsLoaded);
    }

    async analyzeAndSuggest(activeNotes, hmeAnalysisResult, glideContext) {
        const settings = glideContext.appState.harmonicGlide[this.getName()] || {};
        const chaosLevel = typeof settings.chaosLevel === 'number' ? settings.chaosLevel : 0.6;
        const tonalFilterStrength = typeof settings.tonalFilterStrength === 'number' ? settings.tonalFilterStrength : 0.5;
        const suggestions = [];
        if (!activeNotes || activeNotes.length === 0 || !hmeAnalysisResult.scaleNotesPitchClasses) return suggestions;
        const lastNote = activeNotes[activeNotes.length - 1];
        // Генерируем случайные смещения в диапазоне -7..+7
        const count = Math.max(2, Math.round(chaosLevel * 7));
        for (let i = 0; i < count; i++) {
            const offset = Math.floor((Math.random() - 0.5) * 14); // -7..+7
            if (offset === 0) continue;
            const midi = lastNote.midiNote + offset;
            const details = this.musicTheoryServiceRef.getNoteDetails(midi);
            if (!details) continue;
            const isDiatonic = hmeAnalysisResult.scaleNotesPitchClasses.includes(details.pc);
            // Фильтруем по tonalFilterStrength
            if (isDiatonic || Math.random() < chaosLevel * (1 - tonalFilterStrength)) {
                suggestions.push({
                    suggestionId: `randomDirected_${details.midi}`,
                    targetType: 'note',
                    midiNote: details.midi,
                    noteName: details.name,
                    frequency: details.freq,
                    colorSemantic: isDiatonic ? 'neutral' : 'unexpected',
                    subBarLabel: isDiatonic ? `Step: ${details.name}` : `Wild: ${details.name}`
                });
            }
        }
        // Добавим одну явно диатоническую ноту (тонику)
        const diatonicNotes = hmeAnalysisResult.scaleNotesPitchClasses;
        if (diatonicNotes && diatonicNotes.length > 0) {
            const tonicNote = this.musicTheoryServiceRef.getNoteDetails(diatonicNotes[0] + lastNote.name.replace(/\d+/, ''));
            if (tonicNote) {
                suggestions.push({
                    suggestionId: `randomDirected_tonic_${tonicNote.midi}`,
                    targetType: 'note',
                    midiNote: tonicNote.midi,
                    noteName: tonicNote.name,
                    frequency: tonicNote.freq,
                    colorSemantic: 'calm',
                    subBarLabel: `Tonic: ${tonicNote.name}`
                });
            }
        }
        return suggestions;
    }

    getSubBarInfo(activeNotes, hmeAnalysisResult, currentSuggestions, glideContext) {
        if (!currentSuggestions || currentSuggestions.length === 0) return '';
        return currentSuggestions.map(s => s.noteName).join(' | ');
    }

    getModeSpecificControlsConfig(currentSubModeSettings) {
        return [
            { name: 'randomDirected.chaosLevel', labelKey: 'setting_hg_randomDirected_chaosLevel', type: 'knob', min: 0, max: 1, step: 0.01, default: currentSubModeSettings?.chaosLevel },
            { name: 'randomDirected.tonalFilterStrength', labelKey: 'setting_hg_randomDirected_tonalFilterStrength', type: 'knob', min: 0, max: 1, step: 0.01, default: currentSubModeSettings?.tonalFilterStrength }
        ];
    }

    onSubModeSettingChanged(settingName, value, allGlideSettings) {}
}
window.RandomDirectedSubModeStrategy = RandomDirectedSubModeStrategy; 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\padModes\subModes\SemiFreeSubModeStrategy.js
class SemiFreeSubModeStrategy {
    constructor(musicTheoryServiceRef, harmonicMarkerEngineRef, appRef, mainStrategyRef) {
        this.musicTheoryServiceRef = musicTheoryServiceRef;
        this.harmonicMarkerEngineRef = harmonicMarkerEngineRef;
        this.appRef = appRef;
        this.mainStrategyRef = mainStrategyRef;
    }

    getName() {
        return 'semiFree';
    }

    getDisplayName() {
        return (typeof i18n !== 'undefined' && i18n.translate)
            ? i18n.translate('submode_semiFree', 'Semi-Free')
            : 'Semi-Free';
    }

    init() {}

    isUsable() {
        return !!(this.musicTheoryServiceRef && this.musicTheoryServiceRef.isTonalJsLoaded);
    }

    async analyzeAndSuggest(activeNotes, hmeAnalysisResult, glideContext) {
        const settings = glideContext.appState.harmonicGlide[this.getName()] || {};
        const allowNonDiatonic = settings.allowNonDiatonicPassing === true;
        const deviationLevel = typeof settings.deviationLevel === 'number' ? settings.deviationLevel : 0.4;
        const suggestions = [];
        if (!activeNotes || activeNotes.length === 0 || !hmeAnalysisResult.scaleNotesPitchClasses) return suggestions;
        const lastNote = activeNotes[activeNotes.length - 1];
        // Диапазон смещения в полутонах
        const maxDeviation = Math.round(deviationLevel * 5);
        for (let i = -maxDeviation; i <= maxDeviation; i++) {
            if (i === 0) continue;
            const midi = lastNote.midiNote + i;
            const details = this.musicTheoryServiceRef.getNoteDetails(midi);
            if (!details) continue;
            const isDiatonic = hmeAnalysisResult.scaleNotesPitchClasses.includes(details.pc);
            if (!allowNonDiatonic && !isDiatonic) continue;
            suggestions.push({
                suggestionId: `semiFree_${details.midi}`,
                targetType: 'note',
                midiNote: details.midi,
                noteName: details.name,
                frequency: details.freq,
                colorSemantic: isDiatonic ? 'neutral' : 'unexpected',
                subBarLabel: isDiatonic ? `Step: ${details.name}` : `Passing: ${details.name}`
            });
        }
        // Highlight return to tonic
        if (settings.highlightReturnToTonic && hmeAnalysisResult.scaleTonicPc) {
            const tonicNote = this.musicTheoryServiceRef.getNoteDetails(hmeAnalysisResult.scaleTonicPc + lastNote.name.replace(/\d+/, ''));
            if (tonicNote) {
                suggestions.push({
                    suggestionId: `semiFree_tonic_${tonicNote.midi}`,
                    targetType: 'note',
                    midiNote: tonicNote.midi,
                    noteName: tonicNote.name,
                    frequency: tonicNote.freq,
                    colorSemantic: 'calm',
                    subBarLabel: `Tonic: ${tonicNote.name}`
                });
            }
        }
        return suggestions;
    }

    getSubBarInfo(activeNotes, hmeAnalysisResult, currentSuggestions, glideContext) {
        if (!currentSuggestions || currentSuggestions.length === 0) return '';
        const tonicSugg = currentSuggestions.find(s => s.subBarLabel && s.subBarLabel.startsWith('Tonic:'));
        if (tonicSugg) return `<span class="function-T">${tonicSugg.noteName}</span>`;
        return currentSuggestions.map(s => s.noteName).join(' / ');
    }

    getModeSpecificControlsConfig(currentSubModeSettings) {
        return [
            { name: 'semiFree.deviationLevel', labelKey: 'setting_hg_semiFree_deviationLevel', type: 'knob', min: 0, max: 1, step: 0.01, default: currentSubModeSettings?.deviationLevel },
            { name: 'semiFree.allowNonDiatonicPassing', labelKey: 'setting_hg_semiFree_allowNonDiatonicPassing', type: 'toggle', default: currentSubModeSettings?.allowNonDiatonicPassing },
            { name: 'semiFree.highlightReturnToTonic', labelKey: 'setting_hg_semiFree_highlightReturnToTonic', type: 'toggle', default: currentSubModeSettings?.highlightReturnToTonic }
        ];
    }

    onSubModeSettingChanged(settingName, value, allGlideSettings) {}
}
window.SemiFreeSubModeStrategy = SemiFreeSubModeStrategy; 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\padModes\subModes\TonalBindingSubModeStrategy.js
class TonalBindingSubModeStrategy {
    constructor(musicTheoryServiceRef, harmonicMarkerEngineRef, appRef, mainStrategyRef) {
        this.musicTheoryServiceRef = musicTheoryServiceRef;
        this.harmonicMarkerEngineRef = harmonicMarkerEngineRef;
        this.appRef = appRef;
        this.mainStrategyRef = mainStrategyRef;
    }

    getName() {
        return 'tonalBinding';
    }

    getDisplayName() {
        return (typeof i18n !== 'undefined' && i18n.translate)
            ? i18n.translate('submode_tonalBinding', 'Tonal Binding')
            : 'Tonal Binding';
    }

    init() {}

    isUsable() {
        return !!(this.musicTheoryServiceRef && this.musicTheoryServiceRef.isTonalJsLoaded);
    }

    async analyzeAndSuggest(activeNotes, hmeAnalysisResult, glideContext) {
        const settings = glideContext.appState.harmonicGlide[this.getName()] || {};
        const diatonicOnly = settings.diatonicOnly !== false;
        const preferredIntervals = settings.preferredIntervals || ["P5", "P4", "M3", "m3", "M6", "m6"];
        const showRomanNumerals = settings.showRomanNumerals;
        const suggestions = [];
        if (!activeNotes || activeNotes.length === 0 || !hmeAnalysisResult.scaleNotesPitchClasses) return suggestions;
        const lastNote = activeNotes[activeNotes.length - 1];
        const currentFunc = hmeAnalysisResult.currentHarmonicFunction || '';
        const scaleNotes = hmeAnalysisResult.scaleNotesPitchClasses;
        const tonicPc = hmeAnalysisResult.scaleTonicPc;
        const scaleId = glideContext.appState.scale;
        // --- Логика по функции ---
        let targets = [];
        if (/T/.test(currentFunc)) { // Тоника
            targets = ["V", "IV", "ii", "vi"];
        } else if (/D/.test(currentFunc)) { // Доминанта
            targets = ["I", "vi"];
        } else if (/S/.test(currentFunc)) { // Субдоминанта
            targets = ["V", "I"];
        } else {
            targets = ["I", "V", "IV"];
        }
        // --- Генерация аккордов ---
        if (tonicPc && scaleId) {
            const diatonicChords = Tonal.Scale.chords(`${tonicPc} ${scaleId}`);
            const romanNumerals = ["I","ii","iii","IV","V","vi","vii°"];
            for (let i = 0; i < diatonicChords.length; i++) {
                const chordSymbol = diatonicChords[i];
                const chord = Tonal.Chord.get(chordSymbol);
                if (!chord || !chord.notes || chord.notes.length === 0) continue;
                const roman = romanNumerals[i] || '';
                if (!targets.includes(roman.replace(/°/g, ''))) continue;
                if (diatonicOnly && !chord.notes.every(pc => scaleNotes.includes(Tonal.Note.simplify(pc)))) continue;
                const rootPc = Tonal.Note.simplify(chord.tonic);
                const midiNotes = chord.notes.map(pc => this.musicTheoryServiceRef.getNoteDetails(pc + lastNote.name.replace(/\d+/, '')).midi);
                let colorSemantic = 'neutral';
                if (roman === "I") colorSemantic = 'calm';
                else if (roman === "V") colorSemantic = 'powerful';
                else if (roman === "IV") colorSemantic = 'tense';
                else if (["ii","vi"].includes(roman)) colorSemantic = 'calm';
                else if (roman === "vii°") colorSemantic = 'unexpected';
                suggestions.push({
                    suggestionId: `tonalBinding_chord_${chordSymbol}`,
                    targetType: 'chord',
                    midiNotes,
                    chordSymbol: showRomanNumerals ? roman : chordSymbol,
                    chordRootPc: rootPc,
                    chordQuality: chord.type,
                    colorSemantic,
                    subBarLabel: `Next (${roman}): ${chordSymbol}`
                });
            }
        }
        // --- Генерация нот по preferredIntervals ---
        for (const interval of preferredIntervals) {
            try {
                const targetNoteName = Tonal.transpose(lastNote.name, interval);
                const targetNoteDetails = this.musicTheoryServiceRef.getNoteDetails(targetNoteName);
                if (!targetNoteDetails) continue;
                if (diatonicOnly && !scaleNotes.includes(targetNoteDetails.pc)) continue;
                suggestions.push({
                    suggestionId: `tonalBinding_note_${targetNoteDetails.midi}`,
                    targetType: 'note',
                    midiNote: targetNoteDetails.midi,
                    noteName: targetNoteDetails.name,
                    frequency: targetNoteDetails.freq,
                    colorSemantic: 'calm',
                    subBarLabel: `Next: ${targetNoteDetails.name}`
                });
            } catch(e) { continue; }
        }
        // --- Хроматические, если разрешено ---
        if (!diatonicOnly) {
            for (let i = -2; i <= 2; i++) {
                if (i === 0) continue;
                const midi = lastNote.midiNote + i;
                const details = this.musicTheoryServiceRef.getNoteDetails(midi);
                if (details && !scaleNotes.includes(details.pc)) {
                    suggestions.push({
                        suggestionId: `tonalBinding_chromatic_${details.midi}`,
                        targetType: 'note',
                        midiNote: details.midi,
                        noteName: details.name,
                        frequency: details.freq,
                        colorSemantic: 'unexpected',
                        subBarLabel: `Chromatic: ${details.name}`
                    });
                }
            }
        }
        return suggestions;
    }

    getSubBarInfo(activeNotes, hmeAnalysisResult, currentSuggestions, glideContext) {
        const settings = glideContext.appState.harmonicGlide[this.getName()] || {};
        if (!settings.showChordFunctions) return null;
        if (!currentSuggestions || currentSuggestions.length === 0) return '';
        const chordSugg = currentSuggestions.find(s => s.targetType === 'chord');
        if (chordSugg) {
            return `Next (${chordSugg.chordSymbol}): <span class="function-${chordSugg.colorSemantic?.charAt(0).toUpperCase()}">${chordSugg.chordSymbol}</span>`;
        }
        return null;
    }

    getModeSpecificControlsConfig(currentSubModeSettings) {
        return [
            { name: 'tonalBinding.diatonicOnly', labelKey: 'setting_hg_tonalBinding_diatonicOnly', type: 'toggle', default: currentSubModeSettings?.diatonicOnly },
            { name: 'tonalBinding.showChordFunctions', labelKey: 'setting_hg_tonalBinding_showChordFunctions', type: 'toggle', default: currentSubModeSettings?.showChordFunctions },
            { name: 'tonalBinding.preferredIntervals', labelKey: 'setting_hg_tonalBinding_preferredIntervals', type: 'select', options: ["P5","P4","M3","m3","M6","m6"], default: currentSubModeSettings?.preferredIntervals },
            { name: 'tonalBinding.showRomanNumerals', labelKey: 'setting_hg_tonalBinding_showRomanNumerals', type: 'toggle', default: currentSubModeSettings?.showRomanNumerals }
        ];
    }

    onSubModeSettingChanged(settingName, value, allGlideSettings) {
        // Можно реализовать реакцию на изменение настроек
    }
}
window.TonalBindingSubModeStrategy = TonalBindingSubModeStrategy; 
================================================================================

// Файл: C:\Py\Prismtone\app\src\main\assets\js\sidepanel.js
const sidePanel = {
    panels: {},
    closeButtons: [],
    knobsInitialized: new WeakSet(),

    octaveSlider: null,
    octaveValueDisplay: null,
    octaveDownButton: null,
    octaveUpButton: null,
    scaleSelect: null,
    scaleSelectDisplay: null,
    sizeSlider: null,
    sizeValueDisplay: null,
    sizeDownButton: null,
    sizeUpButton: null,
    sizeMap: [7, 12, 24, 36],

    languageSelect: null,
    themeSelect: null,
    visualizerSelect: null,
    touchEffectSelect: null,
    noteNamesToggle: null,
    linesToggle: null,
    multiTouchToggle: null,
    // === НОВОЕ: Ссылка на переключатель Polyphony Volume Scaling ===
    enablePolyphonyScalingToggle: null,
    // ============================================================
    // === НОВОЕ: Ссылка на переключатель Highlight Sharps/Flats ===
    highlightSharpsFlatsToggle: null,
    // ============================================================
    padModeSelect: null,
    padModeSelectorDisplay: null,       // Для отображения выбранного режима
    modeSpecificControlsContainer: null, // Контейнер для настроек режима

    // === Rocket Mode UI ===
    rocketModeEnableToggle: null,
    // ...

    init() {
        console.log('[SidePanel.init PadModes] Initializing...');
        this.panels = {
            settings: document.getElementById('settings-panel'),
            tonality: document.getElementById('tonality-panel'),
            effects: document.getElementById('effects-panel'),
            soundLibrary: document.getElementById('sound-library-panel'),
            padModes: document.getElementById('pad-modes-panel') // Новая панель
        };

        let allPanelsFound = true;
        for (const id in this.panels) {
            if (!this.panels[id]) {
                console.error(`[SidePanel.init v3] Panel element with ID '${id}' not found!`);
                allPanelsFound = false;
            }
        }
        if (!allPanelsFound) {
             console.error("[SidePanel.init v3] Not all panel elements were found. Functionality might be limited.");
        }

        this.closeButtons = document.querySelectorAll('.close-button');
        if (this.closeButtons.length === 0) {
             console.warn('[SidePanel.init v3] No elements with class "close-button" found.');
        }

        this.octaveSlider = document.getElementById('octave-slider');
        this.octaveValueDisplay = document.getElementById('octave-value');
        this.octaveDownButton = document.getElementById('octave-down');
        this.octaveUpButton = document.getElementById('octave-up');
        this.scaleSelect = document.getElementById('scale-select');
        this.scaleSelectDisplay = document.getElementById('scale-select-display');
        this.sizeSlider = document.getElementById('size-slider');
        this.sizeValueDisplay = document.getElementById('size-value');
        this.sizeDownButton = document.getElementById('size-down');
        this.sizeUpButton = document.getElementById('size-up');

        this.languageSelect = document.getElementById('language-select');
        this.themeSelect = document.getElementById('theme-select');
        this.visualizerSelect = document.getElementById('visualizer-select');
        this.touchEffectSelect = document.getElementById('touch-effect-select');
        this.noteNamesToggle = document.getElementById('show-note-names-toggle');
        this.linesToggle = document.getElementById('show-lines-toggle');
        this.multiTouchToggle = document.getElementById('toggle-multi-touch');
        // === ИНИЦИАЛИЗАЦИЯ ПЕРЕКЛЮЧАТЕЛЯ ===
        console.log('[SidePanel.init] Attempting to get element by ID: enable-polyphony-volume-scaling-toggle', document.getElementById('enable-polyphony-volume-scaling-toggle'));
        this.enablePolyphonyScalingToggle = document.getElementById('enable-polyphony-volume-scaling-toggle');
        if (!this.enablePolyphonyScalingToggle) console.warn("[SidePanel.init] Enable Polyphony Scaling toggle ('enable-polyphony-volume-scaling-toggle') NOT FOUND.");
        else console.log("[SidePanel.init] Found Enable Polyphony Scaling toggle.");
        // ===================================

        // === ИНИЦИАЛИЗАЦИЯ НОВОГО ПЕРЕКЛЮЧАТЕЛЯ Highlight Sharps/Flats ===
        console.log('[SidePanel.init] Attempting to get element by ID: highlight-sharps-flats-toggle', document.getElementById('highlight-sharps-flats-toggle'));
        this.highlightSharpsFlatsToggle = document.getElementById('highlight-sharps-flats-toggle');
        if (!this.highlightSharpsFlatsToggle) console.warn("[SidePanel.init] Highlight Sharps/Flats toggle ('highlight-sharps-flats-toggle') NOT FOUND.");
        else console.log("[SidePanel.init] Found Highlight Sharps/Flats toggle.");
        // ==============================================================

        this.padModeSelect = document.getElementById('pad-mode-select');

        this.masterVolumeCeilingSlider = document.getElementById('master-volume-ceiling-slider');
        this.masterVolumeCeilingValue = document.getElementById('master-volume-ceiling-value');
        this.enablePolyphonyVolumeScalingToggle = document.getElementById('enable-polyphony-volume-scaling-toggle');
        this.resetSettingsButton = document.getElementById('reset-settings-button');
        this.restartAudioButton = document.getElementById('restart-audio-button');
        this.reloadAppButton = document.getElementById('reload-app-button');

        this.fxChainSelect = document.getElementById('fx-chain-select');
        this.macroControlsContainer = document.getElementById('macro-controls');
        this.yAxisControlsContainer = document.getElementById('yaxis-controls-container');
        this.yaxisControlTargetDisplay = document.getElementById('yaxis-control-target-display');
        this.resetFxButton = document.getElementById('reset-fx-button');

        this.padModeSelectorDisplay = document.getElementById('pad-mode-selector-display');
        this.modeSpecificControlsContainer = document.getElementById('mode-specific-controls-container');
        if (!this.padModeSelectorDisplay) console.error("[SidePanel.init PadModes] Pad Mode Selector Display not found!");
        if (!this.modeSpecificControlsContainer) console.error("[SidePanel.init PadModes] Mode Specific Controls Container not found!");

        // === Rocket Mode UI ===
        this.rocketModeEnableToggle = document.getElementById('rocket-mode-enable-toggle');
        // ...

        if (this.sizeSlider) {
            this.sizeSlider.min = "8";
            this.sizeSlider.max = "36";
            this.sizeSlider.step = "2";
            this.sizeSlider.value = app && app.state ? app.state.zoneCount.toString() : "12";
        }

        this.addEventListeners();
        this.populateStaticSelects();
        this.populatePadModeSelectDisplay();
        console.log('[SidePanel.init PadModes] Initialized successfully.');
    },

    addEventListeners() {
        console.log('[SidePanel.addEventListeners PadModes] Adding event listeners...');
        this.closeButtons.forEach(btn => {
            if (btn) {
                btn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    const panelId = event.currentTarget.dataset.panelId;
                    if (panelId && this.panels[panelId]) {
                        this.hidePanel(panelId);
                    } else {
                        this.hideAllPanels();
                    }
                });
            }
        });

        if (this.octaveSlider) { this.octaveSlider.addEventListener('input', (e) => this.handleOctaveChange(e.target.value)); this.octaveSlider.addEventListener('change', (e) => this.handleOctaveChange(e.target.value, true)); }
        if (this.octaveDownButton) { this.octaveDownButton.addEventListener('click', () => { if(this.octaveSlider) this.handleOctaveChange(parseInt(this.octaveSlider.value) - 1, true); }); }
        if (this.octaveUpButton) { this.octaveUpButton.addEventListener('click', () => { if(this.octaveSlider) this.handleOctaveChange(parseInt(this.octaveSlider.value) + 1, true); }); }
        if (this.scaleSelect) { this.scaleSelect.addEventListener('change', (e) => { app.setScale(e.target.value); }); }
        if (this.scaleSelectDisplay) {
            this.scaleSelectDisplay.addEventListener('mousedown', (e) => {
                e.preventDefault();
                showCustomSelectorPopover({
                    type: 'scale',
                    title: i18n.translate('scale_label', 'Scale'),
                    itemsArray: MusicTheoryService.getAvailableScaleIds().map(id => ({
                        id: id,
                        name: i18n.translate(id, id.charAt(0).toUpperCase() + id.slice(1))
                    })),
                    currentValue: app.state.scale,
                    onSelect: async (selectedScaleId) => {
                        await app.setScale(selectedScaleId);
                        this.updateScaleDisplay(selectedScaleId);
                    }
                });
            });
        }
        if (this.sizeSlider) {
            this.sizeSlider.addEventListener('input', (e) => this.handleSizeChange(e.target.value));
            this.sizeSlider.addEventListener('change', (e) => this.handleSizeChange(e.target.value, true));
        }
        if (this.sizeDownButton) {
            this.sizeDownButton.addEventListener('click', () => {
                if(this.sizeSlider) {
                    const currentValue = parseInt(this.sizeSlider.value, 10);
                    this.handleSizeChange(currentValue - 2, true);
                }
            });
        }
        if (this.sizeUpButton) {
            this.sizeUpButton.addEventListener('click', () => {
                if(this.sizeSlider) {
                    const currentValue = parseInt(this.sizeSlider.value, 10);
                    this.handleSizeChange(currentValue + 2, true);
                }
            });
        }

        if (this.languageSelect) {
            this.languageSelect.addEventListener('mousedown', (e) => {
                e.preventDefault();
                showCustomSelectorPopover({
                    type: 'language',
                    title: i18n.translate('language_label', 'Language'),
                    selectElement: this.languageSelect,
                    currentValue: app.state.language,
                    onSelect: (val) => { app.applyLanguage(val); bridgeFix.callBridge('setLanguage', val); }
                });
            });
        }
        if (this.themeSelect) {
            this.themeSelect.addEventListener('mousedown', (e) => {
                e.preventDefault();
                showCustomSelectorPopover({
                    type: 'theme',
                    title: i18n.translate('theme_label', 'Theme'),
                    selectElement: this.themeSelect,
                    currentValue: app.state.theme,
                    onSelect: (val) => { app.applyTheme(val); bridgeFix.callBridge('setTheme', val); }
                });
            });
        }
        if (this.visualizerSelect) {
            this.visualizerSelect.addEventListener('mousedown', (e) => {
                e.preventDefault();
                showCustomSelectorPopover({
                    type: 'visualizer',
                    title: i18n.translate('visualizer_label', 'Visualizer'),
                    selectElement: this.visualizerSelect,
                    currentValue: app.state.visualizer,
                    onSelect: (val) => { app.applyVisualizer(val); bridgeFix.callBridge('setVisualizer', val); }
                });
            });
        }
        if (this.touchEffectSelect) {
            this.touchEffectSelect.addEventListener('mousedown', (e) => {
                e.preventDefault();
                showCustomSelectorPopover({
                    type: 'touchEffect',
                    title: i18n.translate('touch_effect_label', 'Touch Effect'),
                    selectElement: this.touchEffectSelect,
                    currentValue: app.state.touchEffect,
                    onSelect: (val) => { app.applyTouchEffect(val); }
                });
            });
        }

        if (this.noteNamesToggle) {
            this.noteNamesToggle.addEventListener('change', () => {
                if (app && typeof app.toggleNoteNames === 'function') {
                    app.toggleNoteNames(this.noteNamesToggle.checked);
                }
            });
        }
        if (this.linesToggle) {
            this.linesToggle.addEventListener('change', () => {
                if (app && typeof app.toggleLines === 'function') {
                    app.toggleLines(this.linesToggle.checked);
                }
            });
        }
        if (this.multiTouchToggle) { /* this.multiTouchToggle.addEventListener('change', () => { app.toggleMultiTouch(this.multiTouchToggle.checked); }); */ } // Мультитач пока disabled

        // === ОБРАБОТЧИК ДЛЯ Polyphony Volume Scaling Toggle ===
        if (this.enablePolyphonyScalingToggle) {
            this.enablePolyphonyScalingToggle.addEventListener('change', () => {
                if (app && typeof app.setEnablePolyphonyVolumeScaling === 'function') {
                    app.setEnablePolyphonyVolumeScaling(this.enablePolyphonyScalingToggle.checked);
                }
            });
        } else { console.warn("[SidePanel.addEventListeners v3] Enable Polyphony Scaling toggle not found."); }
        // ====================================================

        // === ОБРАБОТЧИК ДЛЯ Highlight Sharps/Flats Toggle ===
        if (this.highlightSharpsFlatsToggle) {
            this.highlightSharpsFlatsToggle.addEventListener('change', () => {
                if (app && typeof app.toggleHighlightSharpsFlats === 'function') {
                    app.toggleHighlightSharpsFlats(!!this.highlightSharpsFlatsToggle.checked);
                }
            });
        } else { console.warn("[SidePanel.addEventListeners v3] Highlight Sharps/Flats toggle not found."); }
        // ====================================================

        const fxChainSelect = document.getElementById('fx-chain-select');
        if (fxChainSelect) {
            fxChainSelect.addEventListener('mousedown', (e) => {
                e.preventDefault();
                showCustomSelectorPopover({
                    type: 'fxChain',
                    title: i18n.translate('fx_chain_label', 'FX Chain'),
                    selectElement: fxChainSelect,
                    currentValue: app.state.fxChain,
                    onSelect: (val) => { app.applyFxChain(val); }
                });
            });
        }

        if (this.padModeSelect) {
            this.padModeSelect.addEventListener('mousedown', (e) => {
                e.preventDefault();
                if (typeof PadModeManager !== 'undefined' && typeof showCustomSelectorPopover === 'function') {
                    const modeOptions = PadModeManager.getAvailableModeIds().map(modeId => {
                        const strategy = PadModeManager.strategies[modeId];
                        return {
                            id: modeId,
                            name: strategy && typeof strategy.getDisplayName === 'function' ?
                                  strategy.getDisplayName() :
                                  (strategy && typeof strategy.getName === 'function' ?
                                   i18n.translate(`pad_mode_${strategy.getName()}`, strategy.getName()) :
                                   modeId)
                        };
                    });

                    showCustomSelectorPopover({
                        type: 'padMode',
                        title: i18n.translate('pad_mode_label', 'Pad Mode'),
                        itemsArray: modeOptions,
                        currentValue: app.state.padMode,
                        onSelect: (val) => { app.setPadMode(val); }
                    });
                } else {
                    console.warn("[SidePanel] PadModeManager or showCustomSelectorPopover not available for pad mode select.");
                }
            });
        }

        if (this.masterVolumeCeilingSlider) {
            this.masterVolumeCeilingSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                if (this.masterVolumeCeilingValue) {
                    this.masterVolumeCeilingValue.textContent = `${Math.round(value * 100)}%`;
                }
                app.setMasterVolumeCeiling(value);
            });
        }

        if (this.resetSettingsButton) {
            this.resetSettingsButton.addEventListener('click', () => {
                console.warn("[SidePanel] Reset Settings button clicked. Logic not implemented yet.");
                alert("Reset Settings functionality is not yet implemented.");
            });
        }

        if (this.restartAudioButton) {
            this.restartAudioButton.addEventListener('click', () => {
                app.restartAudioEngine();
            });
        }

        if (this.reloadAppButton) {
            this.reloadAppButton.addEventListener('click', () => {
                app.triggerFullReload();
            });
        }

        if (this.padModeSelectorDisplay) {
            this.padModeSelectorDisplay.addEventListener('mousedown', (e) => {
                e.preventDefault();
                if (typeof PadModeManager === 'undefined' || typeof showCustomSelectorPopover !== 'function') {
                    console.error("[SidePanel] PadModeManager or showCustomSelectorPopover not available.");
                    return;
                }
                const availableModeIds = PadModeManager.getAvailableModeIds();
                const modeOptions = availableModeIds.map(modeId => {
                    const strategy = PadModeManager.strategies[modeId];
                    let displayName = modeId;
                    if (strategy && typeof strategy.getDisplayName === 'function') {
                        displayName = strategy.getDisplayName();
                    } else if (strategy && typeof strategy.getName === 'function') {
                        displayName = i18n.translate(`pad_mode_${strategy.getName()}`, strategy.getName());
                    }
                    return { id: modeId, name: displayName };
                });
                showCustomSelectorPopover({
                    type: 'padMode',
                    title: i18n.translate('pad_mode_select_title', 'Select Pad Mode'),
                    itemsArray: modeOptions,
                    currentValue: app.state.padMode,
                    onSelect: (selectedModeId) => {
                        app.setPadMode(selectedModeId);
                    },
                });
            });
            this.padModeSelectorDisplay.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    this.padModeSelectorDisplay.dispatchEvent(new MouseEvent('mousedown'));
                }
            });
        }

        // === Rocket Mode UI ===
        if (this.rocketModeEnableToggle && this.modeSpecificControlsContainer) {
            this.rocketModeEnableToggle.addEventListener('change', async (e) => {
                const isEnabled = e.target.checked;
                const newMode = isEnabled ? 'rocket' : 'classic';
                if (app && typeof app.setPadMode === 'function') {
                    await app.setPadMode(newMode);
                }
                if (isEnabled && (!this.modeSpecificControlsContainer.hasChildNodes() || 
                    this.modeSpecificControlsContainer.querySelector('p[data-i18n="rocket_mode_settings_placeholder"]'))) {
                    this.displayModeSpecificControls('rocket');
                }
            });
        }
        // ...

        console.log('[SidePanel.addEventListeners PadModes] Listeners added.');
    },

    async populateStaticSelects() {
        console.log('[SidePanel.populateStaticSelects] Populating static select dropdowns...');
        await this.populateSelectWithOptions(this.languageSelect, 'language', 'name', 'id', app.state.language);
        await this.populateSelectWithOptions(this.themeSelect, 'theme', 'name', 'id', app.state.theme);
        await this.populateSelectWithOptions(this.visualizerSelect, 'visualizer', 'name', 'id', app.state.visualizer);
        await this.populateSelectWithOptions(this.touchEffectSelect, 'touchEffect', 'name', 'id', app.state.touchEffect);
        await this.populateSelectWithOptions(document.getElementById('fx-chain-select'), 'fxChain', 'name', 'id', app.state.fxChain);
        await this.populateSelectWithOptions(this.padModeSelect, 'padMode', 'name', 'id', app.state.padMode);
        this.updateScaleDisplay(app.state.scale);
        console.log('[SidePanel.populateStaticSelects] Select dropdowns populated.');
    },

    async populateSelectWithOptions(selectElement, moduleType, textField, valueField, currentAppStateValue) {
        if (!selectElement) { console.warn(`[SidePanel.populateSelectWithOptions v3] Select element for ${moduleType} not found.`); return; }
        selectElement.innerHTML = '';
        try {
            const modules = await moduleManager.getModules(moduleType);
            if (!Array.isArray(modules)) {
                fxChains.addOptionToSelect(selectElement, '', `Error loading ${moduleType}s`, true); return;
            }
            if (modules.length === 0 && moduleType !== 'touchEffect') {
                 fxChains.addOptionToSelect(selectElement, '', `No ${moduleType}s found`, true); return;
            }

            if (moduleType === 'touchEffect') {
                fxChains.addOptionToSelect(selectElement, 'none', i18n.translate('none_touch_effect', 'None'));
            }

            modules.sort((a, b) => (a[textField] || a[valueField]).localeCompare(b[textField] || b[valueField]));
            modules.forEach(mod => {
                if (mod[valueField] === 'none' && moduleType === 'touchEffect') return;
                fxChains.addOptionToSelect(selectElement, mod[valueField], mod[textField] || mod[valueField]);
            });

             if (currentAppStateValue && selectElement.querySelector(`option[value="${currentAppStateValue}"]`)) {
                 selectElement.value = currentAppStateValue;
             } else if (currentAppStateValue) {
                 console.warn(`[SidePanel.populateSelectWithOptions v3] Initial state value '${currentAppStateValue}' for ${moduleType} not found. Setting to first/default.`);
                 if (moduleType === 'touchEffect' && selectElement.querySelector(`option[value="none"]`)) {
                     selectElement.value = 'none';
                 } else if (selectElement.options.length > 0) {
                    selectElement.selectedIndex = 0;
                 }
             } else if (selectElement.options.length > 0) {
                selectElement.selectedIndex = 0;
             }
        } catch (error) {
            console.error(`[SidePanel.populateSelectWithOptions v3] Error populating ${moduleType} select:`, error);
            fxChains.addOptionToSelect(selectElement, '', `Error loading ${moduleType}s`, true);
        }
    },

    updateTonalityControls(octave, scaleId, zoneCount) {
        if (this.octaveSlider) this.octaveSlider.value = octave;
        if (this.octaveValueDisplay) this.octaveValueDisplay.textContent = octave;
        if (this.scaleSelect && this.scaleSelect.options.length > 0) {
            if (this.scaleSelect.querySelector(`option[value="${scaleId}"]`)) { this.scaleSelect.value = scaleId; }
            else { this.scaleSelect.selectedIndex = 0; }
        }
        this.updateScaleDisplay(scaleId);
        if (this.sizeSlider) this.sizeSlider.value = zoneCount;
        if (this.sizeValueDisplay) this.sizeValueDisplay.textContent = zoneCount;
    },

    populatePadModeSelectDisplay() {
        if (!this.padModeSelectorDisplay || typeof PadModeManager === 'undefined') return;
        const currentModeId = app.state.padMode;
        const strategy = PadModeManager.strategies[currentModeId];
        let displayName = currentModeId;
        if (strategy && typeof strategy.getDisplayName === 'function') {
            displayName = strategy.getDisplayName();
        } else if (strategy && typeof strategy.getName === 'function') {
            displayName = i18n.translate(`pad_mode_${strategy.getName()}`, strategy.getName());
        } else if (typeof i18n !== 'undefined') {
            displayName = i18n.translate(`pad_mode_${currentModeId}`, currentModeId);
        }
        this.padModeSelectorDisplay.textContent = displayName;
    },

    displayModeSpecificControls(modeId) {
        const hgModeGroup = document.getElementById('harmonic-glide-mode-select-group');
        const hgCommonContainer = document.getElementById('harmonic-glide-common-settings-container');
        const hgSubmodeContainer = document.getElementById('hg-submode-specific-controls-container');
        if (modeId === 'harmonicGlide') {
            hgModeGroup.style.display = '';
            hgCommonContainer.style.display = '';
            hgSubmodeContainer.style.display = '';
            // --- Селектор подрежимов ---
            const subModeSelectorDisplay = document.getElementById('hg-submode-selector-display');
            const subModeList = ['tonalBinding','adaptiveAnalysis','semiFree','randomDirected'];
            const subModeDisplayNames = subModeList.map(id => {
                const strat = window[id.charAt(0).toUpperCase() + id.slice(1) + 'SubModeStrategy'];
                return strat ? (new strat()).getDisplayName() : id;
            });
            subModeSelectorDisplay.textContent = subModeDisplayNames[subModeList.indexOf(app.state.harmonicGlide.activeSubMode)] || app.state.harmonicGlide.activeSubMode;
            subModeSelectorDisplay.onclick = () => {
                showCustomSelectorPopover({
                    type: 'hg_submode',
                    title: i18n.translate('setting_hg_activeSubMode', 'Logic Sub-Mode'),
                    itemsArray: subModeList.map((id, i) => ({ id, name: subModeDisplayNames[i] })),
                    currentValue: app.state.harmonicGlide.activeSubMode,
                    onSelect: (selectedValue) => app.setHarmonicGlideSetting('activeSubMode', selectedValue)
                });
            };
            // --- Общие настройки ---
            hgCommonContainer.innerHTML = '';
            const strategy = app.PadModeManager.getCurrentStrategy();
            const commonConfig = (strategy && typeof strategy.getCommonControlsConfig === 'function') ? strategy.getCommonControlsConfig() : [];
            commonConfig.forEach(cfg => {
                const value = app.state.harmonicGlide[cfg.name];
                let control;
                if (cfg.type === 'toggle') {
                    control = document.createElement('div');
                    control.className = 'toggle-container';
                    const label = document.createElement('span');
                    label.textContent = i18n.translate(cfg.labelKey, cfg.name);
                    const toggle = document.createElement('label');
                    toggle.className = 'toggle';
                    const input = document.createElement('input');
                    input.type = 'checkbox';
                    input.checked = !!value;
                    input.onchange = e => app.setHarmonicGlideSetting(cfg.name, e.target.checked);
                    const slider = document.createElement('span');
                    slider.className = 'toggle-slider';
                    toggle.appendChild(input); toggle.appendChild(slider);
                    control.appendChild(label); control.appendChild(toggle);
                } else if (cfg.type === 'select') {
                    control = document.createElement('div');
                    control.className = 'dropdown-container';
                    const label = document.createElement('label');
                    label.textContent = i18n.translate(cfg.labelKey, cfg.name);
                    const display = document.createElement('div');
                    display.className = 'dropdown-display';
                    display.textContent = (cfg.options && Array.isArray(cfg.options)) ? (cfg.options.find(opt => (typeof opt === 'object' ? opt.id : opt) === value)?.name || value) : value;
                    display.onclick = () => {
                            showCustomSelectorPopover({
                            type: cfg.name,
                            title: i18n.translate(cfg.labelKey, cfg.name),
                            itemsArray: cfg.options.map(opt => (typeof opt === 'object' ? { id: String(opt.id), name: String(opt.name) } : { id: String(opt), name: String(opt) })),
                            currentValue: value,
                            onSelect: v => app.setHarmonicGlideSetting(cfg.name, v)
                        });
                    };
                    control.appendChild(label); control.appendChild(display);
                } else if (cfg.type === 'knob') {
                    control = document.createElement('div');
                    control.className = 'knob-container';
                    const label = document.createElement('label');
                    label.textContent = i18n.translate(cfg.labelKey, cfg.name);
                    const knob = document.createElement('input');
                    knob.type = 'range';
                    knob.min = cfg.min;
                    knob.max = cfg.max;
                    knob.step = cfg.step;
                    knob.value = value;
                    knob.oninput = e => app.setHarmonicGlideSetting(cfg.name, Number(e.target.value));
                    control.appendChild(knob); control.appendChild(label);
                }
                if (control) hgCommonContainer.appendChild(control);
            });
            // --- Настройки подрежима ---
            hgSubmodeContainer.innerHTML = '';
            const strat = app.PadModeManager.getCurrentStrategy()._currentSubModeStrategy;
            if (strat && typeof strat.getModeSpecificControlsConfig === 'function') {
                const subModeConfig = strat.getModeSpecificControlsConfig(app.state.harmonicGlide[app.state.harmonicGlide.activeSubMode]);
                subModeConfig.forEach(cfg => {
                    const path = cfg.name;
                    const value = path.split('.').reduce((o, k) => o && o[k], app.state.harmonicGlide);
                    let control;
                    if (cfg.type === 'toggle') {
                        control = document.createElement('div');
                        control.className = 'toggle-container';
                        const label = document.createElement('span');
                        label.textContent = i18n.translate(cfg.labelKey, cfg.name);
                        const toggle = document.createElement('label');
                        toggle.className = 'toggle';
                        const input = document.createElement('input');
                        input.type = 'checkbox';
                        input.checked = !!value;
                        input.onchange = e => app.setHarmonicGlideSetting(path, e.target.checked);
                        const slider = document.createElement('span');
                        slider.className = 'toggle-slider';
                        toggle.appendChild(input); toggle.appendChild(slider);
                        control.appendChild(label); control.appendChild(toggle);
                    } else if (cfg.type === 'select') {
                        control = document.createElement('div');
                        control.className = 'dropdown-container';
                        const label = document.createElement('label');
                        label.textContent = i18n.translate(cfg.labelKey, cfg.name);
                        const display = document.createElement('div');
                        display.className = 'dropdown-display';
                        display.textContent = value;
                        display.onclick = () => {
                            showCustomSelectorPopover({
                                type: path,
                                title: i18n.translate(cfg.labelKey, cfg.name),
                                itemsArray: cfg.options.map(opt => ({ id: String(opt), name: String(opt) })),
                                currentValue: value,
                                onSelect: v => app.setHarmonicGlideSetting(path, v)
                            });
                        };
                        control.appendChild(label); control.appendChild(display);
                    } else if (cfg.type === 'knob') {
                        control = document.createElement('div');
                        control.className = 'knob-container';
                        const label = document.createElement('label');
                        label.textContent = i18n.translate(cfg.labelKey, cfg.name);
                        const knob = document.createElement('input');
                        knob.type = 'range';
                        knob.min = cfg.min;
                        knob.max = cfg.max;
                        knob.step = cfg.step;
                        knob.value = value;
                        knob.oninput = e => app.setHarmonicGlideSetting(path, Number(e.target.value));
                        control.appendChild(knob); control.appendChild(label);
                    }
                    if (control) hgSubmodeContainer.appendChild(control);
                });
            }
        } else {
            hgModeGroup.style.display = 'none';
            hgCommonContainer.style.display = 'none';
            hgSubmodeContainer.style.display = 'none';
        }
    },

    updateSettingsControls(langId, themeId, vizId, touchEffectId, showNames, showGrid, enablePolyScaling, highlightSharps, currentPadMode) {
        if (this.languageSelect && this.languageSelect.options.length > 0) { if (this.languageSelect.querySelector(`option[value="${langId}"]`)) this.languageSelect.value = langId; else { this.languageSelect.selectedIndex = 0; } }
        if (this.themeSelect && this.themeSelect.options.length > 0) { if (this.themeSelect.querySelector(`option[value="${themeId}"]`)) this.themeSelect.value = themeId; else { this.themeSelect.selectedIndex = 0; } }
        if (this.visualizerSelect && this.visualizerSelect.options.length > 0) { if (this.visualizerSelect.querySelector(`option[value="${vizId}"]`)) this.visualizerSelect.value = vizId; else { this.visualizerSelect.selectedIndex = 0; } }
        if (this.touchEffectSelect && this.touchEffectSelect.options.length > 0) {
            const targetVal = touchEffectId || 'none';
            if (this.touchEffectSelect.querySelector(`option[value="${targetVal}"]`)) {
                this.touchEffectSelect.value = targetVal;
            } else {
                console.warn(`[SidePanel.updateSettingsControls v3] Touch Effect ID '${targetVal}' not found.`);
                if (this.touchEffectSelect.querySelector(`option[value="none"]`)) {
                    this.touchEffectSelect.value = 'none';
                } else {
                     this.touchEffectSelect.selectedIndex = 0;
                }
            }
        }

        if (this.noteNamesToggle) this.noteNamesToggle.checked = showNames;
        if (this.linesToggle) this.linesToggle.checked = showGrid;
        if (this.highlightSharpsFlatsToggle) this.highlightSharpsFlatsToggle.checked = highlightSharps;

        if (this.enablePolyphonyScalingToggle) this.enablePolyphonyScalingToggle.checked = enablePolyScaling;

        if (this.padModeSelect && this.padModeSelect.options.length > 0) {
            if (currentPadMode && this.padModeSelect.querySelector(`option[value="${currentPadMode}"]`)) {
                this.padModeSelect.value = currentPadMode;
            } else if (this.padModeSelect.options.length > 0) {
                this.padModeSelect.selectedIndex = 0;
            }
        }
        this.populatePadModeSelectDisplay();
        this.displayModeSpecificControls(currentPadMode);
        console.log(`[SidePanel.updateSettingsControls] Updated UI for Language: ${langId}, Theme: ${themeId}, Viz: ${vizId}, Effect: ${touchEffectId}, Names: ${showNames}, Lines: ${showGrid}, PolyScaling: ${enablePolyScaling}, SharpsFlats: ${highlightSharps}, PadMode: ${currentPadMode}`);
    },

    handleOctaveChange(value, finalChange = false) {
        const newOffset = parseInt(value, 10);
        if (isNaN(newOffset)) return;
        const clampedOffset = Math.max(-7, Math.min(7, newOffset));
        if (this.octaveSlider) this.octaveSlider.value = clampedOffset;
        if (this.octaveValueDisplay) this.octaveValueDisplay.textContent = clampedOffset;
        if (finalChange && clampedOffset !== app.state.octaveOffset) { app.setOctaveOffset(clampedOffset); }
    },

    handleSizeChange(value, finalChange = false) {
        const newSize = parseInt(value, 10);
        if (isNaN(newSize)) return;
        let clampedSize = Math.max(8, Math.min(36, newSize));
        if (clampedSize % 2 !== 0) {
            if (clampedSize === 35) clampedSize = 34;
            else if (clampedSize < 8) clampedSize = 8;
            else clampedSize = Math.round(clampedSize / 2) * 2;
            clampedSize = Math.max(8, Math.min(36, clampedSize));
        }
        if (this.sizeSlider) this.sizeSlider.value = clampedSize;
        if (this.sizeValueDisplay) this.sizeValueDisplay.textContent = clampedSize;
        if (finalChange && clampedSize !== app.state.zoneCount) {
            app.setZoneCount(clampedSize);
        }
    },

    showPanel(panelId) {
        this.hideAllPanels(panelId);
        const panel = this.panels[panelId];
        if (panel) {
            panel.classList.add('show');
            if (topbar && typeof topbar.getButtonForPanel === 'function') {
                const button = topbar.getButtonForPanel(panelId);
                if (button) button.classList.add('active');
            }
        }
    },

    hidePanel(panelId) {
        const panel = this.panels[panelId];
        if (panel) {
            panel.classList.remove('show');
            if (topbar && typeof topbar.getButtonForPanel === 'function') {
                const button = topbar.getButtonForPanel(panelId);
                if (button) button.classList.remove('active');
            }
        }
    },

    hideAllPanels(exceptId = null) {
        if (topbar && typeof topbar.deactivateAllButtons === 'function') {
            topbar.deactivateAllButtons();
        }
        for (const id in this.panels) {
            if (id !== exceptId && this.panels[id]) {
                this.hidePanel(id);
            }
        }
    },

    isPanelOpen(panelId) {
        const panel = this.panels[panelId];
        return panel ? panel.classList.contains('show') : false;
    },

    initKnob(knobElement) {
        if (!knobElement || !(knobElement instanceof HTMLElement) || this.knobsInitialized.has(knobElement)) return;
        const paramName = knobElement.dataset.param || 'unknown';
        const dial = knobElement.querySelector('.knob-dial');
        const valueDisplay = knobElement.querySelector('.knob-value');
        if (!dial || !valueDisplay) { return; }

        let isDragging = false, startY = 0, startValueLinear = 0;
        let min = 0, max = 1, step = 0.01, isLog = false;

        try {
            min = parseFloat(knobElement.dataset.min ?? 0);
            max = parseFloat(knobElement.dataset.max ?? 1);
            step = parseFloat(knobElement.dataset.step ?? 0.01);
            isLog = knobElement.dataset.log === 'true';
            if (isNaN(min) || isNaN(max) || isNaN(step)) throw new Error("NaN parsed");
            if (max <= min) { min = 0; max = 1; }
            if (step <= 0) { step = 0.01; }
            if (isLog && min <= 0) { isLog = false; console.warn(`[SidePanel.initKnob] Log scale for ${paramName} disabled due to min <= 0.`); }
        } catch (e) { console.error(`[SidePanel.initKnob] Error parsing data for ${paramName}:`, e); }

        const scaleToValue = (linearValue) => {
            const clampedLinear = Math.max(0, Math.min(1, linearValue));
            if (isLog) return min * Math.pow(max / min, clampedLinear);
            return min + clampedLinear * (max - min);
        };
        const valueToScale = (value) => {
            const clampedValue = Math.max(min, Math.min(max, value));
            if (isLog) {
                if (clampedValue <= min || max <= min) return 0;
                return Math.log(clampedValue / min) / Math.log(max / min);
            }
            if (max - min === 0) return 0;
            return (clampedValue - min) / (max - min);
        };

        const updateKnobUI = (valueToDisplay, triggerChangeEvent = true) => {
            let steppedValue = Math.round(valueToDisplay / step) * step;
            steppedValue = parseFloat(steppedValue.toFixed(5));
            steppedValue = Math.max(min, Math.min(max, steppedValue));

            const linearValue = valueToScale(steppedValue);
            const rotation = linearValue * 270 - 135;
            dial.style.transform = `translateX(-50%) rotate(${rotation}deg)`;

            let displayFormat;
            if (Math.abs(steppedValue) >= 10000 && isLog) displayFormat = (steppedValue / 1000).toFixed(1) + 'k';
            else if (Math.abs(steppedValue) >= 1000) displayFormat = Math.round(steppedValue).toString();
            else if (step >= 1) displayFormat = Math.round(steppedValue).toString();
            else if (step >= 0.1) displayFormat = steppedValue.toFixed(1);
            else if (step >= 0.01) displayFormat = steppedValue.toFixed(2);
            else displayFormat = steppedValue.toFixed(3);
            valueDisplay.textContent = displayFormat;
            knobElement.dataset.currentValue = steppedValue.toString();

            if (triggerChangeEvent) {
                knobElement.dispatchEvent(new CustomEvent('knob-change', { detail: { value: steppedValue }, bubbles: true }));
            }
        };

        const onPointerDown = (e) => {
            if (e.pointerType === 'mouse' && e.button !== 0) return;
            e.preventDefault(); e.stopPropagation();
            isDragging = true; startY = e.clientY;
            startValueLinear = valueToScale(parseFloat(knobElement.dataset.currentValue ?? knobElement.dataset.default ?? min));
            try { knobElement.setPointerCapture(e.pointerId); } catch (err) {}
            knobElement.style.cursor = 'ns-resize'; document.body.style.cursor = 'ns-resize';
        };
        const onPointerMove = (e) => {
            if (!isDragging || (e.pointerId !== knobElement._capturedPointerId && knobElement._capturedPointerId !== undefined)) return;
            e.preventDefault(); e.stopPropagation();
            const deltaY = startY - e.clientY;
            const sensitivityFactor = knobElement.classList.contains('small') ? 250 : 200;
            let newLinearValue = startValueLinear + (deltaY / sensitivityFactor);
            newLinearValue = Math.max(0, Math.min(1, newLinearValue));
            updateKnobUI(scaleToValue(newLinearValue), true);
        };
        const onPointerUp = (e) => {
            if (!isDragging || (e.pointerId !== knobElement._capturedPointerId && knobElement._capturedPointerId !== undefined)) return;
            e.stopPropagation(); isDragging = false;
            if (knobElement.hasPointerCapture(e.pointerId)) { try { knobElement.releasePointerCapture(e.pointerId); } catch (err) {} }
            knobElement.style.cursor = 'ns-resize'; document.body.style.cursor = '';
            delete knobElement._capturedPointerId;
        };

        knobElement.addEventListener('pointerdown', onPointerDown);
        document.addEventListener('pointermove', onPointerMove, {passive: false});
        document.addEventListener('pointerup', onPointerUp);
        knobElement.addEventListener('pointercancel', onPointerUp);
        knobElement.addEventListener('gotpointercapture', (e) => { knobElement._capturedPointerId = e.pointerId; });
        knobElement.addEventListener('lostpointercapture', (e) => { if (isDragging && e.pointerId === knobElement._capturedPointerId) { onPointerUp(e); }});

        knobElement.setValue = (value, triggerEvent = true) => { updateKnobUI(value, triggerEvent); };
        knobElement.getValue = () => parseFloat(knobElement.dataset.currentValue ?? min);
        updateKnobUI(parseFloat(knobElement.dataset.default ?? knobElement.dataset.currentValue ?? min), false);
        this.knobsInitialized.add(knobElement);
    },

    setKnobValue(knobElement, value, triggerEvent = false) {
         if (knobElement && typeof knobElement.setValue === 'function') {
             knobElement.setValue(value, triggerEvent);
         }
    },

    getKnobValue(knobElement) {
        if (knobElement && typeof knobElement.getValue === 'function') {
            return knobElement.getValue();
        }
        return knobElement?.dataset?.currentValue ? parseFloat(knobElement.dataset.currentValue) : 0;
    },

    updateScaleDisplay(scaleId) {
        if (this.scaleSelectDisplay && scaleId) {
            const scaleName = i18n.translate(scaleId, scaleId.charAt(0).toUpperCase() + scaleId.slice(1));
            this.scaleSelectDisplay.textContent = scaleName;
            console.log(`[SidePanel] Scale display updated to: ${scaleName} (ID: ${scaleId})`);
        } else if (this.scaleSelectDisplay) {
            this.scaleSelectDisplay.textContent = i18n.translate('select_option', 'Select Scale');
        }
    }
};
================================================================================

